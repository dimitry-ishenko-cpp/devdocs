<section id="array-api"> <h1>Array API</h1>   <section id="array-structure-and-data-access"> <h2 id="index-0">Array structure and data access</h2> <p>These macros access the <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a> structure members and are defined in <code>ndarraytypes.h</code>. The input argument, <em>arr</em>, can be any <span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span></span> that is directly interpretable as a <span class="c-expr sig sig-inline c"><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span></span> (any instance of the <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> and its sub-types).</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NDIM"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_NDIM</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The number of dimensions in the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FLAGS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_FLAGS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns an integer representing the <a class="reference internal" href="#array-flags"><span class="std std-ref">array-flags</span></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_TYPE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_TYPE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the (builtin) typenumber for the elements of this array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Pack"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Pack</span></span><span class="sig-paren">(</span><span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <span class="kt">void</span><span class="p">*</span><span class="n">item</span>, <span class="k">const</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">value</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> <p>Sets the memory location <code>item</code> of dtype <code>descr</code> to <code>value</code>.</p> <p>The function is equivalent to setting a single array element with a Python assignment. Returns 0 on success and -1 with an error set on failure.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the <code>descr</code> has the <a class="reference internal" href="types-and-structures.html#c.NPY_NEEDS_INIT" title="NPY_NEEDS_INIT"><code>NPY_NEEDS_INIT</code></a> flag set, the data must be valid or the memory zeroed.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SETITEM"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SETITEM</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">void</span><span class="p">*</span><span class="n">itemptr</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert obj and place it in the ndarray, <em>arr</em>, at the place pointed to by itemptr. Return -1 if an error occurs or 0 on success.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In general, prefer the use of <a class="reference internal" href="#c.PyArray_Pack" title="PyArray_Pack"><code>PyArray_Pack</code></a> when handling arbitrary Python objects. Setitem is for example not able to handle arbitrary casts between different dtypes.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ENABLEFLAGS"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ENABLEFLAGS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">flags</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>Enables the specified array flags. This function does no validation, and assumes that you know what you’re doing.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CLEARFLAGS"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_CLEARFLAGS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">flags</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>Clears the specified array flags. This function does no validation, and assumes that you know what you’re doing.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DATA"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DATA</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_BYTES"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_BYTES</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DIMS"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DIMS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a pointer to the dimensions/shape of the array. The number of elements matches the number of dimensions of the array. Can return <code>NULL</code> for 0-dimensional arrays.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SHAPE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SHAPE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>A synonym for <a class="reference internal" href="#c.PyArray_DIMS" title="PyArray_DIMS"><code>PyArray_DIMS</code></a>, named to be consistent with the <a class="reference internal" href="../generated/numpy.ndarray.shape.html#numpy.ndarray.shape" title="numpy.ndarray.shape"><code>shape</code></a> usage within Python.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_STRIDES"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_STRIDES</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a pointer to the strides of the array. The number of elements matches the number of dimensions of the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DIM"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_DIM</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the shape in the <em>n</em> <span class="math notranslate nohighlight">\(^{\textrm{th}}\)</span> dimension.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_STRIDE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_STRIDE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the stride in the <em>n</em> <span class="math notranslate nohighlight">\(^{\textrm{th}}\)</span> dimension.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITEMSIZE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_ITEMSIZE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the itemsize for the elements of this array.</p> <p>Note that, in the old API that was deprecated in version 1.7, this function had the return type <code>int</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SIZE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_SIZE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns the total size (in number of elements) of the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Size"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_Size</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns 0 if <em>obj</em> is not a sub-class of ndarray. Otherwise, returns the total number of elements in the array. Safer version of <a class="reference internal" href="#c.PyArray_SIZE" title="PyArray_SIZE"><code>PyArray_SIZE</code></a> (<em>obj</em>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NBYTES"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_NBYTES</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns the total number of bytes consumed by the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_BASE"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_BASE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</p> <p>If you are constructing an array using the C API, and specifying your own memory, you should use the function <a class="reference internal" href="#c.PyArray_SetBaseObject" title="PyArray_SetBaseObject"><code>PyArray_SetBaseObject</code></a> to set the base to an object which owns the memory.</p> <p>If the <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> flag is set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DESCR"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DESCR</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a borrowed reference to the dtype property of the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DTYPE"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DTYPE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>A synonym for PyArray_DESCR, named to be consistent with the ‘dtype’ usage within Python.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETITEM"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETITEM</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">void</span><span class="p">*</span><span class="n">itemptr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Get a Python object of a builtin type from the ndarray, <em>arr</em>, at the location pointed to by itemptr. Return <code>NULL</code> on failure.</p> <p><a class="reference internal" href="../generated/numpy.ndarray.item.html#numpy.ndarray.item" title="numpy.ndarray.item"><code>numpy.ndarray.item</code></a> is identical to PyArray_GETITEM.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FinalizeFunc"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_FinalizeFunc</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The function pointed to by the <a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.12)"><code>PyCapsule</code></a> <a class="reference internal" href="../arrays.classes.html#numpy.class.__array_finalize__" title="numpy.class.__array_finalize__"><code>__array_finalize__</code></a>. The first argument is the newly created sub-type. The second argument (if not NULL) is the “parent” array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</p> </dd>
</dl> <section id="data-access"> <h3>Data access</h3> <p>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a>. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetPtr"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GetPtr</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">aobj</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">ind</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return a pointer to the data of the ndarray, <em>aobj</em>, at the N-dimensional index given by the c-array, <em>ind</em>, (which must be at least <em>aobj</em> -&gt;nd in size). You may want to typecast the returned pointer to the data type of the ndarray.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETPTR1"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETPTR1</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">i</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETPTR2"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETPTR2</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">i</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">j</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETPTR3"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETPTR3</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">i</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">j</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">k</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETPTR4"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETPTR4</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">i</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">j</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">k</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">l</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Quick, inline access to the element at the given coordinates in the ndarray, <em>obj</em>, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked). The corresponding <em>i</em>, <em>j</em>, <em>k</em>, and <em>l</em> coordinates can be any integer but will be interpreted as <code>npy_intp</code>. You may want to typecast the returned pointer to the data type of the ndarray.</p> </dd>
</dl> </section> </section> <section id="creating-arrays"> <h2>Creating arrays</h2> <section id="from-scratch"> <h3>From scratch</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NewFromDescr"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_NewFromDescr</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="n">subtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">strides</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <span class="kt">int</span><span class="n">flags</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function steals a reference to <em>descr</em>. The easiest way to get one is using <a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code>PyArray_DescrFromType</code></a>.</p> <p>This is the main array creation function. Most new arrays are created with this flexible function.</p> <p>The returned object is an object of Python-type <em>subtype</em>, which must be a subtype of <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>. The array has <em>nd</em> dimensions, described by <em>dims</em>. The data-type descriptor of the new array is <em>descr</em>.</p> <p>If <em>subtype</em> is of an array subclass instead of the base <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>&amp;PyArray_Type</code></a>, then <em>obj</em> is the object to pass to the <a class="reference internal" href="../arrays.classes.html#numpy.class.__array_finalize__" title="numpy.class.__array_finalize__"><code>__array_finalize__</code></a> method of the subclass.</p> <p>If <em>data</em> is <code>NULL</code>, then new unitinialized memory will be allocated and <em>flags</em> can be non-zero to indicate a Fortran-style contiguous array. Use <a class="reference internal" href="#c.PyArray_FILLWBYTE" title="PyArray_FILLWBYTE"><code>PyArray_FILLWBYTE</code></a> to initialize the memory.</p> <p>If <em>data</em> is not <code>NULL</code>, then it is assumed to point to the memory to be used for the array and the <em>flags</em> argument is used as the new flags for the array (except the state of <a class="reference internal" href="#c.NPY_ARRAY_OWNDATA" title="NPY_ARRAY_OWNDATA"><code>NPY_ARRAY_OWNDATA</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> flag of the new array will be reset).</p> <p>In addition, if <em>data</em> is non-NULL, then <em>strides</em> can also be provided. If <em>strides</em> is <code>NULL</code>, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (<em>flags</em> is nonzero for <em>data</em> = <code>NULL</code> or <em>flags</em> &amp; <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> is nonzero non-NULL <em>data</em>). Any provided <em>dims</em> and <em>strides</em> are copied into newly allocated dimension and strides arrays for the new array object.</p> <p><a class="reference internal" href="#c.PyArray_CheckStrides" title="PyArray_CheckStrides"><code>PyArray_CheckStrides</code></a> can help verify non- <code>NULL</code> stride information.</p> <p>If <code>data</code> is provided, it must stay alive for the life of the array. One way to manage this is through <a class="reference internal" href="#c.PyArray_SetBaseObject" title="PyArray_SetBaseObject"><code>PyArray_SetBaseObject</code></a></p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NewLikeArray"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_NewLikeArray</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">prototype</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <span class="kt">int</span><span class="n">subok</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>This function steals a reference to <em>descr</em> if it is not NULL. This array creation routine allows for the convenient creation of a new array matching an existing array’s shapes and memory layout, possibly changing the layout and/or data type.</p> <p>When <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_ANYORDER" title="NPY_ANYORDER"><code>NPY_ANYORDER</code></a>, the result order is <a class="reference internal" href="#c.NPY_ORDER.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code>NPY_FORTRANORDER</code></a> if <em>prototype</em> is a fortran array, <a class="reference internal" href="#c.NPY_ORDER.NPY_CORDER" title="NPY_CORDER"><code>NPY_CORDER</code></a> otherwise. When <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_KEEPORDER" title="NPY_KEEPORDER"><code>NPY_KEEPORDER</code></a>, the result order matches that of <em>prototype</em>, even when the axes of <em>prototype</em> aren’t in C or Fortran order.</p> <p>If <em>descr</em> is NULL, the data type of <em>prototype</em> is used.</p> <p>If <em>subok</em> is 1, the newly created array will use the sub-type of <em>prototype</em> to create the new array, otherwise it will create a base-class array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_New"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_New</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="n">subtype</span>, <span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">type_num</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">strides</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <span class="kt">int</span><span class="n">itemsize</span>, <span class="kt">int</span><span class="n">flags</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is similar to <a class="reference internal" href="#c.PyArray_NewFromDescr" title="PyArray_NewFromDescr"><code>PyArray_NewFromDescr</code></a> (…) except you specify the data-type descriptor with <em>type_num</em> and <em>itemsize</em>, where <em>type_num</em> corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</p> </dd>
</dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If data is passed to <a class="reference internal" href="#c.PyArray_NewFromDescr" title="PyArray_NewFromDescr"><code>PyArray_NewFromDescr</code></a> or <a class="reference internal" href="#c.PyArray_New" title="PyArray_New"><code>PyArray_New</code></a>, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using <a class="reference external" href="https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF" title="(in Python v3.12)"><code>Py_INCREF</code></a> on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SimpleNew"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SimpleNew</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Create a new uninitialized array of type, <em>typenum</em>, whose size in each of <em>nd</em> dimensions is given by the integer array, <em>dims</em>.The memory for the array is uninitialized (unless typenum is <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_OBJECT" title="NPY_OBJECT"><code>NPY_OBJECT</code></a> in which case each element in the array is set to NULL). The <em>typenum</em> argument allows specification of any of the builtin data-types such as <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_FLOAT" title="NPY_FLOAT"><code>NPY_FLOAT</code></a> or <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_LONG" title="NPY_LONG"><code>NPY_LONG</code></a>. The memory for the array can be set to zero if desired using <a class="reference internal" href="#c.PyArray_FILLWBYTE" title="PyArray_FILLWBYTE"><code>PyArray_FILLWBYTE</code></a> (return_object, 0).This function cannot be used to create a flexible-type array (no itemsize given).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SimpleNewFromData"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SimpleNewFromData</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Create an array wrapper around <em>data</em> pointed to by the given pointer. The array flags will have a default that the data area is well-behaved and C-style contiguous. The shape of the array is given by the <em>dims</em> c-array of length <em>nd</em>. The data-type of the array is indicated by <em>typenum</em>. If data comes from another reference-counted Python object, the reference count on this object should be increased after the pointer is passed in, and the base member of the returned ndarray should point to the Python object that owns the data. This will ensure that the provided memory is not freed while the returned array is in existence.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SimpleNewFromDescr"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SimpleNewFromDescr</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_int" title="npy_int"><span class="n">npy_int</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function steals a reference to <em>descr</em>.</p> <p>Create a new array with the provided data-type descriptor, <em>descr</em>, of the shape determined by <em>nd</em> and <em>dims</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FILLWBYTE"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_FILLWBYTE</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">val</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Fill the array pointed to by <em>obj</em> —which must be a (subclass of) ndarray—with the contents of <em>val</em> (evaluated as a byte). This macro calls memset, so obj must be contiguous.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Zeros"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Zeros</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a new <em>nd</em> -dimensional array with shape given by <em>dims</em> and data type given by <em>dtype</em>. If <em>fortran</em> is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. Fill the memory with zeros (or the 0 object if <em>dtype</em> corresponds to <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_OBJECT" title="NPY_OBJECT"><code>NPY_OBJECT</code></a> ).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ZEROS"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ZEROS</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">type_num</span>, <span class="kt">int</span><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Macro form of <a class="reference internal" href="#c.PyArray_Zeros" title="PyArray_Zeros"><code>PyArray_Zeros</code></a> which takes a type-number instead of a data-type object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Empty"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Empty</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a new <em>nd</em> -dimensional array with shape given by <em>dims</em> and data type given by <em>dtype</em>. If <em>fortran</em> is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. The array is uninitialized unless the data type corresponds to <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_OBJECT" title="NPY_OBJECT"><code>NPY_OBJECT</code></a> in which case the array is filled with <a class="reference external" href="https://docs.python.org/3/c-api/none.html#c.Py_None" title="(in Python v3.12)"><code>Py_None</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EMPTY"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_EMPTY</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Macro form of <a class="reference internal" href="#c.PyArray_Empty" title="PyArray_Empty"><code>PyArray_Empty</code></a> which takes a type-number, <em>typenum</em>, instead of a data-type object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Arange"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Arange</span></span><span class="sig-paren">(</span><span class="kt">double</span><span class="n">start</span>, <span class="kt">double</span><span class="n">stop</span>, <span class="kt">double</span><span class="n">step</span>, <span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a new 1-dimensional array of data-type, <em>typenum</em>, that ranges from <em>start</em> to <em>stop</em> (exclusive) in increments of <em>step</em> . Equivalent to <strong>arange</strong> (<em>start</em>, <em>stop</em>, <em>step</em>, dtype).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ArangeObj"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ArangeObj</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">start</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">stop</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">step</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a new 1-dimensional array of data-type determined by <code>descr</code>, that ranges from <code>start</code> to <code>stop</code> (exclusive) in increments of <code>step</code>. Equivalent to arange( <code>start</code>, <code>stop</code>, <code>step</code>, <code>typenum</code> ).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SetBaseObject"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SetBaseObject</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>This function <strong>steals a reference</strong> to <code>obj</code> and sets it as the base property of <code>arr</code>.</p> <p>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array’s <code>base</code> property to ensure the lifetime of the memory buffer is appropriate.</p> <p>The return value is 0 on success, -1 on failure.</p> <p>If the object provided is an array, this function traverses the chain of <code>base</code> pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</p> </dd>
</dl> </section> <section id="from-other-objects"> <h3>From other objects</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromAny"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromAny</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">min_depth</span>, <span class="kt">int</span><span class="n">max_depth</span>, <span class="kt">int</span><span class="n">requirements</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">context</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, <em>op</em>. The parameters allow specification of the required <em>dtype</em>, the minimum (<em>min_depth</em>) and maximum (<em>max_depth</em>) number of dimensions acceptable, and other <em>requirements</em> for the array. This function <strong>steals a reference</strong> to the dtype argument, which needs to be a <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> structure indicating the desired data-type (including required byteorder). The <em>dtype</em> argument may be <code>NULL</code>, indicating that any data-type (and byteorder) is acceptable. Unless <a class="reference internal" href="#c.NPY_ARRAY_FORCECAST" title="NPY_ARRAY_FORCECAST"><code>NPY_ARRAY_FORCECAST</code></a> is present in <code>flags</code>, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use <code>NULL</code> for the <em>dtype</em> and ensure the array is not swapped then use <a class="reference internal" href="#c.PyArray_CheckFromAny" title="PyArray_CheckFromAny"><code>PyArray_CheckFromAny</code></a>. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (<em>e.g.</em> using |) to get the <em>requirements</em> argument. If your code can handle general (<em>e.g.</em> strided, byte-swapped, or unaligned arrays) then <em>requirements</em> may be 0. Also, if <em>op</em> is not already an array (or does not expose the array interface), then a new array will be created (and filled from <em>op</em> using the sequence protocol). The new array will have <a class="reference internal" href="#c.NPY_ARRAY_DEFAULT" title="NPY_ARRAY_DEFAULT"><code>NPY_ARRAY_DEFAULT</code></a> as its flags member. The <em>context</em> argument is unused.</p> <dl class="simple"> <dt><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a></dt>
<dd>
<p>Make sure the returned array is C-style contiguous</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a></dt>
<dd>
<p>Make sure the returned array is Fortran-style contiguous.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></dt>
<dd>
<p>Make sure the returned array is aligned on proper boundaries for its data type. An aligned array has the data pointer and every strides factor as a multiple of the alignment factor for the data-type- descriptor.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a></dt>
<dd>
<p>Make sure the returned array can be written to.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_ENSURECOPY" title="NPY_ARRAY_ENSURECOPY"><code>NPY_ARRAY_ENSURECOPY</code></a></dt>
<dd>
<p>Make sure a copy is made of <em>op</em>. If this flag is not present, data is not copied if it can be avoided.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code>NPY_ARRAY_ENSUREARRAY</code></a></dt>
<dd>
<p>Make sure the result is a base-class ndarray. By default, if <em>op</em> is an instance of a subclass of ndarray, an instance of that same subclass is returned. If this flag is set, an ndarray object will be returned instead.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_FORCECAST" title="NPY_ARRAY_FORCECAST"><code>NPY_ARRAY_FORCECAST</code></a></dt>
<dd>
<p>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</p> </dd> <dt><a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a></dt>
<dd>
<p>If <em>op</em> is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> flag is set in the returned copy and <em>op</em> is made to be read-only. You must be sure to call <a class="reference internal" href="#c.PyArray_ResolveWritebackIfCopy" title="PyArray_ResolveWritebackIfCopy"><code>PyArray_ResolveWritebackIfCopy</code></a> to copy the contents back into <em>op</em> and the <em>op</em> array will be made writeable again. If <em>op</em> is not writeable to begin with, or if it is not already an array, then an error is raised.</p> </dd> </dl> <p><a class="reference internal" href="#combinations-of-array-flags">Combinations of array flags</a> can also be added.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckFromAny"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CheckFromAny</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">min_depth</span>, <span class="kt">int</span><span class="n">max_depth</span>, <span class="kt">int</span><span class="n">requirements</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">context</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Nearly identical to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> (…) except <em>requirements</em> can contain <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code>NPY_ARRAY_NOTSWAPPED</code></a> (over-riding the specification in <em>dtype</em>) and <a class="reference internal" href="#c.NPY_ARRAY_ELEMENTSTRIDES" title="NPY_ARRAY_ELEMENTSTRIDES"><code>NPY_ARRAY_ELEMENTSTRIDES</code></a> which indicates that the array should be aligned in the sense that the strides are multiples of the element size.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromArray"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromArray</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">newtype</span>, <span class="kt">int</span><span class="n">requirements</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Special case of <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> for when <em>op</em> is already an array but it needs to be of a specific <em>newtype</em> (including byte-order) or has certain <em>requirements</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromStructInterface"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromStructInterface</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns an ndarray object from a Python object that exposes the <a class="reference internal" href="../arrays.interface.html#object.__array_struct__" title="object.__array_struct__"><code>__array_struct__</code></a> attribute and follows the array interface protocol. If the object does not contain this attribute then a borrowed reference to <a class="reference external" href="https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.12)"><code>Py_NotImplemented</code></a> is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromInterface"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromInterface</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns an ndarray object from a Python object that exposes the <a class="reference internal" href="../arrays.interface.html#object.__array_interface__" title="object.__array_interface__"><code>__array_interface__</code></a> attribute following the array interface protocol. If the object does not contain this attribute then a borrowed reference to <a class="reference external" href="https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.12)"><code>Py_NotImplemented</code></a> is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromArrayAttr"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromArrayAttr</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">context</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an ndarray object from a Python object that exposes the <a class="reference internal" href="../arrays.classes.html#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a> method. The third-party implementations of <a class="reference internal" href="../arrays.classes.html#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a> must take <code>dtype</code> and <code>copy</code> keyword arguments. <code>context</code> is unused.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ContiguousFromAny"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ContiguousFromAny</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">min_depth</span>, <span class="kt">int</span><span class="n">max_depth</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, <em>op</em>, of (non-flexible) type given by the enumerated <em>typenum</em>, of minimum depth <em>min_depth</em>, and of maximum depth <em>max_depth</em>. Equivalent to a call to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> with requirements set to <a class="reference internal" href="#c.NPY_ARRAY_DEFAULT" title="NPY_ARRAY_DEFAULT"><code>NPY_ARRAY_DEFAULT</code></a> and the type_num member of the type argument set to <em>typenum</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ContiguousFromObject"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ContiguousFromObject</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">min_depth</span>, <span class="kt">int</span><span class="n">max_depth</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function returns a well-behaved C-style contiguous array from any nested sequence or array-interface exporting object. The minimum number of dimensions the array can have is given by <code>min_depth</code> while the maximum is <code>max_depth</code>. This is equivalent to call <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> with requirements <a class="reference internal" href="#c.NPY_ARRAY_DEFAULT" title="NPY_ARRAY_DEFAULT"><code>NPY_ARRAY_DEFAULT</code></a> and <a class="reference internal" href="#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code>NPY_ARRAY_ENSUREARRAY</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromObject"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromObject</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">min_depth</span>, <span class="kt">int</span><span class="n">max_depth</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an aligned and in native-byteorder array from any nested sequence or array-interface exporting object, op, of a type given by the enumerated typenum. The minimum number of dimensions the array can have is given by min_depth while the maximum is max_depth. This is equivalent to a call to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> with requirements set to BEHAVED.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EnsureArray"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_EnsureArray</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function <strong>steals a reference</strong> to <code>op</code> and makes sure that <code>op</code> is a base-class ndarray. It special cases array scalars, but otherwise calls <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> ( <code>op</code>, NULL, 0, 0, <a class="reference internal" href="#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code>NPY_ARRAY_ENSUREARRAY</code></a>, NULL).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromString"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromString</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">string</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">slen</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">num</span>, <span class="kt">char</span><span class="p">*</span><span class="n">sep</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a one-dimensional ndarray of a single type from a binary or (ASCII) text <code>string</code> of length <code>slen</code>. The data-type of the array to-be-created is given by <code>dtype</code>. If num is -1, then <strong>copy</strong> the entire string and return an appropriately sized array, otherwise, <code>num</code> is the number of items to <strong>copy</strong> from the string. If <code>sep</code> is NULL (or “”), then interpret the string as bytes of binary data, otherwise convert the sub-strings separated by <code>sep</code> to items of data-type <code>dtype</code>. Some data-types may not be readable in text mode and an error will be raised if that occurs. All errors return NULL.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromFile"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromFile</span></span><span class="sig-paren">(</span><span class="n">FILE</span><span class="p">*</span><span class="n">fp</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">num</span>, <span class="kt">char</span><span class="p">*</span><span class="n">sep</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a one-dimensional ndarray of a single type from a binary or text file. The open file pointer is <code>fp</code>, the data-type of the array to be created is given by <code>dtype</code>. This must match the data in the file. If <code>num</code> is -1, then read until the end of the file and return an appropriately sized array, otherwise, <code>num</code> is the number of items to read. If <code>sep</code> is NULL (or “”), then read from the file in binary mode, otherwise read from the file in text mode with <code>sep</code> providing the item separator. Some array types cannot be read in text mode in which case an error is raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromBuffer"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromBuffer</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">buf</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">count</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">offset</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Construct a one-dimensional ndarray of a single type from an object, <code>buf</code>, that exports the (single-segment) buffer protocol (or has an attribute __buffer__ that returns an object that exports the buffer protocol). A writeable buffer will be tried first followed by a read- only buffer. The <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> flag of the returned array will reflect which one was successful. The data is assumed to start at <code>offset</code> bytes from the start of the memory location for the object. The type of the data in the buffer will be interpreted depending on the data- type descriptor, <code>dtype.</code> If <code>count</code> is negative then it will be determined from the size of the buffer and the requested itemsize, otherwise, <code>count</code> represents how many elements should be converted from the buffer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CopyInto"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CopyInto</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">dest</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">src</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Copy from the source array, <code>src</code>, into the destination array, <code>dest</code>, performing a data-type conversion if necessary. If an error occurs return -1 (otherwise 0). The shape of <code>src</code> must be broadcastable to the shape of <code>dest</code>. NumPy checks for overlapping memory when copying two arrays.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CopyObject"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CopyObject</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">dest</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">src</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Assign an object <code>src</code> to a NumPy array <code>dest</code> according to array-coercion rules. This is basically identical to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a>, but assigns directly to the output array. Returns 0 on success and -1 on failures.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GETCONTIGUOUS"> <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GETCONTIGUOUS</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If <code>op</code> is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FROM_O"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FROM_O</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert <code>obj</code> to an ndarray. The argument can be any nested sequence or object that exports the array interface. This is a macro form of <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> using <code>NULL</code>, 0, 0, 0 for the other arguments. Your code must be able to handle any data-type descriptor and any combination of data-flags to use this macro.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FROM_OF"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FROM_OF</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">requirements</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyArray_FROM_O" title="PyArray_FROM_O"><code>PyArray_FROM_O</code></a> except it can take an argument of <em>requirements</em> indicating properties the resulting array must have. Available requirements that can be enforced are <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code>NPY_ARRAY_NOTSWAPPED</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ENSURECOPY" title="NPY_ARRAY_ENSURECOPY"><code>NPY_ARRAY_ENSURECOPY</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_FORCECAST" title="NPY_ARRAY_FORCECAST"><code>NPY_ARRAY_FORCECAST</code></a>, and <a class="reference internal" href="#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code>NPY_ARRAY_ENSUREARRAY</code></a>. Standard combinations of flags can also be used:</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FROM_OT"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FROM_OT</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyArray_FROM_O" title="PyArray_FROM_O"><code>PyArray_FROM_O</code></a> except it can take an argument of <em>typenum</em> specifying the type-number the returned array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FROM_OTF"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FROM_OTF</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">requirements</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Combination of <a class="reference internal" href="#c.PyArray_FROM_OF" title="PyArray_FROM_OF"><code>PyArray_FROM_OF</code></a> and <a class="reference internal" href="#c.PyArray_FROM_OT" title="PyArray_FROM_OT"><code>PyArray_FROM_OT</code></a> allowing both a <em>typenum</em> and a <em>flags</em> argument to be provided.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FROMANY"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FROMANY</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">typenum</span>, <span class="kt">int</span><span class="n">min</span>, <span class="kt">int</span><span class="n">max</span>, <span class="kt">int</span><span class="n">requirements</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> except the data-type is specified using a typenumber. <a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code>PyArray_DescrFromType</code></a> (<em>typenum</em>) is passed directly to <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a>. This macro also adds <a class="reference internal" href="#c.NPY_ARRAY_DEFAULT" title="NPY_ARRAY_DEFAULT"><code>NPY_ARRAY_DEFAULT</code></a> to requirements if <a class="reference internal" href="#c.NPY_ARRAY_ENSURECOPY" title="NPY_ARRAY_ENSURECOPY"><code>NPY_ARRAY_ENSURECOPY</code></a> is passed in as requirements.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckAxis"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CheckAxis</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="p">*</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">requirements</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is <code>obj</code>, while <code>*axis</code> is a converted integer (so that &gt;=MAXDIMS is the None value), and <code>requirements</code> gives the needed properties of <code>obj</code>. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of <code>*axis</code> are converted and the new value is checked to ensure consistency with the shape of <code>obj</code>.</p> </dd>
</dl> </section> </section> <section id="dealing-with-types"> <h2>Dealing with types</h2> <section id="general-check-of-python-type"> <h3>General check of Python Type</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Check"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Check</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is a Python object whose type is a sub-type of <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckExact"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CheckExact</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is a Python object with type <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_HasArrayInterface"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_HasArrayInterface</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If <code>op</code> implements any part of the array interface, then <code>out</code> will contain a new reference to the newly created ndarray using the interface or <code>out</code> will contain <code>NULL</code> if an error during conversion occurs. Otherwise, out will contain a borrowed reference to <a class="reference external" href="https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.12)"><code>Py_NotImplemented</code></a> and no error condition is set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_HasArrayInterfaceType"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_HasArrayInterfaceType</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">context</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If <code>op</code> implements any part of the array interface, then <code>out</code> will contain a new reference to the newly created ndarray using the interface or <code>out</code> will contain <code>NULL</code> if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the <a class="reference internal" href="../arrays.classes.html#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a> attribute. <code>context</code> is unused.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IsZeroDim"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IsZeroDim</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is an instance of (a subclass of) <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> and has 0 dimensions.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_IsScalar"> <span class="sig-name descname"><span class="n">PyArray_IsScalar</span></span><span class="sig-paren">(</span><span class="n">op</span>, <span class="n">cls</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is an instance of <code>Py{cls}ArrType_Type</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CheckScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is either an array scalar (an instance of a sub-type of <a class="reference internal" href="types-and-structures.html#c.PyGenericArrType_Type" title="PyGenericArrType_Type"><code>PyGenericArrType_Type</code></a> ), or an instance of (a sub-class of) <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> whose dimensionality is 0.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IsPythonNumber"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IsPythonNumber</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is an instance of a builtin numeric type (int, float, complex, long, bool)</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IsPythonScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IsPythonScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is a builtin Python scalar object (int, float, complex, bytes, str, long, bool).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IsAnyScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IsAnyScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is either a Python scalar object (see <a class="reference internal" href="#c.PyArray_IsPythonScalar" title="PyArray_IsPythonScalar"><code>PyArray_IsPythonScalar</code></a>) or an array scalar (an instance of a sub- type of <a class="reference internal" href="types-and-structures.html#c.PyGenericArrType_Type" title="PyGenericArrType_Type"><code>PyGenericArrType_Type</code></a> ).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckAnyScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CheckAnyScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is a Python scalar object (see <a class="reference internal" href="#c.PyArray_IsPythonScalar" title="PyArray_IsPythonScalar"><code>PyArray_IsPythonScalar</code></a>), an array scalar (an instance of a sub-type of <a class="reference internal" href="types-and-structures.html#c.PyGenericArrType_Type" title="PyGenericArrType_Type"><code>PyGenericArrType_Type</code></a>) or an instance of a sub-type of <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> whose dimensionality is 0.</p> </dd>
</dl> </section> <section id="data-type-accessors"> <h3>Data-type accessors</h3> <p>Some of the descriptor attributes may not always be defined and should or cannot not be accessed directly.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Prior to NumPy 2.0 the ABI was different but unnecessary large for user DTypes. These accessors were all added in 2.0 and can be backported (see <a class="reference internal" href="../../numpy_2_0_migration_guide.html#migration-c-descr"><span class="std std-ref">The PyArray_Descr struct has been changed</span></a>).</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ELSIZE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyDataType_ELSIZE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The element size of the datatype (<code>itemsize</code> in Python).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the <code>descr</code> is attached to an array <code>PyArray_ITEMSIZE(arr)</code> can be used and is available on all NumPy versions.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_SET_ELSIZE"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyDataType_SET_ELSIZE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">size</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Allows setting of the itemsize, this is <em>only</em> relevant for string/bytes datatypes as it is the current pattern to define one with a new size.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ALIGNENT"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyDataType_ALIGNENT</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The alignment of the datatype.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_METADATA"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_METADATA</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The Metadata attached to a dtype, either <code>NULL</code> or a dictionary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_NAMES"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_NAMES</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p><code>NULL</code> or a tuple of structured field names attached to a dtype.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_FIELDS"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_FIELDS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p><code>NULL</code>, <code>None</code>, or a dict of structured dtype fields, this dict must not be mutated, NumPy may change the way fields are stored in the future.</p> <p>This is the same dict as returned by <code>np.dtype.fields</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_C_METADATA"> <a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_C_METADATA</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>C-metadata object attached to a descriptor. This accessor should not be needed usually. The C-Metadata field does provide access to the datetime/timedelta time unit information.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_SUBARRAY"> <a class="reference internal" href="#c.PyDataType_SUBARRAY.PyArray_ArrayDescr" title="PyArray_ArrayDescr"><span class="n">PyArray_ArrayDescr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_SUBARRAY</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Information about a subarray dtype eqivalent to the Python <code>np.dtype.base</code> and <code>np.dtype.shape</code>.</p> <p>If this is non- <code>NULL</code>, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be <code>NULL</code> if this is non- <code>NULL</code> (the fields member of the base descriptor can be non- <code>NULL</code> however).</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyDataType_SUBARRAY.PyArray_ArrayDescr"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_ArrayDescr</span></span><br>
</dt> <dd>
<pre data-language="c">typedef struct {
    PyArray_Descr *base;
    PyObject *shape;
} PyArray_ArrayDescr;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyDataType_SUBARRAY.PyArray_ArrayDescr.base"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">base</span></span><br>
</dt> <dd>
<p>The data-type-descriptor object of the base-type.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyDataType_SUBARRAY.PyArray_ArrayDescr.shape"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">shape</span></span><br>
</dt> <dd>
<p>The shape (always C-style contiguous) of the sub-array as a Python tuple.</p> </dd>
</dl> </dd>
</dl> </dd>
</dl> </section> <section id="data-type-checking"> <h3>Data-type checking</h3> <p>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a <span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span></span> that can be directly interpreted as a <span class="c-expr sig sig-inline c"><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span></span>.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISUNSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISUNSIGNED</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISUNSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISUNSIGNED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISUNSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISUNSIGNED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents an unsigned integer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISSIGNED</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISSIGNED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISSIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISSIGNED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents a signed integer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISINTEGER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISINTEGER</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISINTEGER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISINTEGER</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISINTEGER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISINTEGER</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents any integer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISFLOAT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISFLOAT</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISFLOAT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISFLOAT</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISFLOAT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISFLOAT</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents any floating point number.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISCOMPLEX"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISCOMPLEX</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISCOMPLEX"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISCOMPLEX</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISCOMPLEX"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISCOMPLEX</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents any complex floating point number.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISNUMBER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISNUMBER</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISNUMBER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISNUMBER</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISNUMBER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISNUMBER</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents any integer, floating point, or complex floating point number.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISSTRING"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISSTRING</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISSTRING"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISSTRING</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISSTRING"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISSTRING</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents a string data type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISFLEXIBLE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISFLEXIBLE</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISFLEXIBLE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISFLEXIBLE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISFLEXIBLE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISFLEXIBLE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents one of the flexible array types ( <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_STRING" title="NPY_STRING"><code>NPY_STRING</code></a>, <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_UNICODE" title="NPY_UNICODE"><code>NPY_UNICODE</code></a>, or <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_VOID" title="NPY_VOID"><code>NPY_VOID</code></a> ).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISUNSIZED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISUNSIZED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.18.</span></p> </div> <p>For structured datatypes with no fields this function now returns False.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISUSERDEF"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISUSERDEF</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISUSERDEF"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISUSERDEF</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISUSERDEF"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISUSERDEF</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents a user-defined type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISEXTENDED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISEXTENDED</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISEXTENDED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISEXTENDED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISEXTENDED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISEXTENDED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type is either flexible or user-defined.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISOBJECT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISOBJECT</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISOBJECT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISOBJECT</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISOBJECT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISOBJECT</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents object data type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTypeNum_ISBOOL"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyTypeNum_ISBOOL</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_ISBOOL"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_ISBOOL</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISBOOL"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISBOOL</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type represents Boolean data type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_HASFIELDS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_HASFIELDS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_HASFIELDS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_HASFIELDS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type has fields associated with it.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISNOTSWAPPED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISNOTSWAPPED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">m</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of the ndarray <em>m</em> is in machine byte-order according to the array’s data-type descriptor.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISBYTESWAPPED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISBYTESWAPPED</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">m</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of the ndarray <em>m</em> is <strong>not</strong> in machine byte-order according to the array’s data-type descriptor.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EquivTypes"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">PyArray_EquivTypes</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">type1</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">type2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return <a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code>NPY_TRUE</code></a> if <em>type1</em> and <em>type2</em> actually represent equivalent types for this platform (the fortran member of each type is ignored). For example, on 32-bit platforms, <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_LONG" title="NPY_LONG"><code>NPY_LONG</code></a> and <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_INT" title="NPY_INT"><code>NPY_INT</code></a> are equivalent. Otherwise return <a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code>NPY_FALSE</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EquivArrTypes"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">PyArray_EquivArrTypes</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">a1</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">a2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return <a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code>NPY_TRUE</code></a> if <em>a1</em> and <em>a2</em> are arrays with equivalent types for this platform.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EquivTypenums"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">PyArray_EquivTypenums</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">typenum1</span>, <span class="kt">int</span><span class="n">typenum2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Special case of <a class="reference internal" href="#c.PyArray_EquivTypes" title="PyArray_EquivTypes"><code>PyArray_EquivTypes</code></a> (…) that does not accept flexible data types but may be easier to call.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EquivByteorders"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_EquivByteorders</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">b1</span>, <span class="kt">int</span><span class="n">b2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>True if byteorder characters <em>b1</em> and <em>b2</em> ( <a class="reference internal" href="#c.NPY_LITTLE" title="NPY_LITTLE"><code>NPY_LITTLE</code></a>, <a class="reference internal" href="#c.NPY_BIG" title="NPY_BIG"><code>NPY_BIG</code></a>, <a class="reference internal" href="#c.NPY_NATIVE" title="NPY_NATIVE"><code>NPY_NATIVE</code></a>, <a class="reference internal" href="#c.NPY_IGNORE" title="NPY_IGNORE"><code>NPY_IGNORE</code></a> ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine <a class="reference internal" href="#c.NPY_LITTLE" title="NPY_LITTLE"><code>NPY_LITTLE</code></a> and <a class="reference internal" href="#c.NPY_NATIVE" title="NPY_NATIVE"><code>NPY_NATIVE</code></a> are equivalent where they are not equivalent on a big-endian machine.</p> </dd>
</dl> </section> <section id="converting-data-types"> <h3>Converting data types</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Cast"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Cast</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Mainly for backwards compatibility to the Numeric C-API and for simple casts to non-flexible types. Return a new array object with the elements of <em>arr</em> cast to the data-type <em>typenum</em> which must be one of the enumerated types and not a flexible type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CastToType"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CastToType</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">type</span>, <span class="kt">int</span><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return a new array of the <em>type</em> specified, casting the elements of <em>arr</em> as appropriate. The fortran argument specifies the ordering of the output array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CastTo"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CastTo</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">in</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>As of 1.6, this function simply calls <a class="reference internal" href="#c.PyArray_CopyInto" title="PyArray_CopyInto"><code>PyArray_CopyInto</code></a>, which handles the casting.</p> <p>Cast the elements of the array <em>in</em> into the array <em>out</em>. The output array should be writeable, have an integer-multiple of the number of elements in the input array (more than one copy can be placed in out), and have a data type that is one of the builtin types. Returns 0 on success and -1 if an error occurs.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CanCastSafely"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CanCastSafely</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">fromtype</span>, <span class="kt">int</span><span class="n">totype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns non-zero if an array of data type <em>fromtype</em> can be cast to an array of data type <em>totype</em> without losing information. An exception is that 64-bit integers are allowed to be cast to 64-bit floating point values even though this can lose precision on large integers so as not to proliferate the use of long doubles without explicit requests. Flexible array types are not checked according to their lengths with this function.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CanCastTo"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CanCastTo</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">fromtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">totype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.PyArray_CanCastTypeTo" title="PyArray_CanCastTypeTo"><code>PyArray_CanCastTypeTo</code></a> supersedes this function in NumPy 1.6 and later.</p> <p>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CanCastTypeTo"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CanCastTypeTo</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">fromtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">totype</span>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="n">casting</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Returns non-zero if an array of data type <em>fromtype</em> (which can include flexible types) can be cast safely to an array of data type <em>totype</em> (which can include flexible types) according to the casting rule <em>casting</em>. For simple types with <a class="reference internal" href="#c.NPY_CASTING.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code>NPY_SAFE_CASTING</code></a>, this is basically a wrapper around <a class="reference internal" href="#c.PyArray_CanCastSafely" title="PyArray_CanCastSafely"><code>PyArray_CanCastSafely</code></a>, but for flexible types such as strings or unicode, it produces results taking into account their sizes. Integer and float types can only be cast to a string or unicode type using <a class="reference internal" href="#c.NPY_CASTING.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code>NPY_SAFE_CASTING</code></a> if the string or unicode type is big enough to hold the max value of the integer/float type being cast from.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CanCastArrayTo"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CanCastArrayTo</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">totype</span>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="n">casting</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Returns non-zero if <em>arr</em> can be cast to <em>totype</em> according to the casting rule given in <em>casting</em>. If <em>arr</em> is an array scalar, its value is taken into account, and non-zero is also returned when the value will not overflow or be truncated to an integer when converting to a smaller type.</p> <p>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MinScalarType"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MinScalarType</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>If <em>arr</em> is an array, returns its data type descriptor, but if <em>arr</em> is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</p> <p>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PromoteTypes"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_PromoteTypes</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">type1</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">type2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Finds the data type of smallest size and kind to which <em>type1</em> and <em>type2</em> may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ResultType"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ResultType</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">narrs</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">arrs</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">ndtypes</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtypes</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>This applies type promotion to all the input arrays and dtype objects, using the NumPy rules for combining scalars and arrays, to determine the output type for an operation with the given set of operands. This is the same result type that ufuncs produce.</p> <p>See the documentation of <a class="reference internal" href="../generated/numpy.result_type.html#numpy.result_type" title="numpy.result_type"><code>numpy.result_type</code></a> for more detail about the type promotion algorithm.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ObjectType"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ObjectType</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">mintype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function is superseded by <a class="reference internal" href="#c.PyArray_MinScalarType" title="PyArray_MinScalarType"><code>PyArray_MinScalarType</code></a> and/or <a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code>PyArray_ResultType</code></a>.</p> <p>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The <em>mintype</em> argument represents the minimum type acceptable, and <em>op</em> represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that <em>op</em> should have.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ConvertToCommonType"> <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ConvertToCommonType</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="p">*</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The functionality this provides is largely superseded by iterator <a class="reference internal" href="iterator.html#c.NpyIter" title="NpyIter"><code>NpyIter</code></a> introduced in 1.6, with flag <a class="reference internal" href="iterator.html#c.NPY_ITER_COMMON_DTYPE" title="NPY_ITER_COMMON_DTYPE"><code>NPY_ITER_COMMON_DTYPE</code></a> or with the same dtype parameter for all operands.</p> <p>Convert a sequence of Python objects contained in <em>op</em> to an array of ndarrays each having the same data type. The type is selected in the same way as <a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code>PyArray_ResultType</code></a>. The length of the sequence is returned in <em>n</em>, and an <em>n</em> -length array of <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a> pointers is the return value (or <code>NULL</code> if an error occurs). The returned array must be freed by the caller of this routine (using <a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code>PyDataMem_FREE</code></a> ) and all the array objects in it <code>DECREF</code> ‘d or a memory-leak will occur. The example template-code below shows a typical usage:</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.18.0: </span>A mix of scalars and zero-dimensional arrays now produces a type capable of holding the scalar value. Previously priority was given to the dtype of the arrays.</p> </div> <pre data-language="c">mps = PyArray_ConvertToCommonType(obj, &amp;n);
if (mps==NULL) return NULL;
{code}
&lt;before return&gt;
for (i=0; i&lt;n; i++) Py_DECREF(mps[i]);
PyDataMem_FREE(mps);
{return}
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Zero"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Zero</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to newly created memory of size <em>arr</em> -&gt;itemsize that holds the representation of 0 for that type. The returned pointer, <em>ret</em>, <strong>must be freed</strong> using <a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code>PyDataMem_FREE</code></a> (ret) when it is not needed anymore.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_One"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_One</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to newly created memory of size <em>arr</em> -&gt;itemsize that holds the representation of 1 for that type. The returned pointer, <em>ret</em>, <strong>must be freed</strong> using <a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code>PyDataMem_FREE</code></a> (ret) when it is not needed anymore.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ValidType"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ValidType</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns <a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code>NPY_TRUE</code></a> if <em>typenum</em> represents a valid type-number (builtin or user-defined or character code). Otherwise, this function returns <a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code>NPY_FALSE</code></a>.</p> </dd>
</dl> </section> <section id="user-defined-data-types"> <h3>User-defined data types</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_InitArrFuncs"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_InitArrFuncs</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_ArrFuncs" title="PyArray_ArrFuncs"><span class="n">PyArray_ArrFuncs</span></a><span class="p">*</span><span class="n">f</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Initialize all function pointers and members to <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_RegisterDataType"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_RegisterDataType</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DescrProto" title="PyArray_DescrProto"><span class="n">PyArray_DescrProto</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="admonition note"> <p class="admonition-title">Note</p> <p>As of NumPy 2.0 this API is considered legacy, the new DType API is more powerful and provides additional flexibility. The API may eventually be deprecated but support is continued for the time being.</p> <p><strong>Compiling for NumPy 1.x and 2.x</strong></p> <p>NumPy 2.x requires passing in a <code>PyArray_DescrProto</code> typed struct rather than a <code>PyArray_Descr</code>. This is necessary to allow changes. To allow code to run and compile on both 1.x and 2.x you need to change the type of your struct to <code>PyArray_DescrProto</code> and add:</p> <pre data-language="python">/* Allow compiling on NumPy 1.x */
#if NPY_ABI_VERSION &lt; 0x02000000
#define PyArray_DescrProto PyArray_Descr
#endif
</pre> <p>for 1.x compatibility. Further, the struct will <em>not</em> be the actual descriptor anymore, only it’s type number will be updated. After successful registration, you must thus fetch the actual dtype with:</p> <pre data-language="python">int type_num = PyArray_RegisterDataType(&amp;my_descr_proto);
if (type_num &lt; 0) {
    /* error */
}
PyArray_Descr *my_descr = PyArray_DescrFromType(type_num);
</pre> <p>With these two changes, the code should compile and work on both 1.x and 2.x or later.</p> </div> <p>Register a data-type as a new user-defined data type for arrays. The type must have most of its entries filled in. This is not always checked and errors can produce segfaults. In particular, the typeobj member of the <code>dtype</code> structure must be filled with a Python type that has a fixed-size element-size that corresponds to the elsize member of <em>dtype</em>. Also the <code>f</code> member must have the required functions: nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions may be <code>NULL</code> if no support is desired). To avoid confusion, you should choose a unique character typecode but this is not enforced and not relied on internally.</p> <p>A user-defined type number is returned that uniquely identifies the type. A pointer to the new structure can then be obtained from <a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code>PyArray_DescrFromType</code></a> using the returned type number. A -1 is returned if an error occurs. If this <em>dtype</em> has already been registered (checked only by the address of the pointer), then return the previously-assigned type-number.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_RegisterCastFunc"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_RegisterCastFunc</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <span class="kt">int</span><span class="n">totype</span>, <a class="reference internal" href="#c.PyArray_RegisterCastFunc.PyArray_VectorUnaryFunc" title="PyArray_VectorUnaryFunc"><span class="n">PyArray_VectorUnaryFunc</span></a><span class="p">*</span><span class="n">castfunc</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Register a low-level casting function, <em>castfunc</em>, to convert from the data-type, <em>descr</em>, to the given data-type number, <em>totype</em>. Any old casting function is over-written. A <code>0</code> is returned on success or a <code>-1</code> on failure.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_RegisterCastFunc.PyArray_VectorUnaryFunc"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_VectorUnaryFunc</span></span><br>
</dt> <dd>
<p>The function pointer type for low-level casting functions.</p> </dd>
</dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_RegisterCanCast"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_RegisterCanCast</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span>, <span class="kt">int</span><span class="n">totype</span>, <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><span class="n">NPY_SCALARKIND</span></a><span class="n">scalar</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Register the data-type number, <em>totype</em>, as castable from data-type object, <em>descr</em>, of the given <em>scalar</em> kind. Use <em>scalar</em> = <a class="reference internal" href="#c.NPY_SCALARKIND.NPY_NOSCALAR" title="NPY_NOSCALAR"><code>NPY_NOSCALAR</code></a> to register that an array of data-type <em>descr</em> can be cast safely to a data-type whose type_number is <em>totype</em>. The return value is 0 on success or -1 on failure.</p> </dd>
</dl> </section> <section id="special-functions-for-npy-object"> <h3>Special functions for NPY_OBJECT</h3> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When working with arrays or buffers filled with objects NumPy tries to ensure such buffers are filled with <code>None</code> before any data may be read. However, code paths may existed where an array is only initialized to <code>NULL</code>. NumPy itself accepts <code>NULL</code> as an alias for <code>None</code>, but may <code>assert</code> non-<code>NULL</code> when compiled in debug mode.</p> <p>Because NumPy is not yet consistent about initialization with None, users <strong>must</strong> expect a value of <code>NULL</code> when working with buffers created by NumPy. Users <strong>should</strong> also ensure to pass fully initialized buffers to NumPy, since NumPy may make this a strong requirement in the future.</p> <p>There is currently an intention to ensure that NumPy always initializes object arrays before they may be read. Any failure to do so will be regarded as a bug. In the future, users may be able to rely on non-NULL values when reading from any array, although exceptions for writing to freshly created arrays may remain (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists where proper filling is not done.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_INCREF"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_INCREF</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Used for an array, <em>op</em>, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of <em>op</em>. A -1 is returned if an error occurs, otherwise 0 is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Item_INCREF"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_Item_INCREF</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">ptr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A function to INCREF all the objects at the location <em>ptr</em> according to the data-type <em>dtype</em>. If <em>ptr</em> is the start of a structured type with an object at any offset, then this will (recursively) increment the reference count of all object-like items in the structured type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_XDECREF"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_XDECREF</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Used for an array, <em>op</em>, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of <em>op</em>. Normal return value is 0. A -1 is returned if an error occurs.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Item_XDECREF"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_Item_XDECREF</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">ptr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A function to XDECREF all the object-like items at the location <em>ptr</em> as recorded in the data-type, <em>dtype</em>. This works recursively so that if <code>dtype</code> itself has fields with data-types that contain object-like items, all the object-like fields will be XDECREF <code>'d</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SetWritebackIfCopyBase"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SetWritebackIfCopyBase</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">base</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Precondition: <code>arr</code> is a copy of <code>base</code> (though possibly with different strides, ordering, etc.) Sets the <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> flag and <code>arr-&gt;base</code>, and set <code>base</code> to READONLY. Call <a class="reference internal" href="#c.PyArray_ResolveWritebackIfCopy" title="PyArray_ResolveWritebackIfCopy"><code>PyArray_ResolveWritebackIfCopy</code></a> before calling <a class="reference external" href="https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF" title="(in Python v3.12)"><code>Py_DECREF</code></a> in order to copy any changes back to <code>base</code> and reset the READONLY flag.</p> <p>Returns 0 for success, -1 for failure.</p> </dd>
</dl> </section> </section> <section id="array-flags"> <h2 id="id1">Array flags</h2> <p>The <code>flags</code> attribute of the <code>PyArrayObject</code> structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</p> <p>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in <code>arrayobject.h</code> and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</p> <p>Memory areas of all kinds can be pointed to by an ndarray, necessitating these flags. If you get an arbitrary <code>PyArrayObject</code> in C-code, you need to be aware of the flags that are set. If you need to guarantee a certain kind of array (like <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> and <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code>NPY_ARRAY_BEHAVED</code></a>), then pass these requirements into the PyArray_FromAny function.</p> <p>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</p> <section id="basic-array-flags"> <h3>Basic Array Flags</h3> <p>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_C_CONTIGUOUS"> <span class="sig-name descname"><span class="n">NPY_ARRAY_C_CONTIGUOUS</span></span><br>
</dt> <dd>
<p>The data area is in C-style contiguous order (last index varies the fastest).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_F_CONTIGUOUS"> <span class="sig-name descname"><span class="n">NPY_ARRAY_F_CONTIGUOUS</span></span><br>
</dt> <dd>
<p>The data area is in Fortran-style contiguous order (first index varies the fastest).</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</p> <p>Even for contiguous arrays a stride for a given dimension <code>arr.strides[dim]</code> may be <em>arbitrary</em> if <code>arr.shape[dim] == 1</code> or the array has no elements. It does <em>not</em> generally hold that <code>self.strides[-1] == self.itemsize</code> for C-style contiguous arrays or <code>self.strides[0] == self.itemsize</code> for Fortran-style contiguous arrays is true. The correct way to access the <code>itemsize</code> of an array from the C API is <code>PyArray_ITEMSIZE(arr)</code>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../arrays.ndarray.html#arrays-ndarray"><span class="std std-ref">Internal memory layout of an ndarray</span></a></p> </div> </div> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_OWNDATA"> <span class="sig-name descname"><span class="n">NPY_ARRAY_OWNDATA</span></span><br>
</dt> <dd>
<p>The data area is owned by this array. Should never be set manually, instead create a <code>PyObject</code> wrapping the data and set the array’s base to that object. For an example, see the test in <code>test_mem_policy</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_ALIGNED"> <span class="sig-name descname"><span class="n">NPY_ARRAY_ALIGNED</span></span><br>
</dt> <dd>
<p>The data area and all array elements are aligned appropriately.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_WRITEABLE"> <span class="sig-name descname"><span class="n">NPY_ARRAY_WRITEABLE</span></span><br>
</dt> <dd>
<p>The data area can be written to.</p> <p>Notice that the above 3 flags are defined so that a new, well- behaved array has these flags defined as true.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_WRITEBACKIFCOPY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_WRITEBACKIFCOPY</span></span><br>
</dt> <dd>
<p>The data area represents a (well-behaved) copy whose information should be transferred back to the original when <a class="reference internal" href="#c.PyArray_ResolveWritebackIfCopy" title="PyArray_ResolveWritebackIfCopy"><code>PyArray_ResolveWritebackIfCopy</code></a> is called.</p> <p>This is a special flag that is set if this array represents a copy made because a user required certain flags in <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the “misbehaved” array (which is set read_only). <a class="reference internal" href="#c.PyArray_ResolveWritebackIfCopy" title="PyArray_ResolveWritebackIfCopy"><code>PyArray_ResolveWritebackIfCopy</code></a> will copy its contents back to the “misbehaved” array (casting if necessary) and will reset the “misbehaved” array to <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a>. If the “misbehaved” array was not <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> to begin with then <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> would have returned an error because <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> would not have been possible.</p> </dd>
</dl> <p><a class="reference internal" href="#c.PyArray_UpdateFlags" title="PyArray_UpdateFlags"><code>PyArray_UpdateFlags</code></a> (obj, flags) will update the <code>obj-&gt;flags</code> for <code>flags</code> which can be any of <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, or <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a>.</p> </section> <section id="combinations-of-array-flags"> <h3>Combinations of array flags</h3> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_BEHAVED"> <span class="sig-name descname"><span class="n">NPY_ARRAY_BEHAVED</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_CARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_CARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code>NPY_ARRAY_BEHAVED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_CARRAY_RO"> <span class="sig-name descname"><span class="n">NPY_ARRAY_CARRAY_RO</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_FARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_FARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code>NPY_ARRAY_BEHAVED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_FARRAY_RO"> <span class="sig-name descname"><span class="n">NPY_ARRAY_FARRAY_RO</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_DEFAULT"> <span class="sig-name descname"><span class="n">NPY_ARRAY_DEFAULT</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_CARRAY" title="NPY_ARRAY_CARRAY"><code>NPY_ARRAY_CARRAY</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_IN_ARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_IN_ARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_IN_FARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_IN_FARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_OUT_ARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_OUT_ARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_OUT_FARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_OUT_FARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_INOUT_ARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_INOUT_ARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_INOUT_FARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_INOUT_FARRAY</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_UPDATE_ALL"> <span class="sig-name descname"><span class="n">NPY_ARRAY_UPDATE_ALL</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a></p> </dd>
</dl> </section> <section id="flag-like-constants"> <h3>Flag-like constants</h3> <p>These constants are used in <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> (and its macro forms) to specify desired properties of the new array.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_FORCECAST"> <span class="sig-name descname"><span class="n">NPY_ARRAY_FORCECAST</span></span><br>
</dt> <dd>
<p>Cast to the desired type, even if it can’t be done without losing information.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_ENSURECOPY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_ENSURECOPY</span></span><br>
</dt> <dd>
<p>Make sure the resulting array is a copy of the original.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_ENSUREARRAY"> <span class="sig-name descname"><span class="n">NPY_ARRAY_ENSUREARRAY</span></span><br>
</dt> <dd>
<p>Make sure the resulting object is an actual ndarray, and not a sub-class.</p> </dd>
</dl> <p>These constants are used in <a class="reference internal" href="#c.PyArray_CheckFromAny" title="PyArray_CheckFromAny"><code>PyArray_CheckFromAny</code></a> (and its macro forms) to specify desired properties of the new array.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_NOTSWAPPED"> <span class="sig-name descname"><span class="n">NPY_ARRAY_NOTSWAPPED</span></span><br>
</dt> <dd>
<p>Make sure the returned array has a data-type descriptor that is in machine byte-order, over-riding any specification in the <em>dtype</em> argument. Normally, the byte-order requirement is determined by the <em>dtype</em> argument. If this flag is set and the dtype argument does not indicate a machine byte-order descriptor (or is NULL and the object is already an array with a data-type descriptor that is not in machine byte- order), then a new data-type descriptor is created and used with its byte-order field set to native.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_BEHAVED_NS"> <span class="sig-name descname"><span class="n">NPY_ARRAY_BEHAVED_NS</span></span><br>
</dt> <dd>
<p><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> | <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code>NPY_ARRAY_NOTSWAPPED</code></a></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ARRAY_ELEMENTSTRIDES"> <span class="sig-name descname"><span class="n">NPY_ARRAY_ELEMENTSTRIDES</span></span><br>
</dt> <dd>
<p>Make sure the returned array has strides that are multiples of the element size.</p> </dd>
</dl> </section> <section id="flag-checking"> <h3>Flag checking</h3> <p>For all of these macros <em>arr</em> must be an instance of a (subclass of) <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CHKFLAGS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CHKFLAGS</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">flags</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The first parameter, arr, must be an ndarray or subclass. The parameter, <em>flags</em>, should be an integer consisting of bitwise combinations of the possible flags an array can have: <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_OWNDATA" title="NPY_ARRAY_OWNDATA"><code>NPY_ARRAY_OWNDATA</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IS_C_CONTIGUOUS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IS_C_CONTIGUOUS</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>arr</em> is C-style contiguous.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IS_F_CONTIGUOUS"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IS_F_CONTIGUOUS</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>arr</em> is Fortran-style contiguous.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISFORTRAN"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISFORTRAN</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>arr</em> is Fortran-style contiguous and <em>not</em> C-style contiguous. <a class="reference internal" href="#c.PyArray_IS_F_CONTIGUOUS" title="PyArray_IS_F_CONTIGUOUS"><code>PyArray_IS_F_CONTIGUOUS</code></a> is the correct way to test for Fortran-style contiguity.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISWRITEABLE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISWRITEABLE</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> can be written to</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISALIGNED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISALIGNED</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is properly aligned on the machine.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISBEHAVED"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISBEHAVED</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is aligned and writeable and in machine byte-order according to its descriptor.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISBEHAVED_RO"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISBEHAVED_RO</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is aligned and in machine byte-order.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISCARRAY"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISCARRAY</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is C-style contiguous, and <a class="reference internal" href="#c.PyArray_ISBEHAVED" title="PyArray_ISBEHAVED"><code>PyArray_ISBEHAVED</code></a> (<em>arr</em>) is true.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISFARRAY"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISFARRAY</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is Fortran-style contiguous and <a class="reference internal" href="#c.PyArray_ISBEHAVED" title="PyArray_ISBEHAVED"><code>PyArray_ISBEHAVED</code></a> (<em>arr</em>) is true.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISCARRAY_RO"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISCARRAY_RO</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is C-style contiguous, aligned, and in machine byte-order.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISFARRAY_RO"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISFARRAY_RO</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> is Fortran-style contiguous, aligned, and in machine byte-order <strong>.</strong></p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ISONESEGMENT"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ISONESEGMENT</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if the data area of <em>arr</em> consists of a single (C-style or Fortran-style) contiguous segment.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_UpdateFlags"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_UpdateFlags</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="n">flagmask</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, and <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> array flags can be “calculated” from the array object itself. This routine updates one or more of these flags of <em>arr</em> as specified in <em>flagmask</em> by performing the required calculation.</p> </dd>
</dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is important to keep the flags updated (using <a class="reference internal" href="#c.PyArray_UpdateFlags" title="PyArray_UpdateFlags"><code>PyArray_UpdateFlags</code></a> can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FailUnlessWriteable"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_FailUnlessWriteable</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="k">const</span><span class="kt">char</span><span class="p">*</span><span class="n">name</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function does nothing and returns 0 if <em>obj</em> is writeable. It raises an exception and returns -1 if <em>obj</em> is not writeable. It may also do other house-keeping, such as issuing warnings on arrays which are transitioning to become views. Always call this function at some point before writing to an array.</p> <p><em>name</em> is a name for the array, used to give better error messages. It can be something like “assignment destination”, “output array”, or even just “array”.</p> </dd>
</dl> </section> </section> <section id="arraymethod-api"> <h2>ArrayMethod API</h2> <p>ArrayMethod loops are intended as a generic mechanism for writing loops over arrays, including ufunc loops and casts. The public API is defined in the <code>numpy/dtype_api.h</code> header. See <a class="reference internal" href="types-and-structures.html#arraymethod-structs"><span class="std std-ref">PyArrayMethod_Context and PyArrayMethod_Spec</span></a> for documentation on the C structs exposed in the ArrayMethod API.</p> <section id="slots-and-typedefs"> <h3 id="arraymethod-typedefs">Slots and Typedefs</h3> <p>These are used to identify which kind of function an ArrayMethod slot implements. See <a class="reference internal" href="#arraymethod-typedefs"><span class="std std-ref">Slots and Typedefs</span></a> below for documentation on the functions that must be implemented for each slot.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_resolve_descriptors"> <span class="sig-name descname"><span class="n">NPY_METH_resolve_descriptors</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_ResolveDescriptors"> <span class="k">typedef</span><a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_ResolveDescriptors</span></span><span class="p">)</span><span class="p">(</span><span class="k">struct</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMethodObject_tag" title="PyArrayMethodObject_tag"><span class="n">PyArrayMethodObject_tag</span></a><span class="p">*</span><span class="n">method</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="k">const</span><span class="p">*</span><span class="n">dtypes</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="k">const</span><span class="p">*</span><span class="n">given_descrs</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">loop_descrs</span><span class="p">,</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">view_offset</span><span class="p">)</span><br>
</dt> <dd>
<p>The function used to set the descriptors for an operation based on the descriptors of the operands. For example, a ufunc operation with two input operands and one output operand that is called without <code>out</code> being set in the python API, <code>resolve_descriptors</code> will be passed the descriptors for the two operands and determine the correct descriptor to use for the output based on the output DType set for the ArrayMethod. If <code>out</code> is set, then the output descriptor would be passed in as well and should not be overridden.</p> <p>The <em>method</em> is a pointer to the underlying cast or ufunc loop. In the future we may expose this struct publicly but for now this is an opaque pointer and the method cannot be inspected. The <em>dtypes</em> is an <code>nargs</code> length array of <code>PyArray_DTypeMeta</code> pointers, <em>given_descrs</em> is an <code>nargs</code> length array of input descriptor instances (output descriptors may be NULL if no output was provided by the user), and <em>loop_descrs</em> is an <code>nargs</code> length array of descriptors that must be filled in by the resolve descriptors implementation. <em>view_offset</em> is currently only interesting for casts and can normally be ignored. When a cast does not require any operation, this can be signalled by setting <code>view_offset</code> to 0. On error, you must return <code>(NPY_CASTING)-1</code> with an error set.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_strided_loop"> <span class="sig-name descname"><span class="n">NPY_METH_strided_loop</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_contiguous_loop"> <span class="sig-name descname"><span class="n">NPY_METH_contiguous_loop</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_unaligned_strided_loop"> <span class="sig-name descname"><span class="n">NPY_METH_unaligned_strided_loop</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_unaligned_contiguous_loop"> <span class="sig-name descname"><span class="n">NPY_METH_unaligned_contiguous_loop</span></span><br>
</dt> <dd>
<p>One dimensional strided loops implementing the behavior (either a ufunc or cast). In most cases, <code>NPY_METH_strided_loop</code> is the generic and only version that needs to be implemented. <code>NPY_METH_contiguous_loop</code> can be implemented additionally as a more light-weight/faster version and it is used when all inputs and outputs are contiguous.</p> <p>To deal with possibly unaligned data, NumPy needs to be able to copy unaligned to aligned data. When implementing a new DType, the “cast” or copy for it needs to implement <code>NPY_METH_unaligned_strided_loop</code>. Unlike the normal versions, this loop must not assume that the data can be accessed in an aligned fashion. These loops must copy each value before accessing or storing:</p> <pre data-language="python">type_in in_value;
type_out out_value
memcpy(&amp;value, in_data, sizeof(type_in));
out_value = in_value;
memcpy(out_data, &amp;out_value, sizeof(type_out)
</pre> <p>while a normal loop can just use:</p> <pre data-language="python">*(type_out *)out_data = *(type_in)in_data;
</pre> <p>The unaligned loops are currently only used in casts and will never be picked in ufuncs (ufuncs create a temporary copy to ensure aligned inputs). These slot IDs are ignored when <code>NPY_METH_get_loop</code> is defined, where instead whichever loop returned by the <code>get_loop</code> function is used.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_contiguous_indexed_loop"> <span class="sig-name descname"><span class="n">NPY_METH_contiguous_indexed_loop</span></span><br>
</dt> <dd>
<p>A specialized inner-loop option to speed up common <code>ufunc.at</code> computations.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_StridedLoop"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_StridedLoop</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMethod_Context" title="PyArrayMethod_Context"><span class="n">PyArrayMethod_Context</span></a><span class="p">*</span><span class="n">context</span><span class="p">,</span><span class="kt">char</span><span class="p">*</span><span class="k">const</span><span class="p">*</span><span class="n">data</span><span class="p">,</span><span class="k">const</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">dimensions</span><span class="p">,</span><span class="k">const</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">strides</span><span class="p">,</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="n">auxdata</span><span class="p">)</span><br>
</dt> <dd>
<p>An implementation of an ArrayMethod loop. All of the loop slot IDs listed above must provide a <code>PyArrayMethod_StridedLoop</code> implementation. The <em>context</em> is a struct containing context for the loop operation - in particular the input descriptors. The <em>data</em> are an array of pointers to the beginning of the input and output array buffers. The <em>dimensions</em> are the loop dimensions for the operation. The <em>strides</em> are an <code>nargs</code> length array of strides for each input. The <em>auxdata</em> is an optional set of auxiliary data that can be passed in to the loop - helpful to turn on and off optional behavior or reduce boilerplate by allowing similar ufuncs to share loop implementations or to allocate space that is persistent over multiple strided loop calls.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_get_loop"> <span class="sig-name descname"><span class="n">NPY_METH_get_loop</span></span><br>
</dt> <dd>
<p>Allows more fine-grained control over loop selection. Accepts an implementation of PyArrayMethod_GetLoop, which in turn returns a strided loop implementation. If <code>NPY_METH_get_loop</code> is defined, the other loop slot IDs are ignored, if specified.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_GetLoop"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_GetLoop</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMethod_Context" title="PyArrayMethod_Context"><span class="n">PyArrayMethod_Context</span></a><span class="p">*</span><span class="n">context</span><span class="p">,</span><span class="kt">int</span><span class="n">aligned</span><span class="p">,</span><span class="kt">int</span><span class="n">move_references</span><span class="p">,</span><span class="k">const</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">strides</span><span class="p">,</span><a class="reference internal" href="#c.PyArrayMethod_StridedLoop" title="PyArrayMethod_StridedLoop"><span class="n">PyArrayMethod_StridedLoop</span></a><span class="p">*</span><span class="p">*</span><span class="n">out_loop</span><span class="p">,</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="p">*</span><span class="n">out_transferdata</span><span class="p">,</span><a class="reference internal" href="#c.NPY_ARRAYMETHOD_FLAGS" title="NPY_ARRAYMETHOD_FLAGS"><span class="n">NPY_ARRAYMETHOD_FLAGS</span></a><span class="p">*</span><span class="n">flags</span><span class="p">)</span><span class="p">;</span><br>
</dt> <dd>
<p>Sets the loop to use for an operation at runtime. The <em>context</em> is the runtime context for the operation. <em>aligned</em> indicates whether the data access for the loop is aligned (1) or unaligned (0). <em>move_references</em> indicates whether embedded references in the data should be copied. <em>strides</em> are the strides for the input array, <em>out_loop</em> is a pointer that must be filled in with a pointer to the loop implementation. <em>out_transferdata</em> can be optionally filled in to allow passing in extra user-defined context to an operation. <em>flags</em> must be filled in with ArrayMethod flags relevant for the operation. This is for example necessary to indicate if the inner loop requires the Python GIL to be held.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_METH_get_reduction_initial"> <span class="sig-name descname"><span class="n">NPY_METH_get_reduction_initial</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_GetReductionInitial"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_GetReductionInitial</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMethod_Context" title="PyArrayMethod_Context"><span class="n">PyArrayMethod_Context</span></a><span class="p">*</span><span class="n">context</span><span class="p">,</span><a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="n">reduction_is_empty</span><span class="p">,</span><span class="kt">char</span><span class="p">*</span><span class="n">initial</span><span class="p">)</span><br>
</dt> <dd>
<p>Query an ArrayMethod for the initial value for use in reduction. The <em>context</em> is the ArrayMethod context, mainly to access the input descriptors. <em>reduction_is_empty</em> indicates whether the reduction is empty. When it is, the value returned may differ. In this case it is a “default” value that may differ from the “identity” value normally used. For example:</p> <ul class="simple"> <li>
<code>0.0</code> is the default for <code>sum([])</code>. But <code>-0.0</code> is the correct identity otherwise as it preserves the sign for <code>sum([-0.0])</code>.</li> <li>We use no identity for object, but return the default of <code>0</code> and <code>1</code> for the empty <code>sum([], dtype=object)</code> and <code>prod([], dtype=object)</code>. This allows <code>np.sum(np.array(["a", "b"], dtype=object))</code> to work.</li> <li>
<code>-inf</code> or <code>INT_MIN</code> for <code>max</code> is an identity, but at least <code>INT_MIN</code> not a good <em>default</em> when there are no items.</li> </ul> <p><em>initial</em> is a pointer to the data for the initial value, which should be filled in. Returns -1, 0, or 1 indicating error, no initial value, and the initial value being successfully filled. Errors must not be given when no initial value is correct, since NumPy may call this even when it is not strictly necessary to do so.</p> </dd>
</dl> </section> <section id="flags"> <h3>Flags</h3> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_ARRAYMETHOD_FLAGS</span></span><br>
</dt> <dd>
<p>These flags allow switching on and off custom runtime behavior for ArrayMethod loops. For example, if a ufunc cannot possibly trigger floating point errors, then the <code>NPY_METH_NO_FLOATINGPOINT_ERRORS</code> flag should be set on the ufunc when it is registered.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS.NPY_METH_REQUIRES_PYAPI"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_METH_REQUIRES_PYAPI</span></span><br>
</dt> <dd>
<p>Indicates the method must hold the GIL. If this flag is not set, the GIL is released before the loop is called.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS.NPY_METH_NO_FLOATINGPOINT_ERRORS"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_METH_NO_FLOATINGPOINT_ERRORS</span></span><br>
</dt> <dd>
<p>Indicates the method cannot generate floating errors, so checking for floating errors after the loop completes can be skipped.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS.NPY_METH_SUPPORTS_UNALIGNED"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_METH_SUPPORTS_UNALIGNED</span></span><br>
</dt> <dd>
<p>Indicates the method supports unaligned access.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS.NPY_METH_IS_REORDERABLE"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_METH_IS_REORDERABLE</span></span><br>
</dt> <dd>
<p>Indicates that the result of applying the loop repeatedly (for example, in a reduction operation) does not depend on the order of application.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ARRAYMETHOD_FLAGS.NPY_METH_RUNTIME_FLAGS"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_METH_RUNTIME_FLAGS</span></span><br>
</dt> <dd>
<p>The flags that can be changed at runtime.</p> </dd>
</dl> </dd>
</dl> </section> <section id="typedefs"> <h3>Typedefs</h3> <p>Typedefs for functions that users of the ArrayMethod API can implement are described below.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_TraverseLoop"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_TraverseLoop</span></span><span class="p">)</span><span class="p">(</span><span class="kt">void</span><span class="p">*</span><span class="n">traverse_context</span><span class="p">,</span><span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="p">,</span><span class="kt">char</span><span class="p">*</span><span class="n">data</span><span class="p">,</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">size</span><span class="p">,</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">stride</span><span class="p">,</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="n">auxdata</span><span class="p">)</span><br>
</dt> <dd>
<p>A traverse loop working on a single array. This is similar to the general strided-loop function. This is designed for loops that need to visit every element of a single array.</p> <p>Currently this is used for array clearing, via the <code>NPY_DT_get_clear_loop</code> DType API hook, and zero-filling, via the <code>NPY_DT_get_fill_zero_loop</code> DType API hook. These are most useful for handling arrays storing embedded references to python objects or heap-allocated data.</p> <p>The <em>descr</em> is the descriptor for the array, <em>data</em> is a pointer to the array buffer, <em>size</em> is the 1D size of the array buffer, <em>stride</em> is the stride, and <em>auxdata</em> is optional extra data for the loop.</p> <p>The <em>traverse_context</em> is passed in because we may need to pass in Interpreter state or similar in the future, but we don’t want to pass in a full context (with pointers to dtypes, method, caller which all make no sense for a traverse function). We assume for now that this context can be just passed through in the future (for structured dtypes).</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_GetTraverseLoop"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_GetTraverseLoop</span></span><span class="p">)</span><span class="p">(</span><span class="kt">void</span><span class="p">*</span><span class="n">traverse_context</span><span class="p">,</span><span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">descr</span><span class="p">,</span><span class="kt">int</span><span class="n">aligned</span><span class="p">,</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">fixed_stride</span><span class="p">,</span><a class="reference internal" href="#c.PyArrayMethod_TraverseLoop" title="PyArrayMethod_TraverseLoop"><span class="n">PyArrayMethod_TraverseLoop</span></a><span class="p">*</span><span class="p">*</span><span class="n">out_loop</span><span class="p">,</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="p">*</span><span class="n">out_auxdata</span><span class="p">,</span><a class="reference internal" href="#c.NPY_ARRAYMETHOD_FLAGS" title="NPY_ARRAYMETHOD_FLAGS"><span class="n">NPY_ARRAYMETHOD_FLAGS</span></a><span class="p">*</span><span class="n">flags</span><span class="p">)</span><br>
</dt> <dd>
<p>Simplified get_loop function specific to dtype traversal</p> <p>It should set the flags needed for the traversal loop and set <em>out_loop</em> to the loop function, which must be a valid <code>PyArrayMethod_TraverseLoop</code> pointer. Currently this is used for zero-filling and clearing arrays storing embedded references.</p> </dd>
</dl> </section> <section id="api-functions-and-typedefs"> <h3>API Functions and Typedefs</h3> <p>These functions are part of the main numpy array API and were added along with the rest of the ArrayMethod API.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_AddLoopFromSpec"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_AddLoopFromSpec</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">ufunc</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayMethod_Spec" title="PyArrayMethod_Spec"><span class="n">PyArrayMethod_Spec</span></a><span class="p">*</span><span class="n">spec</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Add loop directly to a ufunc from a given ArrayMethod spec. the main ufunc registration function. This adds a new implementation/loop to a ufunc. It replaces <code>PyUFunc_RegisterLoopForType</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_AddPromoter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_AddPromoter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">ufunc</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">DType_tuple</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">promoter</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Note that currently the output dtypes are always <code>NULL</code> unless they are also part of the signature. This is an implementation detail and could change in the future. However, in general promoters should not have a need for output dtypes. Register a new promoter for a ufunc. The first argument is the ufunc to register the promoter with. The second argument is a Python tuple containing DTypes or None matching the number of inputs and outputs for the ufuncs. The last argument is a promoter is a function stored in a PyCapsule. It is passed the operation and requested DType signatures and can mutate it to attempt a new search for a matching loop/promoter.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_PromoterFunction"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_PromoterFunction</span></span><span class="p">)</span><span class="p">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">ufunc</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="k">const</span><span class="n">op_dtypes</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="k">const</span><span class="n">signature</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">new_op_dtypes</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><br>
</dt> <dd>
<p>Type of the promoter function, which must be wrapped into a <code>PyCapsule</code> with name <code>"numpy._ufunc_promoter"</code>. It is passed the operation and requested DType signatures and can mutate the signatures to attempt a search for a new loop or promoter that can accomplish the operation by casting the inputs to the “promoted” DTypes.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_GiveFloatingpointErrors"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_GiveFloatingpointErrors</span></span><span class="sig-paren">(</span><span class="k">const</span><span class="kt">char</span><span class="p">*</span><span class="n">name</span>, <span class="kt">int</span><span class="n">fpe_errors</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Checks for a floating point error after performing a floating point operation in a manner that takes into account the error signaling configured via <a class="reference internal" href="../generated/numpy.errstate.html#numpy.errstate" title="numpy.errstate"><code>numpy.errstate</code></a>. Takes the name of the operation to use in the error message and an integer flag that is one of <code>NPY_FPE_DIVIDEBYZERO</code>, <code>NPY_FPE_OVERFLOW</code>, <code>NPY_FPE_UNDERFLOW</code>, <code>NPY_FPE_INVALID</code> to indicate which error to check for.</p> <p>Returns -1 on failure (an error was raised) and 0 on success.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_AddWrappingLoop"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_AddWrappingLoop</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">ufunc_obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">new_dtypes</span><span class="p">[</span><span class="p">]</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">wrapped_dtypes</span><span class="p">[</span><span class="p">]</span>, <a class="reference internal" href="#c.PyArrayMethod_TranslateGivenDescriptors" title="PyArrayMethod_TranslateGivenDescriptors"><span class="n">PyArrayMethod_TranslateGivenDescriptors</span></a><span class="p">*</span><span class="n">translate_given_descrs</span>, <a class="reference internal" href="#c.PyArrayMethod_TranslateLoopDescriptors" title="PyArrayMethod_TranslateLoopDescriptors"><span class="n">PyArrayMethod_TranslateLoopDescriptors</span></a><span class="p">*</span><span class="n">translate_loop_descrs</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Allows creating of a fairly lightweight wrapper around an existing ufunc loop. The idea is mainly for units, as this is currently slightly limited in that it enforces that you cannot use a loop from another ufunc.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_TranslateGivenDescriptors"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_TranslateGivenDescriptors</span></span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="n">nin</span><span class="p">,</span><span class="kt">int</span><span class="n">nout</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">wrapped_dtypes</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">given_descrs</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">new_descrs</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><br>
</dt> <dd>
<p>The function to convert the given descriptors (passed in to <code>resolve_descriptors</code>) and translates them for the wrapped loop. The new descriptors MUST be viewable with the old ones, <code>NULL</code> must be supported (for output arguments) and should normally be forwarded.</p> <p>The output of of this function will be used to construct views of the arguments as if they were the translated dtypes and does not use a cast. This means this mechanism is mostly useful for DTypes that “wrap” another DType implementation. For example, a unit DType could use this to wrap an existing floating point DType without needing to re-implement low-level ufunc logic. In the unit example, <code>resolve_descriptors</code> would handle computing the output unit from the input unit.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_TranslateLoopDescriptors"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayMethod_TranslateLoopDescriptors</span></span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="n">nin</span><span class="p">,</span><span class="kt">int</span><span class="n">nout</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">new_dtypes</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">given_descrs</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">original_descrs</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">loop_descrs</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><br>
</dt> <dd>
<p>The function to convert the actual loop descriptors (as returned by the original <code>resolve_descriptors</code> function) to the ones the output array should use. This function must return “viewable” types, it must not mutate them in any form that would break the inner-loop logic. Does not need to support NULL.</p> </dd>
</dl> <section id="wrapping-loop-example"> <h4>Wrapping Loop Example</h4> <p>Suppose you want to wrap the <code>float64</code> multiply implementation for a <code>WrappedDoubleDType</code>. You would add a wrapping loop like so:</p> <pre data-language="c">PyArray_DTypeMeta *orig_dtypes[3] = {
    &amp;WrappedDoubleDType, &amp;WrappedDoubleDType, &amp;WrappedDoubleDType};
PyArray_DTypeMeta *wrapped_dtypes[3] = {
     &amp;PyArray_Float64DType, &amp;PyArray_Float64DType, &amp;PyArray_Float64DType}

PyObject *mod = PyImport_ImportModule("numpy");
if (mod == NULL) {
    return -1;
}
PyObject *multiply = PyObject_GetAttrString(mod, "multiply");
Py_DECREF(mod);

if (multiply == NULL) {
    return -1;
}

int res = PyUFunc_AddWrappingLoop(
    multiply, orig_dtypes, wrapped_dtypes, &amp;translate_given_descrs
    &amp;translate_loop_descrs);

Py_DECREF(multiply);
</pre> <p>Note that this also requires two functions to be defined above this code:</p> <pre data-language="c">static int
translate_given_descrs(int nin, int nout,
                       PyArray_DTypeMeta *NPY_UNUSED(wrapped_dtypes[]),
                       PyArray_Descr *given_descrs[],
                       PyArray_Descr *new_descrs[])
{
    for (int i = 0; i &lt; nin + nout; i++) {
        if (given_descrs[i] == NULL) {
            new_descrs[i] = NULL;
        }
        else {
            new_descrs[i] = PyArray_DescrFromType(NPY_DOUBLE);
        }
    }
    return 0;
}

static int
translate_loop_descrs(int nin, int NPY_UNUSED(nout),
                      PyArray_DTypeMeta *NPY_UNUSED(new_dtypes[]),
                      PyArray_Descr *given_descrs[],
                      PyArray_Descr *original_descrs[],
                      PyArray_Descr *loop_descrs[])
{
    // more complicated parametric DTypes may need to
    // to do additional checking, but we know the wrapped
    // DTypes *have* to be float64 for this example.
    loop_descrs[0] = PyArray_DescrFromType(NPY_FLOAT64);
    Py_INCREF(loop_descrs[0]);
    loop_descrs[1] = PyArray_DescrFromType(NPY_FLOAT64);
    Py_INCREF(loop_descrs[1]);
    loop_descrs[2] = PyArray_DescrFromType(NPY_FLOAT64);
    Py_INCREF(loop_descrs[2]);
}
</pre> </section> </section> </section> <section id="api-for-calling-array-methods"> <h2>API for calling array methods</h2> <section id="conversion"> <h3>Conversion</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetField"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GetField</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">offset</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield" title="numpy.ndarray.getfield"><code>ndarray.getfield</code></a> (<em>self</em>, <em>dtype</em>, <em>offset</em>). This function <a class="reference external" href="https://docs.python.org/3/c-api/intro.html?reference-count-details">steals a reference</a> to <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> and returns a new array of the given <code>dtype</code> using the data in the current array at a specified <code>offset</code> in bytes. The <code>offset</code> plus the itemsize of the new array type must be less than <code>self-&gt;descr-&gt;elsize</code> or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SetField"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SetField</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">offset</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">val</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield" title="numpy.ndarray.setfield"><code>ndarray.setfield</code></a> (<em>self</em>, <em>val</em>, <em>dtype</em>, <em>offset</em> ). Set the field starting at <em>offset</em> in bytes and of the given <em>dtype</em> to <em>val</em>. The <em>offset</em> plus <em>dtype</em> -&gt;elsize must be less than <em>self</em> -&gt;descr-&gt;elsize or an error is raised. Otherwise, the <em>val</em> argument is converted to an array and copied into the field pointed to. If necessary, the elements of <em>val</em> are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in <em>val</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Byteswap"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Byteswap</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="n">inplace</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap" title="numpy.ndarray.byteswap"><code>ndarray.byteswap</code></a> (<em>self</em>, <em>inplace</em>). Return an array whose data area is byteswapped. If <em>inplace</em> is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NewCopy"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_NewCopy</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">old</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.copy.html#numpy.ndarray.copy" title="numpy.ndarray.copy"><code>ndarray.copy</code></a> (<em>self</em>, <em>fortran</em>). Make a copy of the <em>old</em> array. The returned array is always aligned and writeable with data interpreted the same as the old array. If <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_CORDER" title="NPY_CORDER"><code>NPY_CORDER</code></a>, then a C-style contiguous array is returned. If <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code>NPY_FORTRANORDER</code></a>, then a Fortran-style contiguous array is returned. If <em>order is</em> <a class="reference internal" href="#c.NPY_ORDER.NPY_ANYORDER" title="NPY_ANYORDER"><code>NPY_ANYORDER</code></a>, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ToList"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ToList</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist" title="numpy.ndarray.tolist"><code>ndarray.tolist</code></a> (<em>self</em>). Return a nested Python list from <em>self</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ToString"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ToString</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes" title="numpy.ndarray.tobytes"><code>ndarray.tobytes</code></a> (<em>self</em>, <em>order</em>). Return the bytes of this array in a Python string.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ToFile"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ToFile</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="n">FILE</span><span class="p">*</span><span class="n">fp</span>, <span class="kt">char</span><span class="p">*</span><span class="n">sep</span>, <span class="kt">char</span><span class="p">*</span><span class="n">format</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Write the contents of <em>self</em> to the file pointer <em>fp</em> in C-style contiguous fashion. Write the data as binary bytes if <em>sep</em> is the string “”or <code>NULL</code>. Otherwise, write the contents of <em>self</em> as text using the <em>sep</em> string as the item separator. Each item will be printed to the file. If the <em>format</em> string is not <code>NULL</code> or “”, then it is a Python print statement format string showing how the items are to be written.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Dump"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Dump</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">file</span>, <span class="kt">int</span><span class="n">protocol</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Pickle the object in <em>self</em> to the given <em>file</em> (either a string or a Python file object). If <em>file</em> is a Python string it is considered to be the name of a file which is then opened in binary mode. The given <em>protocol</em> is used (if <em>protocol</em> is negative, or the highest available is used). This is a simple wrapper around cPickle.dump(<em>self</em>, <em>file</em>, <em>protocol</em>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Dumps"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Dumps</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">protocol</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Pickle the object in <em>self</em> to a Python string and return it. Use the Pickle <em>protocol</em> provided (or the highest available if <em>protocol</em> is negative).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FillWithScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_FillWithScalar</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Fill the array, <em>arr</em>, with the given scalar object, <em>obj</em>. The object is first converted to the data type of <em>arr</em>, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_View"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_View</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="n">ptype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.view.html#numpy.ndarray.view" title="numpy.ndarray.view"><code>ndarray.view</code></a> (<em>self</em>, <em>dtype</em>). Return a new view of the array <em>self</em> as possibly a different data-type, <em>dtype</em>, and different array subclass <em>ptype</em>.</p> <p>If <em>dtype</em> is <code>NULL</code>, then the returned array will have the same data type as <em>self</em>. The new data-type must be consistent with the size of <em>self</em>. Either the itemsizes must be identical, or <em>self</em> must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</p> </dd>
</dl> </section> <section id="shape-manipulation"> <h3>Shape Manipulation</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Newshape"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Newshape</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><span class="n">PyArray_Dims</span></a><span class="p">*</span><span class="n">newshape</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Result will be a new array (pointing to the same memory location as <em>self</em> if possible), but having a shape given by <em>newshape</em>. If the new shape is not compatible with the strides of <em>self</em>, then a copy of the array with the new specified shape will be returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Reshape"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Reshape</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">shape</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape" title="numpy.ndarray.reshape"><code>ndarray.reshape</code></a> (<em>self</em>, <em>shape</em>) where <em>shape</em> is a sequence. Converts <em>shape</em> to a <a class="reference internal" href="types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><code>PyArray_Dims</code></a> structure and calls <a class="reference internal" href="#c.PyArray_Newshape" title="PyArray_Newshape"><code>PyArray_Newshape</code></a> internally. For back-ward compatibility – Not recommended</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Squeeze"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Squeeze</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze" title="numpy.ndarray.squeeze"><code>ndarray.squeeze</code></a> (<em>self</em>). Return a new view of <em>self</em> with all of the dimensions of length 1 removed from the shape.</p> </dd>
</dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>matrix objects are always 2-dimensional. Therefore, <a class="reference internal" href="#c.PyArray_Squeeze" title="PyArray_Squeeze"><code>PyArray_Squeeze</code></a> has no effect on arrays of matrix sub-class.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SwapAxes"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SwapAxes</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">a1</span>, <span class="kt">int</span><span class="n">a2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes" title="numpy.ndarray.swapaxes"><code>ndarray.swapaxes</code></a> (<em>self</em>, <em>a1</em>, <em>a2</em>). The returned array is a new view of the data in <em>self</em> with the given axes, <em>a1</em> and <em>a2</em>, swapped.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Resize"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Resize</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><span class="n">PyArray_Dims</span></a><span class="p">*</span><span class="n">newshape</span>, <span class="kt">int</span><span class="n">refcheck</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">fortran</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.resize.html#numpy.ndarray.resize" title="numpy.ndarray.resize"><code>ndarray.resize</code></a> (<em>self</em>, <em>newshape</em>, refcheck <code>=</code> <em>refcheck</em>, order= fortran ). This function only works on single-segment arrays. It changes the shape of <em>self</em> inplace and will reallocate the memory for <em>self</em> if <em>newshape</em> has a different total number of elements then the old shape. If reallocation is necessary, then <em>self</em> must own its data, have <em>self</em> - <code>&gt;base==NULL</code>, have <em>self</em> - <code>&gt;weakrefs==NULL</code>, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be <a class="reference internal" href="#c.NPY_ORDER.NPY_ANYORDER" title="NPY_ANYORDER"><code>NPY_ANYORDER</code></a>, <a class="reference internal" href="#c.NPY_ORDER.NPY_CORDER" title="NPY_CORDER"><code>NPY_CORDER</code></a>, or <a class="reference internal" href="#c.NPY_ORDER.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code>NPY_FORTRANORDER</code></a>. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Transpose"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Transpose</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><span class="n">PyArray_Dims</span></a><span class="p">*</span><span class="n">permute</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose" title="numpy.ndarray.transpose"><code>ndarray.transpose</code></a> (<em>self</em>, <em>permute</em>). Permute the axes of the ndarray object <em>self</em> according to the data structure <em>permute</em> and return the result. If <em>permute</em> is <code>NULL</code>, then the resulting array has its axes reversed. For example if <em>self</em> has shape <span class="math notranslate nohighlight">\(10\times20\times30\)</span>, and <em>permute</em> <code>.ptr</code> is (0,2,1) the shape of the result is <span class="math notranslate nohighlight">\(10\times30\times20.\)</span> If <em>permute</em> is <code>NULL</code>, the shape of the result is <span class="math notranslate nohighlight">\(30\times20\times10.\)</span></p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Flatten"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Flatten</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten" title="numpy.ndarray.flatten"><code>ndarray.flatten</code></a> (<em>self</em>, <em>order</em>). Return a 1-d copy of the array. If <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code>NPY_FORTRANORDER</code></a> the elements are scanned out in Fortran order (first-dimension varies the fastest). If <em>order</em> is <a class="reference internal" href="#c.NPY_ORDER.NPY_CORDER" title="NPY_CORDER"><code>NPY_CORDER</code></a>, the elements of <code>self</code> are scanned in C-order (last dimension varies the fastest). If <em>order</em> <a class="reference internal" href="#c.NPY_ORDER.NPY_ANYORDER" title="NPY_ANYORDER"><code>NPY_ANYORDER</code></a>, then the result of <a class="reference internal" href="#c.PyArray_ISFORTRAN" title="PyArray_ISFORTRAN"><code>PyArray_ISFORTRAN</code></a> (<em>self</em>) is used to determine which order to flatten.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Ravel"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Ravel</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <em>self</em>.ravel(<em>order</em>). Same basic functionality as <a class="reference internal" href="#c.PyArray_Flatten" title="PyArray_Flatten"><code>PyArray_Flatten</code></a> (<em>self</em>, <em>order</em>) except if <em>order</em> is 0 and <em>self</em> is C-style contiguous, the shape is altered but no copy is performed.</p> </dd>
</dl> </section> <section id="item-selection-and-manipulation"> <h3>Item selection and manipulation</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_TakeFrom"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_TakeFrom</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">indices</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">ret</span>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><span class="n">NPY_CLIPMODE</span></a><span class="n">clipmode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.take.html#numpy.ndarray.take" title="numpy.ndarray.take"><code>ndarray.take</code></a> (<em>self</em>, <em>indices</em>, <em>axis</em>, <em>ret</em>, <em>clipmode</em>) except <em>axis</em> =None in Python is obtained by setting <em>axis</em> = <a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code>NPY_MAXDIMS</code></a> in C. Extract the items from self indicated by the integer-valued <em>indices</em> along the given <em>axis.</em> The clipmode argument can be <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_RAISE" title="NPY_RAISE"><code>NPY_RAISE</code></a>, <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_WRAP" title="NPY_WRAP"><code>NPY_WRAP</code></a>, or <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_CLIP" title="NPY_CLIP"><code>NPY_CLIP</code></a> to indicate what to do with out-of-bound indices. The <em>ret</em> argument can specify an output array rather than having one created internally.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PutTo"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_PutTo</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">values</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">indices</span>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><span class="n">NPY_CLIPMODE</span></a><span class="n">clipmode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <em>self</em>.put(<em>values</em>, <em>indices</em>, <em>clipmode</em> ). Put <em>values</em> into <em>self</em> at the corresponding (flattened) <em>indices</em>. If <em>values</em> is too small it will be repeated as necessary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PutMask"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_PutMask</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">values</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">mask</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Place the <em>values</em> in <em>self</em> wherever corresponding positions (using a flattened context) in <em>mask</em> are true. The <em>mask</em> and <em>self</em> arrays must have the same total number of elements. If <em>values</em> is too small, it will be repeated as necessary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Repeat"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Repeat</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat" title="numpy.ndarray.repeat"><code>ndarray.repeat</code></a> (<em>self</em>, <em>op</em>, <em>axis</em>). Copy the elements of <em>self</em>, <em>op</em> times along the given <em>axis</em>. Either <em>op</em> is a scalar integer or a sequence of length <em>self</em> -&gt;dimensions[ <em>axis</em> ] indicating how many times to repeat each item along the axis.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Choose"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Choose</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">ret</span>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><span class="n">NPY_CLIPMODE</span></a><span class="n">clipmode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.choose.html#numpy.ndarray.choose" title="numpy.ndarray.choose"><code>ndarray.choose</code></a> (<em>self</em>, <em>op</em>, <em>ret</em>, <em>clipmode</em>). Create a new array by selecting elements from the sequence of arrays in <em>op</em> based on the integer values in <em>self</em>. The arrays must all be broadcastable to the same shape and the entries in <em>self</em> should be between 0 and len(<em>op</em>). The output is placed in <em>ret</em> unless it is <code>NULL</code> in which case a new output is created. The <em>clipmode</em> argument determines behavior for when entries in <em>self</em> are not between 0 and len(<em>op</em>).</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_Choose.NPY_RAISE"> <span class="sig-name descname"><span class="n">NPY_RAISE</span></span><br>
</dt> <dd>
<p>raise a ValueError;</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_Choose.NPY_WRAP"> <span class="sig-name descname"><span class="n">NPY_WRAP</span></span><br>
</dt> <dd>
<p>wrap values &lt; 0 by adding len(<em>op</em>) and values &gt;=len(<em>op</em>) by subtracting len(<em>op</em>) until they are in range;</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_Choose.NPY_CLIP"> <span class="sig-name descname"><span class="n">NPY_CLIP</span></span><br>
</dt> <dd>
<p>all values are clipped to the region [0, len(<em>op</em>) ).</p> </dd>
</dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Sort"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Sort</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="#c.NPY_SORTKIND" title="NPY_SORTKIND"><span class="n">NPY_SORTKIND</span></a><span class="n">kind</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.sort.html#numpy.ndarray.sort" title="numpy.ndarray.sort"><code>ndarray.sort</code></a> (<em>self</em>, <em>axis</em>, <em>kind</em>). Return an array with the items of <em>self</em> sorted along <em>axis</em>. The array is sorted using the algorithm denoted by <em>kind</em>, which is an integer/enum pointing to the type of sorting algorithms used.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ArgSort"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ArgSort</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort" title="numpy.ndarray.argsort"><code>ndarray.argsort</code></a> (<em>self</em>, <em>axis</em>). Return an array of indices such that selection of these indices along the given <code>axis</code> would return a sorted version of <em>self</em>. If <em>self</em> -&gt;descr is a data-type with fields defined, then self-&gt;descr-&gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_LexSort"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_LexSort</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">sort_keys</span>, <span class="kt">int</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Given a sequence of arrays (<em>sort_keys</em>) of the same shape, return an array of indices (similar to <a class="reference internal" href="#c.PyArray_ArgSort" title="PyArray_ArgSort"><code>PyArray_ArgSort</code></a> (…)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first <em>sort_key</em> and then using the second <em>sort_key</em> and so forth. This is equivalent to the lexsort(<em>sort_keys</em>, <em>axis</em>) Python command. Because of the way the merge-sort works, be sure to understand the order the <em>sort_keys</em> must be in (reversed from the order you would use when comparing two elements).</p> <p>If these arrays are all collected in a structured array, then <a class="reference internal" href="#c.PyArray_Sort" title="PyArray_Sort"><code>PyArray_Sort</code></a> (…) can also be used to sort the array directly.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SearchSorted"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_SearchSorted</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">values</span>, <a class="reference internal" href="#c.NPY_SEARCHSIDE" title="NPY_SEARCHSIDE"><span class="n">NPY_SEARCHSIDE</span></a><span class="n">side</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">perm</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted" title="numpy.ndarray.searchsorted"><code>ndarray.searchsorted</code></a> (<em>self</em>, <em>values</em>, <em>side</em>, <em>perm</em>). Assuming <em>self</em> is a 1-d array in ascending order, then the output is an array of indices the same shape as <em>values</em> such that, if the elements in <em>values</em> were inserted before the indices, the order of <em>self</em> would be preserved. No checking is done on whether or not self is in ascending order.</p> <p>The <em>side</em> argument indicates whether the index returned should be that of the first suitable location (if <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT" title="NPY_SEARCHLEFT"><code>NPY_SEARCHLEFT</code></a>) or of the last (if <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT" title="NPY_SEARCHRIGHT"><code>NPY_SEARCHRIGHT</code></a>).</p> <p>The <em>sorter</em> argument, if not <code>NULL</code>, must be a 1D array of integer indices the same length as <em>self</em>, that sorts it into ascending order. This is typically the result of a call to <a class="reference internal" href="#c.PyArray_ArgSort" title="PyArray_ArgSort"><code>PyArray_ArgSort</code></a> (…) Binary search is used to find the required insertion points.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Partition"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Partition</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">ktharray</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="#c.NPY_SELECTKIND" title="NPY_SELECTKIND"><span class="n">NPY_SELECTKIND</span></a><span class="n">which</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.partition.html#numpy.ndarray.partition" title="numpy.ndarray.partition"><code>ndarray.partition</code></a> (<em>self</em>, <em>ktharray</em>, <em>axis</em>, <em>kind</em>). Partitions the array so that the values of the element indexed by <em>ktharray</em> are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If <em>self</em>-&gt;descr is a data-type with fields defined, then self-&gt;descr-&gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ArgPartition"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ArgPartition</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">ktharray</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="#c.NPY_SELECTKIND" title="NPY_SELECTKIND"><span class="n">NPY_SELECTKIND</span></a><span class="n">which</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition" title="numpy.ndarray.argpartition"><code>ndarray.argpartition</code></a> (<em>self</em>, <em>ktharray</em>, <em>axis</em>, <em>kind</em>). Return an array of indices such that selection of these indices along the given <code>axis</code> would return a partitioned version of <em>self</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Diagonal"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Diagonal</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">offset</span>, <span class="kt">int</span><span class="n">axis1</span>, <span class="kt">int</span><span class="n">axis2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal" title="numpy.ndarray.diagonal"><code>ndarray.diagonal</code></a> (<em>self</em>, <em>offset</em>, <em>axis1</em>, <em>axis2</em> ). Return the <em>offset</em> diagonals of the 2-d arrays defined by <em>axis1</em> and <em>axis2</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CountNonzero"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_CountNonzero</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Counts the number of non-zero elements in the array object <em>self</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Nonzero"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Nonzero</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><code>ndarray.nonzero</code></a> (<em>self</em>). Returns a tuple of index arrays that select elements of <em>self</em> that are nonzero. If (nd= <a class="reference internal" href="#c.PyArray_NDIM" title="PyArray_NDIM"><code>PyArray_NDIM</code></a> ( <code>self</code> ))==1, then a single index array is returned. The index arrays have data type <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_INTP" title="NPY_INTP"><code>NPY_INTP</code></a>. If a tuple is returned (nd <span class="math notranslate nohighlight">\(\neq\)</span> 1), then its length is nd.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Compress"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Compress</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">condition</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.compress.html#numpy.ndarray.compress" title="numpy.ndarray.compress"><code>ndarray.compress</code></a> (<em>self</em>, <em>condition</em>, <em>axis</em> ). Return the elements along <em>axis</em> corresponding to elements of <em>condition</em> that are true.</p> </dd>
</dl> </section> <section id="calculation"> <h3>Calculation</h3> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Pass in <a class="reference internal" href="#c.NPY_RAVEL_AXIS" title="NPY_RAVEL_AXIS"><code>NPY_RAVEL_AXIS</code></a> for axis in order to achieve the same effect that is obtained by passing in <code>axis=None</code> in Python (treating the array as a 1-d array).</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to <code>Py_DECREF</code> out if not NULL or a memory-leak will occur.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ArgMax"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ArgMax</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax" title="numpy.ndarray.argmax"><code>ndarray.argmax</code></a> (<em>self</em>, <em>axis</em>). Return the index of the largest element of <em>self</em> along <em>axis</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ArgMin"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ArgMin</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin" title="numpy.ndarray.argmin"><code>ndarray.argmin</code></a> (<em>self</em>, <em>axis</em>). Return the index of the smallest element of <em>self</em> along <em>axis</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Max"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Max</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.max.html#numpy.ndarray.max" title="numpy.ndarray.max"><code>ndarray.max</code></a> (<em>self</em>, <em>axis</em>). Returns the largest element of <em>self</em> along the given <em>axis</em>. When the result is a single element, returns a numpy scalar instead of an ndarray.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Min"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Min</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.min.html#numpy.ndarray.min" title="numpy.ndarray.min"><code>ndarray.min</code></a> (<em>self</em>, <em>axis</em>). Return the smallest element of <em>self</em> along the given <em>axis</em>. When the result is a single element, returns a numpy scalar instead of an ndarray.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Ptp"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Ptp</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the difference between the largest element of <em>self</em> along <em>axis</em> and the smallest element of <em>self</em> along <em>axis</em>. When the result is a single element, returns a numpy scalar instead of an ndarray.</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not “large” enough to handle the output. By default, all integer data-types are made at least as large as <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_LONG" title="NPY_LONG"><code>NPY_LONG</code></a> for the “add” and “multiply” ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Mean"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Mean</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.mean.html#numpy.ndarray.mean" title="numpy.ndarray.mean"><code>ndarray.mean</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Returns the mean of the elements along the given <em>axis</em>, using the enumerated type <em>rtype</em> as the data type to sum in. Default sum behavior is obtained using <a class="reference internal" href="dtype.html#c.NPY_NOTYPE" title="NPY_NOTYPE"><code>NPY_NOTYPE</code></a> for <em>rtype</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Trace"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Trace</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">offset</span>, <span class="kt">int</span><span class="n">axis1</span>, <span class="kt">int</span><span class="n">axis2</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.trace.html#numpy.ndarray.trace" title="numpy.ndarray.trace"><code>ndarray.trace</code></a> (<em>self</em>, <em>offset</em>, <em>axis1</em>, <em>axis2</em>, <em>rtype</em>). Return the sum (using <em>rtype</em> as the data type of summation) over the <em>offset</em> diagonal elements of the 2-d arrays defined by <em>axis1</em> and <em>axis2</em> variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Clip"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Clip</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">min</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">max</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.clip.html#numpy.ndarray.clip" title="numpy.ndarray.clip"><code>ndarray.clip</code></a> (<em>self</em>, <em>min</em>, <em>max</em>). Clip an array, <em>self</em>, so that values larger than <em>max</em> are fixed to <em>max</em> and values less than <em>min</em> are fixed to <em>min</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Conjugate"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Conjugate</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate" title="numpy.ndarray.conjugate"><code>ndarray.conjugate</code></a> (<em>self</em>). Return the complex conjugate of <em>self</em>. If <em>self</em> is not of complex data type, then return <em>self</em> with a reference.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>self</strong> – Input array.</li> <li>
<strong>out</strong> – Output array. If provided, the result is placed into this array.</li> </ul> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<p>The complex conjugate of <em>self</em>.</p> </dd> </dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Round"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Round</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">decimals</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.round.html#numpy.ndarray.round" title="numpy.ndarray.round"><code>ndarray.round</code></a> (<em>self</em>, <em>decimals</em>, <em>out</em>). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the <span class="math notranslate nohighlight">\(10^{-\textrm{decimals}}\)</span> digit so that negative <em>decimals</em> cause rounding to the nearest 10’s, 100’s, etc. If out is <code>NULL</code>, then the output array is created, otherwise the output is placed in <em>out</em> which must be the correct size and type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Std"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Std</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.std.html#numpy.ndarray.std" title="numpy.ndarray.std"><code>ndarray.std</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return the standard deviation using data along <em>axis</em> converted to data type <em>rtype</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Sum"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Sum</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.sum.html#numpy.ndarray.sum" title="numpy.ndarray.sum"><code>ndarray.sum</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return 1-d vector sums of elements in <em>self</em> along <em>axis</em>. Perform the sum after converting data to data type <em>rtype</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CumSum"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CumSum</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum" title="numpy.ndarray.cumsum"><code>ndarray.cumsum</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return cumulative 1-d sums of elements in <em>self</em> along <em>axis</em>. Perform the sum after converting data to data type <em>rtype</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Prod"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Prod</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.prod.html#numpy.ndarray.prod" title="numpy.ndarray.prod"><code>ndarray.prod</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return 1-d products of elements in <em>self</em> along <em>axis</em>. Perform the product after converting data to data type <em>rtype</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CumProd"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CumProd</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <span class="kt">int</span><span class="n">rtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod" title="numpy.ndarray.cumprod"><code>ndarray.cumprod</code></a> (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return 1-d cumulative products of elements in <code>self</code> along <code>axis</code>. Perform the product after converting data to data type <code>rtype</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_All"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_All</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.all.html#numpy.ndarray.all" title="numpy.ndarray.all"><code>ndarray.all</code></a> (<em>self</em>, <em>axis</em>). Return an array with True elements for every 1-d sub-array of <code>self</code> defined by <code>axis</code> in which all the elements are True.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Any"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Any</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">self</span>, <span class="kt">int</span><span class="n">axis</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="../generated/numpy.ndarray.any.html#numpy.ndarray.any" title="numpy.ndarray.any"><code>ndarray.any</code></a> (<em>self</em>, <em>axis</em>). Return an array with True elements for every 1-d sub-array of <em>self</em> defined by <em>axis</em> in which any of the elements are True.</p> </dd>
</dl> </section> </section> <section id="functions"> <h2>Functions</h2> <section id="array-functions"> <h3>Array Functions</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_AsCArray"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_AsCArray</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">op</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ptr</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">dims</span>, <span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">typedescr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional array so that algorithms can be implemented using C’s a[i][j][k] syntax. This routine returns a pointer, <em>ptr</em>, that simulates this kind of C-style array, for 1-, 2-, and 3-d ndarrays.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>op</strong> – The address to any Python object. This Python object will be replaced with an equivalent well-behaved, C-style contiguous, ndarray of the given data type specified by the last two arguments. Be sure that stealing a reference in this way to the input object is justified.</li> <li>
<strong>ptr</strong> – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for 3-d) variable where ctype is the equivalent C-type for the data type. On return, <em>ptr</em> will be addressable as a 1-d, 2-d, or 3-d array.</li> <li>
<strong>dims</strong> – An output array that contains the shape of the array object. This array gives boundaries on any looping that will take place.</li> <li>
<strong>nd</strong> – The dimensionality of the array (1, 2, or 3).</li> <li>
<strong>typedescr</strong> – A <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> structure indicating the desired data-type (including required byteorder). The call will steal a reference to the parameter.</li> </ul> </dd> </dl> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Free"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Free</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ptr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Must be called with the same objects and memory locations returned from <a class="reference internal" href="#c.PyArray_AsCArray" title="PyArray_AsCArray"><code>PyArray_AsCArray</code></a> (…). This function cleans up memory that otherwise would get leaked.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Concatenate"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Concatenate</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Join the sequence of objects in <em>obj</em> together along <em>axis</em> into a single array. If the dimensions or types are not compatible an error is raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_InnerProduct"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_InnerProduct</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj1</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compute a product-sum over the last dimensions of <em>obj1</em> and <em>obj2</em>. Neither array is conjugated.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MatrixProduct"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MatrixProduct</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj1</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compute a product-sum over the last dimension of <em>obj1</em> and the second-to-last dimension of <em>obj2</em>. For 2-d arrays this is a matrix-product. Neither array is conjugated.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MatrixProduct2"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MatrixProduct2</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj1</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Same as PyArray_MatrixProduct, but store the result in <em>out</em>. The output array must have the correct shape, type, and be C-contiguous, or an exception is raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_EinsteinSum"> <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_EinsteinSum</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">subscripts</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">nop</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">op_in</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="n">order</span>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="n">casting</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">out</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Applies the Einstein summation convention to the array operands provided, returning a new array or placing the result in <em>out</em>. The string in <em>subscripts</em> is a comma separated list of index letters. The number of operands is in <em>nop</em>, and <em>op_in</em> is an array containing those operands. The data type of the output can be forced with <em>dtype</em>, the output order can be forced with <em>order</em> (<a class="reference internal" href="#c.NPY_ORDER.NPY_KEEPORDER" title="NPY_KEEPORDER"><code>NPY_KEEPORDER</code></a> is recommended), and when <em>dtype</em> is specified, <em>casting</em> indicates how permissive the data conversion should be.</p> <p>See the <a class="reference internal" href="../generated/numpy.einsum.html#numpy.einsum" title="numpy.einsum"><code>einsum</code></a> function for more details.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Correlate"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Correlate</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op1</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op2</span>, <span class="kt">int</span><span class="n">mode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compute the 1-d correlation of the 1-d arrays <em>op1</em> and <em>op2</em> . The correlation is computed at each output point by multiplying <em>op1</em> by a shifted version of <em>op2</em> and summing the result. As a result of the shift, needed values outside of the defined range of <em>op1</em> and <em>op2</em> are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as <em>op1</em>, 2 - return all possible shifts (any overlap at all is accepted).</p> <h4 class="rubric">Notes</h4> <p>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Correlate2"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Correlate2</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op1</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op2</span>, <span class="kt">int</span><span class="n">mode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying <em>op1</em> by a shifted version of <em>op2</em> and summing the result. As a result of the shift, needed values outside of the defined range of <em>op1</em> and <em>op2</em> are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as <em>op1</em>, 2 - return all possible shifts (any overlap at all is accepted).</p> <h4 class="rubric">Notes</h4> <p>Compute z as follows:</p> <pre data-language="python">z[k] = sum_n op1[n] * conj(op2[n+k])
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Where"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Where</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">condition</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">x</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">y</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If both <code>x</code> and <code>y</code> are <code>NULL</code>, then return <a class="reference internal" href="#c.PyArray_Nonzero" title="PyArray_Nonzero"><code>PyArray_Nonzero</code></a> (<em>condition</em>). Otherwise, both <em>x</em> and <em>y</em> must be given and the object returned is shaped like <em>condition</em> and has elements of <em>x</em> and <em>y</em> where <em>condition</em> is respectively True or False.</p> </dd>
</dl> </section> <section id="other-functions"> <h3>Other functions</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CheckStrides"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">PyArray_CheckStrides</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">elsize</span>, <span class="kt">int</span><span class="n">nd</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">numbytes</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">newstrides</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Determine if <em>newstrides</em> is a strides array consistent with the memory of an <em>nd</em> -dimensional array with shape <code>dims</code> and element-size, <em>elsize</em>. The <em>newstrides</em> array is checked to see if jumping by the provided number of bytes in each direction will ever mean jumping more than <em>numbytes</em> which is the assumed size of the available memory segment. If <em>numbytes</em> is 0, then an equivalent <em>numbytes</em> is computed assuming <em>nd</em>, <em>dims</em>, and <em>elsize</em> refer to a single-segment array. Return <a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code>NPY_TRUE</code></a> if <em>newstrides</em> is acceptable, otherwise return <a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code>NPY_FALSE</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiplyList"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_MultiplyList</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">seq</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiplyIntList"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_MultiplyIntList</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="k">const</span><span class="p">*</span><span class="n">seq</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Both of these routines multiply an <em>n</em> -length array, <em>seq</em>, of integers and return the result. No overflow checking is performed.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CompareLists"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CompareLists</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">l1</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">l2</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Given two <em>n</em> -length arrays of integers, <em>l1</em>, and <em>l2</em>, return 1 if the lists are identical; otherwise, return 0.</p> </dd>
</dl> </section> </section> <section id="auxiliary-data-with-object-semantics"> <h2>Auxiliary data with object semantics</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.0.</span></p> </div> <dl class="c type"> <dt class="sig sig-object c" id="c.NpyAuxData"> <span class="k">type</span><span class="sig-name descname"><span class="n">NpyAuxData</span></span><br>
</dt> 
</dl> <p>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct <a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><code>NpyAuxData</code></a>, mandating a few conventions so that it is possible to do this.</p> <p>Defining an <a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><code>NpyAuxData</code></a> is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here’s an example for a function which doubles up an element using an element copier function as a primitive.</p> <pre data-language="c">typedef struct {
    NpyAuxData base;
    ElementCopier_Func *func;
    NpyAuxData *funcdata;
} eldoubler_aux_data;

void free_element_doubler_aux_data(NpyAuxData *data)
{
    eldoubler_aux_data *d = (eldoubler_aux_data *)data;
    /* Free the memory owned by this auxdata */
    NPY_AUXDATA_FREE(d-&gt;funcdata);
    PyArray_free(d);
}

NpyAuxData *clone_element_doubler_aux_data(NpyAuxData *data)
{
    eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));
    if (ret == NULL) {
        return NULL;
    }

    /* Raw copy of all data */
    memcpy(ret, data, sizeof(eldoubler_aux_data));

    /* Fix up the owned auxdata so we have our own copy */
    ret-&gt;funcdata = NPY_AUXDATA_CLONE(ret-&gt;funcdata);
    if (ret-&gt;funcdata == NULL) {
        PyArray_free(ret);
        return NULL;
    }

    return (NpyAuxData *)ret;
}

NpyAuxData *create_element_doubler_aux_data(
                            ElementCopier_Func *func,
                            NpyAuxData *funcdata)
{
    eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));
    if (ret == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    memset(&amp;ret, 0, sizeof(eldoubler_aux_data));
    ret-&gt;base-&gt;free = &amp;free_element_doubler_aux_data;
    ret-&gt;base-&gt;clone = &amp;clone_element_doubler_aux_data;
    ret-&gt;func = func;
    ret-&gt;funcdata = funcdata;

    return (NpyAuxData *)ret;
}
</pre> <dl class="c type"> <dt class="sig sig-object c" id="c.NpyAuxData_FreeFunc"> <span class="k">type</span><span class="sig-name descname"><span class="n">NpyAuxData_FreeFunc</span></span><br>
</dt> <dd>
<p>The function pointer type for NpyAuxData free functions.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.NpyAuxData_CloneFunc"> <span class="k">type</span><span class="sig-name descname"><span class="n">NpyAuxData_CloneFunc</span></span><br>
</dt> <dd>
<p>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_AUXDATA_FREE"> <span class="kt">void</span><span class="sig-name descname"><span class="n">NPY_AUXDATA_FREE</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="n">auxdata</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A macro which calls the auxdata’s free function appropriately, does nothing if auxdata is NULL.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_AUXDATA_CLONE"> <a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">NPY_AUXDATA_CLONE</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="n">auxdata</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A macro which calls the auxdata’s clone function appropriately, returning a deep copy of the auxiliary data.</p> </dd>
</dl> </section> <section id="array-iterators"> <h2>Array iterators</h2> <p>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, <a class="reference internal" href="iterator.html#c.NpyIter" title="NpyIter"><code>NpyIter</code></a>.</p> <p>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently, as seen in <a class="reference internal" href="iterator.html#iteration-example"><span class="std std-ref">the example</span></a> which provides more description of this useful approach to looping over an array from C.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IterNew"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_IterNew</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an array iterator object from the array, <em>arr</em>. This is equivalent to <em>arr</em>. <strong>flat</strong>. The array iterator object makes it easy to loop over an N-dimensional non-contiguous array in C-style contiguous fashion.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IterAllButAxis"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_IterAllButAxis</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span>, <span class="kt">int</span><span class="p">*</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an array iterator that will iterate over all axes but the one provided in <em>*axis</em>. The returned iterator cannot be used with <a class="reference internal" href="#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code>PyArray_ITER_GOTO1D</code></a>. This iterator could be used to write something similar to what ufuncs do wherein the loop over the largest axis is done by a separate sub-routine. If <em>*axis</em> is negative then <em>*axis</em> will be set to the axis having the smallest stride and that axis will be used.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_BroadcastToShape"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_BroadcastToShape</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">arr</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <span class="kt">int</span><span class="n">nd</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an array iterator that is broadcast to iterate as an array of the shape provided by <em>dimensions</em> and <em>nd</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArrayIter_Check"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArrayIter_Check</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates true if <em>op</em> is an array iterator (or instance of a subclass of the array iterator type).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_RESET"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ITER_RESET</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Reset an <em>iterator</em> to the beginning of the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_NEXT"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ITER_NEXT</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Incremement the index and the dataptr members of the <em>iterator</em> to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_DATA"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ITER_DATA</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to the current element of the array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_GOTO"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ITER_GOTO</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">destination</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the <em>iterator</em> index, dataptr, and coordinates members to the location in the array indicated by the N-dimensional c-array, <em>destination</em>, which must have size at least <em>iterator</em> -&gt;nd_m1+1.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_GOTO1D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ITER_GOTO1D</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">index</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the <em>iterator</em> index and dataptr to the location in the array indicated by the integer <em>index</em> which points to an element in the C-styled flattened array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ITER_NOTDONE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ITER_NOTDONE</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">iterator</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</p> </dd>
</dl> </section> <section id="broadcasting-multi-iterators"> <h2>Broadcasting (multi-iterators)</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIterNew"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MultiIterNew</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">num</span>, <span class="p">...</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A simplified interface to broadcasting. This function takes the number of arrays to broadcast and then <em>num</em> extra ( <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><code>PyObject *</code></a> ) arguments. These arguments are converted to arrays and iterators are created. <a class="reference internal" href="#c.PyArray_Broadcast" title="PyArray_Broadcast"><code>PyArray_Broadcast</code></a> is then called on the resulting multi-iterator object. The resulting, broadcasted mult-iterator object is then returned. A broadcasted operation can then be performed using a single loop and using <a class="reference internal" href="#c.PyArray_MultiIter_NEXT" title="PyArray_MultiIter_NEXT"><code>PyArray_MultiIter_NEXT</code></a> (..)</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_RESET"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_RESET</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Reset all the iterators to the beginning in a multi-iterator object, <em>multi</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_NEXT"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_NEXT</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Advance each iterator in a multi-iterator object, <em>multi</em>, to its next (broadcasted) element.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_DATA"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_DATA</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span>, <span class="kt">int</span><span class="n">i</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the data-pointer of the <em>i</em> <span class="math notranslate nohighlight">\(^{\textrm{th}}\)</span> iterator in a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_NEXTi"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_NEXTi</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span>, <span class="kt">int</span><span class="n">i</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Advance the pointer of only the <em>i</em> <span class="math notranslate nohighlight">\(^{\textrm{th}}\)</span> iterator.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_GOTO"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_GOTO</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">destination</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Advance each iterator in a multi-iterator object, <em>multi</em>, to the given <span class="math notranslate nohighlight">\(N\)</span> -dimensional <em>destination</em> where <span class="math notranslate nohighlight">\(N\)</span> is the number of dimensions in the broadcasted array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_GOTO1D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_GOTO1D</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">index</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Advance each iterator in a multi-iterator object, <em>multi</em>, to the corresponding location of the <em>index</em> into the flattened broadcasted array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_NOTDONE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_NOTDONE</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_SIZE"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_MultiIter_SIZE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns the total broadcasted size of a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_NDIM"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_NDIM</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns the number of dimensions in the broadcasted result of a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_INDEX"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_MultiIter_INDEX</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns the current (1-d) index into the broadcasted result of a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_NUMITER"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_NUMITER</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns the number of iterators that are represented by a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_ITERS"> <span class="kt">void</span><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_ITERS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns an array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_MultiIter_DIMS"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_MultiIter_DIMS</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">multi</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.26.0.</span></p> </div> <p>Returns a pointer to the dimensions/shape of the broadcasted result of a multi-iterator object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Broadcast"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Broadcast</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">mit</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function encapsulates the broadcasting rules. The <em>mit</em> container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_RemoveSmallest"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_RemoveSmallest</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span><span class="n">mit</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function takes a multi-iterator object that has been previously “broadcasted,” finds the dimension with the smallest “sum of strides” in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless <em>mit</em> -&gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won’t require large stride jumps.</p> </dd>
</dl> </section> <section id="neighborhood-iterator"> <h2>Neighborhood iterator</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> <p>Neighborhood iterators are subclasses of the iterator object, and can be used to iter over a neighborhood of a point. For example, you may want to iterate over every voxel of a 3d image, and for every such voxel, iterate over an hypercube. Neighborhood iterator automatically handle boundaries, thus making this kind of code much easier to write than manual boundaries handling, at the cost of a slight overhead.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_NeighborhoodIterNew</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayIterObject" title="PyArrayIterObject"><span class="n">PyArrayIterObject</span></a><span class="p">*</span><span class="n">iter</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">bounds</span>, <span class="kt">int</span><span class="n">mode</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">fill_value</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by <em>iter</em>, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</p> <p>The <em>bounds</em> argument is expected to be a (2 * iter-&gt;ao-&gt;nd) arrays, such as the range bound[2*i]-&gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &lt;= bounds[2*i+1]).</p> <p>The mode should be one of:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_ZERO_PADDING"> <span class="sig-name descname"><span class="n">NPY_NEIGHBORHOOD_ITER_ZERO_PADDING</span></span><br>
</dt> <dd>
<p>Zero padding. Outside bounds values will be 0.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_ONE_PADDING"> <span class="sig-name descname"><span class="n">NPY_NEIGHBORHOOD_ITER_ONE_PADDING</span></span><br>
</dt> <dd>
<p>One padding, Outside bounds values will be 1.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING"> <span class="sig-name descname"><span class="n">NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING</span></span><br>
</dt> <dd>
<p>Constant padding. Outside bounds values will be the same as the first item in fill_value.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING"> <span class="sig-name descname"><span class="n">NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING</span></span><br>
</dt> <dd>
<p>Mirror padding. Outside bounds values will be as if the array items were mirrored. For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will be 1, x[4] will be 4, x[5] will be 1, etc…</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING"> <span class="sig-name descname"><span class="n">NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING</span></span><br>
</dt> <dd>
<p>Circular padding. Outside bounds values will be as if the array was repeated. For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc…</p> </dd>
</dl> <p>If the mode is constant filling (<a class="reference internal" href="#c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING" title="NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING"><code>NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING</code></a>), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</p> <ul class="simple"> <li>The iterator holds a reference to iter</li> <li>Return NULL on failure (in which case the reference count of iter is not changed)</li> <li>iter itself can be a Neighborhood iterator: this can be useful for .e.g automatic boundaries handling</li> <li>the object returned by this function should be safe to use as a normal iterator</li> <li>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</li> <li>If the position of iter is not the beginning of the data and the underlying data for iter is contiguous, the iterator will point to the start of the data instead of position pointed by iter. To avoid this situation, iter should be moved to the required position only after the creation of iterator, and PyArrayNeighborhoodIter_Reset must be called.</li> </ul> <pre data-language="c">PyArrayIterObject *iter;
PyArrayNeighborhoodIterObject *neigh_iter;
iter = PyArray_IterNew(x);

/*For a 3x3 kernel */
bounds = {-1, 1, -1, 1};
neigh_iter = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
     iter, bounds, NPY_NEIGHBORHOOD_ITER_ZERO_PADDING, NULL);

for(i = 0; i &lt; iter-&gt;size; ++i) {
     for (j = 0; j &lt; neigh_iter-&gt;size; ++j) {
             /* Walk around the item currently pointed by iter-&gt;dataptr */
             PyArrayNeighborhoodIter_Next(neigh_iter);
     }

     /* Move to the next point of iter */
     PyArrayIter_Next(iter);
     PyArrayNeighborhoodIter_Reset(neigh_iter);
}
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArrayNeighborhoodIter_Reset"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArrayNeighborhoodIter_Reset</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayNeighborhoodIterObject" title="PyArrayNeighborhoodIterObject"><span class="n">PyArrayNeighborhoodIterObject</span></a><span class="p">*</span><span class="n">iter</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Reset the iterator position to the first point of the neighborhood. This should be called whenever the iter argument given at PyArray_NeighborhoodIterObject is changed (see example)</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArrayNeighborhoodIter_Next"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArrayNeighborhoodIter_Next</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayNeighborhoodIterObject" title="PyArrayNeighborhoodIterObject"><span class="n">PyArrayNeighborhoodIterObject</span></a><span class="p">*</span><span class="n">iter</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>After this call, iter-&gt;dataptr points to the next point of the neighborhood. Calling this function after every point of the neighborhood has been visited is undefined.</p> </dd>
</dl> </section> <section id="array-scalars"> <h2>Array scalars</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Return"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Return</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function steals a reference to <em>arr</em>.</p> <p>This function checks to see if <em>arr</em> is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Scalar"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_Scalar</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">base</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an array scalar object of the given <em>dtype</em> by <strong>copying</strong> from memory pointed to by <em>data</em>. <em>base</em> is expected to be the array object that is the owner of the data. <em>base</em> is required if <code>dtype</code> is a <code>void</code> scalar, or if the <code>NPY_USE_GETITEM</code> flag is set and it is known that the <code>getitem</code> method uses the <code>arr</code> argument without checking if it is <code>NULL</code>. Otherwise <code>base</code> may be <code>NULL</code>.</p> <p>If the data is not in native byte order (as indicated by <code>dtype-&gt;byteorder</code>) then this function will byteswap the data, because array scalars are always in correct machine-byte order.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ToScalar"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_ToScalar</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return an array scalar object of the type and itemsize indicated by the array object <em>arr</em> copied from the memory pointed to by <em>data</em> and swapping if the data in <em>arr</em> is not in machine byte-order.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_FromScalar"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_FromScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">scalar</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">outcode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return a 0-dimensional array of type determined by <em>outcode</em> from <em>scalar</em> which should be an array-scalar object. If <em>outcode</em> is NULL, then the type is determined from <em>scalar</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ScalarAsCtype"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_ScalarAsCtype</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">scalar</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ctypeptr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return in <em>ctypeptr</em> a pointer to the actual value in an array scalar. There is no error checking so <em>scalar</em> must be an array-scalar object, and ctypeptr must have enough space to hold the correct type. For flexible-sized types, a pointer to the data is copied into the memory of <em>ctypeptr</em>, for all other types, the actual data is copied into the address pointed to by <em>ctypeptr</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CastScalarToCtype"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CastScalarToCtype</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">scalar</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ctypeptr</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">outcode</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the data (cast to the data type indicated by <em>outcode</em>) from the array-scalar, <em>scalar</em>, into the memory pointed to by <em>ctypeptr</em> (which must be large enough to handle the incoming memory).</p> <p>Returns -1 on failure, and 0 on success.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_TypeObjectFromType"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_TypeObjectFromType</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">type</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a scalar type-object from a type-number, <em>type</em> . Equivalent to <a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code>PyArray_DescrFromType</code></a> (<em>type</em>)-&gt;typeobj except for reference counting and error-checking. Returns a new reference to the typeobject on success or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ScalarKind"> <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><span class="n">NPY_SCALARKIND</span></a><span class="sig-name descname"><span class="n">PyArray_ScalarKind</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">typenum</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>See the function <a class="reference internal" href="#c.PyArray_MinScalarType" title="PyArray_MinScalarType"><code>PyArray_MinScalarType</code></a> for an alternative mechanism introduced in NumPy 1.6.0.</p> <p>Return the kind of scalar represented by <em>typenum</em> and the array in <em>*arr</em> (if <em>arr</em> is not <code>NULL</code> ). The array is assumed to be rank-0 and only used if <em>typenum</em> represents a signed integer. If <em>arr</em> is not <code>NULL</code> and the first element is negative then <a class="reference internal" href="#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR" title="NPY_INTNEG_SCALAR"><code>NPY_INTNEG_SCALAR</code></a> is returned, otherwise <a class="reference internal" href="#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR" title="NPY_INTPOS_SCALAR"><code>NPY_INTPOS_SCALAR</code></a> is returned. The possible return values are the enumerated values in <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><code>NPY_SCALARKIND</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CanCoerceScalar"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CanCoerceScalar</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="n">thistype</span>, <span class="kt">char</span><span class="n">neededtype</span>, <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><span class="n">NPY_SCALARKIND</span></a><span class="n">scalar</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>See the function <a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code>PyArray_ResultType</code></a> for details of NumPy type promotion, updated in NumPy 1.6.0.</p> <p>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is <a class="reference internal" href="#c.NPY_SCALARKIND.NPY_NOSCALAR" title="NPY_NOSCALAR"><code>NPY_NOSCALAR</code></a>, then this function is equivalent to <a class="reference internal" href="#c.PyArray_CanCastSafely" title="PyArray_CanCastSafely"><code>PyArray_CanCastSafely</code></a>. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</p> </dd>
</dl> </section> <section id="data-type-descriptors"> <h2>Data-type descriptors</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference. Functions that take <span class="c-expr sig sig-inline c"><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span></span> objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrCheck"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_DescrCheck</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates as true if <em>obj</em> is a data-type object ( <span class="c-expr sig sig-inline c"><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span></span> ).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrNew"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrNew</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return a new data-type object copied from <em>obj</em> (the fields reference is just updated so that the new object points to the same fields dictionary if any).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrNewFromType"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrNewFromType</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Create a new data-type object from the built-in (or user-registered) data-type indicated by <em>typenum</em>. All builtin types should not have any of their fields changed. This creates a new copy of the <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> structure so that you can fill it in as appropriate. This function is especially needed for flexible data-types which need to have a new elsize member in order to be meaningful in array construction.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrNewByteorder"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrNewByteorder</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">char</span><span class="n">newendian</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Create a new data-type object with the byteorder set according to <em>newendian</em>. All referenced data-type objects (in subdescr and fields members of the data-type object) are also changed (recursively).</p> <p>The value of <em>newendian</em> is one of these macros:</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_IGNORE"> <span class="sig-name descname"><span class="n">NPY_IGNORE</span></span><br>
</dt> <dt class="sig sig-object c" id="c.NPY_SWAP"> <span class="sig-name descname"><span class="n">NPY_SWAP</span></span><br>
</dt> <dt class="sig sig-object c" id="c.NPY_NATIVE"> <span class="sig-name descname"><span class="n">NPY_NATIVE</span></span><br>
</dt> <dt class="sig sig-object c" id="c.NPY_LITTLE"> <span class="sig-name descname"><span class="n">NPY_LITTLE</span></span><br>
</dt> <dt class="sig sig-object c" id="c.NPY_BIG"> <span class="sig-name descname"><span class="n">NPY_BIG</span></span><br>
</dt> <dd>
<p>If a byteorder of <a class="reference internal" href="#c.NPY_IGNORE" title="NPY_IGNORE"><code>NPY_IGNORE</code></a> is encountered it is left alone. If newendian is <a class="reference internal" href="#c.NPY_SWAP" title="NPY_SWAP"><code>NPY_SWAP</code></a>, then all byte-orders are swapped. Other valid newendian values are <a class="reference internal" href="#c.NPY_NATIVE" title="NPY_NATIVE"><code>NPY_NATIVE</code></a>, <a class="reference internal" href="#c.NPY_LITTLE" title="NPY_LITTLE"><code>NPY_LITTLE</code></a>, and <a class="reference internal" href="#c.NPY_BIG" title="NPY_BIG"><code>NPY_BIG</code></a> which all cause the returned data-typed descriptor (and all it’s referenced data-type descriptors) to have the corresponding byte- order.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrFromObject"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrFromObject</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">mintype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Determine an appropriate data-type object from the object <em>op</em> (which should be a “nested” sequence object) and the minimum data-type descriptor mintype (which can be <code>NULL</code> ). Similar in behavior to array(<em>op</em>).dtype. Don’t confuse this function with <a class="reference internal" href="#c.PyArray_DescrConverter" title="PyArray_DescrConverter"><code>PyArray_DescrConverter</code></a>. This function essentially looks at all the objects in the (nested) sequence and determines the data-type from the elements it finds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrFromScalar"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrFromScalar</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">scalar</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return a data-type object from an array-scalar object. No checking is done to be sure that <em>scalar</em> is an array scalar. If no suitable data-type can be determined, then a data-type of <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_OBJECT" title="NPY_OBJECT"><code>NPY_OBJECT</code></a> is returned by default.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrFromType"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_DescrFromType</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">typenum</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a data-type object corresponding to <em>typenum</em>. The <em>typenum</em> can be one of the enumerated types, a character code for one of the enumerated types, or a user-defined type. If you want to use a flexible size array, then you need to <code>flexible typenum</code> and set the results <code>elsize</code> parameter to the desired size. The typenum is one of the <a class="reference internal" href="dtype.html#c.NPY_TYPES" title="NPY_TYPES"><code>NPY_TYPES</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_DescrConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any compatible Python object, <em>obj</em>, to a data-type object in <em>dtype</em>. A large number of Python objects can be converted to data-type objects. See <a class="reference internal" href="../arrays.dtypes.html#arrays-dtypes"><span class="std std-ref">Data type objects (dtype)</span></a> for a complete description. This version of the converter converts None objects to a <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE" title="NPY_DEFAULT_TYPE"><code>NPY_DEFAULT_TYPE</code></a> data-type object. This function can be used with the “O&amp;” character code in <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.12)"><code>PyArg_ParseTuple</code></a> processing.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DescrConverter2"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_DescrConverter2</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any compatible Python object, <em>obj</em>, to a data-type object in <em>dtype</em>. This version of the converter converts None objects so that the returned data-type is <code>NULL</code>. This function can also be used with the “O&amp;” character in PyArg_ParseTuple processing.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Pyarray_DescrAlignConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">Pyarray_DescrAlignConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Like <a class="reference internal" href="#c.PyArray_DescrConverter" title="PyArray_DescrConverter"><code>PyArray_DescrConverter</code></a> except it aligns C-struct-like objects on word-boundaries as the compiler would.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Pyarray_DescrAlignConverter2"> <span class="kt">int</span><span class="sig-name descname"><span class="n">Pyarray_DescrAlignConverter2</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Like <a class="reference internal" href="#c.PyArray_DescrConverter2" title="PyArray_DescrConverter2"><code>PyArray_DescrConverter2</code></a> except it aligns C-struct-like objects on word-boundaries as the compiler would.</p> </dd>
</dl> </section> <section id="data-type-promotion-and-inspection"> <h2>Data Type Promotion and Inspection</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CommonDType"> <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_CommonDType</span></span><span class="sig-paren">(</span><span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">dtype1</span>, <span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">dtype2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function defines the common DType operator. Note that the common DType will not be <code>object</code> (unless one of the DTypes is <code>object</code>). Similar to <a class="reference internal" href="../generated/numpy.result_type.html#numpy.result_type" title="numpy.result_type"><code>numpy.result_type</code></a>, but works on the classes and not instances.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PromoteDTypeSequence"> <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_PromoteDTypeSequence</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">length</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="p">*</span><span class="n">dtypes_in</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Promotes a list of DTypes with each other in a way that should guarantee stable results even when changing the order. This function is smarter and can often return successful and unambiguous results when <code>common_dtype(common_dtype(dt1, dt2), dt3)</code> would depend on the operation order or fail. Nevertheless, DTypes should aim to ensure that their common-dtype implementation is associative and commutative! (Mainly, unsigned and signed integers are not.)</p> <p>For guaranteed consistent results DTypes must implement common-Dtype “transitively”. If A promotes B and B promotes C, than A must generally also promote C; where “promotes” means implements the promotion. (There are some exceptions for abstract DTypes)</p> <p>In general this approach always works as long as the most generic dtype is either strictly larger, or compatible with all other dtypes. For example promoting <code>float16</code> with any other float, integer, or unsigned integer again gives a floating point number.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetDefaultDescr"> <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_GetDefaultDescr</span></span><span class="sig-paren">(</span><span class="k">const</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">DType</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Given a DType class, returns the default instance (descriptor). This checks for a <code>singleton</code> first and only calls the <code>default_descr</code> function if necessary.</p> </dd>
</dl> </section> <section id="custom-data-types"> <h2 id="dtype-api">Custom Data Types</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> <p>These functions allow defining custom flexible data types outside of NumPy. See <a class="reference external" href="https://numpy.org/neps/nep-0042-new-dtypes.html#nep42" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 42</span></a> for more details about the rationale and design of the new DType system. See the <a class="reference external" href="https://github.com/numpy/numpy-user-dtypes">numpy-user-dtypes repository</a> for a number of example DTypes. Also see <a class="reference internal" href="types-and-structures.html#dtypemeta"><span class="std std-ref">PyArray_DTypeMeta and PyArrayDTypeMeta_Spec</span></a> for documentation on <code>PyArray_DTypeMeta</code> and <code>PyArrayDTypeMeta_Spec</code>.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArrayInitDTypeMeta_FromSpec"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArrayInitDTypeMeta_FromSpec</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">Dtype</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayDTypeMeta_Spec" title="PyArrayDTypeMeta_Spec"><span class="n">PyArrayDTypeMeta_Spec</span></a><span class="p">*</span><span class="n">spec</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Initialize a new DType. It must currently be a static Python C type that is declared as <a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><code>PyArray_DTypeMeta</code></a> and not <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><code>PyTypeObject</code></a>. Further, it must subclass <code>np.dtype</code> and set its type to <a class="reference internal" href="types-and-structures.html#c.PyArrayDTypeMeta_Type" title="PyArrayDTypeMeta_Type"><code>PyArrayDTypeMeta_Type</code></a> (before calling <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Ready" title="(in Python v3.12)"><code>PyType_Ready</code></a>), which has additional fields compared to a normal <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><code>PyTypeObject</code></a>. See the examples in the <code>numpy-user-dtypes</code> repository for usage with both parametric and non-parametric data types.</p> </dd>
</dl> <section id="dtype-flags"> <h3 id="id2">Flags</h3> <p>Flags that can be set on the <code>PyArrayDTypeMeta_Spec</code> to initialize the DType.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_ABSTRACT"> <span class="sig-name descname"><span class="n">NPY_DT_ABSTRACT</span></span><br>
</dt> <dd>
<p>Indicates the DType is an abstract “base” DType in a DType hierarchy and should not be directly instantiated.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PARAMETRIC"> <span class="sig-name descname"><span class="n">NPY_DT_PARAMETRIC</span></span><br>
</dt> <dd>
<p>Indicates the DType is parametric and does not have a unique singleton instance.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_NUMERIC"> <span class="sig-name descname"><span class="n">NPY_DT_NUMERIC</span></span><br>
</dt> <dd>
<p>Indicates the DType represents a numerical value.</p> </dd>
</dl> </section> <section id="slot-ids-and-api-function-typedefs"> <h3 id="dtype-slots">Slot IDs and API Function Typedefs</h3> <p>These IDs correspond to slots in the DType API and are used to identify implementations of each slot from the items of the <code>slots</code> array member of <code>PyArrayDTypeMeta_Spec</code> struct.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_discover_descr_from_pyobject"> <span class="sig-name descname"><span class="n">NPY_DT_discover_descr_from_pyobject</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_DiscoverDescrFromPyobject"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_DiscoverDescrFromPyobject</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">cls</span><span class="p">,</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span><span class="p">)</span><br>
</dt> <dd>
<p>Used during DType inference to find the correct DType for a given PyObject. Must return a descriptor instance appropriate to store the data in the python object that is passed in. <em>obj</em> is the python object to inspect and <em>cls</em> is the DType class to create a descriptor for.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_default_descr"> <span class="sig-name descname"><span class="n">NPY_DT_default_descr</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_DefaultDescriptor"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_DefaultDescriptor</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">cls</span><span class="p">)</span><br>
</dt> <dd>
<p>Returns the default descriptor instance for the DType. Must be defined for parametric data types. Non-parametric data types return the singleton by default.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_common_dtype"> <span class="sig-name descname"><span class="n">NPY_DT_common_dtype</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_CommonDType"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_CommonDType</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">dtype1</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">dtype2</span><span class="p">)</span><br>
</dt> <dd>
<p>Given two input DTypes, determines the appropriate “common” DType that can store values for both types. Returns <code>Py_NotImplemented</code> if no such type exists.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_common_instance"> <span class="sig-name descname"><span class="n">NPY_DT_common_instance</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_CommonInstance"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_CommonInstance</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype1</span><span class="p">,</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype2</span><span class="p">)</span><br>
</dt> <dd>
<p>Given two input descriptors, determines the appropriate “common” descriptor that can store values for both instances. Returns <code>NULL</code> on error.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_ensure_canonical"> <span class="sig-name descname"><span class="n">NPY_DT_ensure_canonical</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_EnsureCanonical"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_EnsureCanonical</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="p">)</span><br>
</dt> <dd>
<p>Returns the “canonical” representation for a descriptor instance. The notion of a canonical descriptor generalizes the concept of byte order, in that a canonical descriptor always has native byte order. If the descriptor is already canonical, this function returns a new reference to the input descriptor.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_setitem"> <span class="sig-name descname"><span class="n">NPY_DT_setitem</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_SetItem"> <span class="k">typedef</span><span class="kt">int</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_SetItem</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">,</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="p">,</span><span class="kt">char</span><span class="p">*</span><span class="p">)</span><br>
</dt> <dd>
<p>Implements scalar setitem for an array element given a PyObject.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_getitem"> <span class="sig-name descname"><span class="n">NPY_DT_getitem</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_GetItem"> <span class="k">typedef</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_GetItem</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">,</span><span class="kt">char</span><span class="p">*</span><span class="p">)</span><br>
</dt> <dd>
<p>Implements scalar getitem for an array element. Must return a python scalar.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_get_clear_loop"> <span class="sig-name descname"><span class="n">NPY_DT_get_clear_loop</span></span><br>
</dt> <dd>
<p>If defined, sets a traversal loop that clears data in the array. This is most useful for arrays of references that must clean up array entries before the array is garbage collected. Implements <code>PyArrayMethod_GetTraverseLoop</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_get_fill_zero_loop"> <span class="sig-name descname"><span class="n">NPY_DT_get_fill_zero_loop</span></span><br>
</dt> <dd>
<p>If defined, sets a traversal loop that fills an array with “zero” values, which may have a DType-specific meaning. This is called inside <a class="reference internal" href="../generated/numpy.zeros.html#numpy.zeros" title="numpy.zeros"><code>numpy.zeros</code></a> for arrays that need to write a custom sentinel value that represents zero if for some reason a zero-filled array is not sufficient. Implements <code>PyArrayMethod_GetTraverseLoop</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_finalize_descr"> <span class="sig-name descname"><span class="n">NPY_DT_finalize_descr</span></span><br>
</dt> 
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_FinalizeDescriptor"> <span class="k">typedef</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">(</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_FinalizeDescriptor</span></span><span class="p">)</span><span class="p">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="p">)</span><br>
</dt> <dd>
<p>If defined, a function that is called to “finalize” a descriptor instance after an array is created. One use of this function is to force newly created arrays to have a newly created descriptor instance, no matter what input descriptor is provided by a user.</p> </dd>
</dl> <section id="pyarray-arrfuncs-slots"> <h4>PyArray_ArrFuncs slots</h4> <p>In addition the above slots, the following slots are exposed to allow filling the <a class="reference internal" href="types-and-structures.html#arrfuncs-type"><span class="std std-ref">PyArray_ArrFuncs</span></a> struct attached to descriptor instances. Note that in the future these will be replaced by proper DType API slots but for now we have exposed the legacy <code>PyArray_ArrFuncs</code> slots.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_getitem"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_getitem</span></span><br>
</dt> <dd>
<p>Allows setting a per-dtype getitem. Note that this is not necessary to define unless the default version calling the function defined with the <code>NPY_DT_getitem</code> ID is unsuitable. This version will be slightly faster than using <code>NPY_DT_getitem</code> at the cost of sometimes needing to deal with a NULL input array.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_setitem"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_setitem</span></span><br>
</dt> <dd>
<p>Allows setting a per-dtype setitem. Note that this is not necessary to define unless the default version calling the function defined with the <code>NPY_DT_setitem</code> ID is unsuitable for some reason.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_compare"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_compare</span></span><br>
</dt> <dd>
<p>Computes a comparison for <a class="reference internal" href="../generated/numpy.sort.html#numpy.sort" title="numpy.sort"><code>numpy.sort</code></a>, implements <code>PyArray_CompareFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_argmax"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_argmax</span></span><br>
</dt> <dd>
<p>Computes the argmax for <a class="reference internal" href="../generated/numpy.argmax.html#numpy.argmax" title="numpy.argmax"><code>numpy.argmax</code></a>, implements <code>PyArray_ArgFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_argmin"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_argmin</span></span><br>
</dt> <dd>
<p>Computes the argmin for <a class="reference internal" href="../generated/numpy.argmin.html#numpy.argmin" title="numpy.argmin"><code>numpy.argmin</code></a>, implements <code>PyArray_ArgFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_dotfunc"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_dotfunc</span></span><br>
</dt> <dd>
<p>Computes the dot product for <a class="reference internal" href="../generated/numpy.dot.html#numpy.dot" title="numpy.dot"><code>numpy.dot</code></a>, implements <code>PyArray_DotFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_scanfunc"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_scanfunc</span></span><br>
</dt> <dd>
<p>A formatted input function for <a class="reference internal" href="../generated/numpy.fromfile.html#numpy.fromfile" title="numpy.fromfile"><code>numpy.fromfile</code></a>, implements <code>PyArray_ScanFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_fromstr"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_fromstr</span></span><br>
</dt> <dd>
<p>A string parsing function for <a class="reference internal" href="../generated/numpy.fromstring.html#numpy.fromstring" title="numpy.fromstring"><code>numpy.fromstring</code></a>, implements <code>PyArray_FromStrFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_nonzero"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_nonzero</span></span><br>
</dt> <dd>
<p>Computes the nonzero function for <a class="reference internal" href="../generated/numpy.nonzero.html#numpy.nonzero" title="numpy.nonzero"><code>numpy.nonzero</code></a>, implements <code>PyArray_NonzeroFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_fill"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_fill</span></span><br>
</dt> <dd>
<p>An array filling function for <a class="reference internal" href="../generated/numpy.ndarray.fill.html#numpy.ndarray.fill" title="numpy.ndarray.fill"><code>numpy.ndarray.fill</code></a>, implements <code>PyArray_FillFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_fillwithscalar"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_fillwithscalar</span></span><br>
</dt> <dd>
<p>A function to fill an array with a scalar value for <a class="reference internal" href="../generated/numpy.ndarray.fill.html#numpy.ndarray.fill" title="numpy.ndarray.fill"><code>numpy.ndarray.fill</code></a>, implements <code>PyArray_FillWithScalarFunc</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_sort"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_sort</span></span><br>
</dt> <dd>
<p>An array of PyArray_SortFunc of length <code>NPY_NSORTS</code>. If set, allows defining custom sorting implementations for each of the sorting algorithms numpy implements.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DT_PyArray_ArrFuncs_argsort"> <span class="sig-name descname"><span class="n">NPY_DT_PyArray_ArrFuncs_argsort</span></span><br>
</dt> <dd>
<p>An array of PyArray_ArgSortFunc of length <code>NPY_NSORTS</code>. If set, allows defining custom argsorting implementations for each of the sorting algorithms numpy implements.</p> </dd>
</dl> </section> </section> <section id="macros-and-static-inline-functions"> <h3>Macros and Static Inline Functions</h3> <p>These macros and static inline functions are provided to allow more understandable and idiomatic code when working with <code>PyArray_DTypeMeta</code> instances.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DTYPE"> <span class="sig-name descname"><span class="n">NPY_DTYPE</span></span><span class="sig-paren">(</span><span class="n">descr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a <code>PyArray_DTypeMeta *</code> pointer to the DType of a given descriptor instance.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_DT_NewRef"> <span class="k">static</span><span class="k">inline</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">NPY_DT_NewRef</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="n">o</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns a <code>PyArray_DTypeMeta *</code> pointer to a new reference to a DType.</p> </dd>
</dl> </section> </section> <section id="conversion-utilities"> <h2>Conversion utilities</h2> <section id="for-use-with-pyarg-parsetuple"> <h3>For use with <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.12)"><code>PyArg_ParseTuple</code></a>
</h3> <p>All of these functions can be used in <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.12)"><code>PyArg_ParseTuple</code></a> (…) with the “O&amp;” format specifier to automatically convert any Python object to the required C-object. All of these functions return <a class="reference internal" href="#c.NPY_SUCCEED" title="NPY_SUCCEED"><code>NPY_SUCCEED</code></a> if successful and <a class="reference internal" href="#c.NPY_FAIL" title="NPY_FAIL"><code>NPY_FAIL</code></a> if not. The first argument to all of these function is a Python object. The second argument is the <strong>address</strong> of the C-type to convert the Python object to.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_Converter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_Converter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">address</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any Python object to a <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a>. If <a class="reference internal" href="#c.PyArray_Check" title="PyArray_Check"><code>PyArray_Check</code></a> (<em>obj</em>) is TRUE then its reference count is incremented and a reference placed in <em>address</em>. If <em>obj</em> is not an array, then convert it to an array using <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code>PyArray_FromAny</code></a> . No matter what is returned, you must DECREF the object returned by this routine in <em>address</em> when you are done with it.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_OutputConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_OutputConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">address</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a default converter for output arrays given to functions. If <em>obj</em> is <a class="reference external" href="https://docs.python.org/3/c-api/none.html#c.Py_None" title="(in Python v3.12)"><code>Py_None</code></a> or <code>NULL</code>, then <em>*address</em> will be <code>NULL</code> but the call will succeed. If <a class="reference internal" href="#c.PyArray_Check" title="PyArray_Check"><code>PyArray_Check</code></a> ( <em>obj</em>) is TRUE then it is returned in <em>*address</em> without incrementing its reference count.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IntpConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IntpConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><span class="n">PyArray_Dims</span></a><span class="p">*</span><span class="n">seq</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any Python sequence, <em>obj</em>, smaller than <a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code>NPY_MAXDIMS</code></a> to a C-array of <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><code>npy_intp</code></a>. The Python object could also be a single number. The <em>seq</em> variable is a pointer to a structure with members ptr and len. On successful return, <em>seq</em> -&gt;ptr contains a pointer to memory that must be freed, by calling <a class="reference internal" href="#c.PyDimMem_FREE" title="PyDimMem_FREE"><code>PyDimMem_FREE</code></a>, to avoid a memory leak. The restriction on memory size allows this converter to be conveniently used for sequences intended to be interpreted as array shapes.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_BufferConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_BufferConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Chunk" title="PyArray_Chunk"><span class="n">PyArray_Chunk</span></a><span class="p">*</span><span class="n">buf</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any Python object, <em>obj</em>, with a (single-segment) buffer interface to a variable with members that detail the object’s use of its chunk of memory. The <em>buf</em> variable is a pointer to a structure with base, ptr, len, and flags members. The <a class="reference internal" href="types-and-structures.html#c.PyArray_Chunk" title="PyArray_Chunk"><code>PyArray_Chunk</code></a> structure is binary compatible with the Python’s buffer object (through its len member on 32-bit platforms and its ptr member on 64-bit platforms). On return, the base member is set to <em>obj</em> (or its base if <em>obj</em> is already a buffer object pointing to another object). If you need to hold on to the memory be sure to INCREF the base member. The chunk of memory is pointed to by <em>buf</em> -&gt;ptr member and has length <em>buf</em> -&gt;len. The flags member of <em>buf</em> is <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> with the <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> flag set if <em>obj</em> has a writeable buffer interface.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_AxisConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_AxisConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">int</span><span class="p">*</span><span class="n">axis</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert a Python object, <em>obj</em>, representing an axis argument to the proper value for passing to the functions that take an integer axis. Specifically, if <em>obj</em> is None, <em>axis</em> is set to <a class="reference internal" href="#c.NPY_RAVEL_AXIS" title="NPY_RAVEL_AXIS"><code>NPY_RAVEL_AXIS</code></a> which is interpreted correctly by the C-API functions that take axis arguments.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_BoolConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_BoolConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="p">*</span><span class="n">value</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any Python object, <em>obj</em>, to <a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code>NPY_TRUE</code></a> or <a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code>NPY_FALSE</code></a>, and place the result in <em>value</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ByteorderConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ByteorderConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">char</span><span class="p">*</span><span class="n">endian</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert Python strings into the corresponding byte-order character: ‘&gt;’, ‘&lt;’, ‘s’, ‘=’, or ‘|’.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SortkindConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SortkindConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="#c.NPY_SORTKIND" title="NPY_SORTKIND"><span class="n">NPY_SORTKIND</span></a><span class="p">*</span><span class="n">sort</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert Python strings into one of <a class="reference internal" href="#c.NPY_SORTKIND.NPY_QUICKSORT" title="NPY_QUICKSORT"><code>NPY_QUICKSORT</code></a> (starts with ‘q’ or ‘Q’), <a class="reference internal" href="#c.NPY_SORTKIND.NPY_HEAPSORT" title="NPY_HEAPSORT"><code>NPY_HEAPSORT</code></a> (starts with ‘h’ or ‘H’), <a class="reference internal" href="#c.NPY_SORTKIND.NPY_MERGESORT" title="NPY_MERGESORT"><code>NPY_MERGESORT</code></a> (starts with ‘m’ or ‘M’) or <a class="reference internal" href="#c.NPY_SORTKIND.NPY_STABLESORT" title="NPY_STABLESORT"><code>NPY_STABLESORT</code></a> (starts with ‘t’ or ‘T’). <a class="reference internal" href="#c.NPY_SORTKIND.NPY_MERGESORT" title="NPY_MERGESORT"><code>NPY_MERGESORT</code></a> and <a class="reference internal" href="#c.NPY_SORTKIND.NPY_STABLESORT" title="NPY_STABLESORT"><code>NPY_STABLESORT</code></a> are aliased to each other for backwards compatibility and may refer to one of several stable sorting algorithms depending on the data type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SearchsideConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SearchsideConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="#c.NPY_SEARCHSIDE" title="NPY_SEARCHSIDE"><span class="n">NPY_SEARCHSIDE</span></a><span class="p">*</span><span class="n">side</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert Python strings into one of <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT" title="NPY_SEARCHLEFT"><code>NPY_SEARCHLEFT</code></a> (starts with ‘l’ or ‘L’), or <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT" title="NPY_SEARCHRIGHT"><code>NPY_SEARCHRIGHT</code></a> (starts with ‘r’ or ‘R’).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_OrderConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_OrderConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><span class="n">NPY_ORDER</span></a><span class="p">*</span><span class="n">order</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><code>NPY_ORDER</code></a> enumeration <a class="reference internal" href="#c.NPY_ORDER.NPY_CORDER" title="NPY_CORDER"><code>NPY_CORDER</code></a>, <a class="reference internal" href="#c.NPY_ORDER.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code>NPY_FORTRANORDER</code></a>, <a class="reference internal" href="#c.NPY_ORDER.NPY_ANYORDER" title="NPY_ANYORDER"><code>NPY_ANYORDER</code></a>, and <a class="reference internal" href="#c.NPY_ORDER.NPY_KEEPORDER" title="NPY_KEEPORDER"><code>NPY_KEEPORDER</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_CastingConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_CastingConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="p">*</span><span class="n">casting</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’ into the <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><code>NPY_CASTING</code></a> enumeration <a class="reference internal" href="#c.NPY_CASTING.NPY_NO_CASTING" title="NPY_NO_CASTING"><code>NPY_NO_CASTING</code></a>, <a class="reference internal" href="#c.NPY_CASTING.NPY_EQUIV_CASTING" title="NPY_EQUIV_CASTING"><code>NPY_EQUIV_CASTING</code></a>, <a class="reference internal" href="#c.NPY_CASTING.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code>NPY_SAFE_CASTING</code></a>, <a class="reference internal" href="#c.NPY_CASTING.NPY_SAME_KIND_CASTING" title="NPY_SAME_KIND_CASTING"><code>NPY_SAME_KIND_CASTING</code></a>, and <a class="reference internal" href="#c.NPY_CASTING.NPY_UNSAFE_CASTING" title="NPY_UNSAFE_CASTING"><code>NPY_UNSAFE_CASTING</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ClipmodeConverter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ClipmodeConverter</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">object</span>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><span class="n">NPY_CLIPMODE</span></a><span class="p">*</span><span class="n">val</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><code>NPY_CLIPMODE</code></a> enumeration <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_CLIP" title="NPY_CLIP"><code>NPY_CLIP</code></a>, <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_WRAP" title="NPY_WRAP"><code>NPY_WRAP</code></a>, and <a class="reference internal" href="#c.NPY_CLIPMODE.NPY_RAISE" title="NPY_RAISE"><code>NPY_RAISE</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ConvertClipmodeSequence"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ConvertClipmodeSequence</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">object</span>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><span class="n">NPY_CLIPMODE</span></a><span class="p">*</span><span class="n">modes</span>, <span class="kt">int</span><span class="n">n</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Converts either a sequence of clipmodes or a single clipmode into a C array of <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><code>NPY_CLIPMODE</code></a> values. The number of clipmodes <em>n</em> must be known before calling this function. This function is provided to help functions allow a different clipmode for each dimension.</p> </dd>
</dl> </section> <section id="other-conversions"> <h3>Other conversions</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PyIntAsInt"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_PyIntAsInt</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert all kinds of Python objects (including arrays and array scalars) to a standard integer. On error, -1 is returned and an exception set. You may find useful the macro:</p> <pre data-language="c">#define error_converting(x) (((x) == -1) &amp;&amp; PyErr_Occurred())
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_PyIntAsIntp"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">PyArray_PyIntAsIntp</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert all kinds of Python objects (including arrays and array scalars) to a (platform-pointer-sized) integer. On error, -1 is returned and an exception set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_IntpFromSequence"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_IntpFromSequence</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">seq</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">vals</span>, <span class="kt">int</span><span class="n">maxvals</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Convert any Python sequence (or single Python number) passed in as <em>seq</em> to (up to) <em>maxvals</em> pointer-sized integers and place them in the <em>vals</em> array. The sequence can be smaller then <em>maxvals</em> as the number of converted objects is returned.</p> </dd>
</dl> </section> </section> <section id="including-and-importing-the-c-api"> <h2 id="including-the-c-api">Including and importing the C API</h2> <p>To use the NumPy C-API you typically need to include the <code>numpy/ndarrayobject.h</code> header and <code>numpy/ufuncobject.h</code> for some ufunc related functionality (<code>arrayobject.h</code> is an alias for <code>ndarrayobject.h</code>).</p> <p>These two headers export most relevant functionality. In general any project which uses the NumPy API must import NumPy using one of the functions <code>PyArray_ImportNumPyAPI()</code> or <code>import_array()</code>. In some places, functionality which requires <code>import_array()</code> is not needed, because you only need type definitions. In this case, it is sufficient to include <code>numpy/ndarratypes.h</code>.</p> <p>For the typical Python project, multiple C or C++ files will be compiled into a single shared object (the Python C-module) and <code>PyArray_ImportNumPyAPI()</code> should be called inside it’s module initialization.</p> <p>When you have a single C-file, this will consist of:</p> <pre data-language="c">#include "numpy/ndarrayobject.h"

PyMODINIT_FUNC PyInit_my_module(void)
{
    if (PyArray_ImportNumPyAPI() &lt; 0) {
        return NULL;
    }
    /* Other initialization code. */
}
</pre> <p>However, most projects will have additional C files which are all linked together into a single Python module. In this case, the helper C files typically do not have a canonical place where <code>PyArray_ImportNumPyAPI</code> should be called (although it is OK and fast to call it often).</p> <p>To solve this, NumPy provides the following pattern that the the main file is modified to define <code>PY_ARRAY_UNIQUE_SYMBOL</code> before the include:</p> <pre data-language="c">/* Main module file */
#define PY_ARRAY_UNIQUE_SYMBOL MyModule
#include "numpy/ndarrayobject.h"

PyMODINIT_FUNC PyInit_my_module(void)
{
    if (PyArray_ImportNumPyAPI() &lt; 0) {
        return NULL;
    }
    /* Other initialization code. */
}
</pre> <p>while the other files use:</p> <pre data-language="C">/* Second file without any import */
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL MyModule
#include "numpy/ndarrayobject.h"
</pre> <p>You can of course add the defines to a local header used throughout. You just have to make sure that the main file does _not_ define <code>NO_IMPORT_ARRAY</code>.</p> <p>For <code>numpy/ufuncobject.h</code> the same logic applies, but the unique symbol mechanism is <code>#define PY_UFUNC_UNIQUE_SYMBOL</code> (both can match).</p> <p>Additionally, you will probably wish to add a <code>#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION</code> to avoid warnings about possible use of old API.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are experiencing access violations make sure that the NumPy API was properly imported and the symbol <code>PyArray_API</code> is not <code>NULL</code>. When in a debugger, this symbols actual name will be <code>PY_ARRAY_UNIQUE_SYMBOL``+``PyArray_API</code>, so for example <code>MyModulePyArray_API</code> in the above. (E.g. even a <code>printf("%p\n", PyArray_API);</code> just before the crash.)</p> </div> <section id="mechanism-details-and-dynamic-linking"> <h3>Mechanism details and dynamic linking</h3> <p>The main part of the mechanism is that without NumPy needs to define a <code>void **PyArray_API</code> table for you to look up all functions. Depending on your macro setup, this takes different routes depending on whether <a class="reference internal" href="#c.NO_IMPORT_ARRAY" title="NO_IMPORT_ARRAY"><code>NO_IMPORT_ARRAY</code></a> and <a class="reference internal" href="#c.PY_ARRAY_UNIQUE_SYMBOL" title="PY_ARRAY_UNIQUE_SYMBOL"><code>PY_ARRAY_UNIQUE_SYMBOL</code></a> are defined:</p> <ul class="simple"> <li>If neither is defined, the C-API is declared to <code>static void **PyArray_API</code>, so it is only visible within the compilation unit/file using <code>#include &lt;numpy/arrayobject.h&gt;</code>.</li> <li>If only <code>PY_ARRAY_UNIQUE_SYMBOL</code> is defined (it could be empty) then the it is declared to a non-static <code>void **</code> allowing it to be used by other files which are linked.</li> <li>If <code>NO_IMPORT_ARRAY</code> is defined, the table is declared as <code>extern void **</code>, meaning that it must be linked to a file which does not use <code>NO_IMPORT_ARRAY</code>.</li> </ul> <p>The <code>PY_ARRAY_UNIQUE_SYMBOL</code> mechanism additionally mangles the names to avoid conflicts.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version NumPy: </span>2.1 changed the headers to avoid sharing the table outside of a single shared object/dll (this was always the case on Windows). Please see <a class="reference internal" href="#c.NPY_API_SYMBOL_ATTRIBUTE" title="NPY_API_SYMBOL_ATTRIBUTE"><code>NPY_API_SYMBOL_ATTRIBUTE</code></a> for details.</p> </div> <p>In order to make use of the C-API from another extension module, the <a class="reference internal" href="#c.import_array" title="import_array"><code>import_array</code></a> function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ImportNumPyAPI"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ImportNumPyAPI</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Ensures that the NumPy C-API is imported and usable. It returns <code>0</code> on success and <code>-1</code> with an error set if NumPy couldn’t be imported. While preferable to call it once at module initialization, this function is very light-weight if called multiple times.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0: </span>This function is backported in the <code>npy_2_compat.h</code> header.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.import_array"> <span class="sig-name descname"><span class="n">import_array</span></span><span class="sig-paren">(</span><span class="n">void</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it. This macro includes a <code>return NULL;</code> on error, so that <code>PyArray_ImportNumPyAPI()</code> is preferable for custom error checking. You may also see use of <code>_import_array()</code> (a function, not a macro, but you may want to raise a better error if it fails) and the variations <code>import_array1(ret)</code> which customizes the return value.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PY_ARRAY_UNIQUE_SYMBOL"> <span class="sig-name descname"><span class="n">PY_ARRAY_UNIQUE_SYMBOL</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_API_SYMBOL_ATTRIBUTE"> <span class="sig-name descname"><span class="n">NPY_API_SYMBOL_ATTRIBUTE</span></span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> <p>An additional symbol which can be used to share e.g. visibility beyond shared object boundaries. By default, NumPy adds the C visibility hidden attribute (if available): <code>void __attribute__((visibility("hidden"))) **PyArray_API;</code>. You can change this by defining <code>NPY_API_SYMBOL_ATTRIBUTE</code>, which will make this: <code>void NPY_API_SYMBOL_ATTRIBUTE **PyArray_API;</code> (with additional name mangling via the unique symbol).</p> <p>Adding an empty <code>#define NPY_API_SYMBOL_ATTRIBUTE</code> will have the same behavior as NumPy 1.x.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Windows never had shared visbility although you can use this macro to achieve it. We generally discourage sharing beyond shared boundary lines since importing the array API includes NumPy version checks.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NO_IMPORT_ARRAY"> <span class="sig-name descname"><span class="n">NO_IMPORT_ARRAY</span></span><br>
</dt> <dd>
<p>Defining <code>NO_IMPORT_ARRAY</code> before the <code>ndarrayobject.h</code> include indicates that the NumPy C API import is handled in a different file and the include mechanism will not be added here. You must have one file without <code>NO_IMPORT_ARRAY</code> defined.</p> <pre data-language="c">#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include &lt;numpy/arrayobject.h&gt;
</pre> <p>On the other hand, coolhelper.c would contain at the top:</p> <pre data-language="c">#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include &lt;numpy/arrayobject.h&gt;
</pre> <p>You can also put the common two last lines into an extension-local header file as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that file.</p> <p>Internally, these #defines work as follows:</p> <ul class="simple"> <li>If neither is defined, the C-API is declared to be <code>static void**</code>, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</li> <li>If <a class="reference internal" href="#c.PY_ARRAY_UNIQUE_SYMBOL" title="PY_ARRAY_UNIQUE_SYMBOL"><code>PY_ARRAY_UNIQUE_SYMBOL</code></a> is #defined, but <a class="reference internal" href="#c.NO_IMPORT_ARRAY" title="NO_IMPORT_ARRAY"><code>NO_IMPORT_ARRAY</code></a> is not, the C-API is declared to be <code>void**</code>, so that it will also be visible to other compilation units.</li> <li>If <a class="reference internal" href="#c.NO_IMPORT_ARRAY" title="NO_IMPORT_ARRAY"><code>NO_IMPORT_ARRAY</code></a> is #defined, regardless of whether <a class="reference internal" href="#c.PY_ARRAY_UNIQUE_SYMBOL" title="PY_ARRAY_UNIQUE_SYMBOL"><code>PY_ARRAY_UNIQUE_SYMBOL</code></a> is, the C-API is declared to be <code>extern void**</code>, so it is expected to be defined in another compilation unit.</li> <li>Whenever <a class="reference internal" href="#c.PY_ARRAY_UNIQUE_SYMBOL" title="PY_ARRAY_UNIQUE_SYMBOL"><code>PY_ARRAY_UNIQUE_SYMBOL</code></a> is #defined, it also changes the name of the variable holding the C-API, which defaults to <code>PyArray_API</code>, to whatever the macro is #defined to.</li> </ul> </dd>
</dl> </section> <section id="checking-the-api-version"> <h3>Checking the API Version</h3> <p>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That’s why several functions are provided to check for numpy versions. The macros <a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code>NPY_VERSION</code></a> and <a class="reference internal" href="#c.NPY_FEATURE_VERSION" title="NPY_FEATURE_VERSION"><code>NPY_FEATURE_VERSION</code></a> corresponds to the numpy version used to build the extension, whereas the versions returned by the functions <a class="reference internal" href="#c.PyArray_GetNDArrayCVersion" title="PyArray_GetNDArrayCVersion"><code>PyArray_GetNDArrayCVersion</code></a> and <a class="reference internal" href="#c.PyArray_GetNDArrayCFeatureVersion" title="PyArray_GetNDArrayCFeatureVersion"><code>PyArray_GetNDArrayCFeatureVersion</code></a> corresponds to the runtime numpy’s version.</p> <p>The rules for ABI and API compatibilities can be summarized as follows:</p> <ul class="simple"> <li>Whenever <a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code>NPY_VERSION</code></a> != <code>PyArray_GetNDArrayCVersion()</code>, the extension has to be recompiled (ABI incompatibility).</li> <li>
<a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code>NPY_VERSION</code></a> == <code>PyArray_GetNDArrayCVersion()</code> and <a class="reference internal" href="#c.NPY_FEATURE_VERSION" title="NPY_FEATURE_VERSION"><code>NPY_FEATURE_VERSION</code></a> &lt;= <code>PyArray_GetNDArrayCFeatureVersion()</code> means backward compatible changes.</li> </ul> <p>ABI incompatibility is automatically detected in every numpy’s version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest <a class="reference internal" href="#c.NPY_FEATURE_VERSION" title="NPY_FEATURE_VERSION"><code>NPY_FEATURE_VERSION</code></a> as possible.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_VERSION"> <span class="sig-name descname"><span class="n">NPY_VERSION</span></span><br>
</dt> <dd>
<p>The current version of the ndarray object (check to see if this variable is defined to guarantee the <code>numpy/arrayobject.h</code> header is being used).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_FEATURE_VERSION"> <span class="sig-name descname"><span class="n">NPY_FEATURE_VERSION</span></span><br>
</dt> <dd>
<p>The current version of the C-API.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetNDArrayCVersion"> <span class="kt">unsigned</span><span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_GetNDArrayCVersion</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This just returns the value <a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code>NPY_VERSION</code></a>. <a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code>NPY_VERSION</code></a> changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function <a class="reference internal" href="#c.import_array" title="import_array"><code>import_array</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetNDArrayCFeatureVersion"> <span class="kt">unsigned</span><span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_GetNDArrayCFeatureVersion</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="sig-paren">)</span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> <p>This just returns the value <a class="reference internal" href="#c.NPY_FEATURE_VERSION" title="NPY_FEATURE_VERSION"><code>NPY_FEATURE_VERSION</code></a>. <a class="reference internal" href="#c.NPY_FEATURE_VERSION" title="NPY_FEATURE_VERSION"><code>NPY_FEATURE_VERSION</code></a> changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</p> </dd>
</dl> </section> <section id="internal-flexibility"> <h3>Internal Flexibility</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SetStringFunction"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_SetStringFunction</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">op</span>, <span class="kt">int</span><span class="n">repr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as <em>op</em>. If <em>repr</em> is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not <em>op</em> is callable is performed. The callable passed in to <em>op</em> should expect an array argument and should return a string to be printed.</p> </dd>
</dl> </section> <section id="memory-management"> <h3>Memory management</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataMem_NEW"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataMem_NEW</span></span><span class="sig-paren">(</span><span class="n">size_t</span><span class="n">nbytes</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataMem_FREE"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyDataMem_FREE</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">ptr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataMem_RENEW"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataMem_RENEW</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">ptr</span>, <span class="n">size_t</span><span class="n">newbytes</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Macros to allocate, free, and reallocate memory. These macros are used internally to create arrays.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDimMem_NEW"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDimMem_NEW</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">nd</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDimMem_FREE"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyDimMem_FREE</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">ptr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDimMem_RENEW"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDimMem_RENEW</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">ptr</span>, <span class="n">size_t</span><span class="n">newnd</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Macros to allocate, free, and reallocate dimension and strides memory.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_malloc"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_malloc</span></span><span class="sig-paren">(</span><span class="n">size_t</span><span class="n">nbytes</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_free"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_free</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">ptr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_realloc"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">PyArray_realloc</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">ptr</span>, <span class="n">size_t</span><span class="n">nbytes</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>These macros use different memory allocators, depending on the constant <a class="reference internal" href="#c.PyArray_realloc.NPY_USE_PYMEM" title="NPY_USE_PYMEM"><code>NPY_USE_PYMEM</code></a>. The system malloc is used when <a class="reference internal" href="#c.PyArray_realloc.NPY_USE_PYMEM" title="NPY_USE_PYMEM"><code>NPY_USE_PYMEM</code></a> is 0, if <a class="reference internal" href="#c.PyArray_realloc.NPY_USE_PYMEM" title="NPY_USE_PYMEM"><code>NPY_USE_PYMEM</code></a> is 1, then the Python memory allocator is used.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_realloc.NPY_USE_PYMEM"> <span class="sig-name descname"><span class="n">NPY_USE_PYMEM</span></span><br>
</dt> 
</dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_ResolveWritebackIfCopy"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_ResolveWritebackIfCopy</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If <code>obj-&gt;flags</code> has <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a>, this function clears the flags, <code>DECREF</code> s <code>obj-&gt;base</code> and makes it writeable, and sets <code>obj-&gt;base</code> to NULL. It then copies <code>obj-&gt;data</code> to <code>obj-&gt;base-&gt;data</code>, and returns the error state of the copy operation. This is the opposite of <a class="reference internal" href="#c.PyArray_SetWritebackIfCopyBase" title="PyArray_SetWritebackIfCopyBase"><code>PyArray_SetWritebackIfCopyBase</code></a>. Usually this is called once you are finished with <code>obj</code>, just before <code>Py_DECREF(obj)</code>. It may be called multiple times, or with <code>NULL</code> input. See also <a class="reference internal" href="#c.PyArray_DiscardWritebackIfCopy" title="PyArray_DiscardWritebackIfCopy"><code>PyArray_DiscardWritebackIfCopy</code></a>.</p> <p>Returns 0 if nothing was done, -1 on error, and 1 if action was taken.</p> </dd>
</dl> </section> <section id="threading-support"> <h3>Threading support</h3> <p>These macros are only meaningful if <a class="reference internal" href="#c.NPY_ALLOW_THREADS" title="NPY_ALLOW_THREADS"><code>NPY_ALLOW_THREADS</code></a> evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. <a class="reference internal" href="#c.NPY_ALLOW_THREADS" title="NPY_ALLOW_THREADS"><code>NPY_ALLOW_THREADS</code></a> is true (defined as <code>1</code>) unless the build option <code>-Ddisable-threading</code> is set to <code>true</code> - in which case <a class="reference internal" href="#c.NPY_ALLOW_THREADS" title="NPY_ALLOW_THREADS"><code>NPY_ALLOW_THREADS</code></a> is false (<code>0</code>).</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ALLOW_THREADS"> <span class="sig-name descname"><span class="n">NPY_ALLOW_THREADS</span></span><br>
</dt> 
</dl> <section id="group-1"> <h4>Group 1</h4> <p>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_BEGIN_ALLOW_THREADS"> <span class="sig-name descname"><span class="n">NPY_BEGIN_ALLOW_THREADS</span></span><br>
</dt> <dd>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.12)"><code>Py_BEGIN_ALLOW_THREADS</code></a> except it uses <a class="reference internal" href="#c.NPY_ALLOW_THREADS" title="NPY_ALLOW_THREADS"><code>NPY_ALLOW_THREADS</code></a> to determine if the macro if replaced with white-space or not.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_END_ALLOW_THREADS"> <span class="sig-name descname"><span class="n">NPY_END_ALLOW_THREADS</span></span><br>
</dt> <dd>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS" title="(in Python v3.12)"><code>Py_END_ALLOW_THREADS</code></a> except it uses <a class="reference internal" href="#c.NPY_ALLOW_THREADS" title="NPY_ALLOW_THREADS"><code>NPY_ALLOW_THREADS</code></a> to determine if the macro if replaced with white-space or not.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_BEGIN_THREADS_DEF"> <span class="sig-name descname"><span class="n">NPY_BEGIN_THREADS_DEF</span></span><br>
</dt> <dd>
<p>Place in the variable declaration area. This macro sets up the variable needed for storing the Python state.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_BEGIN_THREADS"> <span class="sig-name descname"><span class="n">NPY_BEGIN_THREADS</span></span><br>
</dt> <dd>
<p>Place right before code that does not need the Python interpreter (no Python C-API calls). This macro saves the Python state and releases the GIL.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_END_THREADS"> <span class="sig-name descname"><span class="n">NPY_END_THREADS</span></span><br>
</dt> <dd>
<p>Place right after code that does not need the Python interpreter. This macro acquires the GIL and restores the Python state from the saved variable.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_BEGIN_THREADS_DESCR"> <span class="kt">void</span><span class="sig-name descname"><span class="n">NPY_BEGIN_THREADS_DESCR</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Useful to release the GIL only if <em>dtype</em> does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_END_THREADS_DESCR"> <span class="kt">void</span><span class="sig-name descname"><span class="n">NPY_END_THREADS_DESCR</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.NPY_BEGIN_THREADS_THRESHOLDED"> <span class="kt">void</span><span class="sig-name descname"><span class="n">NPY_BEGIN_THREADS_THRESHOLDED</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">loop_size</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Useful to release the GIL only if <em>loop_size</em> exceeds a minimum threshold, currently set to 500. Should be matched with a <a class="reference internal" href="#c.NPY_END_THREADS" title="NPY_END_THREADS"><code>NPY_END_THREADS</code></a> to regain the GIL.</p> </dd>
</dl> </section> <section id="group-2"> <h4>Group 2</h4> <p>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ALLOW_C_API_DEF"> <span class="sig-name descname"><span class="n">NPY_ALLOW_C_API_DEF</span></span><br>
</dt> <dd>
<p>Place in the variable declaration area to set up the necessary variable.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ALLOW_C_API"> <span class="sig-name descname"><span class="n">NPY_ALLOW_C_API</span></span><br>
</dt> <dd>
<p>Place before code that needs to call the Python C-API (when it is known that the GIL has already been released).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_DISABLE_C_API"> <span class="sig-name descname"><span class="n">NPY_DISABLE_C_API</span></span><br>
</dt> <dd>
<p>Place after code that needs to call the Python C-API (to re-release the GIL).</p> </dd>
</dl> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Never use semicolons after the threading support macros.</p> </div> </section> </section> <section id="priority"> <h3>Priority</h3> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_PRIORITY"> <span class="sig-name descname"><span class="n">NPY_PRIORITY</span></span><br>
</dt> <dd>
<p>Default priority for arrays.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_SUBTYPE_PRIORITY"> <span class="sig-name descname"><span class="n">NPY_SUBTYPE_PRIORITY</span></span><br>
</dt> <dd>
<p>Default subtype priority.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_SCALAR_PRIORITY"> <span class="sig-name descname"><span class="n">NPY_SCALAR_PRIORITY</span></span><br>
</dt> <dd>
<p>Default scalar priority (very small)</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_GetPriority"> <span class="kt">double</span><span class="sig-name descname"><span class="n">PyArray_GetPriority</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">obj</span>, <span class="kt">double</span><span class="n">def</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return the <a class="reference internal" href="../arrays.classes.html#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> attribute (converted to a double) of <em>obj</em> or <em>def</em> if no attribute of that name exists. Fast returns that avoid the attribute lookup are provided for objects of type <a class="reference internal" href="types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>.</p> </dd>
</dl> </section> <section id="default-buffers"> <h3>Default buffers</h3> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_BUFSIZE"> <span class="sig-name descname"><span class="n">NPY_BUFSIZE</span></span><br>
</dt> <dd>
<p>Default size of the user-settable internal buffers.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_MIN_BUFSIZE"> <span class="sig-name descname"><span class="n">NPY_MIN_BUFSIZE</span></span><br>
</dt> <dd>
<p>Smallest size of user-settable internal buffers.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_MAX_BUFSIZE"> <span class="sig-name descname"><span class="n">NPY_MAX_BUFSIZE</span></span><br>
</dt> <dd>
<p>Largest size allowed for the user-settable buffers.</p> </dd>
</dl> </section> <section id="other-constants"> <h3>Other constants</h3> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_NUM_FLOATTYPE"> <span class="sig-name descname"><span class="n">NPY_NUM_FLOATTYPE</span></span><br>
</dt> <dd>
<p>The number of floating-point types</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_MAXDIMS"> <span class="sig-name descname"><span class="n">NPY_MAXDIMS</span></span><br>
</dt> <dd>
<p>The maximum number of dimensions that may be used by NumPy. This is set to 64 and was 32 before NumPy 2.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We encourage you to avoid <code>NPY_MAXDIMS</code>. A future version of NumPy may wish to remove any dimension limitation (and thus the constant). The limitation was created so that NumPy can use stack allocations internally for scratch space.</p> <p>If your algorithm has a reasonable maximum number of dimension you could check and use that locally.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_MAXARGS"> <span class="sig-name descname"><span class="n">NPY_MAXARGS</span></span><br>
</dt> <dd>
<p>The maximum number of array arguments that can be used in some functions. This used to be 32 before NumPy 2 and is now 64. To continue to allow using it as a check whether a number of arguments is compatible ufuncs, this macro is now runtime dependent.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We discourage any use of <code>NPY_MAXARGS</code> that isn’t explicitly tied to checking for known NumPy limitations.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_FALSE"> <span class="sig-name descname"><span class="n">NPY_FALSE</span></span><br>
</dt> <dd>
<p>Defined as 0 for use with Bool.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_TRUE"> <span class="sig-name descname"><span class="n">NPY_TRUE</span></span><br>
</dt> <dd>
<p>Defined as 1 for use with Bool.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_FAIL"> <span class="sig-name descname"><span class="n">NPY_FAIL</span></span><br>
</dt> <dd>
<p>The return value of failed converter functions which are called using the “O&amp;” syntax in <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.12)"><code>PyArg_ParseTuple</code></a>-like functions.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_SUCCEED"> <span class="sig-name descname"><span class="n">NPY_SUCCEED</span></span><br>
</dt> <dd>
<p>The return value of successful converter functions which are called using the “O&amp;” syntax in <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.12)"><code>PyArg_ParseTuple</code></a>-like functions.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_RAVEL_AXIS"> <span class="sig-name descname"><span class="n">NPY_RAVEL_AXIS</span></span><br>
</dt> <dd>
<p>Some NumPy functions (mainly the C-entrypoints for Python functions) have an <code>axis</code> argument. This macro may be passed for <code>axis=None</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This macro is NumPy version dependent at runtime. The value is now the minimum integer. However, on NumPy 1.x <code>NPY_MAXDIMS</code> was used (at the time set to 32).</p> </div> </dd>
</dl> </section> <section id="miscellaneous-macros"> <h3>Miscellaneous Macros</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_SAMESHAPE"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyArray_SAMESHAPE</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">a1</span>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">a2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Evaluates as True if arrays <em>a1</em> and <em>a2</em> have the same shape.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_MAX"> <span class="sig-name descname"><span class="n">PyArray_MAX</span></span><span class="sig-paren">(</span><span class="n">a</span>, <span class="n">b</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns the maximum of <em>a</em> and <em>b</em>. If (<em>a</em>) or (<em>b</em>) are expressions they are evaluated twice.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyArray_MIN"> <span class="sig-name descname"><span class="n">PyArray_MIN</span></span><span class="sig-paren">(</span><span class="n">a</span>, <span class="n">b</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns the minimum of <em>a</em> and <em>b</em>. If (<em>a</em>) or (<em>b</em>) are expressions they are evaluated twice.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyArray_DiscardWritebackIfCopy"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyArray_DiscardWritebackIfCopy</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">obj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>If <code>obj-&gt;flags</code> has <a class="reference internal" href="#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a>, this function clears the flags, <code>DECREF</code> s <code>obj-&gt;base</code> and makes it writeable, and sets <code>obj-&gt;base</code> to NULL. In contrast to <a class="reference internal" href="#c.PyArray_ResolveWritebackIfCopy" title="PyArray_ResolveWritebackIfCopy"><code>PyArray_ResolveWritebackIfCopy</code></a> it makes no attempt to copy the data from <code>obj-&gt;base</code>. This undoes <a class="reference internal" href="#c.PyArray_SetWritebackIfCopyBase" title="PyArray_SetWritebackIfCopyBase"><code>PyArray_SetWritebackIfCopyBase</code></a>. Usually this is called after an error when you are finished with <code>obj</code>, just before <code>Py_DECREF(obj)</code>. It may be called multiple times, or with <code>NULL</code> input.</p> </dd>
</dl> </section> <section id="enumerated-types"> <h3>Enumerated Types</h3> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_SORTKIND"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_SORTKIND</span></span><br>
</dt> <dd>
<p>A special variable-type which can take on different values to indicate the sorting algorithm being used.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SORTKIND.NPY_QUICKSORT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_QUICKSORT</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SORTKIND.NPY_HEAPSORT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_HEAPSORT</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SORTKIND.NPY_MERGESORT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_MERGESORT</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SORTKIND.NPY_STABLESORT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_STABLESORT</span></span><br>
</dt> <dd>
<p>Used as an alias of <a class="reference internal" href="#c.NPY_SORTKIND.NPY_MERGESORT" title="NPY_MERGESORT"><code>NPY_MERGESORT</code></a> and vice versa.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SORTKIND.NPY_NSORTS"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_NSORTS</span></span><br>
</dt> <dd>
<p>Defined to be the number of sorts. It is fixed at three by the need for backwards compatibility, and consequently <a class="reference internal" href="#c.NPY_SORTKIND.NPY_MERGESORT" title="NPY_MERGESORT"><code>NPY_MERGESORT</code></a> and <a class="reference internal" href="#c.NPY_SORTKIND.NPY_STABLESORT" title="NPY_STABLESORT"><code>NPY_STABLESORT</code></a> are aliased to each other and may refer to one of several stable sorting algorithms depending on the data type.</p> </dd>
</dl> </dd>
</dl> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_SCALARKIND</span></span><br>
</dt> <dd>
<p>A special variable type indicating the number of “kinds” of scalars distinguished in determining scalar-coercion rules. This variable can take on the values:</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_NOSCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_NOSCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_BOOL_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_BOOL_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_INTPOS_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_INTPOS_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_INTNEG_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_INTNEG_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_FLOAT_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_FLOAT_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_COMPLEX_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_COMPLEX_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_OBJECT_SCALAR"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_OBJECT_SCALAR</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SCALARKIND.NPY_NSCALARKINDS"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_NSCALARKINDS</span></span><br>
</dt> <dd>
<p>Defined to be the number of scalar kinds (not including <a class="reference internal" href="#c.NPY_SCALARKIND.NPY_NOSCALAR" title="NPY_NOSCALAR"><code>NPY_NOSCALAR</code></a>).</p> </dd>
</dl> </dd>
</dl> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_ORDER"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_ORDER</span></span><br>
</dt> <dd>
<p>An enumeration type indicating the element order that an array should be interpreted in. When a brand new array is created, generally only <strong>NPY_CORDER</strong> and <strong>NPY_FORTRANORDER</strong> are used, whereas when one or more inputs are provided, the order can be based on them.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ORDER.NPY_ANYORDER"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_ANYORDER</span></span><br>
</dt> <dd>
<p>Fortran order if all the inputs are Fortran, C otherwise.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ORDER.NPY_CORDER"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_CORDER</span></span><br>
</dt> <dd>
<p>C order.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ORDER.NPY_FORTRANORDER"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_FORTRANORDER</span></span><br>
</dt> <dd>
<p>Fortran order.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_ORDER.NPY_KEEPORDER"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_KEEPORDER</span></span><br>
</dt> <dd>
<p>An order as close to the order of the inputs as possible, even if the input is in neither C nor Fortran order.</p> </dd>
</dl> </dd>
</dl> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_CLIPMODE"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_CLIPMODE</span></span><br>
</dt> <dd>
<p>A variable type indicating the kind of clipping that should be applied in certain functions.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CLIPMODE.NPY_RAISE"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_RAISE</span></span><br>
</dt> <dd>
<p>The default for most operations, raises an exception if an index is out of bounds.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CLIPMODE.NPY_CLIP"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_CLIP</span></span><br>
</dt> <dd>
<p>Clips an index to the valid range if it is out of bounds.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CLIPMODE.NPY_WRAP"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_WRAP</span></span><br>
</dt> <dd>
<p>Wraps an index to the valid range if it is out of bounds.</p> </dd>
</dl> </dd>
</dl> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_SEARCHSIDE"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_SEARCHSIDE</span></span><br>
</dt> <dd>
<p>A variable type indicating whether the index returned should be that of the first suitable location (if <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT" title="NPY_SEARCHLEFT"><code>NPY_SEARCHLEFT</code></a>) or of the last (if <a class="reference internal" href="#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT" title="NPY_SEARCHRIGHT"><code>NPY_SEARCHRIGHT</code></a>).</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SEARCHSIDE.NPY_SEARCHLEFT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_SEARCHLEFT</span></span><br>
</dt> 
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_SEARCHRIGHT</span></span><br>
</dt> 
</dl> </dd>
</dl> <dl class="c enum"> <dt class="sig sig-object c" id="c.NPY_SELECTKIND"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_SELECTKIND</span></span><br>
</dt> <dd>
<p>A variable type indicating the selection algorithm being used.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_SELECTKIND.NPY_INTROSELECT"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_INTROSELECT</span></span><br>
</dt> 
</dl> </dd>
</dl> <dl class="c enum" id="index-1"> <dt class="sig sig-object c" id="c.NPY_CASTING"> <span class="k">enum</span><span class="sig-name descname"><span class="n">NPY_CASTING</span></span><br>
</dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>An enumeration type indicating how permissive data conversions should be. This is used by the iterator added in NumPy 1.6, and is intended to be used more broadly in a future version.</p> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CASTING.NPY_NO_CASTING"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_NO_CASTING</span></span><br>
</dt> <dd>
<p>Only allow identical types.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CASTING.NPY_EQUIV_CASTING"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_EQUIV_CASTING</span></span><br>
</dt> <dd>
<p>Allow identical and casts involving byte swapping.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CASTING.NPY_SAFE_CASTING"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_SAFE_CASTING</span></span><br>
</dt> <dd>
<p>Only allow casts which will not cause values to be rounded, truncated, or otherwise changed.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CASTING.NPY_SAME_KIND_CASTING"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_SAME_KIND_CASTING</span></span><br>
</dt> <dd>
<p>Allow any safe casts, and casts between types of the same kind. For example, float64 -&gt; float32 is permitted with this rule.</p> </dd>
</dl> <dl class="c enumerator"> <dt class="sig sig-object c" id="c.NPY_CASTING.NPY_UNSAFE_CASTING"> <span class="k">enumerator</span><span class="sig-name descname"><span class="n">NPY_UNSAFE_CASTING</span></span><br>
</dt> <dd>
<p>Allow any cast, no matter what kind of data loss may occur.</p> </dd>
</dl> </dd>
</dl> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/c-api/array.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/c-api/array.html</a>
  </p>
</div>
