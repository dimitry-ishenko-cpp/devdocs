<section id="python-types-and-c-structures"> <h1>Python types and C-structures</h1> <p>Several new types are defined in the C-code. Most of these are accessible from Python, but a few are not exposed due to their limited use. Every new Python type has an associated <span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span></span> with an internal structure that includes a pointer to a “method table” that defines how the new object behaves in Python. When you receive a Python object into C code, you always get a pointer to a <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><code>PyObject</code></a> structure. Because a <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><code>PyObject</code></a> structure is very generic and defines only <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" title="(in Python v3.12)"><code>PyObject_HEAD</code></a>, by itself it is not very interesting. However, different objects contain more details after the <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" title="(in Python v3.12)"><code>PyObject_HEAD</code></a> (but you have to cast to the correct type to access them — or use accessor functions or macros).</p> <section id="new-python-types-defined"> <h2>New Python types defined</h2> <p>Python types are the functional equivalent in C of classes in Python. By constructing a new Python type you make available a new object for Python. The ndarray object is an example of a new type defined in C. New types are defined in C by two basic steps:</p> <ol class="arabic simple"> <li>creating a C-structure (usually named <code>Py{Name}Object</code>) that is binary- compatible with the <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><code>PyObject</code></a> structure itself but holds the additional information needed for that particular object;</li> <li>populating the <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><code>PyTypeObject</code></a> table (pointed to by the ob_type member of the <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><code>PyObject</code></a> structure) with pointers to functions that implement the desired behavior for the type.</li> </ol> <p>Instead of special method names which define behavior for Python classes, there are “function tables” which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be “sub-typed “from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</p> <p>There are two major new types: the ndarray ( <a class="reference internal" href="#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> ) and the ufunc ( <a class="reference internal" href="#c.PyUFunc_Type" title="PyUFunc_Type"><code>PyUFunc_Type</code></a> ). Additional types play a supportive role: the <a class="reference internal" href="#c.PyArrayIter_Type" title="PyArrayIter_Type"><code>PyArrayIter_Type</code></a>, the <a class="reference internal" href="#c.PyArrayMultiIter_Type" title="PyArrayMultiIter_Type"><code>PyArrayMultiIter_Type</code></a>, and the <a class="reference internal" href="#c.PyArrayDescr_Type" title="PyArrayDescr_Type"><code>PyArrayDescr_Type</code></a> . The <a class="reference internal" href="#c.PyArrayIter_Type" title="PyArrayIter_Type"><code>PyArrayIter_Type</code></a> is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The <a class="reference internal" href="#c.PyArrayMultiIter_Type" title="PyArrayMultiIter_Type"><code>PyArrayMultiIter_Type</code></a> is the type of the object returned when calling <code>broadcast</code>. It handles iteration and broadcasting over a collection of nested sequences. Also, the <a class="reference internal" href="#c.PyArrayDescr_Type" title="PyArrayDescr_Type"><code>PyArrayDescr_Type</code></a> is the data-type-descriptor type whose instances describe the data and <a class="reference internal" href="#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><code>PyArray_DTypeMeta</code></a> is the metaclass for data-type descriptors. There are also new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. Additional types are placeholders that allow the array scalars to fit into a hierarchy of actual Python types. Finally, the <a class="reference internal" href="#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><code>PyArray_DTypeMeta</code></a> instances corresponding to the NumPy built-in data types are also publicly visible.</p> <section id="pyarray-type-and-pyarrayobject"> <h3>PyArray_Type and PyArrayObject</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArray_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArray_Type</span></span><br>
</dt> <dd>
<p>The Python type of the ndarray is <a class="reference internal" href="#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a>. In C, every ndarray is a pointer to a <a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a> structure. The ob_type member of this structure contains a pointer to the <a class="reference internal" href="#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> typeobject.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayObject</span></span><br>
</dt> <dt class="sig sig-object c" id="c.NPY_AO"> <span class="k">type</span><span class="sig-name descname"><span class="n">NPY_AO</span></span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a> C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of <a class="reference internal" href="#c.NPY_AO" title="NPY_AO"><code>NPY_AO</code></a> (deprecated) which is defined to be equivalent to <a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a>. Direct access to the struct fields are deprecated. Use the <code>PyArray_*(arr)</code> form instead. As of NumPy 1.20, the size of this struct is not considered part of the NumPy ABI (see note at the end of the member list).</p> <pre data-language="c">typedef struct PyArrayObject {
    PyObject_HEAD
    char *data;
    int nd;
    npy_intp *dimensions;
    npy_intp *strides;
    PyObject *base;
    PyArray_Descr *descr;
    int flags;
    PyObject *weakreflist;
    /* version dependent private members */
} PyArrayObject;
</pre> <dl class="simple"> <dt><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" title="(in Python v3.12)"><code>PyObject_HEAD</code></a></dt>
<dd>
<p>This is needed by all Python objects. It consists of (at least) a reference count member ( <code>ob_refcnt</code> ) and a pointer to the typeobject ( <code>ob_type</code> ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</p> </dd> </dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.data"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">data</span></span><br>
</dt> <dd>
<p>Accessible via <a class="reference internal" href="array.html#c.PyArray_DATA" title="PyArray_DATA"><code>PyArray_DATA</code></a>, this data member is a pointer to the first element of the array. This pointer can (and normally should) be recast to the data type of the array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.nd"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nd</span></span><br>
</dt> <dd>
<p>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. Macro <a class="reference internal" href="array.html#c.PyArray_NDIM" title="PyArray_NDIM"><code>PyArray_NDIM</code></a> defined in <code>ndarraytypes.h</code> points to this data member. <code>NPY_MAXDIMS</code> is defined as a compile time constant limiting the number of dimensions. This number is 64 since NumPy 2 and was 32 before. However, we may wish to remove this limitations in the future so that it is best to explicitly check dimensionality for code that relies on such an upper bound.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.dimensions"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">dimensions</span></span><br>
</dt> <dd>
<p>An array of integers providing the shape in each dimension as long as nd <span class="math notranslate nohighlight">\(\geq\)</span> 1. The integer is always large enough to hold a pointer on the platform, so the dimension size is only limited by memory. <a class="reference internal" href="array.html#c.PyArray_DIMS" title="PyArray_DIMS"><code>PyArray_DIMS</code></a> is the macro associated with this data member.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.strides"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">strides</span></span><br>
</dt> <dd>
<p>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension. Associated with macro <a class="reference internal" href="array.html#c.PyArray_STRIDES" title="PyArray_STRIDES"><code>PyArray_STRIDES</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.base"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">base</span></span><br>
</dt> <dd>
<p>Pointed to by <a class="reference internal" href="array.html#c.PyArray_BASE" title="PyArray_BASE"><code>PyArray_BASE</code></a>, this member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</p> <ul class="simple"> <li>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</li> <li>If this array has the <a class="reference internal" href="array.html#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a> flag set, then this array is a working copy of a “misbehaved” array.</li> </ul> <p>When <code>PyArray_ResolveWritebackIfCopy</code> is called, the array pointed to by base will be updated with the contents of this array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.descr"> <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">descr</span></span><br>
</dt> <dd>
<p>A pointer to a data-type descriptor object (see below). The data-type descriptor object is an instance of a new built-in type which allows a generic description of memory. There is a descriptor structure for each data type supported. This descriptor structure contains useful information about the type as well as a pointer to a table of function pointers to implement specific functionality. As the name suggests, it is associated with the macro <a class="reference internal" href="array.html#c.PyArray_DESCR" title="PyArray_DESCR"><code>PyArray_DESCR</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.flags"> <span class="kt">int</span><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>Pointed to by the macro <a class="reference internal" href="array.html#c.PyArray_FLAGS" title="PyArray_FLAGS"><code>PyArray_FLAGS</code></a>, this data member represents the flags indicating how the memory pointed to by data is to be interpreted. Possible flags are <a class="reference internal" href="array.html#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_OWNDATA" title="NPY_ARRAY_OWNDATA"><code>NPY_ARRAY_OWNDATA</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_WRITEBACKIFCOPY" title="NPY_ARRAY_WRITEBACKIFCOPY"><code>NPY_ARRAY_WRITEBACKIFCOPY</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.NPY_AO.weakreflist"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">weakreflist</span></span><br>
</dt> <dd>
<p>This member allows array objects to have weak references (using the weakref module).</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Further members are considered private and version dependent. If the size of the struct is important for your code, special care must be taken. A possible use-case when this is relevant is subclassing in C. If your code relies on <code>sizeof(PyArrayObject)</code> to be constant, you must add the following check at import time:</p> <pre data-language="c">if (sizeof(PyArrayObject) &lt; PyArray_Type.tp_basicsize) {
    PyErr_SetString(PyExc_ImportError,
       "Binary incompatibility with NumPy, must recompile/update X.");
    return NULL;
}
</pre> <p>To ensure that your code does not have to be compiled for a specific NumPy version, you may add a constant, leaving room for changes in NumPy. A solution guaranteed to be compatible with any future NumPy version requires the use of a runtime calculate offset and allocation size.</p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> typeobject implements many of the features of <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><code>Python objects</code></a> including the <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_number" title="(in Python v3.12)"><code>tp_as_number</code></a>, <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence" title="(in Python v3.12)"><code>tp_as_sequence</code></a>, <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping" title="(in Python v3.12)"><code>tp_as_mapping</code></a>, and <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer" title="(in Python v3.12)"><code>tp_as_buffer</code></a> interfaces. The <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.richcmpfunc" title="(in Python v3.12)"><code>rich comparison</code></a>) is also used along with new-style attribute lookup for member (<a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_members" title="(in Python v3.12)"><code>tp_members</code></a>) and properties (<a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset" title="(in Python v3.12)"><code>tp_getset</code></a>). The <a class="reference internal" href="#c.PyArray_Type" title="PyArray_Type"><code>PyArray_Type</code></a> can also be sub-typed.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>The <code>tp_as_number</code> methods use a generic approach to call whatever function has been registered for handling the operation. When the <code>_multiarray_umath module</code> is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with <a class="reference internal" href="ufunc.html#c.PyUFunc_ReplaceLoopBySignature" title="PyUFunc_ReplaceLoopBySignature"><code>PyUFunc_ReplaceLoopBySignature</code></a> The <code>tp_str</code> and <code>tp_repr</code> methods can also be altered using <a class="reference internal" href="array.html#c.PyArray_SetStringFunction" title="PyArray_SetStringFunction"><code>PyArray_SetStringFunction</code></a>.</p> </div> </section> <section id="pygenericarrtype-type"> <h3>PyGenericArrType_Type</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyGenericArrType_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyGenericArrType_Type</span></span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.PyGenericArrType_Type" title="PyGenericArrType_Type"><code>PyGenericArrType_Type</code></a> is the PyTypeObject definition which create the <a class="reference internal" href="../arrays.scalars.html#numpy.generic" title="numpy.generic"><code>numpy.generic</code></a> python type.</p> </dd>
</dl> </section> <section id="pyarraydescr-type-and-pyarray-descr"> <h3>PyArrayDescr_Type and PyArray_Descr</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayDescr_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayDescr_Type</span></span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.PyArrayDescr_Type" title="PyArrayDescr_Type"><code>PyArrayDescr_Type</code></a> is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> objects that is also maintained. Once a data-type-descriptor object is “registered” it should never be deallocated either. The function <a class="reference internal" href="array.html#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code>PyArray_DescrFromType</code></a> (…) can be used to retrieve a <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> object from an enumerated type-number (either built-in or user- defined).</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_DescrProto"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_DescrProto</span></span><br>
</dt> <dd>
<p>Identical structure to <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a>. This struct is used for static definition of a prototype for registering a new legacy DType by <a class="reference internal" href="array.html#c.PyArray_RegisterDataType" title="PyArray_RegisterDataType"><code>PyArray_RegisterDataType</code></a>.</p> <p>See the note in <a class="reference internal" href="array.html#c.PyArray_RegisterDataType" title="PyArray_RegisterDataType"><code>PyArray_RegisterDataType</code></a> for details.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_Descr"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_Descr</span></span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><code>PyArray_Descr</code></a> structure lies at the heart of the <a class="reference internal" href="#c.PyArrayDescr_Type" title="PyArrayDescr_Type"><code>PyArrayDescr_Type</code></a>. While it is described here for completeness, it should be considered internal to NumPy and manipulated via <code>PyArrayDescr_*</code> or <code>PyDataType*</code> functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</p> <ul class="simple"> <li>Never declare a non-pointer instance of the struct</li> <li>Never perform pointer arithmetic</li> <li>Never use <code>sizeof(PyArray_Descr)</code>
</li> </ul> <p>It has the following structure:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    PyTypeObject *typeobj;
    char kind;
    char type;
    char byteorder;
    char _former_flags;  // unused field
    int type_num;
    /*
     * Definitions after this one must be accessed through accessor
     * functions (see below) when compiling with NumPy 1.x support.
     */
    npy_uint64 flags;
    npy_intp elsize;
    npy_intp alignment;
    NpyAuxData *c_metadata;
    npy_hash_t hash;
    void *reserved_null[2];  // unused field, must be NULLed.
} PyArray_Descr;
</pre> <p>Some dtypes have additional members which are accessible through <code>PyDataType_NAMES</code>, <code>PyDataType_FIELDS</code>, <code>PyDataType_SUBARRAY</code>, and in some cases (times) <code>PyDataType_C_METADATA</code>.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.typeobj"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">typeobj</span></span><br>
</dt> <dd>
<p>Pointer to a typeobject that is the corresponding Python type for the elements of this array. For the builtin types, this points to the corresponding array scalar. For user-defined types, this should point to a user-defined typeobject. This typeobject can either inherit from array scalars or not. If it does not inherit from array scalars, then the <a class="reference internal" href="#c.NPY_USE_GETITEM" title="NPY_USE_GETITEM"><code>NPY_USE_GETITEM</code></a> and <a class="reference internal" href="#c.NPY_USE_SETITEM" title="NPY_USE_SETITEM"><code>NPY_USE_SETITEM</code></a> flags should be set in the <code>flags</code> member.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.kind"> <span class="kt">char</span><span class="sig-name descname"><span class="n">kind</span></span><br>
</dt> <dd>
<p>A character code indicating the kind of array (using the array interface typestring notation). A ‘b’ represents Boolean, a ‘i’ represents signed integer, a ‘u’ represents unsigned integer, ‘f’ represents floating point, ‘c’ represents complex floating point, ‘S’ represents 8-bit zero-terminated bytes, ‘U’ represents 32-bit/character unicode string, and ‘V’ represents arbitrary.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.type"> <span class="kt">char</span><span class="sig-name descname"><span class="n">type</span></span><br>
</dt> <dd>
<p>A traditional character code indicating the data type.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.byteorder"> <span class="kt">char</span><span class="sig-name descname"><span class="n">byteorder</span></span><br>
</dt> <dd>
<p>A character indicating the byte-order: ‘&gt;’ (big-endian), ‘&lt;’ (little- endian), ‘=’ (native), ‘|’ (irrelevant, ignore). All builtin data- types have byteorder ‘=’.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.flags"> <a class="reference internal" href="dtype.html#c.npy_uint64" title="npy_uint64"><span class="n">npy_uint64</span></a><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>A data-type bit-flag that determines if the data-type exhibits object- array like behavior. Each bit in this member is a flag which are named as:</p> <ul class="simple"> <li><a class="reference internal" href="#c.NPY_ITEM_REFCOUNT" title="NPY_ITEM_REFCOUNT"><code>NPY_ITEM_REFCOUNT</code></a></li> <li><a class="reference internal" href="#c.NPY_ITEM_HASOBJECT" title="NPY_ITEM_HASOBJECT"><code>NPY_ITEM_HASOBJECT</code></a></li> <li><a class="reference internal" href="#c.NPY_LIST_PICKLE" title="NPY_LIST_PICKLE"><code>NPY_LIST_PICKLE</code></a></li> <li><a class="reference internal" href="#c.NPY_ITEM_IS_POINTER" title="NPY_ITEM_IS_POINTER"><code>NPY_ITEM_IS_POINTER</code></a></li> <li><a class="reference internal" href="#c.NPY_NEEDS_INIT" title="NPY_NEEDS_INIT"><code>NPY_NEEDS_INIT</code></a></li> <li><a class="reference internal" href="#c.NPY_NEEDS_PYAPI" title="NPY_NEEDS_PYAPI"><code>NPY_NEEDS_PYAPI</code></a></li> <li><a class="reference internal" href="#c.NPY_USE_GETITEM" title="NPY_USE_GETITEM"><code>NPY_USE_GETITEM</code></a></li> <li><a class="reference internal" href="#c.NPY_USE_SETITEM" title="NPY_USE_SETITEM"><code>NPY_USE_SETITEM</code></a></li> <li><a class="reference internal" href="#c.NPY_FROM_FIELDS" title="NPY_FROM_FIELDS"><code>NPY_FROM_FIELDS</code></a></li> <li><a class="reference internal" href="#c.NPY_OBJECT_DTYPE_FLAGS" title="NPY_OBJECT_DTYPE_FLAGS"><code>NPY_OBJECT_DTYPE_FLAGS</code></a></li> </ul> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.type_num"> <span class="kt">int</span><span class="sig-name descname"><span class="n">type_num</span></span><br>
</dt> <dd>
<p>A number that uniquely identifies the data type. For new data-types, this number is assigned when the data-type is registered.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.elsize"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">elsize</span></span><br>
</dt> <dd>
<p>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</p> <p>See <code>PyDataType_ELSIZE</code> and <code>PyDataType_SET_ELSIZE</code> for a way to access this field in a NumPy 1.x compatible way.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.alignment"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">alignment</span></span><br>
</dt> <dd>
<p>A number providing alignment information for this data type. Specifically, it shows how far from the start of a 2-element structure (whose first element is a <code>char</code> ), the compiler places an item of this type: <code>offsetof(struct {char c; type v;},
v)</code></p> <p>See <code>PyDataType_ALIGNMENT</code> for a way to access this field in a NumPy 1.x compatible way.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.metadata"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">metadata</span></span><br>
</dt> <dd>
<p>Metadata about this dtype.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.c_metadata"> <a class="reference internal" href="array.html#c.NpyAuxData" title="NpyAuxData"><span class="n">NpyAuxData</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">c_metadata</span></span><br>
</dt> <dd>
<p>Metadata specific to the C implementation of the particular dtype. Added for NumPy 1.7.0.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_Descr.npy_hash_t"> <span class="k">type</span><span class="sig-name descname"><span class="n">npy_hash_t</span></span><br>
</dt> 
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Descr.hash"> <a class="reference internal" href="#c.PyArray_Descr.npy_hash_t" title="npy_hash_t"><span class="n">npy_hash_t</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">hash</span></span><br>
</dt> <dd>
<p>Used for caching hash values.</p> </dd>
</dl> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ITEM_REFCOUNT"> <span class="sig-name descname"><span class="n">NPY_ITEM_REFCOUNT</span></span><br>
</dt> <dd>
<p>Indicates that items of this data-type must be reference counted (using <a class="reference external" href="https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF" title="(in Python v3.12)"><code>Py_INCREF</code></a> and <a class="reference external" href="https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF" title="(in Python v3.12)"><code>Py_DECREF</code></a> ).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ITEM_HASOBJECT"> <span class="sig-name descname"><span class="n">NPY_ITEM_HASOBJECT</span></span><br>
</dt> <dd>
<p>Same as <a class="reference internal" href="#c.NPY_ITEM_REFCOUNT" title="NPY_ITEM_REFCOUNT"><code>NPY_ITEM_REFCOUNT</code></a>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LIST_PICKLE"> <span class="sig-name descname"><span class="n">NPY_LIST_PICKLE</span></span><br>
</dt> <dd>
<p>Indicates arrays of this data-type must be converted to a list before pickling.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_ITEM_IS_POINTER"> <span class="sig-name descname"><span class="n">NPY_ITEM_IS_POINTER</span></span><br>
</dt> <dd>
<p>Indicates the item is a pointer to some other data-type</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_NEEDS_INIT"> <span class="sig-name descname"><span class="n">NPY_NEEDS_INIT</span></span><br>
</dt> <dd>
<p>Indicates memory for this data-type must be initialized (set to 0) on creation.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_NEEDS_PYAPI"> <span class="sig-name descname"><span class="n">NPY_NEEDS_PYAPI</span></span><br>
</dt> <dd>
<p>Indicates this data-type requires the Python C-API during access (so don’t give up the GIL if array access is going to be needed).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_USE_GETITEM"> <span class="sig-name descname"><span class="n">NPY_USE_GETITEM</span></span><br>
</dt> <dd>
<p>On array access use the <code>f-&gt;getitem</code> function pointer instead of the standard conversion to an array scalar. Must use if you don’t define an array scalar to go along with the data-type.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_USE_SETITEM"> <span class="sig-name descname"><span class="n">NPY_USE_SETITEM</span></span><br>
</dt> <dd>
<p>When creating a 0-d array from an array scalar use <code>f-&gt;setitem</code> instead of the standard copy from an array scalar. Must use if you don’t define an array scalar to go along with the data-type.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_FROM_FIELDS"> <span class="sig-name descname"><span class="n">NPY_FROM_FIELDS</span></span><br>
</dt> <dd>
<p>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( <a class="reference internal" href="#c.NPY_NEEDS_INIT" title="NPY_NEEDS_INIT"><code>NPY_NEEDS_INIT</code></a> | <a class="reference internal" href="#c.NPY_LIST_PICKLE" title="NPY_LIST_PICKLE"><code>NPY_LIST_PICKLE</code></a> | <a class="reference internal" href="#c.NPY_ITEM_REFCOUNT" title="NPY_ITEM_REFCOUNT"><code>NPY_ITEM_REFCOUNT</code></a> | <a class="reference internal" href="#c.NPY_NEEDS_PYAPI" title="NPY_NEEDS_PYAPI"><code>NPY_NEEDS_PYAPI</code></a> ).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_OBJECT_DTYPE_FLAGS"> <span class="sig-name descname"><span class="n">NPY_OBJECT_DTYPE_FLAGS</span></span><br>
</dt> <dd>
<p>Bits set for the object data-type: ( <a class="reference internal" href="#c.NPY_LIST_PICKLE" title="NPY_LIST_PICKLE"><code>NPY_LIST_PICKLE</code></a> | <a class="reference internal" href="#c.NPY_USE_GETITEM" title="NPY_USE_GETITEM"><code>NPY_USE_GETITEM</code></a> | <a class="reference internal" href="#c.NPY_ITEM_IS_POINTER" title="NPY_ITEM_IS_POINTER"><code>NPY_ITEM_IS_POINTER</code></a> | <a class="reference internal" href="#c.NPY_ITEM_REFCOUNT" title="NPY_ITEM_REFCOUNT"><code>NPY_ITEM_REFCOUNT</code></a> | <a class="reference internal" href="#c.NPY_NEEDS_INIT" title="NPY_NEEDS_INIT"><code>NPY_NEEDS_INIT</code></a> | <a class="reference internal" href="#c.NPY_NEEDS_PYAPI" title="NPY_NEEDS_PYAPI"><code>NPY_NEEDS_PYAPI</code></a>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_FLAGCHK"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_FLAGCHK</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span>, <span class="kt">int</span><span class="n">flags</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Return true if all the given flags are set for the data-type object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_REFCHK"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyDataType_REFCHK</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Equivalent to <a class="reference internal" href="#c.PyDataType_FLAGCHK" title="PyDataType_FLAGCHK"><code>PyDataType_FLAGCHK</code></a> (<em>dtype</em>, <a class="reference internal" href="#c.NPY_ITEM_REFCOUNT" title="NPY_ITEM_REFCOUNT"><code>NPY_ITEM_REFCOUNT</code></a>).</p> </dd>
</dl> </section> <section id="pyarray-arrfuncs"> <h3 id="arrfuncs-type">PyArray_ArrFuncs</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDataType_GetArrFuncs"> <a class="reference internal" href="#c.PyArray_ArrFuncs" title="PyArray_ArrFuncs"><span class="n">PyArray_ArrFuncs</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyDataType_GetArrFuncs</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">dtype</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Fetch the legacy <code>PyArray_ArrFuncs</code> of the datatype (cannot fail).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version NumPy: </span>2.0 This function was added in a backwards compatible and backportable way in NumPy 2.0 (see <code>npy_2_compat.h</code>). Any code that previously accessed the <code>-&gt;f</code> slot of the <code>PyArray_Descr</code>, must now use this function and backport it to compile with 1.x. (The <code>npy_2_compat.h</code> header can be vendored for this purpose.)</p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_ArrFuncs</span></span><br>
</dt> <dd>
<p>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are <code>nonzero</code>, <code>copyswap</code>, <code>copyswapn</code>, <code>setitem</code>, <code>getitem</code>, and <code>cast</code>. These are assumed to be non- <code>NULL</code> and <code>NULL</code> entries will cause a program crash. The other functions may be <code>NULL</code> which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is <code>NULL</code> when you register a user-defined data-type).</p> <pre data-language="c">typedef struct {
    PyArray_VectorUnaryFunc *cast[NPY_NTYPES_LEGACY];
    PyArray_GetItemFunc *getitem;
    PyArray_SetItemFunc *setitem;
    PyArray_CopySwapNFunc *copyswapn;
    PyArray_CopySwapFunc *copyswap;
    PyArray_CompareFunc *compare;
    PyArray_ArgFunc *argmax;
    PyArray_DotFunc *dotfunc;
    PyArray_ScanFunc *scanfunc;
    PyArray_FromStrFunc *fromstr;
    PyArray_NonzeroFunc *nonzero;
    PyArray_FillFunc *fill;
    PyArray_FillWithScalarFunc *fillwithscalar;
    PyArray_SortFunc *sort[NPY_NSORTS];
    PyArray_ArgSortFunc *argsort[NPY_NSORTS];
    PyObject *castdict;
    PyArray_ScalarKindFunc *scalarkind;
    int **cancastscalarkindto;
    int *cancastto;
    void *_unused1;
    void *_unused2;
    void *_unused3;
    PyArray_ArgFunc *argmin;
} PyArray_ArrFuncs;
</pre> <p>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The <code>nonzero</code>, <code>copyswap</code>, <code>copyswapn</code>, <code>getitem</code>, and <code>setitem</code> functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The functions are largely legacy API, however, some are still used. As of NumPy 2.x they are only available via <code>PyDataType_GetArrFuncs</code> (see the function for more details). Before using any function defined in the struct you should check whether it is <code>NULL</code>. In general, the functions <code>getitem</code>, <code>setitem</code>, <code>copyswap</code>, and <code>copyswapn</code> can be expected to be defined, but all functions are expected to be replaced with newer API. For example, <code>PyArray_Pack</code> is a more powerful version of <code>setitem</code> that for example correctly deals with casts.</p> </div> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.cast"> <span class="kt">void</span><span class="sig-name descname"><span class="n">cast</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">from</span>, <span class="kt">void</span><span class="p">*</span><span class="n">to</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">n</span>, <span class="kt">void</span><span class="p">*</span><span class="n">fromarr</span>, <span class="kt">void</span><span class="p">*</span><span class="n">toarr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>An array of function pointers to cast from the current type to all of the other builtin types. Each function casts a contiguous, aligned, and notswapped buffer pointed at by <em>from</em> to a contiguous, aligned, and notswapped buffer pointed at by <em>to</em> The number of items to cast is given by <em>n</em>, and the arguments <em>fromarr</em> and <em>toarr</em> are interpreted as PyArrayObjects for flexible arrays to get itemsize information.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.getitem"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">getitem</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that returns a standard Python object from a single element of the array object <em>arr</em> pointed to by <em>data</em>. This function must be able to deal with “misbehaved “(misaligned and/or swapped) arrays correctly.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.setitem"> <span class="kt">int</span><span class="sig-name descname"><span class="n">setitem</span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">item</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that sets the Python object <em>item</em> into the array, <em>arr</em>, at the position pointed to by <em>data</em> . This function deals with “misbehaved” arrays. If successful, a zero is returned, otherwise, a negative one is returned (and a Python error set).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.copyswapn"> <span class="kt">void</span><span class="sig-name descname"><span class="n">copyswapn</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">dest</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">dstride</span>, <span class="kt">void</span><span class="p">*</span><span class="n">src</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">sstride</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">n</span>, <span class="kt">int</span><span class="n">swap</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.copyswap"> <span class="kt">void</span><span class="sig-name descname"><span class="n">copyswap</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">dest</span>, <span class="kt">void</span><span class="p">*</span><span class="n">src</span>, <span class="kt">int</span><span class="n">swap</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>These members are both pointers to functions to copy data from <em>src</em> to <em>dest</em> and <em>swap</em> if indicated. The value of arr is only used for flexible ( <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_STRING" title="NPY_TYPES.NPY_STRING"><code>NPY_STRING</code></a>, <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_UNICODE" title="NPY_TYPES.NPY_UNICODE"><code>NPY_UNICODE</code></a>, and <a class="reference internal" href="dtype.html#c.NPY_TYPES.NPY_VOID" title="NPY_TYPES.NPY_VOID"><code>NPY_VOID</code></a> ) arrays (and is obtained from <code>arr-&gt;descr-&gt;elsize</code> ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved <em>src</em> data. If <em>src</em> is NULL then no copy is performed. If <em>swap</em> is 0, then no byteswapping occurs. It is assumed that <em>dest</em> and <em>src</em> do not overlap. If they overlap, then use <code>memmove</code> (…) first followed by <code>copyswap(n)</code> with NULL valued <code>src</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.compare"> <span class="kt">int</span><span class="sig-name descname"><span class="n">compare</span></span><span class="sig-paren">(</span><span class="k">const</span><span class="kt">void</span><span class="p">*</span><span class="n">d1</span>, <span class="k">const</span><span class="kt">void</span><span class="p">*</span><span class="n">d2</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that compares two elements of the array, <code>arr</code>, pointed to by <code>d1</code> and <code>d2</code>. This function requires behaved (aligned and not swapped) arrays. The return value is 1 if * <code>d1</code> &gt; * <code>d2</code>, 0 if * <code>d1</code> == * <code>d2</code>, and -1 if * <code>d1</code> &lt; * <code>d2</code>. The array object <code>arr</code> is used to retrieve itemsize and field information for flexible arrays.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.argmax"> <span class="kt">int</span><span class="sig-name descname"><span class="n">argmax</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">n</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">max_ind</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that retrieves the index of the largest of <code>n</code> elements in <code>arr</code> beginning at the element pointed to by <code>data</code>. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the largest element is returned in <code>max_ind</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.dotfunc"> <span class="kt">void</span><span class="sig-name descname"><span class="n">dotfunc</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">ip1</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">is1</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ip2</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">is2</span>, <span class="kt">void</span><span class="p">*</span><span class="n">op</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">n</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that multiplies two <code>n</code> -length sequences together, adds them, and places the result in element pointed to by <code>op</code> of <code>arr</code>. The start of the two sequences are pointed to by <code>ip1</code> and <code>ip2</code>. To get to the next element in each sequence requires a jump of <code>is1</code> and <code>is2</code> <em>bytes</em>, respectively. This function requires behaved (though not necessarily contiguous) memory.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.scanfunc"> <span class="kt">int</span><span class="sig-name descname"><span class="n">scanfunc</span></span><span class="sig-paren">(</span><span class="n">FILE</span><span class="p">*</span><span class="n">fd</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ip</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that scans (scanf style) one element of the corresponding type from the file descriptor <code>fd</code> into the array memory pointed to by <code>ip</code>. The array is assumed to be behaved. The last argument <code>arr</code> is the array to be scanned into. Returns number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or EOF if input failure occurs before the first receiving argument was assigned. This function should be called without holding the Python GIL, and has to grab it for error reporting.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.fromstr"> <span class="kt">int</span><span class="sig-name descname"><span class="n">fromstr</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">str</span>, <span class="kt">void</span><span class="p">*</span><span class="n">ip</span>, <span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">endptr</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that converts the string pointed to by <code>str</code> to one element of the corresponding type and places it in the memory location pointed to by <code>ip</code>. After the conversion is completed, <code>*endptr</code> points to the rest of the string. The last argument <code>arr</code> is the array into which ip points (needed for variable-size data- types). Returns 0 on success or -1 on failure. Requires a behaved array. This function should be called without holding the Python GIL, and has to grab it for error reporting.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.nonzero"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">nonzero</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that returns TRUE if the item of <code>arr</code> pointed to by <code>data</code> is nonzero. This function can deal with misbehaved arrays.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.fill"> <span class="kt">void</span><span class="sig-name descname"><span class="n">fill</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">length</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that fills a contiguous array of given length with data. The first two elements of the array must already be filled- in. From these two values, a delta will be computed and the values from item 3 to the end will be computed by repeatedly adding this computed delta. The data buffer must be well-behaved.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.fillwithscalar"> <span class="kt">void</span><span class="sig-name descname"><span class="n">fillwithscalar</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">buffer</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">length</span>, <span class="kt">void</span><span class="p">*</span><span class="n">value</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that fills a contiguous <code>buffer</code> of the given <code>length</code> with a single scalar <code>value</code> whose address is given. The final argument is the array which is needed to get the itemsize for variable-length arrays.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.sort"> <span class="kt">int</span><span class="sig-name descname"><span class="n">sort</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">start</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">length</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far <a class="reference internal" href="array.html#c.NPY_SORTKIND.NPY_QUICKSORT" title="NPY_SORTKIND.NPY_QUICKSORT"><code>NPY_QUICKSORT</code></a>, <a class="reference internal" href="array.html#c.NPY_SORTKIND.NPY_HEAPSORT" title="NPY_SORTKIND.NPY_HEAPSORT"><code>NPY_HEAPSORT</code></a>, and <a class="reference internal" href="array.html#c.NPY_SORTKIND.NPY_MERGESORT" title="NPY_SORTKIND.NPY_MERGESORT"><code>NPY_MERGESORT</code></a> are defined). These sorts are done in-place assuming contiguous and aligned data.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.argsort"> <span class="kt">int</span><span class="sig-name descname"><span class="n">argsort</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">start</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">result</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">length</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>An array of function pointers to sorting algorithms for this data type. The same sorting algorithms as for sort are available. The indices producing the sort are returned in <code>result</code> (which must be initialized with indices 0 to <code>length-1</code> inclusive).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.castdict"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">castdict</span></span><br>
</dt> <dd>
<p>Either <code>NULL</code> or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a <span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.12)"><span class="n">PyCapsule</span></a><span class="p">*</span></span> and keyed by the data-type number.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.scalarkind"> <a class="reference internal" href="array.html#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><span class="n">NPY_SCALARKIND</span></a><span class="sig-name descname"><span class="n">scalarkind</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A function to determine how scalars of this type should be interpreted. The argument is <code>NULL</code> or a 0-dimensional array containing the data (if that is needed to determine the kind of scalar). The return value must be of type <a class="reference internal" href="array.html#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><code>NPY_SCALARKIND</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.cancastscalarkindto"> <span class="kt">int</span><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">cancastscalarkindto</span></span><br>
</dt> <dd>
<p>Either <code>NULL</code> or an array of <a class="reference internal" href="array.html#c.NPY_SCALARKIND.NPY_NSCALARKINDS" title="NPY_SCALARKIND.NPY_NSCALARKINDS"><code>NPY_NSCALARKINDS</code></a> pointers. These pointers should each be either <code>NULL</code> or a pointer to an array of integers (terminated by <a class="reference internal" href="dtype.html#c.NPY_NOTYPE" title="NPY_NOTYPE"><code>NPY_NOTYPE</code></a>) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.cancastto"> <span class="kt">int</span><span class="p">*</span><span class="sig-name descname"><span class="n">cancastto</span></span><br>
</dt> <dd>
<p>Either <code>NULL</code> or an array of integers (terminated by <a class="reference internal" href="dtype.html#c.NPY_NOTYPE" title="NPY_NOTYPE"><code>NPY_NOTYPE</code></a> ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_ArrFuncs.argmin"> <span class="kt">int</span><span class="sig-name descname"><span class="n">argmin</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="p">*</span><span class="n">data</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="n">n</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">min_ind</span>, <span class="kt">void</span><span class="p">*</span><span class="n">arr</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A pointer to a function that retrieves the index of the smallest of <code>n</code> elements in <code>arr</code> beginning at the element pointed to by <code>data</code>. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the smallest element is returned in <code>min_ind</code>.</p> </dd>
</dl> </dd>
</dl> </section> <section id="pyarraymethod-context-and-pyarraymethod-spec"> <h3 id="arraymethod-structs">PyArrayMethod_Context and PyArrayMethod_Spec</h3> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethodObject_tag"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayMethodObject_tag</span></span><br>
</dt> <dd>
<p>An opaque struct used to represent the method “self” in ArrayMethod loops.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_Context"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayMethod_Context</span></span><br>
</dt> <dd>
<p>A struct that is passed in to ArrayMethod loops to provide context for the runtime usage of the loop.</p> <pre data-language="c">typedef struct {
    PyObject *caller;
    struct PyArrayMethodObject_tag *method;
    PyArray_Descr *const *descriptors;
} PyArrayMethod_Context
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Context.caller"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">caller</span></span><br>
</dt> <dd>
<p>The caller, which is typically the ufunc that called the loop. May be <code>NULL</code> when a call is not from a ufunc (e.g. casts).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Context.method"> <span class="k">struct</span><a class="reference internal" href="#c.PyArrayMethodObject_tag" title="PyArrayMethodObject_tag"><span class="n">PyArrayMethodObject_tag</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">method</span></span><br>
</dt> <dd>
<p>The method “self”. Currently this object is an opaque pointer.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Context.descriptors"> <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">descriptors</span></span><br>
</dt> <dd>
<p>An array of descriptors for the ufunc loop, filled in by <code>resolve_descriptors</code>. The length of the array is <code>nin</code> + <code>nout</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayMethod_Spec</span></span><br>
</dt> <dd>
<p>A struct used to register an ArrayMethod with NumPy. We use the slots mechanism used by the Python limited API. See below for the slot definitions.</p> <pre data-language="c">typedef struct {
   const char *name;
   int nin, nout;
   NPY_CASTING casting;
   NPY_ARRAYMETHOD_FLAGS flags;
   PyArray_DTypeMeta **dtypes;
   PyType_Slot *slots;
} PyArrayMethod_Spec;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.name"> <span class="k">const</span><span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">name</span></span><br>
</dt> <dd>
<p>The name of the loop.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.nin"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nin</span></span><br>
</dt> <dd>
<p>The number of input operands</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.nout"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nout</span></span><br>
</dt> <dd>
<p>The number of output operands.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.casting"> <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING"><span class="n">NPY_CASTING</span></a><span class="sig-name descname"><span class="n">casting</span></span><br>
</dt> <dd>
<p>Used to indicate how minimally permissive a casting operation should be. For example, if a cast operation might in some circumstances be safe, but in others unsafe, then <code>NPY_UNSAFE_CASTING</code> should be set. Not used for ufunc loops but must still be set.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.flags"> <a class="reference internal" href="array.html#c.NPY_ARRAYMETHOD_FLAGS" title="NPY_ARRAYMETHOD_FLAGS"><span class="n">NPY_ARRAYMETHOD_FLAGS</span></a><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>The flags set for the method.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.dtypes"> <a class="reference internal" href="#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><span class="n">PyArray_DTypeMeta</span></a><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">dtypes</span></span><br>
</dt> <dd>
<p>The DTypes for the loop. Must be <code>nin</code> + <code>nout</code> in length.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMethod_Spec.slots"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Slot" title="(in Python v3.12)"><span class="n">PyType_Slot</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">slots</span></span><br>
</dt> <dd>
<p>An array of slots for the method. Slot IDs must be one of the values below.</p> </dd>
</dl> </dd>
</dl> </section> <section id="pyarray-dtypemeta-and-pyarraydtypemeta-spec"> <h3 id="dtypemeta">PyArray_DTypeMeta and PyArrayDTypeMeta_Spec</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_Type</span></span><br>
</dt> <dd>
<p>The python type object corresponding to <a class="reference internal" href="#c.PyArray_DTypeMeta" title="PyArray_DTypeMeta"><code>PyArray_DTypeMeta</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_DTypeMeta</span></span><br>
</dt> <dd>
<p>A largely opaque struct representing DType classes. Each instance defines a metaclass for a single NumPy data type. Data types can either be non-parametric or parametric. For non-parametric types, the DType class has a one-to-one correspondence with the descriptor instance created from the DType class. Parametric types can correspond to many different dtype instances depending on the chosen parameters. This type is available in the public <code>numpy/dtype_api.h</code> header. Currently use of this struct is not supported in the limited CPython API, so if <code>Py_LIMITED_API</code> is set, this type is a typedef for <code>PyTypeObject</code>.</p> <pre data-language="c">typedef struct {
     PyHeapTypeObject super;
     PyArray_Descr *singleton;
     int type_num;
     PyTypeObject *scalar_type;
     npy_uint64 flags;
     void *dt_slots;
     void *reserved[3];
} PyArray_DTypeMeta
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.super"> <span class="n">PyHeapTypeObject</span><span class="sig-name descname"><span class="n">super</span></span><br>
</dt> <dd>
<p>The superclass, providing hooks into the python object API. Set members of this struct to fill in the functions implementing the <code>PyTypeObject</code> API (e.g. <code>tp_new</code>).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.singleton"> <a class="reference internal" href="#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">singleton</span></span><br>
</dt> <dd>
<p>A descriptor instance suitable for use as a singleton descriptor for the data type. This is useful for non-parametric types representing simple plain old data type where there is only one logical descriptor instance for all data of the type. Can be NULL if a singleton instance is not appropriate.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.type_num"> <span class="kt">int</span><span class="sig-name descname"><span class="n">type_num</span></span><br>
</dt> <dd>
<p>Corresponds to the type number for legacy data types. Data types defined outside of NumPy and possibly future data types shipped with NumPy will have <code>type_num</code> set to -1, so this should not be relied on to discriminate between data types.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.scalar_type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">scalar_type</span></span><br>
</dt> <dd>
<p>The type of scalar instances for this data type.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.flags"> <a class="reference internal" href="dtype.html#c.npy_uint64" title="npy_uint64"><span class="n">npy_uint64</span></a><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>Flags can be set to indicate to NumPy that this data type has optional behavior. See <a class="reference internal" href="array.html#dtype-flags"><span class="std std-ref">Flags</span></a> for a listing of allowed flag values.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_DTypeMeta.dt_slots"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">dt_slots</span></span><br>
</dt> <dd>
<p>An opaque pointer to a private struct containing implementations of functions in the DType API. This is filled in from the <code>slots</code> member of the <code>PyArrayDTypeMeta_Spec</code> instance used to initialize the DType.</p> </dd>
</dl> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Spec"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayDTypeMeta_Spec</span></span><br>
</dt> <dd>
<p>A struct used to initialize a new DType with the <code>PyArrayInitDTypeMeta_FromSpec</code> function.</p> <pre data-language="c">typedef struct {
    PyTypeObject *typeobj;
    int flags;
    PyArrayMethod_Spec **casts;
    PyType_Slot *slots;
    PyTypeObject *baseclass;
}
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Spec.typeobj"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">typeobj</span></span><br>
</dt> <dd>
<p>Either <code>NULL</code> or the type of the python scalar associated with the DType. Scalar indexing into an array returns an item with this type.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Spec.flags"> <span class="kt">int</span><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>Static flags for the DType class, indicating whether the DType is parametric, abstract, or represents numeric data. The latter is optional but is useful to set to indicate to downstream code if the DType represents data that are numbers (ints, floats, or other numeric data type) or something else (e.g. a string, unit, or date).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Spec.casts"> <a class="reference internal" href="#c.PyArrayMethod_Spec" title="PyArrayMethod_Spec"><span class="n">PyArrayMethod_Spec</span></a><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">casts</span></span><span class="p">;</span><br>
</dt> <dd>
<p>A <code>NULL</code>-terminated array of ArrayMethod specifications for casts defined by the DType.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayDTypeMeta_Spec.slots"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Slot" title="(in Python v3.12)"><span class="n">PyType_Slot</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">slots</span></span><span class="p">;</span><br>
</dt> <dd>
<p>A <code>NULL</code>-terminated array of slot specifications for implementations of functions in the DType API. Slot IDs must be one of the DType slot IDs enumerated in <a class="reference internal" href="array.html#dtype-slots"><span class="std std-ref">Slot IDs and API Function Typedefs</span></a>.</p> </dd>
</dl> </dd>
</dl> </section> <section id="exposed-dtypes-classes-pyarray-dtypemeta-objects"> <h3>Exposed DTypes classes (<code>PyArray_DTypeMeta</code> objects)</h3> <p>For use with promoters, NumPy exposes a number of Dtypes following the pattern <code>PyArray_&lt;Name&gt;DType</code> corresponding to those found in <code>np.dtypes</code>.</p> <p>Additionally, the three DTypes, <code>PyArray_PyLongDType</code>, <code>PyArray_PyFloatDType</code>, <code>PyArray_PyComplexDType</code> correspond to the Python scalar values. These cannot be used in all places, but do allow for example the common dtype operation and implementing promotion with them may be necessary.</p> <p>Further, the following abstract DTypes are defined which cover both the builtin NumPy ones and the python ones, and users can in principle subclass from them (this does not inherit any DType specific functionality): * <code>PyArray_IntAbstractDType</code> * <code>PyArray_FloatAbstractDType</code> * <code>PyArray_ComplexAbstractDType</code></p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As of NumPy 2.0, the <em>only</em> valid use for these DTypes is registering a promoter conveniently to e.g. match “any integers” (and subclass checks). Because of this, they are not exposed to Python.</p> </div> </section> <section id="pyufunc-type-and-pyufuncobject"> <h3>PyUFunc_Type and PyUFuncObject</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyUFunc_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyUFunc_Type</span></span><br>
</dt> <dd>
<p>The ufunc object is implemented by creation of the <a class="reference internal" href="#c.PyUFunc_Type" title="PyUFunc_Type"><code>PyUFunc_Type</code></a>. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (<em>e.g.</em> atanh).</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyUFuncObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyUFuncObject</span></span><br>
</dt> <dd>
<p>The core of the ufunc is the <a class="reference internal" href="#c.PyUFuncObject" title="PyUFuncObject"><code>PyUFuncObject</code></a> which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via <code>PyUFunc_*</code> functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</p> <ul class="simple"> <li>Never declare a non-pointer instance of the struct</li> <li>Never perform pointer arithmetic</li> <li>Never use <code>sizeof(PyUFuncObject)</code>
</li> </ul> <p>It has the following structure:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    int nin;
    int nout;
    int nargs;
    int identity;
    PyUFuncGenericFunction *functions;
    void **data;
    int ntypes;
    int reserved1;
    const char *name;
    char *types;
    const char *doc;
    void *ptr;
    PyObject *obj;
    PyObject *userloops;
    int core_enabled;
    int core_num_dim_ix;
    int *core_num_dims;
    int *core_dim_ixs;
    int *core_offsets;
    char *core_signature;
    PyUFunc_TypeResolutionFunc *type_resolver;
    void *reserved2;
    void *reserved3;
    npy_uint32 *op_flags;
    npy_uint32 *iter_flags;
    /* new in API version 0x0000000D */
    npy_intp *core_dim_sizes;
    npy_uint32 *core_dim_flags;
    PyObject *identity_value;
    /* Further private slots (size depends on the NumPy version) */
} PyUFuncObject;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.nin"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nin</span></span><br>
</dt> <dd>
<p>The number of input arguments.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.nout"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nout</span></span><br>
</dt> <dd>
<p>The number of output arguments.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.nargs"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nargs</span></span><br>
</dt> <dd>
<p>The total number of arguments (<em>nin</em> + <em>nout</em>). This must be less than <a class="reference internal" href="array.html#c.NPY_MAXARGS" title="NPY_MAXARGS"><code>NPY_MAXARGS</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.identity"> <span class="kt">int</span><span class="sig-name descname"><span class="n">identity</span></span><br>
</dt> <dd>
<p>Either <a class="reference internal" href="ufunc.html#c.PyUFunc_One" title="PyUFunc_One"><code>PyUFunc_One</code></a>, <a class="reference internal" href="ufunc.html#c.PyUFunc_Zero" title="PyUFunc_Zero"><code>PyUFunc_Zero</code></a>, <a class="reference internal" href="ufunc.html#c.PyUFunc_MinusOne" title="PyUFunc_MinusOne"><code>PyUFunc_MinusOne</code></a>, <a class="reference internal" href="ufunc.html#c.PyUFunc_None" title="PyUFunc_None"><code>PyUFunc_None</code></a>, <a class="reference internal" href="ufunc.html#c.PyUFunc_ReorderableNone" title="PyUFunc_ReorderableNone"><code>PyUFunc_ReorderableNone</code></a>, or <a class="reference internal" href="ufunc.html#c.PyUFunc_IdentityValue" title="PyUFunc_IdentityValue"><code>PyUFunc_IdentityValue</code></a> to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.functions"> <span class="kt">void</span><span class="sig-name descname"><span class="n">functions</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">dims</span>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">extradata</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>An array of function pointers — one for each data type supported by the ufunc. This is the vector loop that is called to implement the underlying function <em>dims</em> [0] times. The first argument, <em>args</em>, is an array of <em>nargs</em> pointers to behaved memory. Pointers to the data for the input arguments are first, followed by the pointers to the data for the output arguments. How many bytes must be skipped to get to the next element in the sequence is specified by the corresponding entry in the <em>steps</em> array. The last argument allows the loop to receive extra information. This is commonly used so that a single, generic vector loop can be used for multiple functions. In this case, the actual scalar function to call is passed in as <em>extradata</em>. The size of this function pointer array is ntypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.data"> <span class="kt">void</span><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">data</span></span><br>
</dt> <dd>
<p>Extra data to be passed to the 1-d vector loops or <code>NULL</code> if no extra-data is needed. This C-array must be the same size ( <em>i.e.</em> ntypes) as the functions array. <code>NULL</code> is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.ntypes"> <span class="kt">int</span><span class="sig-name descname"><span class="n">ntypes</span></span><br>
</dt> <dd>
<p>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.name"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">name</span></span><br>
</dt> <dd>
<p>A string name for the ufunc. This is used dynamically to build the __doc__ attribute of ufuncs.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.types"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">types</span></span><br>
</dt> <dd>
<p>An array of <span class="math notranslate nohighlight">\(nargs \times ntypes\)</span> 8-bit type_numbers which contains the type signature for the function for each of the supported (builtin) data types. For each of the <em>ntypes</em> functions, the corresponding set of type numbers in this array shows how the <em>args</em> argument should be interpreted in the 1-d vector loop. These type numbers do not have to be the same type and mixed-type ufuncs are supported.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.doc"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">doc</span></span><br>
</dt> <dd>
<p>Documentation for the ufunc. Should not contain the function signature as this is generated dynamically when __doc__ is retrieved.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.ptr"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">ptr</span></span><br>
</dt> <dd>
<p>Any dynamically allocated memory. Currently, this is used for dynamic ufuncs created from a python function to store room for the types, data, and name members.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.obj"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">obj</span></span><br>
</dt> <dd>
<p>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.userloops"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">userloops</span></span><br>
</dt> <dd>
<p>A dictionary of user-defined 1-d vector loops (stored as CObject ptrs) for user-defined types. A loop may be registered by the user for any user-defined type. It is retrieved by type number. User defined type numbers are always larger than <a class="reference internal" href="dtype.html#c.NPY_USERDEF" title="NPY_USERDEF"><code>NPY_USERDEF</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_enabled"> <span class="kt">int</span><span class="sig-name descname"><span class="n">core_enabled</span></span><br>
</dt> <dd>
<p>0 for scalar ufuncs; 1 for generalized ufuncs</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_num_dim_ix"> <span class="kt">int</span><span class="sig-name descname"><span class="n">core_num_dim_ix</span></span><br>
</dt> <dd>
<p>Number of distinct core dimension names in the signature</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_num_dims"> <span class="kt">int</span><span class="p">*</span><span class="sig-name descname"><span class="n">core_num_dims</span></span><br>
</dt> <dd>
<p>Number of core dimensions of each argument</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_dim_ixs"> <span class="kt">int</span><span class="p">*</span><span class="sig-name descname"><span class="n">core_dim_ixs</span></span><br>
</dt> <dd>
<p>Dimension indices in a flattened form; indices of argument <code>k</code> are stored in <code>core_dim_ixs[core_offsets[k] : core_offsets[k] +
core_numdims[k]]</code></p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_offsets"> <span class="kt">int</span><span class="p">*</span><span class="sig-name descname"><span class="n">core_offsets</span></span><br>
</dt> <dd>
<p>Position of 1st core dimension of each argument in <code>core_dim_ixs</code>, equivalent to cumsum(<code>core_num_dims</code>)</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_signature"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">core_signature</span></span><br>
</dt> <dd>
<p>Core signature string</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.type_resolver"> <a class="reference internal" href="#c.PyUFuncObject.type_resolver.PyUFunc_TypeResolutionFunc" title="PyUFunc_TypeResolutionFunc"><span class="n">PyUFunc_TypeResolutionFunc</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">type_resolver</span></span><br>
</dt> <dd>
<p>A function which resolves the types and fills an array with the dtypes for the inputs and outputs</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyUFuncObject.type_resolver.PyUFunc_TypeResolutionFunc"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyUFunc_TypeResolutionFunc</span></span><br>
</dt> <dd>
<p>The function pointer type for <a class="reference internal" href="#c.PyUFuncObject.type_resolver" title="type_resolver"><code>type_resolver</code></a></p> </dd>
</dl> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.op_flags"> <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32"><span class="n">npy_uint32</span></a><span class="sig-name descname"><span class="n">op_flags</span></span><br>
</dt> <dd>
<p>Override the default operand flags for each ufunc operand.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.iter_flags"> <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32"><span class="n">npy_uint32</span></a><span class="sig-name descname"><span class="n">iter_flags</span></span><br>
</dt> <dd>
<p>Override the default nditer flags for the ufunc.</p> </dd>
</dl> <p>Added in API version 0x0000000D</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_dim_sizes"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">core_dim_sizes</span></span><br>
</dt> <dd>
<p>For each distinct core dimension, the possible <a class="reference internal" href="generalized-ufuncs.html#frozen"><span class="std std-ref">frozen</span></a> size if <a class="reference internal" href="#c.UFUNC_CORE_DIM_SIZE_INFERRED" title="UFUNC_CORE_DIM_SIZE_INFERRED"><code>UFUNC_CORE_DIM_SIZE_INFERRED</code></a> is <code>0</code></p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.core_dim_flags"> <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32"><span class="n">npy_uint32</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">core_dim_flags</span></span><br>
</dt> <dd>
<p>For each distinct core dimension, a set of flags ( <a class="reference internal" href="#c.UFUNC_CORE_DIM_CAN_IGNORE" title="UFUNC_CORE_DIM_CAN_IGNORE"><code>UFUNC_CORE_DIM_CAN_IGNORE</code></a> and <a class="reference internal" href="#c.UFUNC_CORE_DIM_SIZE_INFERRED" title="UFUNC_CORE_DIM_SIZE_INFERRED"><code>UFUNC_CORE_DIM_SIZE_INFERRED</code></a>)</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyUFuncObject.identity_value"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">identity_value</span></span><br>
</dt> <dd>
<p>Identity for reduction, when <a class="reference internal" href="#c.PyUFuncObject.identity" title="PyUFuncObject.identity"><code>PyUFuncObject.identity</code></a> is equal to <a class="reference internal" href="ufunc.html#c.PyUFunc_IdentityValue" title="PyUFunc_IdentityValue"><code>PyUFunc_IdentityValue</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_CORE_DIM_CAN_IGNORE"> <span class="sig-name descname"><span class="n">UFUNC_CORE_DIM_CAN_IGNORE</span></span><br>
</dt> <dd>
<p>if the dim name ends in <code>?</code></p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_CORE_DIM_SIZE_INFERRED"> <span class="sig-name descname"><span class="n">UFUNC_CORE_DIM_SIZE_INFERRED</span></span><br>
</dt> <dd>
<p>if the dim size will be determined from the operands and not from a <a class="reference internal" href="generalized-ufuncs.html#frozen"><span class="std std-ref">frozen</span></a> signature</p> </dd>
</dl> </section> <section id="pyarrayiter-type-and-pyarrayiterobject"> <h3>PyArrayIter_Type and PyArrayIterObject</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayIter_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayIter_Type</span></span><br>
</dt> <dd>
<p>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayIterObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayIterObject</span></span><br>
</dt> <dd>
<p>The C-structure corresponding to an object of <a class="reference internal" href="#c.PyArrayIter_Type" title="PyArrayIter_Type"><code>PyArrayIter_Type</code></a> is the <a class="reference internal" href="#c.PyArrayIterObject" title="PyArrayIterObject"><code>PyArrayIterObject</code></a>. The <a class="reference internal" href="#c.PyArrayIterObject" title="PyArrayIterObject"><code>PyArrayIterObject</code></a> is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the “next” position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the <a class="reference internal" href="#c.PyArrayIterObject" title="PyArrayIterObject"><code>PyArrayIterObject</code></a> structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for “broadcasting,” or to loop over only specific dimensions.</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    int   nd_m1;
    npy_intp  index;
    npy_intp  size;
    npy_intp  coordinates[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp  dims_m1[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp  strides[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp  backstrides[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp  factors[NPY_MAXDIMS_LEGACY_ITERS];
    PyArrayObject *ao;
    char  *dataptr;
    npy_bool  contiguous;
} PyArrayIterObject;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.nd_m1"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nd_m1</span></span><br>
</dt> <dd>
<p><span class="math notranslate nohighlight">\(N-1\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of dimensions in the underlying array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.index"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">index</span></span><br>
</dt> <dd>
<p>The current 1-d index into the array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.size"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">size</span></span><br>
</dt> <dd>
<p>The total size of the underlying array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.coordinates"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">coordinates</span></span><br>
</dt> <dd>
<p>An <span class="math notranslate nohighlight">\(N\)</span> -dimensional index into the array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.dims_m1"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">dims_m1</span></span><br>
</dt> <dd>
<p>The size of the array minus 1 in each dimension.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.strides"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">strides</span></span><br>
</dt> <dd>
<p>The strides of the array. How many bytes needed to jump to the next element in each dimension.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.backstrides"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">backstrides</span></span><br>
</dt> <dd>
<p>How many bytes needed to jump from the end of a dimension back to its beginning. Note that <code>backstrides[k] == strides[k] *
dims_m1[k]</code>, but it is stored here as an optimization.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.factors"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">factors</span></span><br>
</dt> <dd>
<p>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.ao"> <a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">ao</span></span><br>
</dt> <dd>
<p>A pointer to the underlying ndarray this iterator was created to represent.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.dataptr"> <span class="kt">char</span><span class="p">*</span><span class="sig-name descname"><span class="n">dataptr</span></span><br>
</dt> <dd>
<p>This member points to an element in the ndarray indicated by the index.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayIterObject.contiguous"> <a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool"><span class="n">npy_bool</span></a><span class="sig-name descname"><span class="n">contiguous</span></span><br>
</dt> <dd>
<p>This flag is true if the underlying array is <a class="reference internal" href="array.html#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>. It is used to simplify calculations when possible.</p> </dd>
</dl> </dd>
</dl> <p>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros <a class="reference internal" href="array.html#c.PyArray_ITER_NEXT" title="PyArray_ITER_NEXT"><code>PyArray_ITER_NEXT</code></a> (it), <a class="reference internal" href="array.html#c.PyArray_ITER_GOTO" title="PyArray_ITER_GOTO"><code>PyArray_ITER_GOTO</code></a> (it, dest), or <a class="reference internal" href="array.html#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code>PyArray_ITER_GOTO1D</code></a> (it, index). All of these macros require the argument <em>it</em> to be a <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyArrayIterObject" title="PyArrayIterObject"><span class="n">PyArrayIterObject</span></a><span class="p">*</span></span>.</p> </section> <section id="pyarraymultiiter-type-and-pyarraymultiiterobject"> <h3>PyArrayMultiIter_Type and PyArrayMultiIterObject</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayMultiIter_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayMultiIter_Type</span></span><br>
</dt> <dd>
<p>This type provides an iterator that encapsulates the concept of broadcasting. It allows <span class="math notranslate nohighlight">\(N\)</span> arrays to be broadcast together so that the loop progresses in C-style contiguous fashion over the broadcasted array. The corresponding C-structure is the <a class="reference internal" href="#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><code>PyArrayMultiIterObject</code></a> whose memory layout must begin any object, <em>obj</em>, passed in to the <a class="reference internal" href="array.html#c.PyArray_Broadcast" title="PyArray_Broadcast"><code>PyArray_Broadcast</code></a> (obj) function. Broadcasting is performed by adjusting array iterators so that each iterator represents the broadcasted shape and size, but has its strides adjusted so that the correct element from the array is used at each iteration.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayMultiIterObject</span></span><br>
</dt> <dd>
<pre data-language="c">typedef struct {
    PyObject_HEAD
    int numiter;
    npy_intp size;
    npy_intp index;
    int nd;
    npy_intp dimensions[NPY_MAXDIMS_LEGACY_ITERS];
    PyArrayIterObject *iters[];
} PyArrayMultiIterObject;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.numiter"> <span class="kt">int</span><span class="sig-name descname"><span class="n">numiter</span></span><br>
</dt> <dd>
<p>The number of arrays that need to be broadcast to the same shape.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.size"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">size</span></span><br>
</dt> <dd>
<p>The total broadcasted size.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.index"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">index</span></span><br>
</dt> <dd>
<p>The current (1-d) index into the broadcasted result.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.nd"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nd</span></span><br>
</dt> <dd>
<p>The number of dimensions in the broadcasted result.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.dimensions"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">dimensions</span></span><br>
</dt> <dd>
<p>The shape of the broadcasted result (only <code>nd</code> slots are used).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayMultiIterObject.iters"> <a class="reference internal" href="#c.PyArrayIterObject" title="PyArrayIterObject"><span class="n">PyArrayIterObject</span></a><span class="p">*</span><span class="p">*</span><span class="sig-name descname"><span class="n">iters</span></span><br>
</dt> <dd>
<p>An array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</p> </dd>
</dl> </dd>
</dl> </section> <section id="pyarrayneighborhooditer-type-and-pyarrayneighborhooditerobject"> <h3>PyArrayNeighborhoodIter_Type and PyArrayNeighborhoodIterObject</h3> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayNeighborhoodIter_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayNeighborhoodIter_Type</span></span><br>
</dt> <dd>
<p>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayNeighborhoodIterObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayNeighborhoodIterObject</span></span><br>
</dt> <dd>
<p>The C-structure corresponding to an object of <a class="reference internal" href="#c.PyArrayNeighborhoodIter_Type" title="PyArrayNeighborhoodIter_Type"><code>PyArrayNeighborhoodIter_Type</code></a> is the <a class="reference internal" href="#c.PyArrayNeighborhoodIterObject" title="PyArrayNeighborhoodIterObject"><code>PyArrayNeighborhoodIterObject</code></a>.</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    int nd_m1;
    npy_intp index, size;
    npy_intp coordinates[NPY_MAXDIMS_LEGACY_ITERS]
    npy_intp dims_m1[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp strides[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp backstrides[NPY_MAXDIMS_LEGACY_ITERS];
    npy_intp factors[NPY_MAXDIMS_LEGACY_ITERS];
    PyArrayObject *ao;
    char *dataptr;
    npy_bool contiguous;
    npy_intp bounds[NPY_MAXDIMS_LEGACY_ITERS][2];
    npy_intp limits[NPY_MAXDIMS_LEGACY_ITERS][2];
    npy_intp limits_sizes[NPY_MAXDIMS_LEGACY_ITERS];
    npy_iter_get_dataptr_t translate;
    npy_intp nd;
    npy_intp dimensions[NPY_MAXDIMS_LEGACY_ITERS];
    PyArrayIterObject* _internal_iter;
    char* constant;
    int mode;
} PyArrayNeighborhoodIterObject;
</pre> </dd>
</dl> </section> <section id="scalararraytypes"> <h3>ScalarArrayTypes</h3> <p>There is a Python type for each of the different built-in data types that can be present in the array. Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are <code>Py{TYPE}ArrType_Type</code> where <code>{TYPE}</code> can be</p>  <p><strong>Bool</strong>, <strong>Byte</strong>, <strong>Short</strong>, <strong>Int</strong>, <strong>Long</strong>, <strong>LongLong</strong>, <strong>UByte</strong>, <strong>UShort</strong>, <strong>UInt</strong>, <strong>ULong</strong>, <strong>ULongLong</strong>, <strong>Half</strong>, <strong>Float</strong>, <strong>Double</strong>, <strong>LongDouble</strong>, <strong>CFloat</strong>, <strong>CDouble</strong>, <strong>CLongDouble</strong>, <strong>String</strong>, <strong>Unicode</strong>, <strong>Void</strong>, <strong>Datetime</strong>, <strong>Timedelta</strong>, and <strong>Object</strong>.</p>  <p>These type names are part of the C-API and can therefore be created in extension C-code. There is also a <code>PyIntpArrType_Type</code> and a <code>PyUIntpArrType_Type</code> that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function <a class="reference internal" href="array.html#c.PyArray_ScalarAsCtype" title="PyArray_ScalarAsCtype"><code>PyArray_ScalarAsCtype</code></a> (..) can be used to extract the C-type value from the array scalar and the function <a class="reference internal" href="array.html#c.PyArray_Scalar" title="PyArray_Scalar"><code>PyArray_Scalar</code></a> (…) can be used to construct an array scalar from a C-value.</p> </section> </section> <section id="other-c-structures"> <h2>Other C-structures</h2> <p>A few new C-structures were found to be useful in the development of NumPy. These C-structures are used in at least one C-API call and are therefore documented here. The main reason these structures were defined is to make it easy to use the Python ParseTuple C-API to convert from Python objects to a useful C-Object.</p> <section id="pyarray-dims"> <h3>PyArray_Dims</h3> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_Dims"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_Dims</span></span><br>
</dt> <dd>
<p>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</p> <pre data-language="c">typedef struct {
    npy_intp *ptr;
    int len;
} PyArray_Dims;
</pre> <p>The members of this structure are</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Dims.ptr"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">ptr</span></span><br>
</dt> <dd>
<p>A pointer to a list of (<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><code>npy_intp</code></a>) integers which usually represent array shape or array strides.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Dims.len"> <span class="kt">int</span><span class="sig-name descname"><span class="n">len</span></span><br>
</dt> <dd>
<p>The length of the list of integers. It is assumed safe to access <em>ptr</em> [0] to <em>ptr</em> [len-1].</p> </dd>
</dl> </dd>
</dl> </section> <section id="pyarray-chunk"> <h3>PyArray_Chunk</h3> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArray_Chunk"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArray_Chunk</span></span><br>
</dt> <dd>
<p>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (<em>i.e.</em> if <a class="reference internal" href="config.html#c.NPY_SIZEOF_INT" title="NPY_SIZEOF_INT"><code>NPY_SIZEOF_INT</code></a> == <a class="reference internal" href="config.html#c.NPY_SIZEOF_INTP" title="NPY_SIZEOF_INTP"><code>NPY_SIZEOF_INTP</code></a>), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    PyObject *base;
    void *ptr;
    npy_intp len;
    int flags;
} PyArray_Chunk;
</pre> <p>The members are</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Chunk.base"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">base</span></span><br>
</dt> <dd>
<p>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Chunk.ptr"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">ptr</span></span><br>
</dt> <dd>
<p>A pointer to the start of the single-segment chunk of memory.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Chunk.len"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="sig-name descname"><span class="n">len</span></span><br>
</dt> <dd>
<p>The length of the segment in bytes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArray_Chunk.flags"> <span class="kt">int</span><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>Any data flags (<em>e.g.</em> <a class="reference internal" href="array.html#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> ) that should be used to interpret the memory.</p> </dd>
</dl> </dd>
</dl> </section> <section id="pyarrayinterface"> <h3>PyArrayInterface</h3> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../arrays.interface.html#arrays-interface"><span class="std std-ref">The array interface protocol</span></a></p> </div> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayInterface"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayInterface</span></span><br>
</dt> <dd>
<p>The <a class="reference internal" href="#c.PyArrayInterface" title="PyArrayInterface"><code>PyArrayInterface</code></a> structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The <a class="reference internal" href="../arrays.interface.html#object.__array_struct__" title="object.__array_struct__"><code>__array_struct__</code></a> method of an object that supports the rapid array interface protocol should return a <a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.12)"><code>PyCapsule</code></a> that contains a pointer to a <a class="reference internal" href="#c.PyArrayInterface" title="PyArrayInterface"><code>PyArrayInterface</code></a> structure with the relevant details of the array. After the new array is created, the attribute should be <code>DECREF</code>’d which will free the <a class="reference internal" href="#c.PyArrayInterface" title="PyArrayInterface"><code>PyArrayInterface</code></a> structure. Remember to <code>INCREF</code> the object (whose <a class="reference internal" href="../arrays.interface.html#object.__array_struct__" title="object.__array_struct__"><code>__array_struct__</code></a> attribute was retrieved) and point the base member of the new <a class="reference internal" href="#c.PyArrayObject" title="PyArrayObject"><code>PyArrayObject</code></a> to this same object. In this way the memory for the array will be managed correctly.</p> <pre data-language="c">typedef struct {
    int two;
    int nd;
    char typekind;
    int itemsize;
    int flags;
    npy_intp *shape;
    npy_intp *strides;
    void *data;
    PyObject *descr;
} PyArrayInterface;
</pre> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.two"> <span class="kt">int</span><span class="sig-name descname"><span class="n">two</span></span><br>
</dt> <dd>
<p>the integer 2 as a sanity check.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.nd"> <span class="kt">int</span><span class="sig-name descname"><span class="n">nd</span></span><br>
</dt> <dd>
<p>the number of dimensions in the array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.typekind"> <span class="kt">char</span><span class="sig-name descname"><span class="n">typekind</span></span><br>
</dt> <dd>
<p>A character indicating what kind of array is present according to the typestring convention with ‘t’ -&gt; bitfield, ‘b’ -&gt; Boolean, ‘i’ -&gt; signed integer, ‘u’ -&gt; unsigned integer, ‘f’ -&gt; floating point, ‘c’ -&gt; complex floating point, ‘O’ -&gt; object, ‘S’ -&gt; (byte-)string, ‘U’ -&gt; unicode, ‘V’ -&gt; void.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.itemsize"> <span class="kt">int</span><span class="sig-name descname"><span class="n">itemsize</span></span><br>
</dt> <dd>
<p>The number of bytes each item in the array requires.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.flags"> <span class="kt">int</span><span class="sig-name descname"><span class="n">flags</span></span><br>
</dt> <dd>
<p>Any of the bits <a class="reference internal" href="array.html#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a> (1), <a class="reference internal" href="array.html#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> (2), <a class="reference internal" href="array.html#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a> (0x100), <a class="reference internal" href="array.html#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code>NPY_ARRAY_NOTSWAPPED</code></a> (0x200), or <a class="reference internal" href="array.html#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code>NPY_ARRAY_WRITEABLE</code></a> (0x400) to indicate something about the data. The <a class="reference internal" href="array.html#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code>NPY_ARRAY_ALIGNED</code></a>, <a class="reference internal" href="array.html#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code>NPY_ARRAY_C_CONTIGUOUS</code></a>, and <a class="reference internal" href="array.html#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code>NPY_ARRAY_F_CONTIGUOUS</code></a> flags can actually be determined from the other parameters. The flag <a class="reference internal" href="../arrays.interface.html#c.NPY_ARR_HAS_DESCR" title="NPY_ARR_HAS_DESCR"><code>NPY_ARR_HAS_DESCR</code></a> (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.shape"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">shape</span></span><br>
</dt> <dd>
<p>An array containing the size of the array in each dimension.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.strides"> <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">strides</span></span><br>
</dt> <dd>
<p>An array containing the number of bytes to jump to get to the next element in each dimension.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.data"> <span class="kt">void</span><span class="p">*</span><span class="sig-name descname"><span class="n">data</span></span><br>
</dt> <dd>
<p>A pointer <em>to</em> the first element of the array.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyArrayInterface.descr"> <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.12)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">descr</span></span><br>
</dt> <dd>
<p>A Python object describing the data-type in more detail (same as the <em>descr</em> key in <a class="reference internal" href="../arrays.interface.html#object.__array_interface__" title="object.__array_interface__"><code>__array_interface__</code></a>). This can be <code>NULL</code> if <em>typekind</em> and <em>itemsize</em> provide enough information. This field is also ignored unless <a class="reference internal" href="../arrays.interface.html#c.NPY_ARR_HAS_DESCR" title="NPY_ARR_HAS_DESCR"><code>NPY_ARR_HAS_DESCR</code></a> flag is on in <em>flags</em>.</p> </dd>
</dl> </dd>
</dl> </section> <section id="internally-used-structures"> <h3>Internally used structures</h3> <p>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyUFunc_Loop1d"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyUFunc_Loop1d</span></span><br>
</dt> <dd>
<p>A simple linked-list of C-structures containing the information needed to define a 1-d loop for a ufunc for every defined signature of a user-defined data-type.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyArrayMapIter_Type"> <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" title="(in Python v3.12)"><span class="n">PyTypeObject</span></a><span class="sig-name descname"><span class="n">PyArrayMapIter_Type</span></span><br>
</dt> <dd>
<p>Advanced indexing is handled with this Python type. It is simply a loose wrapper around the C-structure containing the variables needed for advanced array indexing.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyArrayMapIterObject"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyArrayMapIterObject</span></span><br>
</dt> <dd>
<p>The C-structure associated with <a class="reference internal" href="#c.PyArrayMapIter_Type" title="PyArrayMapIter_Type"><code>PyArrayMapIter_Type</code></a>. This structure is useful if you are trying to understand the advanced-index mapping code. It is defined in the <code>arrayobject.h</code> header. This type is not exposed to Python and could be replaced with a C-structure. As a Python type it takes advantage of reference- counted memory management.</p> </dd>
</dl> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/c-api/types-and-structures.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/c-api/types-and-structures.html</a>
  </p>
</div>
