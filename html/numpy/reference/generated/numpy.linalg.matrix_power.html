<h1>numpy.linalg.matrix_power</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.linalg.matrix_power"> <span class="sig-prename descclassname">linalg.</span><span class="sig-name descname">matrix_power</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/linalg/linalg.py#L560-L673"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Raise a square matrix to the (integer) power <code>n</code>.</p> <p>For positive integers <code>n</code>, the power is computed by repeated matrix squarings and matrix multiplications. If <code>n == 0</code>, the identity matrix of the same shape as M is returned. If <code>n &lt; 0</code>, the inverse is computed and then raised to the <code>abs(n)</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Stacks of object matrices are not currently supported.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>a</strong><span class="classifier">(…, M, M) array_like</span>
</dt>
<dd>
<p>Matrix to be “powered”.</p> </dd> <dt>
<strong>n</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The exponent can be any integer or long integer, positive, negative, or zero.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>a**n</strong><span class="classifier">(…, M, M) ndarray or matrix object</span>
</dt>
<dd>
<p>The return value is the same shape and type as <code>M</code>; if the exponent is positive or zero then the type of the elements is the same as those of <code>M</code>. If the exponent is negative the elements are floating-point.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>LinAlgError</dt>
<dd>
<p>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from numpy.linalg import matrix_power
&gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
&gt;&gt;&gt; matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
&gt;&gt;&gt; matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])
</pre> <p>Somewhat more sophisticated example</p> <pre data-language="python">&gt;&gt;&gt; q = np.zeros((4, 4))
&gt;&gt;&gt; q[0:2, 0:2] = -i
&gt;&gt;&gt; q[2:4, 2:4] = i
&gt;&gt;&gt; q # one of the three quaternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
&gt;&gt;&gt; matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.linalg.matrix_power.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.linalg.matrix_power.html</a>
  </p>
</div>
