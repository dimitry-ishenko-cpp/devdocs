<h1>numpy.exp</h1> <dl class="py data"> <dt class="sig sig-object py" id="numpy.exp"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">exp</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">/</span></em>, <em class="sig-param"><span class="n">out=None</span></em>, <em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">where=True</span></em>, <em class="sig-param"><span class="n">casting='same_kind'</span></em>, <em class="sig-param"><span class="n">order='K'</span></em>, <em class="sig-param"><span class="n">dtype=None</span></em>, <em class="sig-param"><span class="n">subok=True</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">signature</span></em>, <em class="sig-param"><span class="n">extobj</span></em><span class="optional">]</span><span class="sig-paren">)</span><em class="property"><span class="p">=</span>&lt;ufunc 'exp'&gt;</em>
</dt> <dd>
<p>Calculate the exponential of all elements in the input array.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input values.</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span>
</dt>
<dd>
<p>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</p> </dd> <dt>
<strong>where</strong><span class="classifier">array_like, optional</span>
</dt>
<dd>
<p>This condition is broadcast over the input. At locations where the condition is True, the <code>out</code> array will be set to the ufunc result. Elsewhere, the <code>out</code> array will retain its original value. Note that if an uninitialized <code>out</code> array is created via the default <code>out=None</code>, locations within it where the condition is False will remain uninitialized.</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>For other keyword-only arguments, see the <a class="reference internal" href="../ufuncs.html#ufuncs-kwargs"><span class="std std-ref">ufunc docs</span></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>out</strong><span class="classifier">ndarray or scalar</span>
</dt>
<dd>
<p>Output array, element-wise exponential of <code>x</code>. This is a scalar if <code>x</code> is a scalar.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.expm1.html#numpy.expm1" title="numpy.expm1"><code>expm1</code></a></dt>
<dd>
<p>Calculate <code>exp(x) - 1</code> for all elements in the array.</p> </dd> <dt><a class="reference internal" href="numpy.exp2.html#numpy.exp2" title="numpy.exp2"><code>exp2</code></a></dt>
<dd>
<p>Calculate <code>2**x</code> for all elements in the array.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The irrational number <code>e</code> is also known as Euler’s number. It is approximately 2.718281, and is the base of the natural logarithm, <code>ln</code> (this means that, if <span class="math notranslate nohighlight">\(x = \ln y = \log_e y\)</span>, then <span class="math notranslate nohighlight">\(e^x = y\)</span>. For real input, <code>exp(x)</code> is always positive.</p> <p>For complex arguments, <code>x = a + ib</code>, we can write <span class="math notranslate nohighlight">\(e^x = e^a e^{ib}\)</span>. The first term, <span class="math notranslate nohighlight">\(e^a\)</span>, is already known (it is the real argument, described above). The second term, <span class="math notranslate nohighlight">\(e^{ib}\)</span>, is <span class="math notranslate nohighlight">\(\cos b + i \sin b\)</span>, a function with magnitude 1 and a periodic phase.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4deec93ed654-1"><span class="brackets">1</span></dt> <dd>
<p>Wikipedia, “Exponential function”, <a class="reference external" href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a></p> </dd> <dt class="label" id="r4deec93ed654-2"><span class="brackets">2</span></dt> <dd>
<p>M. Abramovitz and I. A. Stegun, “Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables,” Dover, 1964, p. 69, <a class="reference external" href="https://personal.math.ubc.ca/~cbm/aands/page_69.htm">https://personal.math.ubc.ca/~cbm/aands/page_69.htm</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
</pre> <pre data-language="python">&gt;&gt;&gt; x = np.linspace(-2*np.pi, 2*np.pi, 100)
&gt;&gt;&gt; xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
&gt;&gt;&gt; out = np.exp(xx)
</pre> <pre data-language="python">&gt;&gt;&gt; plt.subplot(121)
&gt;&gt;&gt; plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
&gt;&gt;&gt; plt.title('Magnitude of exp(x)')
</pre> <pre data-language="python">&gt;&gt;&gt; plt.subplot(122)
&gt;&gt;&gt; plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
&gt;&gt;&gt; plt.title('Phase (angle) of exp(x)')
&gt;&gt;&gt; plt.show()
</pre> <figure class="align-default"> <img alt="../../_images/numpy-exp-1.png" class="plot-directive" src="data:image/png;base64,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"> </figure> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.exp.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.exp.html</a>
  </p>
</div>
