<section id="numpy-fmax"> <h1>numpy.fmax</h1> <dl class="py data"> <dt class="sig sig-object py" id="numpy.fmax"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">fmax</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">/</span></em>, <em class="sig-param"><span class="n">out=None</span></em>, <em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">where=True</span></em>, <em class="sig-param"><span class="n">casting='same_kind'</span></em>, <em class="sig-param"><span class="n">order='K'</span></em>, <em class="sig-param"><span class="n">dtype=None</span></em>, <em class="sig-param"><span class="n">subok=True</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">signature</span></em><span class="optional">]</span><span class="sig-paren">)</span><em class="property"><span class="p">=</span>&lt;ufunc 'fmax'&gt;</em>
</dt> <dd>
<p>Element-wise maximum of array elements.</p> <p>Compare two arrays and return a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x1, x2</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span>
</dt>
<dd>
<p>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</p> </dd> <dt>
<strong>where</strong><span class="classifier">array_like, optional</span>
</dt>
<dd>
<p>This condition is broadcast over the input. At locations where the condition is True, the <code>out</code> array will be set to the ufunc result. Elsewhere, the <code>out</code> array will retain its original value. Note that if an uninitialized <code>out</code> array is created via the default <code>out=None</code>, locations within it where the condition is False will remain uninitialized.</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>For other keyword-only arguments, see the <a class="reference internal" href="../ufuncs.html#ufuncs-kwargs"><span class="std std-ref">ufunc docs</span></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">ndarray or scalar</span>
</dt>
<dd>
<p>The maximum of <code>x1</code> and <code>x2</code>, element-wise. This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.fmin.html#numpy.fmin" title="numpy.fmin"><code>fmin</code></a></dt>
<dd>
<p>Element-wise minimum of two arrays, ignores NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.maximum.html#numpy.maximum" title="numpy.maximum"><code>maximum</code></a></dt>
<dd>
<p>Element-wise maximum of two arrays, propagates NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.amax.html#numpy.amax" title="numpy.amax"><code>amax</code></a></dt>
<dd>
<p>The maximum value of an array along a given axis, propagates NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.nanmax.html#numpy.nanmax" title="numpy.nanmax"><code>nanmax</code></a></dt>
<dd>
<p>The maximum value of an array along a given axis, ignores NaNs.</p> </dd> <dt>
<a class="reference internal" href="numpy.minimum.html#numpy.minimum" title="numpy.minimum"><code>minimum</code></a>, <a class="reference internal" href="numpy.amin.html#numpy.amin" title="numpy.amin"><code>amin</code></a>, <a class="reference internal" href="numpy.nanmin.html#numpy.nanmin" title="numpy.nanmin"><code>nanmin</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>The fmax is equivalent to <code>np.where(x1 &gt;= x2, x1, x2)</code> when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.fmax([2, 3, 4], [1, 5, 2])
array([ 2.,  5.,  4.])
</pre> <pre data-language="python">&gt;&gt;&gt; np.fmax(np.eye(2), [0.5, 2])
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])
</pre> <pre data-language="python">&gt;&gt;&gt; np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([ 0.,  0., nan])
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/generated/numpy.fmax.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/generated/numpy.fmax.html</a>
  </p>
</div>
