<section id="numpy-minimum"> <h1>numpy.minimum</h1> <dl class="py data"> <dt class="sig sig-object py" id="numpy.minimum"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">minimum</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">/</span></em>, <em class="sig-param"><span class="n">out=None</span></em>, <em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">where=True</span></em>, <em class="sig-param"><span class="n">casting='same_kind'</span></em>, <em class="sig-param"><span class="n">order='K'</span></em>, <em class="sig-param"><span class="n">dtype=None</span></em>, <em class="sig-param"><span class="n">subok=True</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">signature</span></em><span class="optional">]</span><span class="sig-paren">)</span><em class="property"><span class="p">=</span>&lt;ufunc 'minimum'&gt;</em>
</dt> <dd>
<p>Element-wise minimum of array elements.</p> <p>Compare two arrays and return a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x1, x2</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span>
</dt>
<dd>
<p>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</p> </dd> <dt>
<strong>where</strong><span class="classifier">array_like, optional</span>
</dt>
<dd>
<p>This condition is broadcast over the input. At locations where the condition is True, the <code>out</code> array will be set to the ufunc result. Elsewhere, the <code>out</code> array will retain its original value. Note that if an uninitialized <code>out</code> array is created via the default <code>out=None</code>, locations within it where the condition is False will remain uninitialized.</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>For other keyword-only arguments, see the <a class="reference internal" href="../ufuncs.html#ufuncs-kwargs"><span class="std std-ref">ufunc docs</span></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">ndarray or scalar</span>
</dt>
<dd>
<p>The minimum of <code>x1</code> and <code>x2</code>, element-wise. This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.maximum.html#numpy.maximum" title="numpy.maximum"><code>maximum</code></a></dt>
<dd>
<p>Element-wise maximum of two arrays, propagates NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.fmin.html#numpy.fmin" title="numpy.fmin"><code>fmin</code></a></dt>
<dd>
<p>Element-wise minimum of two arrays, ignores NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.amin.html#numpy.amin" title="numpy.amin"><code>amin</code></a></dt>
<dd>
<p>The minimum value of an array along a given axis, propagates NaNs.</p> </dd> <dt><a class="reference internal" href="numpy.nanmin.html#numpy.nanmin" title="numpy.nanmin"><code>nanmin</code></a></dt>
<dd>
<p>The minimum value of an array along a given axis, ignores NaNs.</p> </dd> <dt>
<a class="reference internal" href="numpy.fmax.html#numpy.fmax" title="numpy.fmax"><code>fmax</code></a>, <a class="reference internal" href="numpy.amax.html#numpy.amax" title="numpy.amax"><code>amax</code></a>, <a class="reference internal" href="numpy.nanmax.html#numpy.nanmax" title="numpy.nanmax"><code>nanmax</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The minimum is equivalent to <code>np.where(x1 &lt;= x2, x1, x2)</code> when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.minimum([2, 3, 4], [1, 5, 2])
array([1, 3, 2])
</pre> <pre data-language="python">&gt;&gt;&gt; np.minimum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])
</pre> <pre data-language="python">&gt;&gt;&gt; np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([nan, nan, nan])
&gt;&gt;&gt; np.minimum(-np.inf, 1)
-inf
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/generated/numpy.minimum.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/generated/numpy.minimum.html</a>
  </p>
</div>
