<h1>numpy.linalg.norm</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.linalg.norm"> <span class="sig-prename descclassname">linalg.</span><span class="sig-name descname">norm</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">ord</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/linalg/linalg.py#L2357-L2607"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Matrix or vector norm.</p> <p>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the <code>ord</code> parameter.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input array. If <code>axis</code> is None, <code>x</code> must be 1-D or 2-D, unless <code>ord</code> is None. If both <code>axis</code> and <code>ord</code> are None, the 2-norm of <code>x.ravel</code> will be returned.</p> </dd> <dt>
<strong>ord</strong><span class="classifier">{non-zero int, inf, -inf, ‘fro’, ‘nuc’}, optional</span>
</dt>
<dd>
<p>Order of the norm (see table under <code>Notes</code>). inf means numpy’s <a class="reference internal" href="../constants.html#numpy.inf" title="numpy.inf"><code>inf</code></a> object. The default is None.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">{None, int, 2-tuple of ints}, optional.</span>
</dt>
<dd>
<p>If <code>axis</code> is an integer, it specifies the axis of <code>x</code> along which to compute the vector norms. If <code>axis</code> is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If <code>axis</code> is None then either a vector norm (when <code>x</code> is 1-D) or a matrix norm (when <code>x</code> is 2-D) is returned. The default is None.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.8.0.</span></p> </div> </dd> <dt>
<strong>keepdims</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original <code>x</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.10.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>n</strong><span class="classifier">float or ndarray</span>
</dt>
<dd>
<p>Norm of the matrix or vector(s).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.norm.html#scipy.linalg.norm" title="(in SciPy v1.8.1)"><code>scipy.linalg.norm</code></a></dt>
<dd>
<p>Similar function in SciPy.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For values of <code>ord &lt; 1</code>, the result is, strictly speaking, not a mathematical ‘norm’, but it may still be useful for various numerical purposes.</p> <p>The following norms can be calculated:</p> <table class="table">  <thead> <tr>
<th class="head"><p>ord</p></th> <th class="head"><p>norm for matrices</p></th> <th class="head"><p>norm for vectors</p></th> </tr> </thead>  <tr>
<td><p>None</p></td> <td><p>Frobenius norm</p></td> <td><p>2-norm</p></td> </tr> <tr>
<td><p>‘fro’</p></td> <td><p>Frobenius norm</p></td> <td><p>–</p></td> </tr> <tr>
<td><p>‘nuc’</p></td> <td><p>nuclear norm</p></td> <td><p>–</p></td> </tr> <tr>
<td><p>inf</p></td> <td><p>max(sum(abs(x), axis=1))</p></td> <td><p>max(abs(x))</p></td> </tr> <tr>
<td><p>-inf</p></td> <td><p>min(sum(abs(x), axis=1))</p></td> <td><p>min(abs(x))</p></td> </tr> <tr>
<td><p>0</p></td> <td><p>–</p></td> <td><p>sum(x != 0)</p></td> </tr> <tr>
<td><p>1</p></td> <td><p>max(sum(abs(x), axis=0))</p></td> <td><p>as below</p></td> </tr> <tr>
<td><p>-1</p></td> <td><p>min(sum(abs(x), axis=0))</p></td> <td><p>as below</p></td> </tr> <tr>
<td><p>2</p></td> <td><p>2-norm (largest sing. value)</p></td> <td><p>as below</p></td> </tr> <tr>
<td><p>-2</p></td> <td><p>smallest singular value</p></td> <td><p>as below</p></td> </tr> <tr>
<td><p>other</p></td> <td><p>–</p></td> <td><p>sum(abs(x)**ord)**(1./ord)</p></td> </tr>  </table> <p>The Frobenius norm is given by <a class="reference internal" href="#rac1c834adb66-1" id="id1">[1]</a>:</p>  <p><span class="math notranslate nohighlight">\(||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}\)</span></p>  <p>The nuclear norm is the sum of the singular values.</p> <p>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when <code>x.ndim != 2</code>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rac1c834adb66-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, ...,  2,  3,  4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])
</pre> <pre data-language="python">&gt;&gt;&gt; LA.norm(a)
7.745966692414834
&gt;&gt;&gt; LA.norm(b)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; LA.norm(a, np.inf)
4.0
&gt;&gt;&gt; LA.norm(b, np.inf)
9.0
&gt;&gt;&gt; LA.norm(a, -np.inf)
0.0
&gt;&gt;&gt; LA.norm(b, -np.inf)
2.0
</pre> <pre data-language="python">&gt;&gt;&gt; LA.norm(a, 1)
20.0
&gt;&gt;&gt; LA.norm(b, 1)
7.0
&gt;&gt;&gt; LA.norm(a, -1)
-4.6566128774142013e-010
&gt;&gt;&gt; LA.norm(b, -1)
6.0
&gt;&gt;&gt; LA.norm(a, 2)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 2)
7.3484692283495345
</pre> <pre data-language="python">&gt;&gt;&gt; LA.norm(a, -2)
0.0
&gt;&gt;&gt; LA.norm(b, -2)
1.8570331885190563e-016 # may vary
&gt;&gt;&gt; LA.norm(a, 3)
5.8480354764257312 # may vary
&gt;&gt;&gt; LA.norm(a, -3)
0.0
</pre> <p>Using the <code>axis</code> argument to compute vector norms:</p> <pre data-language="python">&gt;&gt;&gt; c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
&gt;&gt;&gt; LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
&gt;&gt;&gt; LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
&gt;&gt;&gt; LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])
</pre> <p>Using the <code>axis</code> argument to compute matrix norms:</p> <pre data-language="python">&gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)
&gt;&gt;&gt; LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
&gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.linalg.norm.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.linalg.norm.html</a>
  </p>
</div>
