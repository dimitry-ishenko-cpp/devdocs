<section id="numpy-nanquantile"> <h1>numpy.nanquantile</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.nanquantile"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">nanquantile</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">axis=None</span></em>, <em class="sig-param"><span class="n">out=None</span></em>, <em class="sig-param"><span class="n">overwrite_input=False</span></em>, <em class="sig-param"><span class="n">method='linear'</span></em>, <em class="sig-param"><span class="n">keepdims=&lt;no value&gt;</span></em>, <em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">weights=None</span></em>, <em class="sig-param"><span class="n">interpolation=None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v2.0.0/numpy/lib/_nanfunctions_impl.py#L1434-L1616"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the qth quantile of the data along the specified axis, while ignoring nan values. Returns the qth quantile(s) of the array elements.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.0.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input array or object that can be converted to an array, containing nan values to be ignored</p> </dd> <dt>
<strong>q</strong><span class="classifier">array_like of float</span>
</dt>
<dd>
<p>Probability or sequence of probabilities for the quantiles to compute. Values must be between 0 and 1 inclusive.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span>
</dt>
<dd>
<p>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, optional</span>
</dt>
<dd>
<p>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary.</p> </dd> <dt>
<strong>overwrite_input</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If True, then allow the input array <code>a</code> to be modified by intermediate calculations, to save memory. In this case, the contents of the input <code>a</code> after this function completes is undefined.</p> </dd> <dt>
<strong>method</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>This parameter specifies the method to use for estimating the quantile. There are many different methods, some unique to NumPy. See the notes for explanation. The options sorted by their R type as summarized in the H&amp;F paper <a class="reference internal" href="#r02de30f409d2-1" id="id1">[1]</a> are:</p> <ol class="arabic simple"> <li>‘inverted_cdf’</li> <li>‘averaged_inverted_cdf’</li> <li>‘closest_observation’</li> <li>‘interpolated_inverted_cdf’</li> <li>‘hazen’</li> <li>‘weibull’</li> <li>‘linear’ (default)</li> <li>‘median_unbiased’</li> <li>‘normal_unbiased’</li> </ol> <p>The first three methods are discontinuous. NumPy further defines the following discontinuous variations of the default ‘linear’ (7.) option:</p> <ul class="simple"> <li>‘lower’</li> <li>‘higher’,</li> <li>‘midpoint’</li> <li>‘nearest’</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.22.0: </span>This argument was previously called “interpolation” and only offered the “linear” default and last four options.</p> </div> </dd> <dt>
<strong>keepdims</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array <code>a</code>.</p> <p>If this is anything but the default value it will be passed through (in the special case of an empty array) to the <a class="reference internal" href="numpy.mean.html#numpy.mean" title="numpy.mean"><code>mean</code></a> function of the underlying array. If the array is a sub-class and <a class="reference internal" href="numpy.mean.html#numpy.mean" title="numpy.mean"><code>mean</code></a> does not have the kwarg <code>keepdims</code> this will raise a RuntimeError.</p> </dd> <dt>
<strong>weights</strong><span class="classifier">array_like, optional</span>
</dt>
<dd>
<p>An array of weights associated with the values in <code>a</code>. Each value in <code>a</code> contributes to the quantile according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of <code>a</code> along the given axis) or of the same shape as <code>a</code>. If <code>weights=None</code>, then all data in <code>a</code> are assumed to have a weight equal to one. Only <code>method=”inverted_cdf”</code> supports weights.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.0.</span></p> </div> </dd> <dt>
<strong>interpolation</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Deprecated name for the method keyword argument.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.22.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>quantile</strong><span class="classifier">scalar or ndarray</span>
</dt>
<dd>
<p>If <code>q</code> is a single probability and <code>axis=None</code>, then the result is a scalar. If multiple probability levels are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of <code>a</code>. If the input contains integers or floats smaller than <code>float64</code>, the output data-type is <code>float64</code>. Otherwise, the output data-type is the same as that of the input. If <code>out</code> is specified, that array is returned instead.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.quantile.html#numpy.quantile" title="numpy.quantile"><code>quantile</code></a></dt>
 <dt>
<a class="reference internal" href="numpy.nanmean.html#numpy.nanmean" title="numpy.nanmean"><code>nanmean</code></a>, <a class="reference internal" href="numpy.nanmedian.html#numpy.nanmedian" title="numpy.nanmedian"><code>nanmedian</code></a>
</dt>
 <dt><a class="reference internal" href="numpy.nanmedian.html#numpy.nanmedian" title="numpy.nanmedian"><code>nanmedian</code></a></dt>
<dd>
<p>equivalent to <code>nanquantile(..., 0.5)</code></p> </dd> <dt><a class="reference internal" href="numpy.nanpercentile.html#numpy.nanpercentile" title="numpy.nanpercentile"><code>nanpercentile</code></a></dt>
<dd>
<p>same as nanquantile, but with q in the range [0, 100].</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For more information please see <a class="reference internal" href="numpy.quantile.html#numpy.quantile" title="numpy.quantile"><code>numpy.quantile</code></a></p> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r02de30f409d2-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>R. J. Hyndman and Y. Fan, “Sample quantiles in statistical packages,” The American Statistician, 50(4), pp. 361-365, 1996</p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
&gt;&gt;&gt; np.quantile(a, 0.5)
np.float64(nan)
&gt;&gt;&gt; np.nanquantile(a, 0.5)
3.0
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.nanquantile(a, 0.5, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0, out=out)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; m
array([6.5,  2. ,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
array([7., 2.])
&gt;&gt;&gt; assert not np.all(a==b)
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/generated/numpy.nanquantile.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/generated/numpy.nanquantile.html</a>
  </p>
</div>
