<h1>numpy.ptp</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.ptp"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">ptp</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis=None</span></em>, <em class="sig-param"><span class="n">out=None</span></em>, <em class="sig-param"><span class="n">keepdims=&lt;no value&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/core/fromnumeric.py#L2578-L2669"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Range of values (maximum - minimum) along an axis.</p> <p>The name of the function comes from the acronym for ‘peak to peak’.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#numpy.ptp" title="numpy.ptp"><code>ptp</code></a> preserves the data type of the array. This means the return value for an input of signed integers with n bits (e.g. <code>np.int8</code>, <code>np.int16</code>, etc) is also a signed integer with n bits. In that case, peak-to-peak values greater than <code>2**(n-1)-1</code> will be returned as negative values. An example with a work-around is shown below.</p> </div> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input values.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span>
</dt>
<dd>
<p>Axis along which to find the peaks. By default, flatten the array. <code>axis</code> may be negative, in which case it counts from the last to the first axis.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.0.</span></p> </div> <p>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</p> </dd> <dt>
<strong>out</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary.</p> </dd> <dt>
<strong>keepdims</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <p>If the default value is passed, then <code>keepdims</code> will not be passed through to the <a class="reference internal" href="#numpy.ptp" title="numpy.ptp"><code>ptp</code></a> method of sub-classes of <a class="reference internal" href="numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>, however any non-default value will be. If the sub-class’ method does not implement <code>keepdims</code> any exceptions will be raised.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>ptp</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>A new array holding the result, unless <code>out</code> was specified, in which case a reference to <code>out</code> is returned.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.array([[4, 9, 2, 10],
...               [6, 9, 7, 12]])
</pre> <pre data-language="python">&gt;&gt;&gt; np.ptp(x, axis=1)
array([8, 6])
</pre> <pre data-language="python">&gt;&gt;&gt; np.ptp(x, axis=0)
array([2, 0, 5, 2])
</pre> <pre data-language="python">&gt;&gt;&gt; np.ptp(x)
10
</pre> <p>This example shows that a negative value can be returned when the input is an array of signed integers.</p> <pre data-language="python">&gt;&gt;&gt; y = np.array([[1, 127],
...               [0, 127],
...               [-1, 127],
...               [-2, 127]], dtype=np.int8)
&gt;&gt;&gt; np.ptp(y, axis=1)
array([ 126,  127, -128, -127], dtype=int8)
</pre> <p>A work-around is to use the <code>view()</code> method to view the result as unsigned integers with the same bit width:</p> <pre data-language="python">&gt;&gt;&gt; np.ptp(y, axis=1).view(np.uint8)
array([126, 127, 128, 129], dtype=uint8)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.ptp.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.ptp.html</a>
  </p>
</div>
