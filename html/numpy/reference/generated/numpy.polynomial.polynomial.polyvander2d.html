<section id="numpy-polynomial-polynomial-polyvander2d"> <h1>numpy.polynomial.polynomial.polyvander2d</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.polynomial.polynomial.polyvander2d"> <span class="sig-prename descclassname">polynomial.polynomial.</span><span class="sig-name descname">polyvander2d</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">deg</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v2.0.0/numpy/polynomial/polynomial.py#L1164-L1238"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pseudo-Vandermonde matrix of given degrees.</p> <p>Returns the pseudo-Vandermonde matrix of degrees <code>deg</code> and sample points <code>(x, y)</code>. The pseudo-Vandermonde matrix is defined by</p> <div class="math notranslate nohighlight"> \[V[..., (deg[1] + 1)*i + j] = x^i * y^j,\]</div> <p>where <code>0 &lt;= i &lt;= deg[0]</code> and <code>0 &lt;= j &lt;= deg[1]</code>. The leading indices of <code>V</code> index the points <code>(x, y)</code> and the last index encodes the powers of <code>x</code> and <code>y</code>.</p> <p>If <code>V = polyvander2d(x, y, [xdeg, ydeg])</code>, then the columns of <code>V</code> correspond to the elements of a 2-D coefficient array <code>c</code> of shape (xdeg + 1, ydeg + 1) in the order</p> <div class="math notranslate nohighlight"> \[c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...\]</div> <p>and <code>np.dot(V, c.flat)</code> and <code>polyval2d(x, y, c)</code> will be the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of 2-D polynomials of the same degrees and sample points.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x, y</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</p> </dd> <dt>
<strong>deg</strong><span class="classifier">list of ints</span>
</dt>
<dd>
<p>List of maximum degrees of the form [x_deg, y_deg].</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>vander2d</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>The shape of the returned matrix is <code>x.shape + (order,)</code>, where <span class="math notranslate nohighlight">\(order = (deg[0]+1)*(deg([1]+1)\)</span>. The dtype will be the same as the converted <code>x</code> and <code>y</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="reference internal" href="numpy.polynomial.polynomial.polyvander.html#numpy.polynomial.polynomial.polyvander" title="numpy.polynomial.polynomial.polyvander"><code>polyvander</code></a>, <a class="reference internal" href="numpy.polynomial.polynomial.polyvander3d.html#numpy.polynomial.polynomial.polyvander3d" title="numpy.polynomial.polynomial.polyvander3d"><code>polyvander3d</code></a>, <a class="reference internal" href="numpy.polynomial.polynomial.polyval2d.html#numpy.polynomial.polynomial.polyval2d" title="numpy.polynomial.polynomial.polyval2d"><code>polyval2d</code></a>, <a class="reference internal" href="numpy.polynomial.polynomial.polyval3d.html#numpy.polynomial.polynomial.polyval3d" title="numpy.polynomial.polynomial.polyval3d"><code>polyval3d</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Examples</h4> <p>The 2-D pseudo-Vandermonde matrix of degree <code>[1, 2]</code> and sample points <code>x = [-1, 2]</code> and <code>y = [1, 3]</code> is as follows:</p> <pre data-language="python">&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; x = np.array([-1, 2])
&gt;&gt;&gt; y = np.array([1, 3])
&gt;&gt;&gt; m, n = 1, 2
&gt;&gt;&gt; deg = np.array([m, n])
&gt;&gt;&gt; V = P.polyvander2d(x=x, y=y, deg=deg)
&gt;&gt;&gt; V
array([[ 1.,  1.,  1., -1., -1., -1.],
       [ 1.,  3.,  9.,  2.,  6., 18.]])
</pre> <p>We can verify the columns for any <code>0 &lt;= i &lt;= m</code> and <code>0 &lt;= j &lt;= n</code>:</p> <pre data-language="python">&gt;&gt;&gt; i, j = 0, 1
&gt;&gt;&gt; V[:, (deg[1]+1)*i + j] == x**i * y**j
array([ True,  True])
</pre> <p>The (1D) Vandermonde matrix of sample points <code>x</code> and degree <code>m</code> is a special case of the (2D) pseudo-Vandermonde matrix with <code>y</code> points all zero and degree <code>[m, 0]</code>.</p> <pre data-language="python">&gt;&gt;&gt; P.polyvander2d(x=x, y=0*x, deg=(m, 0)) == P.polyvander(x=x, deg=m)
array([[ True,  True],
       [ True,  True]])
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/generated/numpy.polynomial.polynomial.polyvander2d.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/generated/numpy.polynomial.polynomial.polyvander2d.html</a>
  </p>
</div>
