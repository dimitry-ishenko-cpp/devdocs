<section id="random-sampling-numpy-random"> <h1 id="numpyrandom">Random sampling (numpy.random)</h1> <section id="quick-start"> <h2 id="random-quick-start">Quick start</h2> <p>The <a class="reference internal" href="#module-numpy.random" title="numpy.random"><code>numpy.random</code></a> module implements pseudo-random number generators (PRNGs or RNGs, for short) with the ability to draw samples from a variety of probability distributions. In general, users will create a <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> instance with <a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> and call the various methods on it to obtain samples from different distributions.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
# Generate one random float uniformly distributed over the range [0, 1)
&gt;&gt;&gt; rng.random()  
0.06369197489564249  # may vary
# Generate an array of 10 numbers according to a unit Gaussian distribution.
&gt;&gt;&gt; rng.standard_normal(10)  
array([-0.31018314, -1.8922078 , -0.3628523 , -0.63526532,  0.43181166,  # may vary
        0.51640373,  1.25693945,  0.07779185,  0.84090247, -2.13406828])
# Generate an array of 5 integers uniformly over the range [0, 10).
&gt;&gt;&gt; rng.integers(low=0, high=10, size=5)  
array([8, 7, 6, 2, 0])  # may vary
</pre> <p>Our RNGs are deterministic sequences and can be reproduced by specifying a seed integer to derive its initial state. By default, with no seed provided, <a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> will seed the RNG from nondeterministic data from the operating system and therefore generate different numbers each time. The pseudo-random sequences will be independent for all practical purposes, at least those purposes for which our pseudo-randomness was good for in the first place.</p> <pre data-language="python">&gt;&gt;&gt; rng1 = np.random.default_rng()
&gt;&gt;&gt; rng1.random()  
0.6596288841243357  # may vary
&gt;&gt;&gt; rng2 = np.random.default_rng()
&gt;&gt;&gt; rng2.random()  
0.11885628817151628  # may vary
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The pseudo-random number generators implemented in this module are designed for statistical modeling and simulation. They are not suitable for security or cryptographic purposes. See the <a class="reference external" href="https://docs.python.org/3/library/secrets.html#module-secrets" title="(in Python v3.12)"><code>secrets</code></a> module from the standard library for such use cases.</p> </div> <p id="recommend-secrets-randbits">Seeds should be large positive integers. <a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> can take positive integers of any size. We recommend using very large, unique numbers to ensure that your seed is different from anyone else’s. This is good practice to ensure that your results are statistically independent from theirs unless you are intentionally <em>trying</em> to reproduce their result. A convenient way to get such a seed number is to use <a class="reference external" href="https://docs.python.org/3/library/secrets.html#secrets.randbits" title="(in Python v3.12)"><code>secrets.randbits</code></a> to get an arbitrary 128-bit integer.</p> <pre data-language="python">&gt;&gt;&gt; import secrets
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; secrets.randbits(128)  
122807528840384100672342137672332424406  # may vary
&gt;&gt;&gt; rng1 = np.random.default_rng(122807528840384100672342137672332424406)
&gt;&gt;&gt; rng1.random()
0.5363922081269535
&gt;&gt;&gt; rng2 = np.random.default_rng(122807528840384100672342137672332424406)
&gt;&gt;&gt; rng2.random()
0.5363922081269535
</pre> <p>See the documentation on <a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> and <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> for more advanced options for controlling the seed in specialized scenarios.</p> <p><a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> and its associated infrastructure was introduced in NumPy version 1.17.0. There is still a lot of code that uses the older <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a> and the functions in <a class="reference internal" href="#module-numpy.random" title="numpy.random"><code>numpy.random</code></a>. While there are no plans to remove them at this time, we do recommend transitioning to <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> as you can. The algorithms are faster, more flexible, and will receive more improvements in the future. For the most part, <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> can be used as a replacement for <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a>. See <a class="reference internal" href="legacy.html#legacy"><span class="std std-ref">Legacy random generation</span></a> for information on the legacy infrastructure, <a class="reference internal" href="new-or-different.html#new-or-different"><span class="std std-ref">What’s new or different</span></a> for information on transitioning, and <a class="reference external" href="https://numpy.org/neps/nep-0019-rng-policy.html#nep19" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 19</span></a> for some of the reasoning for the transition.</p> </section> <section id="design"> <h2>Design</h2> <p>Users primarily interact with <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> instances. Each <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> instance owns a <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> instance that implements the core RNG algorithm. The <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</p> <p>The <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</p> <p>NumPy implements several different <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> classes implementing different RNG algorithms. <a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> currently uses <a class="reference internal" href="bit_generators/pcg64.html#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> as the default <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>. It has better statistical properties and performance than the <a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a> algorithm used in the legacy <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a>. See <a class="reference internal" href="bit_generators/index.html#random-bit-generators"><span class="std std-ref">Bit generators</span></a> for more details on the supported BitGenerators.</p> <p><a class="reference internal" href="generator.html#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> and BitGenerators delegate the conversion of seeds into RNG states to <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> internally. <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> implements a sophisticated algorithm that intermediates between the user’s input and the internal implementation details of each <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> algorithm, each of which can require different amounts of bits for its state. Importantly, it lets you use arbitrary-sized integers and arbitrary sequences of such integers to mix together into the RNG state. This is a useful primitive for constructing a <a class="reference internal" href="parallel.html#seedsequence-spawn"><span class="std std-ref">flexible pattern for parallel RNG streams</span></a>.</p> <p>For backward compatibility, we still maintain the legacy <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a> class. It continues to use the <a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a> algorithm by default, and old seeds continue to reproduce the same results. The convenience <a class="reference internal" href="legacy.html#functions-in-numpy-random"><span class="std std-ref">Functions in numpy.random</span></a> are still aliases to the methods on a single global <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a> instance. See <a class="reference internal" href="legacy.html#legacy"><span class="std std-ref">Legacy random generation</span></a> for the complete details. See <a class="reference internal" href="new-or-different.html#new-or-different"><span class="std std-ref">What’s new or different</span></a> for a detailed comparison between <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> and <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a>.</p> <section id="parallel-generation"> <h3>Parallel Generation</h3> <p>The included generators can be used in parallel, distributed applications in a number of ways:</p> <ul class="simple"> <li><a class="reference internal" href="parallel.html#seedsequence-spawn"><span class="std std-ref">SeedSequence spawning</span></a></li> <li><a class="reference internal" href="parallel.html#sequence-of-seeds"><span class="std std-ref">Sequence of integer seeds</span></a></li> <li><a class="reference internal" href="parallel.html#independent-streams"><span class="std std-ref">Independent streams</span></a></li> <li><a class="reference internal" href="parallel.html#parallel-jumped"><span class="std std-ref">Jumping the BitGenerator state</span></a></li> </ul> <p>Users with a very large amount of parallelism will want to consult <a class="reference internal" href="upgrading-pcg64.html#upgrading-pcg64"><span class="std std-ref">Upgrading PCG64 with PCG64DXSM</span></a>.</p> </section> </section> <section id="concepts"> <h2>Concepts</h2>  <ul> <li class="toctree-l1"><a class="reference internal" href="generator.html">Random <code>Generator</code></a></li> <li class="toctree-l1"><a class="reference internal" href="legacy.html">Legacy Generator (RandomState)</a></li> <li class="toctree-l1"><a class="reference internal" href="bit_generators/index.html">Bit generators</a></li> <li class="toctree-l1"><a class="reference internal" href="bit_generators/index.html#seeding-and-entropy">Seeding and entropy</a></li> <li class="toctree-l1"><a class="reference internal" href="upgrading-pcg64.html">Upgrading PCG64 with PCG64DXSM</a></li> <li class="toctree-l1"><a class="reference internal" href="compatibility.html">Compatibility policy</a></li> </ul>  </section> <section id="features"> <h2>Features</h2>  <ul> <li class="toctree-l1">
<a class="reference internal" href="parallel.html">Parallel Applications</a><ul> <li class="toctree-l2"><a class="reference internal" href="parallel.html#seedsequence-spawning"><code>SeedSequence</code> spawning</a></li> <li class="toctree-l2"><a class="reference internal" href="parallel.html#sequence-of-integer-seeds">Sequence of integer seeds</a></li> <li class="toctree-l2"><a class="reference internal" href="parallel.html#independent-streams">Independent streams</a></li> <li class="toctree-l2"><a class="reference internal" href="parallel.html#jumping-the-bitgenerator-state">Jumping the BitGenerator state</a></li> </ul> </li> <li class="toctree-l1"><a class="reference internal" href="multithreading.html">Multithreaded Generation</a></li> <li class="toctree-l1"><a class="reference internal" href="new-or-different.html">What’s new or different</a></li> <li class="toctree-l1">
<a class="reference internal" href="performance.html">Comparing Performance</a><ul> <li class="toctree-l2"><a class="reference internal" href="performance.html#recommendation">Recommendation</a></li> <li class="toctree-l2"><a class="reference internal" href="performance.html#timings">Timings</a></li> <li class="toctree-l2"><a class="reference internal" href="performance.html#performance-on-different-operating-systems">Performance on different operating systems</a></li> </ul> </li> <li class="toctree-l1"><a class="reference internal" href="c-api.html">C API for random</a></li> <li class="toctree-l1">
<a class="reference internal" href="extending.html">Examples of using Numba, Cython, CFFI</a><ul> <li class="toctree-l2"><a class="reference internal" href="extending.html#numba">Numba</a></li> <li class="toctree-l2"><a class="reference internal" href="extending.html#cython">Cython</a></li> <li class="toctree-l2"><a class="reference internal" href="extending.html#cffi">CFFI</a></li> <li class="toctree-l2"><a class="reference internal" href="extending.html#new-bitgenerators">New BitGenerators</a></li> <li class="toctree-l2"><a class="reference internal" href="extending.html#examples">Examples</a></li> </ul> </li> </ul>  <section id="original-source-of-the-generator-and-bitgenerators"> <h3>Original Source of the Generator and BitGenerators</h3> <p>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at <a class="github reference external" href="https://github.com/bashtage/randomgen">bashtage/randomgen</a>.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/random/index.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/random/index.html</a>
  </p>
</div>
