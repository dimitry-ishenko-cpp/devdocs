<h1>numpy.random.SeedSequence</h1> <dl class="py class"> <dt class="sig sig-object py" id="numpy.random.SeedSequence"> <em class="property">class</em><span class="sig-prename descclassname">numpy.random.</span><span class="sig-name descname">SeedSequence</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">entropy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">spawn_key</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>SeedSequence mixes sources of entropy in a reproducible way to set the initial state for independent and very probably non-overlapping BitGenerators.</p> <p>Once the SeedSequence is instantiated, you can call the <a class="reference internal" href="numpy.random.seedsequence.generate_state.html#numpy.random.SeedSequence.generate_state" title="numpy.random.SeedSequence.generate_state"><code>generate_state</code></a> method to get an appropriately sized seed. Calling <a class="reference internal" href="numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>spawn(n)</code></a> will create <code>n</code> SeedSequences that can be used to seed independent BitGenerators, i.e. for different threads.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>entropy</strong><span class="classifier">{None, int, sequence[int]}, optional</span>
</dt>
<dd>
<p>The entropy for creating a <a class="reference internal" href="#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a>.</p> </dd> <dt>
<strong>spawn_key</strong><span class="classifier">{(), sequence[int]}, optional</span>
</dt>
<dd>
<p>A third source of entropy, used internally when calling <a class="reference internal" href="numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a></p> </dd> <dt>
<strong>pool_size</strong><span class="classifier">{int}, optional</span>
</dt>
<dd>
<p>Size of the pooled entropy to store. Default is 4 to give a 128-bit entropy pool. 8 (for 256 bits) is another reasonable choice if working with larger PRNGs, but there is very little to be gained by selecting another value.</p> </dd> <dt>
<strong>n_children_spawned</strong><span class="classifier">{int}, optional</span>
</dt>
<dd>
<p>The number of children already spawned. Only pass this if reconstructing a <a class="reference internal" href="#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> from a serialized form.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Best practice for achieving reproducible bit streams is to use the default <code>None</code> for the initial entropy, and then use <a class="reference internal" href="numpy.random.seedsequence.entropy.html#numpy.random.SeedSequence.entropy" title="numpy.random.SeedSequence.entropy"><code>SeedSequence.entropy</code></a> to log/pickle the <a class="reference internal" href="numpy.random.seedsequence.entropy.html#numpy.random.SeedSequence.entropy" title="numpy.random.SeedSequence.entropy"><code>entropy</code></a> for reproducibility:</p> <pre data-language="python">&gt;&gt;&gt; sq1 = np.random.SeedSequence()
&gt;&gt;&gt; sq1.entropy
243799254704924441050048792905230269161  # random
&gt;&gt;&gt; sq2 = np.random.SeedSequence(sq1.entropy)
&gt;&gt;&gt; np.all(sq1.generate_state(10) == sq2.generate_state(10))
True
</pre> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>entropy</strong></dt>
 <dt><strong>n_children_spawned</strong></dt>
 <dt><strong>pool</strong></dt>
 <dt><strong>pool_size</strong></dt>
 <dt><strong>spawn_key</strong></dt>
 <dt><strong>state</strong></dt>
 </dl> </dd> </dl> <h4 class="rubric">Methods</h4> <table class="autosummary longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="numpy.random.seedsequence.generate_state.html#numpy.random.SeedSequence.generate_state" title="numpy.random.SeedSequence.generate_state"><code>generate_state</code></a>(n_words[, dtype])</p></td> <td><p>Return the requested number of words for PRNG seeding.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>spawn</code></a>(n_children)</p></td> <td><p>Spawn a number of child <a class="reference internal" href="#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> s by extending the <a class="reference internal" href="numpy.random.seedsequence.spawn_key.html#numpy.random.SeedSequence.spawn_key" title="numpy.random.SeedSequence.spawn_key"><code>spawn_key</code></a>.</p></td> </tr>  </table> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/random/bit_generators/generated/numpy.random.SeedSequence.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/random/bit_generators/generated/numpy.random.SeedSequence.html</a>
  </p>
</div>
