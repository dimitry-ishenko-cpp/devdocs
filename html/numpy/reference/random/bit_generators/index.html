<section id="bit-generators"> <h1 id="random-bit-generators">Bit generators</h1> <p>The random values produced by <a class="reference internal" href="../generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> originate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., <a class="reference external" href="https://numba.pydata.org">numba</a>.</p> <section id="supported-bitgenerators"> <h2>Supported BitGenerators</h2> <p>The included BitGenerators are:</p> <ul class="simple"> <li>PCG-64 - The default. A fast generator that can be advanced by an arbitrary amount. See the documentation for <a class="reference internal" href="generated/numpy.random.pcg64.advance.html#numpy.random.PCG64.advance" title="numpy.random.PCG64.advance"><code>advance</code></a>. PCG-64 has a period of <span class="math notranslate nohighlight">\(2^{128}\)</span>. See the <a class="reference external" href="https://www.pcg-random.org/">PCG author’s page</a> for more details about this class of PRNG.</li> <li>PCG-64 DXSM - An upgraded version of PCG-64 with better statistical properties in parallel contexts. See <a class="reference internal" href="../upgrading-pcg64.html#upgrading-pcg64"><span class="std std-ref">Upgrading PCG64 with PCG64DXSM</span></a> for more information on these improvements.</li> <li>MT19937 - The standard Python BitGenerator. Adds a <a class="reference internal" href="generated/numpy.random.mt19937.jumped.html#numpy.random.MT19937.jumped" title="numpy.random.MT19937.jumped"><code>MT19937.jumped</code></a> function that returns a new generator with state as-if <span class="math notranslate nohighlight">\(2^{128}\)</span> draws have been made.</li> <li>Philox - A counter-based generator capable of being advanced an arbitrary number of steps or generating independent streams. See the <a class="reference external" href="https://www.deshawresearch.com/resources_random123.html">Random123</a> page for more details about this class of bit generators.</li> <li>SFC64 - A fast generator based on random invertible mappings. Usually the fastest generator of the four. See the <a class="reference external" href="https://pracrand.sourceforge.net/RNG_engines.txt">SFC author’s page</a> for (a little) more detail.</li> </ul> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>([seed])</p></td> <td><p>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</p></td> </tr>  </table> </div>  <ul> <li class="toctree-l1"><a class="reference internal" href="mt19937.html">MT19937</a></li> <li class="toctree-l1"><a class="reference internal" href="pcg64.html">PCG64</a></li> <li class="toctree-l1"><a class="reference internal" href="pcg64dxsm.html">PCG64DXSM</a></li> <li class="toctree-l1"><a class="reference internal" href="philox.html">Philox</a></li> <li class="toctree-l1"><a class="reference internal" href="sfc64.html">SFC64</a></li> </ul>  </section> </section> <section id="seeding-and-entropy"> <h1 id="id1">Seeding and entropy</h1> <p>A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a>, which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states.</p> <pre data-language="python">from numpy.random import PCG64

bg = PCG64(12345678903141592653589793)
</pre> <p><a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> is designed to be convenient for implementing best practices. We recommend that a stochastic program defaults to using entropy from the OS so that each run is different. The program should print out or log that entropy. In order to reproduce a past value, the program should allow the user to provide that value through some mechanism, a command-line argument is common, so that the user can then re-enter that entropy to reproduce the result. <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> can take care of everything except for communicating with the user, which is up to you.</p> <pre data-language="python">from numpy.random import PCG64, SeedSequence

# Get the user's seed somehow, maybe through `argparse`.
# If the user did not provide a seed, it should return `None`.
seed = get_user_seed()
ss = SeedSequence(seed)
print('seed = {}'.format(ss.entropy))
bg = PCG64(ss)
</pre> <p>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</p> <p>There will not be anything <em>wrong</em> with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> does. If you just need <em>some</em> fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</p> <p>If you need to generate a good seed “offline”, then <code>SeedSequence().entropy</code> or using <code>secrets.randbits(128)</code> from the standard library are both convenient ways.</p> <p>If you need to run several stochastic simulations in parallel, best practice is to construct a random generator instance for each simulation. To make sure that the random streams have distinct initial states, you can use the <code>spawn</code> method of <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a>. For instance, here we construct a list of 12 instances:</p> <pre data-language="python">from numpy.random import PCG64, SeedSequence

# High quality initial entropy
entropy = 0x87351080e25cb0fad77a44a3be03b491
base_seq = SeedSequence(entropy)
child_seqs = base_seq.spawn(12)    # a list of 12 SeedSequences
generators = [PCG64(seq) for seq in child_seqs]
</pre> <p>If you already have an initial random generator instance, you can shorten the above by using the <a class="reference internal" href="generated/numpy.random.bitgenerator.spawn.html#numpy.random.BitGenerator.spawn" title="numpy.random.BitGenerator.spawn"><code>spawn</code></a> method:</p> <pre data-language="python">from numpy.random import PCG64, SeedSequence
# High quality initial entropy
entropy = 0x87351080e25cb0fad77a44a3be03b491
base_bitgen = PCG64(entropy)
generators = base_bitgen.spawn(12)
</pre> <p>An alternative way is to use the fact that a <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> can be initialized by a tuple of elements. Here we use a base entropy value and an integer <code>worker_id</code></p> <pre data-language="python">from numpy.random import PCG64, SeedSequence

# High quality initial entropy
entropy = 0x87351080e25cb0fad77a44a3be03b491
sequences = [SeedSequence((entropy, worker_id)) for worker_id in range(12)]
generators = [PCG64(seq) for seq in sequences]
</pre> <p>Note that the sequences produced by the latter method will be distinct from those constructed via <a class="reference internal" href="generated/numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>spawn</code></a>.</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a>([entropy, spawn_key, pool_size])</p></td> <td><p>SeedSequence mixes sources of entropy in a reproducible way to set the initial state for independent and very probably non-overlapping BitGenerators.</p></td> </tr>  </table> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/random/bit_generators/index.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/random/bit_generators/index.html</a>
  </p>
</div>
