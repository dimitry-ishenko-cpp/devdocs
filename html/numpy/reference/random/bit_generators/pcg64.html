<h1>Permuted Congruential Generator (64-bit, PCG64)</h1> <dl class="py class"> <dt class="sig sig-object py" id="numpy.random.PCG64"> <em class="property">class</em><span class="sig-prename descclassname">numpy.random.</span><span class="sig-name descname">PCG64</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>BitGenerator for the PCG-64 pseudo-random number generator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>seed</strong><span class="classifier">{None, int, array_like[ints], SeedSequence}, optional</span>
</dt>
<dd>
<p>A seed to initialize the <a class="reference internal" href="generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>. If None, then fresh, unpredictable entropy will be pulled from the OS. If an <code>int</code> or <code>array_like[ints]</code> is passed, then it will be passed to <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to derive the initial <a class="reference internal" href="generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> state. One may also pass in a <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> instance.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>PCG-64 is a 128-bit implementation of O’Neill’s permutation congruential generator (<a class="reference internal" href="#r4523891264fe-1" id="id1">[1]</a>, <a class="reference internal" href="#r4523891264fe-2" id="id2">[2]</a>). PCG-64 has a period of <span class="math notranslate nohighlight">\(2^{128}\)</span> and supports advancing an arbitrary number of steps as well as <span class="math notranslate nohighlight">\(2^{127}\)</span> streams. The specific member of the PCG family that we use is PCG XSL RR 128/64 as described in the paper (<a class="reference internal" href="#r4523891264fe-2" id="id3">[2]</a>).</p> <p><code>PCG64</code> provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers. These are not directly consumable in Python and must be consumed by a <code>Generator</code> or similar object that supports low-level access.</p> <p>Supports the method <a class="reference internal" href="generated/numpy.random.pcg64.advance.html#numpy.random.PCG64.advance" title="numpy.random.PCG64.advance"><code>advance</code></a> to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</p> <p><strong>State and Seeding</strong></p> <p>The <code>PCG64</code> state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</p> <p>The input seed is processed by <a class="reference internal" href="generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to generate both values. The increment is not independently settable.</p> <p><strong>Parallel Features</strong></p> <p>The preferred way to use a BitGenerator in parallel applications is to use the <a class="reference internal" href="generated/numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a> method to obtain entropy values, and to use these to generate new BitGenerators:</p> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, PCG64, SeedSequence
&gt;&gt;&gt; sg = SeedSequence(1234)
&gt;&gt;&gt; rg = [Generator(PCG64(s)) for s in sg.spawn(10)]
</pre> <p><strong>Compatibility Guarantee</strong></p> <p><code>PCG64</code> makes a guarantee that a fixed seed will always produce the same random integer stream.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4523891264fe-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p><a class="reference external" href="http://www.pcg-random.org/">“PCG, A Family of Better Random Number Generators”</a></p> </dd> <dt class="label" id="r4523891264fe-2">
<span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span>
</dt> <dd>
<p>O’Neill, Melissa E. <a class="reference external" href="https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf">“PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation”</a></p> </dd> </dl> </dd>
</dl> <section id="state"> <h2>State</h2> <table class="autosummary longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.pcg64.state.html#numpy.random.PCG64.state" title="numpy.random.PCG64.state"><code>state</code></a></p></td> <td><p>Get or set the PRNG state</p></td> </tr>  </table> </section> <section id="parallel-generation"> <h2>Parallel generation</h2> <table class="autosummary longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.pcg64.advance.html#numpy.random.PCG64.advance" title="numpy.random.PCG64.advance"><code>advance</code></a>(delta)</p></td> <td><p>Advance the underlying RNG as-if delta draws have occurred.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.random.pcg64.jumped.html#numpy.random.PCG64.jumped" title="numpy.random.PCG64.jumped"><code>jumped</code></a>([jumps])</p></td> <td><p>Returns a new bit generator with the state jumped.</p></td> </tr>  </table> </section> <section id="extending"> <h2>Extending</h2> <table class="autosummary longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.pcg64.cffi.html#numpy.random.PCG64.cffi" title="numpy.random.PCG64.cffi"><code>cffi</code></a></p></td> <td><p>CFFI interface</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.random.pcg64.ctypes.html#numpy.random.PCG64.ctypes" title="numpy.random.PCG64.ctypes"><code>ctypes</code></a></p></td> <td><p>ctypes interface</p></td> </tr>  </table> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/random/bit_generators/pcg64.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/random/bit_generators/pcg64.html</a>
  </p>
</div>
