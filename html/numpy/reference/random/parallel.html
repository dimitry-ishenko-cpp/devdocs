<section id="parallel-random-number-generation"> <h1>Parallel random number generation</h1> <p>There are four main strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</p> <section id="seedsequence-spawning"> <h2 id="seedsequence-spawn">SeedSequence spawning</h2> <p>NumPy allows you to spawn new (with very high probability) independent <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> and <a class="reference internal" href="generator.html#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> instances via their <code>spawn()</code> method. This spawning is implemented by the <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> used for initializing the bit generators random stream.</p> <p><a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> <a class="reference external" href="https://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html">implements an algorithm</a> to process a user-provided seed, typically as an integer of some size, and to convert it into an initial state for a <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>. It uses hashing techniques to ensure that low-quality seeds are turned into high quality initial states (at least, with very high probability).</p> <p>For example, <a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a> has a state consisting of 624 <code>uint32</code> integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for <a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a>, but not a good one. The Mersenne Twister algorithm <a class="reference external" href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/MT2002/emt19937ar.html">suffers if there are too many 0s</a>. Similarly, two adjacent 32-bit integer seeds (i.e. <code>12345</code> and <code>12346</code>) would produce very similar streams.</p> <p><a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> avoids these problems by using successions of integer hashes with good <a class="reference external" href="https://en.wikipedia.org/wiki/Avalanche_effect">avalanche properties</a> to ensure that flipping any bit in the input has about a 50% chance of flipping any bit in the output. Two input seeds that are very close to each other will produce initial states that are very far from each other (with very high probability). It is also constructed in such a way that you can provide arbitrary-sized integers or lists of integers. <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> will take all of the bits that you provide and mix them together to produce however many bits the consuming <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> needs to initialize itself.</p> <p>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator.html#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse. Note that while <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> attempts to solve many of the issues related to user-provided small seeds, we still <a class="reference internal" href="index.html#recommend-secrets-randbits"><span class="std std-ref">recommend</span></a> using <a class="reference external" href="https://docs.python.org/3/library/secrets.html#secrets.randbits" title="(in Python v3.12)"><code>secrets.randbits</code></a> to generate seeds with 128 bits of entropy to avoid the remaining biases introduced by human-chosen seeds.</p> <pre data-language="python">from numpy.random import SeedSequence, default_rng

ss = SeedSequence(12345)

# Spawn off 10 child SeedSequences to pass to child processes.
child_seeds = ss.spawn(10)
streams = [default_rng(s) for s in child_seeds]
</pre> <p>For convenience the direct use of <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> is not necessary. The above <code>streams</code> can be spawned directly from a parent generator via <a class="reference internal" href="generated/numpy.random.generator.spawn.html#numpy.random.Generator.spawn" title="numpy.random.Generator.spawn"><code>spawn</code></a>:</p> <pre data-language="python">parent_rng = default_rng(12345)
streams = parent_rng.spawn(10)
</pre> <p>Child objects can also spawn to make grandchildren, and so on. Each child has a <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> with its position in the tree of spawned child objects mixed in with the user-provided seed to generate independent (with very high probability) streams.</p> <pre data-language="python">grandchildren = streams[0].spawn(4)
</pre> <p>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general “tree-hashing” scheme is <a class="reference external" href="https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf">not unique to numpy</a> but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</p> <p>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (<a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>), will be about <span class="math notranslate nohighlight">\(n^2*2^{-128}\)</span> where <code>n</code> is the number of streams spawned. If a program uses an aggressive million streams, about <span class="math notranslate nohighlight">\(2^{20}\)</span>, then the probability that at least one pair of them are identical is about <span class="math notranslate nohighlight">\(2^{-88}\)</span>, which is in solidly-ignorable territory (<a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>).</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id3" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it’s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</p> </aside> <aside class="footnote brackets" id="id4" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span> <p>In this calculation, we can mostly ignore the amount of numbers drawn from each stream. See <a class="reference internal" href="upgrading-pcg64.html#upgrading-pcg64"><span class="std std-ref">Upgrading PCG64 with PCG64DXSM</span></a> for the technical details about <a class="reference internal" href="bit_generators/pcg64.html#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a>. The other PRNGs we provide have some extra protection built in that avoids overlaps if the <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> pools differ in the slightest bit. <a class="reference internal" href="bit_generators/pcg64dxsm.html#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a> has <span class="math notranslate nohighlight">\(2^{127}\)</span> separate cycles determined by the seed in addition to the position in the <span class="math notranslate nohighlight">\(2^{128}\)</span> long period for each cycle, so one has to both get on or near the same cycle <em>and</em> seed a nearby position in the cycle. <a class="reference internal" href="bit_generators/philox.html#numpy.random.Philox" title="numpy.random.Philox"><code>Philox</code></a> has completely independent cycles determined by the seed. <a class="reference internal" href="bit_generators/sfc64.html#numpy.random.SFC64" title="numpy.random.SFC64"><code>SFC64</code></a> incorporates a 64-bit counter so every unique seed is at least <span class="math notranslate nohighlight">\(2^{64}\)</span> iterations away from any other seed. And finally, <a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a> has just an unimaginably huge period. Getting a collision internal to <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> is the way a failure would be observed.</p> </aside> </aside> </section> <section id="sequence-of-integer-seeds"> <h2 id="sequence-of-seeds">Sequence of integer seeds</h2> <p>As discussed in the previous section, <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.html#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> can not only take an integer seed, it can also take an arbitrary-length sequence of (non-negative) integers. If one exercises a little care, one can use this feature to design <em>ad hoc</em> schemes for getting safe parallel PRNG streams with similar safety guarantees as spawning.</p> <p>For example, one common use case is that a worker process is passed one root seed integer for the whole calculation and also an integer worker ID (or something more granular like a job ID, batch ID, or something similar). If these IDs are created deterministically and uniquely, then one can derive reproducible parallel PRNG streams by combining the ID and the root seed integer in a list.</p> <pre data-language="python"># default_rng() and each of the BitGenerators use SeedSequence underneath, so
# they all accept sequences of integers as seeds the same way.
from numpy.random import default_rng

def worker(root_seed, worker_id):
    rng = default_rng([worker_id, root_seed])
    # Do work ...

root_seed = 0x8c3c010cb4754c905776bdac5ee7501
results = [worker(root_seed, worker_id) for worker_id in range(10)]
</pre> <p>This can be used to replace a number of unsafe strategies that have been used in the past which try to combine the root seed and the ID back into a single integer seed value. For example, it is common to see users add the worker ID to the root seed, especially with the legacy <a class="reference internal" href="legacy.html#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a> code.</p> <pre data-language="python"># UNSAFE! Do not do this!
worker_seed = root_seed + worker_id
rng = np.random.RandomState(worker_seed)
</pre> <p>It is true that for any one run of a parallel program constructed this way, each worker will have distinct streams. However, it is quite likely that multiple invocations of the program with different seeds will get overlapping sets of worker seeds. It is not uncommon (in the author’s self-experience) to change the root seed merely by an increment or two when doing these repeat runs. If the worker seeds are also derived by small increments of the worker ID, then subsets of the workers will return identical results, causing a bias in the overall ensemble of results.</p> <p>Combining the worker ID and the root seed as a list of integers eliminates this risk. Lazy seeding practices will still be fairly safe.</p> <p>This scheme does require that the extra IDs be unique and deterministically created. This may require coordination between the worker processes. It is recommended to place the varying IDs <em>before</em> the unvarying root seed. <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.spawn.html#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>spawn</code></a> <em>appends</em> integers after the user-provided seed, so if you might be mixing both this <em>ad hoc</em> mechanism and spawning, or passing your objects down to library code that might be spawning, then it is a little bit safer to prepend your worker IDs rather than append them to avoid a collision.</p> <pre data-language="python"># Good.
worker_seed = [worker_id, root_seed]

# Less good. It will *work*, but it's less flexible.
worker_seed = [root_seed, worker_id]
</pre> <p>With those caveats in mind, the safety guarantees against collision are about the same as with spawning, discussed in the previous section. The algorithmic mechanisms are the same.</p> </section> <section id="independent-streams"> <h2 id="id5">Independent streams</h2> <p><a class="reference internal" href="bit_generators/philox.html#numpy.random.Philox" title="numpy.random.Philox"><code>Philox</code></a> is a counter-based RNG based which generates values by encrypting an incrementing counter using weak cryptographic primitives. The seed determines the key that is used for the encryption. Unique keys create unique, independent streams. <a class="reference internal" href="bit_generators/philox.html#numpy.random.Philox" title="numpy.random.Philox"><code>Philox</code></a> lets you bypass the seeding algorithm to directly set the 128-bit key. Similar, but different, keys will still create independent streams.</p> <pre data-language="python">import secrets
from numpy.random import Philox

# 128-bit number as a seed
root_seed = secrets.getrandbits(128)
streams = [Philox(key=root_seed + stream_id) for stream_id in range(10)]
</pre> <p>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</p> </section> <section id="jumping-the-bitgenerator-state"> <h2 id="parallel-jumped">Jumping the BitGenerator state</h2> <p><code>jumped</code> advances the state of the BitGenerator <em>as-if</em> a large number of random numbers have been drawn, and returns a new instance with this state. The specific number of draws varies by BitGenerator, and ranges from <span class="math notranslate nohighlight">\(2^{64}\)</span> to <span class="math notranslate nohighlight">\(2^{128}\)</span>. Additionally, the <em>as-if</em> draws also depend on the size of the default random number produced by the specific BitGenerator. The BitGenerators that support <code>jumped</code>, along with the period of the BitGenerator, the size of the jump and the bits in the default unsigned random are listed below.</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>BitGenerator</p></th> <th class="head"><p>Period</p></th> <th class="head"><p>Jump Size</p></th> <th class="head"><p>Bits per Draw</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="bit_generators/mt19937.html#numpy.random.MT19937" title="numpy.random.MT19937"><code>MT19937</code></a></p></td> <td><p><span class="math notranslate nohighlight">\(2^{19937}-1\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(2^{128}\)</span></p></td> <td><p>32</p></td> </tr> <tr>
<td><p><a class="reference internal" href="bit_generators/pcg64.html#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a></p></td> <td><p><span class="math notranslate nohighlight">\(2^{128}\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(~2^{127}\)</span> (<a class="footnote-reference brackets" href="#id8" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>)</p></td> <td><p>64</p></td> </tr> <tr>
<td><p><a class="reference internal" href="bit_generators/pcg64dxsm.html#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a></p></td> <td><p><span class="math notranslate nohighlight">\(2^{128}\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(~2^{127}\)</span> (<a class="footnote-reference brackets" href="#id8" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>)</p></td> <td><p>64</p></td> </tr> <tr>
<td><p><a class="reference internal" href="bit_generators/philox.html#numpy.random.Philox" title="numpy.random.Philox"><code>Philox</code></a></p></td> <td><p><span class="math notranslate nohighlight">\(2^{256}\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(2^{128}\)</span></p></td> <td><p>64</p></td> </tr>  </table> </div> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id8" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id7">2</a>)</span> <p>The jump size is <span class="math notranslate nohighlight">\((\phi-1)*2^{128}\)</span> where <span class="math notranslate nohighlight">\(\phi\)</span> is the golden ratio. As the jumps wrap around the period, the actual distances between neighboring streams will slowly grow smaller than the jump size, but using the golden ratio this way is a classic method of constructing a low-discrepancy sequence that spreads out the states around the period optimally. You will not be able to jump enough to make those distances small enough to overlap in your lifetime.</p> </aside> </aside> <p><code>jumped</code> can be used to produce long blocks which should be long enough to not overlap.</p> <pre data-language="python">import secrets
from numpy.random import PCG64

seed = secrets.getrandbits(128)
blocked_rng = []
rng = PCG64(seed)
for i in range(10):
    blocked_rng.append(rng.jumped(i))
</pre> <p>When using <code>jumped</code>, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use <code>blocked_rng[0].jumped()</code> as it would overlap with <code>blocked_rng[1]</code>. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with <code>range(10, 20)</code>, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/random/parallel.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/random/parallel.html</a>
  </p>
</div>
