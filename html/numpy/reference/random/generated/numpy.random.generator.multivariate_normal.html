<section id="numpy-random-generator-multivariate-normal"> <h1>numpy.random.Generator.multivariate_normal</h1> <p>method</p> <dl class="py method"> <dt class="sig sig-object py" id="numpy.random.Generator.multivariate_normal"> <span class="sig-prename descclassname">random.Generator.</span><span class="sig-name descname">multivariate_normal</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">mean</span></em>, <em class="sig-param"><span class="n">cov</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check_valid</span><span class="o">=</span><span class="default_value">'warn'</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-8</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'svd'</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Draw random samples from a multivariate normal distribution.</p> <p>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or “center”) and variance (the squared standard deviation, or “width”) of the one-dimensional normal distribution.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>mean</strong><span class="classifier">1-D array_like, of length N</span>
</dt>
<dd>
<p>Mean of the N-dimensional distribution.</p> </dd> <dt>
<strong>cov</strong><span class="classifier">2-D array_like, of shape (N, N)</span>
</dt>
<dd>
<p>Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling.</p> </dd> <dt>
<strong>size</strong><span class="classifier">int or tuple of ints, optional</span>
</dt>
<dd>
<p>Given a shape of, for example, <code>(m,n,k)</code>, <code>m*n*k</code> samples are generated, and packed in an <code>m</code>-by-<code>n</code>-by-<code>k</code> arrangement. Because each sample is <code>N</code>-dimensional, the output shape is <code>(m,n,k,N)</code>. If no shape is specified, a single (<code>N</code>-D) sample is returned.</p> </dd> <dt>
<strong>check_valid</strong><span class="classifier">{ ‘warn’, ‘raise’, ‘ignore’ }, optional</span>
</dt>
<dd>
<p>Behavior when the covariance matrix is not positive semidefinite.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</p> </dd> <dt>
<strong>method</strong><span class="classifier">{ ‘svd’, ‘eigh’, ‘cholesky’}, optional</span>
</dt>
<dd>
<p>The cov input is used to compute a factor matrix A such that <code>A @ A.T = cov</code>. This argument is used to select the method used to compute the factor matrix A. The default method ‘svd’ is the slowest, while ‘cholesky’ is the fastest but less robust than the slowest method. The method <code>eigh</code> uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.18.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>out</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>The drawn samples, of shape <em>size</em>, if that was provided. If not, the shape is <code>(N,)</code>.</p> <p>In other words, each entry <code>out[i,j,...,:]</code> is an N-dimensional value drawn from the distribution.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</p> <p>Covariance indicates the level to which two variables vary together. From the multivariate normal distribution, we draw N-dimensional samples, <span class="math notranslate nohighlight">\(X = [x_1, x_2, ... x_N]\)</span>. The covariance matrix element <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the covariance of <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The element <span class="math notranslate nohighlight">\(C_{ii}\)</span> is the variance of <span class="math notranslate nohighlight">\(x_i\)</span> (i.e. its “spread”).</p> <p>Instead of specifying the full covariance matrix, popular approximations include:</p> <ul class="simple"> <li>Spherical covariance (<a class="reference internal" href="../../generated/numpy.cov.html#numpy.cov" title="numpy.cov"><code>cov</code></a> is a multiple of the identity matrix)</li> <li>Diagonal covariance (<a class="reference internal" href="../../generated/numpy.cov.html#numpy.cov" title="numpy.cov"><code>cov</code></a> has non-negative elements, and only on the diagonal)</li> </ul> <p>This geometrical property can be seen in two dimensions by plotting generated data-points:</p> <pre data-language="python">&gt;&gt;&gt; mean = [0, 0]
&gt;&gt;&gt; cov = [[1, 0], [0, 100]]  # diagonal covariance
</pre> <p>Diagonal covariance means that points are oriented along x or y-axis:</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x, y = rng.multivariate_normal(mean, cov, 5000).T
&gt;&gt;&gt; plt.plot(x, y, 'x')
&gt;&gt;&gt; plt.axis('equal')
&gt;&gt;&gt; plt.show()
</pre> <p>Note that the covariance matrix must be positive semidefinite (a.k.a. nonnegative-definite). Otherwise, the behavior of this method is undefined and backwards compatibility is not guaranteed.</p> <p>This function internally uses linear algebra routines, and thus results may not be identical (even up to precision) across architectures, OSes, or even builds. For example, this is likely if <code>cov</code> has multiple equal singular values and <code>method</code> is <code>'svd'</code> (default). In this case, <code>method='cholesky'</code> may be more robust.</p> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r73135c1078a9-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p>Papoulis, A., “Probability, Random Variables, and Stochastic Processes,” 3rd ed., New York: McGraw-Hill, 1991.</p> </div> <div class="citation" id="r73135c1078a9-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p>Duda, R. O., Hart, P. E., and Stork, D. G., “Pattern Classification,” 2nd ed., New York: Wiley, 2001.</p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; mean = (1, 2)
&gt;&gt;&gt; cov = [[1, 0], [0, 1]]
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = rng.multivariate_normal(mean, cov, (3, 3))
&gt;&gt;&gt; x.shape
(3, 3, 2)
</pre> <p>We can use a different method other than the default to factorize cov:</p> <pre data-language="python">&gt;&gt;&gt; y = rng.multivariate_normal(mean, cov, (3, 3), method='cholesky')
&gt;&gt;&gt; y.shape
(3, 3, 2)
</pre> <p>Here we generate 800 samples from the bivariate normal distribution with mean [0, 0] and covariance matrix [[6, -3], [-3, 3.5]]. The expected variances of the first and second components of the sample are 6 and 3.5, respectively, and the expected correlation coefficient is -3/sqrt(6*3.5) ≈ -0.65465.</p> <pre data-language="python">&gt;&gt;&gt; cov = np.array([[6, -3], [-3, 3.5]])
&gt;&gt;&gt; pts = rng.multivariate_normal([0, 0], cov, size=800)
</pre> <p>Check that the mean, covariance, and correlation coefficient of the sample are close to the expected values:</p> <pre data-language="python">&gt;&gt;&gt; pts.mean(axis=0)
array([ 0.0326911 , -0.01280782])  # may vary
&gt;&gt;&gt; np.cov(pts.T)
array([[ 5.96202397, -2.85602287],
       [-2.85602287,  3.47613949]])  # may vary
&gt;&gt;&gt; np.corrcoef(pts.T)[0, 1]
-0.6273591314603949  # may vary
</pre> <p>We can visualize this data with a scatter plot. The orientation of the point cloud illustrates the negative correlation of the components of this sample.</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(pts[:, 0], pts[:, 1], '.', alpha=0.5)
&gt;&gt;&gt; plt.axis('equal')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.show()
</pre> <figure class="align-default"> <img alt="../../../_images/numpy-random-Generator-multivariate_normal-1.png" class="plot-directive" src="data:image/png;base64,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"> </figure> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/random/generated/numpy.random.Generator.multivariate_normal.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/random/generated/numpy.random.Generator.multivariate_normal.html</a>
  </p>
</div>
