<section id="numpy-2-0-migration-guide"> <h1 id="numpy-2-migration-guide">NumPy 2.0 migration guide</h1> <p>This document contains a set of instructions on how to update your code to work with NumPy 2.0. It covers changes in NumPy’s Python and C APIs.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Note that NumPy 2.0 also breaks binary compatibility - if you are distributing binaries for a Python package that depends on NumPy’s C API, please see <a class="reference internal" href="dev/depending_on_numpy.html#numpy-2-abi-handling"><span class="std std-ref">NumPy 2.0-specific advice</span></a>.</p> </div> <section id="ruff-plugin"> <h2>Ruff plugin</h2> <p>Many of the changes covered in the 2.0 release notes and in this migration guide can be automatically adapted in downstream code with a dedicated <a class="reference external" href="https://docs.astral.sh/ruff/">Ruff</a> rule, namely rule <a class="reference external" href="https://docs.astral.sh/ruff/rules/numpy2-deprecation/">NPY201</a>.</p> <p>You should install <code>ruff&gt;=0.4.8</code> and add the <code>NPY201</code> rule to your <code>pyproject.toml</code>:</p> <pre data-language="python">[tool.ruff.lint]
select = ["NPY201"]
</pre> <p>You can also apply the NumPy 2.0 rule directly from the command line:</p> <pre data-language="python">$ ruff check path/to/code/ --select NPY201
</pre> </section> <section id="changes-to-numpy-data-type-promotion"> <h2 id="migration-promotion-changes">Changes to NumPy data type promotion</h2> <p>NumPy 2.0 changes promotion (the result of combining dissimilar data types) as per <a class="reference external" href="https://numpy.org/neps/nep-0050-scalar-promotion.html#nep50" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 50</span></a>. Please see the NEP for details on this change. It includes a table of example changes and a backwards compatibility section.</p> <p>The largest backwards compatibility change is that the precision of scalars is now preserved consistently. Two examples are:</p> <ul class="simple"> <li>
<code>np.float32(3) + 3.</code> now returns a float32 when it previously returned a float64.</li> <li>
<code>np.array([3], dtype=np.float32) + np.float64(3)</code> will now return a float64 array. (The higher precision of the scalar is not ignored.)</li> </ul> <p>For floating point values, this can lead to lower precision results when working with scalars. For integers, errors or overflows are possible.</p> <p>To solve this, you may cast explicitly. Very often, it may also be a good solution to ensure you are working with Python scalars via <code>int()</code>, <code>float()</code>, or <code>numpy_scalar.item()</code>.</p> <p>To track down changes, you can enable emitting warnings for changed behavior (use <code>warnings.simplefilter</code> to raise it as an error for a traceback):</p> <pre data-language="python">np._set_promotion_state("weak_and_warn")
</pre> <p>which is useful during testing. Unfortunately, running this may flag many changes that are irrelevant in practice.</p> </section> <section id="windows-default-integer"> <h2 id="migration-windows-int64">Windows default integer</h2> <p>The default integer used by NumPy is now 64bit on all 64bit systems (and 32bit on 32bit system). For historic reasons related to Python 2 it was previously equivalent to the C <code>long</code> type. The default integer is now equivalent to <code>np.intp</code>.</p> <p>Most end-users should not be affected by this change. Some operations will use more memory, but some operations may actually become faster. If you experience issues due to calling a library written in a compiled language it may help to explicitly cast to a <code>long</code>, for example with: <code>arr = arr.astype("long", copy=False)</code>.</p> <p>Libraries interfacing with compiled code that are written in C, Cython, or a similar language may require updating to accommodate user input if they are using the <code>long</code> or equivalent type on the C-side. In this case, you may wish to use <code>intp</code> and cast user input or support both <code>long</code> and <code>intp</code> (to better support NumPy 1.x as well). When creating a new integer array in C or Cython, the new <code>NPY_DEFAULT_INT</code> macro will evaluate to either <code>NPY_LONG</code> or <code>NPY_INTP</code> depending on the NumPy version.</p> <p>Note that the NumPy random API is not affected by this change.</p> </section> <section id="c-api-changes"> <h2>C-API Changes</h2> <p>Some definitions were removed or replaced due to being outdated or unmaintainable. Some new API definitions will evaluate differently at runtime between NumPy 2.0 and NumPy 1.x. Some are defined in <code>numpy/_core/include/numpy/npy_2_compat.h</code> (for example <code>NPY_DEFAULT_INT</code>) which can be vendored in full or part to have the definitions available when compiling against NumPy 1.x.</p> <p>If necessary, <code>PyArray_RUNTIME_VERSION &gt;= NPY_2_0_API_VERSION</code> can be used to explicitly implement different behavior on NumPy 1.x and 2.0. (The compat header defines it in a way compatible with such use.)</p> <p>Please let us know if you require additional workarounds here.</p> <section id="the-pyarray-descr-struct-has-been-changed"> <h3 id="migration-c-descr">The <code>PyArray_Descr</code> struct has been changed</h3> <p>One of the most impactful C-API changes is that the <code>PyArray_Descr</code> struct is now more opaque to allow us to add additional flags and have itemsizes not limited by the size of <code>int</code> as well as allow improving structured dtypes in the future and not burden new dtypes with their fields.</p> <p>Code which only uses the type number and other initial fields is unaffected. Most code will hopefully mainly access the <code>-&gt;elsize</code> field, when the dtype/descriptor itself is attached to an array (e.g. <code>arr-&gt;descr-&gt;elsize</code>) this is best replaced with <code>PyArray_ITEMSIZE(arr)</code>.</p> <p>Where not possible, new accessor functions are required:</p> <ul class="simple"> <li>
<code>PyDataType_ELSIZE</code> and <code>PyDataType_SET_ELSIZE</code> (note that the result is now <code>npy_intp</code> and not <code>int</code>).</li> <li><code>PyDataType_ALIGNMENT</code></li> <li>
<code>PyDataType_FIELDS</code>, <code>PyDataType_NAMES</code>, <code>PyDataType_SUBARRAY</code>
</li> <li><code>PyDataType_C_METADATA</code></li> </ul> <p>Cython code should use Cython 3, in which case the change is transparent. (Struct access is available for elsize and alignment when compiling only for NumPy 2.)</p> <p>For compiling with both 1.x and 2.x if you use these new accessors it is unfortunately necessary to either define them locally via a macro like:</p> <pre data-language="python">#if NPY_ABI_VERSION &lt; 0x02000000
  #define PyDataType_ELSIZE(descr) ((descr)-&gt;elsize)
#endif
</pre> <p>or adding <code>npy2_compat.h</code> into your code base and explicitly include it when compiling with NumPy 1.x (as they are new API). Including the file has no effect on NumPy 2.</p> <p>Please do not hesitate to open a NumPy issue, if you require assistance or the provided functions are not sufficient.</p> <p><strong>Custom User DTypes:</strong> Existing user dtypes must now use <a class="reference internal" href="reference/c-api/types-and-structures.html#c.PyArray_DescrProto" title="PyArray_DescrProto"><code>PyArray_DescrProto</code></a> to define their dtype and slightly modify the code. See note in <a class="reference internal" href="reference/c-api/array.html#c.PyArray_RegisterDataType" title="PyArray_RegisterDataType"><code>PyArray_RegisterDataType</code></a>.</p> </section> <section id="functionality-moved-to-headers-requiring-import-array"> <h3>Functionality moved to headers requiring <code>import_array()</code>
</h3> <p>If you previously included only <code>ndarraytypes.h</code> you may find that some functionality is not available anymore and requires the inclusion of <code>ndarrayobject.h</code> or similar. This include is also needed when vendoring <code>npy_2_compat.h</code> into your own codebase to allow use of the new definitions when compiling with NumPy 1.x.</p> <p>Functionality which previously did not require import includes:</p> <ul class="simple"> <li>Functions to access dtype flags: <code>PyDataType_FLAGCHK</code>, <code>PyDataType_REFCHK</code>, and the related <code>NPY_BEGIN_THREADS_DESCR</code>.</li> <li>
<code>PyArray_GETITEM</code> and <code>PyArray_SETITEM</code>.</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is important that the <code>import_array()</code> mechanism is used to ensure that the full NumPy API is accessible when using the <code>npy_2_compat.h</code> header. In most cases your extension module probably already calls it. However, if not we have added <code>PyArray_ImportNumPyAPI()</code> as a preferable way to ensure the NumPy API is imported. This function is light-weight when called multiple times so that you may insert it wherever it may be needed (if you wish to avoid setting it up at module import).</p> </div> </section> <section id="increased-maximum-number-of-dimensions"> <h3 id="migration-maxdims">Increased maximum number of dimensions</h3> <p>The maximum number of dimensions (and arguments) was increased to 64. This affects the <code>NPY_MAXDIMS</code> and <code>NPY_MAXARGS</code> macros. It may be good to review their use, and we generally encourage you to not use these macros (especially <code>NPY_MAXARGS</code>), so that a future version of NumPy can remove this limitation on the number of dimensions.</p> <p><code>NPY_MAXDIMS</code> was also used to signal <code>axis=None</code> in the C-API, including the <code>PyArray_AxisConverter</code>. The latter will return <code>-2147483648</code> as an axis (the smallest integer value). Other functions may error with <code>AxisError: axis 64 is out of bounds for array of dimension</code> in which case you need to pass <code>NPY_RAVEL_AXIS</code> instead of <code>NPY_MAXDIMS</code>. <code>NPY_RAVEL_AXIS</code> is defined in the <code>npy_2_compat.h</code> header and runtime dependent (mapping to 32 on NumPy 1.x and <code>-2147483648</code> on NumPy 2.x).</p> </section> <section id="complex-types-underlying-type-changes"> <h3>Complex types - Underlying type changes</h3> <p>The underlying C types for all of the complex types have been changed to use native C99 types. While the memory layout of those types remains identical to the types used in NumPy 1.x, the API is slightly different, since direct field access (like <code>c.real</code> or <code>c.imag</code>) is no longer possible.</p> <p>It is recommended to use the functions <code>npy_creal</code> and <code>npy_cimag</code> (and the corresponding float and long double variants) to retrieve the real or imaginary part of a complex number, as these will work with both NumPy 1.x and with NumPy 2.x. New functions <code>npy_csetreal</code> and <code>npy_csetimag</code>, along with compatibility macros <code>NPY_CSETREAL</code> and <code>NPY_CSETIMAG</code> (and the corresponding float and long double variants), have been added for setting the real or imaginary part.</p> <p>The underlying type remains a struct under C++ (all of the above still remains valid).</p> <p>This has implications for Cython. It is recommened to always use the native typedefs <code>cfloat_t</code>, <code>cdouble_t</code>, <code>clongdouble_t</code> rather than the NumPy types <code>npy_cfloat</code>, etc, unless you have to interface with C code written using the NumPy types. You can still write cython code using the <code>c.real</code> and <code>c.imag</code> attributes (using the native typedefs), but you can no longer use in-place operators <code>c.imag += 1</code> in Cython’s c++ mode.</p> </section> </section> <section id="changes-to-namespaces"> <h2>Changes to namespaces</h2> <p>In NumPy 2.0 certain functions, modules, and constants were moved or removed to make the NumPy namespace more user-friendly by removing unnecessary or outdated functionality and clarifying which parts of NumPy are considered private. Please see the tables below for guidance on migration. For most changes this means replacing it with a backwards compatible alternative.</p> <p>Please refer to <a class="reference external" href="https://numpy.org/neps/nep-0052-python-api-cleanup.html">NEP 52</a> for more details.</p> <section id="main-namespace"> <h3>Main namespace</h3> <p>About 100 members of the main <code>np</code> namespace have been deprecated, removed, or moved to a new place. It was done to reduce clutter and establish only one way to access a given attribute. The table below shows members that have been removed:</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>removed member</p></th> <th class="head"><p>migration guideline</p></th> </tr> </thead>  <tr>
<td><p>add_docstring</p></td> <td><p>It’s still available as <code>np.lib.add_docstring</code>.</p></td> </tr> <tr>
<td><p>add_newdoc</p></td> <td><p>It’s still available as <code>np.lib.add_newdoc</code>.</p></td> </tr> <tr>
<td><p>add_newdoc_ufunc</p></td> <td><p>It’s an internal function and doesn’t have a replacement.</p></td> </tr> <tr>
<td><p>alltrue</p></td> <td><p>Use <code>all</code> instead.</p></td> </tr> <tr>
<td><p>asfarray</p></td> <td><p>Use <code>np.asarray</code> with a float dtype instead.</p></td> </tr> <tr>
<td><p>byte_bounds</p></td> <td><p>Now it’s available under <code>np.lib.array_utils.byte_bounds</code></p></td> </tr> <tr>
<td><p>cast</p></td> <td><p>Use <code>np.asarray(arr, dtype=dtype)</code> instead.</p></td> </tr> <tr>
<td><p>cfloat</p></td> <td><p>Use <code>np.complex128</code> instead.</p></td> </tr> <tr>
<td><p>clongfloat</p></td> <td><p>Use <code>np.clongdouble</code> instead.</p></td> </tr> <tr>
<td><p>compat</p></td> <td><p>There’s no replacement, as Python 2 is no longer supported.</p></td> </tr> <tr>
<td><p>complex_</p></td> <td><p>Use <code>np.complex128</code> instead.</p></td> </tr> <tr>
<td><p>cumproduct</p></td> <td><p>Use <code>np.cumprod</code> instead.</p></td> </tr> <tr>
<td><p>DataSource</p></td> <td><p>It’s still available as <code>np.lib.npyio.DataSource</code>.</p></td> </tr> <tr>
<td><p>deprecate</p></td> <td><p>Emit <code>DeprecationWarning</code> with <code>warnings.warn</code> directly, or use <code>typing.deprecated</code>.</p></td> </tr> <tr>
<td><p>deprecate_with_doc</p></td> <td><p>Emit <code>DeprecationWarning</code> with <code>warnings.warn</code> directly, or use <code>typing.deprecated</code>.</p></td> </tr> <tr>
<td><p>disp</p></td> <td><p>Use your own printing function instead.</p></td> </tr> <tr>
<td><p>fastCopyAndTranspose</p></td> <td><p>Use <code>arr.T.copy()</code> instead.</p></td> </tr> <tr>
<td><p>find_common_type</p></td> <td><p>Use <code>numpy.promote_types</code> or <code>numpy.result_type</code> instead. To achieve semantics for the <code>scalar_types</code> argument, use <code>numpy.result_type</code> and pass the Python values <code>0</code>, <code>0.0</code>, or <code>0j</code>.</p></td> </tr> <tr>
<td><p>get_array_wrap</p></td> <td></td> </tr> <tr>
<td><p>float_</p></td> <td><p>Use <code>np.float64</code> instead.</p></td> </tr> <tr>
<td><p>geterrobj</p></td> <td><p>Use the np.errstate context manager instead.</p></td> </tr> <tr>
<td><p>Inf</p></td> <td><p>Use <code>np.inf</code> instead.</p></td> </tr> <tr>
<td><p>Infinity</p></td> <td><p>Use <code>np.inf</code> instead.</p></td> </tr> <tr>
<td><p>infty</p></td> <td><p>Use <code>np.inf</code> instead.</p></td> </tr> <tr>
<td><p>issctype</p></td> <td><p>Use <code>issubclass(rep, np.generic)</code> instead.</p></td> </tr> <tr>
<td><p>issubclass_</p></td> <td><p>Use <code>issubclass</code> builtin instead.</p></td> </tr> <tr>
<td><p>issubsctype</p></td> <td><p>Use <code>np.issubdtype</code> instead.</p></td> </tr> <tr>
<td><p>mat</p></td> <td><p>Use <code>np.asmatrix</code> instead.</p></td> </tr> <tr>
<td><p>maximum_sctype</p></td> <td><p>Use a specific dtype instead. You should avoid relying on any implicit mechanism and select the largest dtype of a kind explicitly in the code.</p></td> </tr> <tr>
<td><p>NaN</p></td> <td><p>Use <code>np.nan</code> instead.</p></td> </tr> <tr>
<td><p>nbytes</p></td> <td><p>Use <code>np.dtype(&lt;dtype&gt;).itemsize</code> instead.</p></td> </tr> <tr>
<td><p>NINF</p></td> <td><p>Use <code>-np.inf</code> instead.</p></td> </tr> <tr>
<td><p>NZERO</p></td> <td><p>Use <code>-0.0</code> instead.</p></td> </tr> <tr>
<td><p>longcomplex</p></td> <td><p>Use <code>np.clongdouble</code> instead.</p></td> </tr> <tr>
<td><p>longfloat</p></td> <td><p>Use <code>np.longdouble</code> instead.</p></td> </tr> <tr>
<td><p>lookfor</p></td> <td><p>Search NumPy’s documentation directly.</p></td> </tr> <tr>
<td><p>obj2sctype</p></td> <td><p>Use <code>np.dtype(obj).type</code> instead.</p></td> </tr> <tr>
<td><p>PINF</p></td> <td><p>Use <code>np.inf</code> instead.</p></td> </tr> <tr>
<td><p>product</p></td> <td><p>Use <code>np.prod</code> instead.</p></td> </tr> <tr>
<td><p>PZERO</p></td> <td><p>Use <code>0.0</code> instead.</p></td> </tr> <tr>
<td><p>recfromcsv</p></td> <td><p>Use <code>np.genfromtxt</code> with comma delimiter instead.</p></td> </tr> <tr>
<td><p>recfromtxt</p></td> <td><p>Use <code>np.genfromtxt</code> instead.</p></td> </tr> <tr>
<td><p>round_</p></td> <td><p>Use <code>np.round</code> instead.</p></td> </tr> <tr>
<td><p>safe_eval</p></td> <td><p>Use <code>ast.literal_eval</code> instead.</p></td> </tr> <tr>
<td><p>sctype2char</p></td> <td><p>Use <code>np.dtype(obj).char</code> instead.</p></td> </tr> <tr>
<td><p>sctypes</p></td> <td><p>Access dtypes explicitly instead.</p></td> </tr> <tr>
<td><p>seterrobj</p></td> <td><p>Use the np.errstate context manager instead.</p></td> </tr> <tr>
<td><p>set_numeric_ops</p></td> <td><p>For the general case, use <code>PyUFunc_ReplaceLoopBySignature</code>. For ndarray subclasses, define the <code>__array_ufunc__</code> method and override the relevant ufunc.</p></td> </tr> <tr>
<td><p>set_string_function</p></td> <td><p>Use <code>np.set_printoptions</code> instead with a formatter for custom printing of NumPy objects.</p></td> </tr> <tr>
<td><p>singlecomplex</p></td> <td><p>Use <code>np.complex64</code> instead.</p></td> </tr> <tr>
<td><p>string_</p></td> <td><p>Use <code>np.bytes_</code> instead.</p></td> </tr> <tr>
<td><p>sometrue</p></td> <td><p>Use <code>any</code> instead.</p></td> </tr> <tr>
<td><p>source</p></td> <td><p>Use <code>inspect.getsource</code> instead.</p></td> </tr> <tr>
<td><p>tracemalloc_domain</p></td> <td><p>It’s now available from <code>np.lib</code>.</p></td> </tr> <tr>
<td><p>unicode_</p></td> <td><p>Use <code>np.str_</code> instead.</p></td> </tr> <tr>
<td><p>who</p></td> <td><p>Use an IDE variable explorer or <code>locals()</code> instead.</p></td> </tr>  </table> </div> <p>If the table doesn’t contain an item that you were using but was removed in <code>2.0</code>, then it means it was a private member. You should either use the existing API or, in case it’s infeasible, reach out to us with a request to restore the removed entry.</p> <p>The next table presents deprecated members, which will be removed in a release after <code>2.0</code>:</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>deprecated member</p></th> <th class="head"><p>migration guideline</p></th> </tr> </thead>  <tr>
<td><p>in1d</p></td> <td><p>Use <code>np.isin</code> instead.</p></td> </tr> <tr>
<td><p>row_stack</p></td> <td><p>Use <code>np.vstack</code> instead (<code>row_stack</code> was an alias for <code>vstack</code>).</p></td> </tr> <tr>
<td><p>trapz</p></td> <td><p>Use <code>np.trapezoid</code> or a <code>scipy.integrate</code> function instead.</p></td> </tr>  </table> </div> <p>Finally, a set of internal enums has been removed. As they weren’t used in downstream libraries we don’t provide any information on how to replace them:</p> <p>[<code>FLOATING_POINT_SUPPORT</code>, <code>FPE_DIVIDEBYZERO</code>, <code>FPE_INVALID</code>, <code>FPE_OVERFLOW</code>, <code>FPE_UNDERFLOW</code>, <code>UFUNC_BUFSIZE_DEFAULT</code>, <code>UFUNC_PYVALS_NAME</code>, <code>CLIP</code>, <code>WRAP</code>, <code>RAISE</code>, <code>BUFSIZE</code>, <code>ALLOW_THREADS</code>, <code>MAXDIMS</code>, <code>MAY_SHARE_EXACT</code>, <code>MAY_SHARE_BOUNDS</code>]</p> </section> <section id="numpy-lib-namespace"> <h3>numpy.lib namespace</h3> <p>Most of the functions available within <code>np.lib</code> are also present in the main namespace, which is their primary location. To make it unambiguous how to access each public function, <code>np.lib</code> is now empty and contains only a handful of specialized submodules, classes and functions:</p> <ul class="simple"> <li>
<code>array_utils</code>, <code>format</code>, <code>introspect</code>, <code>mixins</code>, <code>npyio</code> and <code>stride_tricks</code> submodules,</li> <li>
<code>Arrayterator</code> and <code>NumpyVersion</code> classes,</li> <li>
<code>add_docstring</code> and <code>add_newdoc</code> functions,</li> <li>
<code>tracemalloc_domain</code> constant.</li> </ul> <p>If you get an <code>AttributeError</code> when accessing an attribute from <code>np.lib</code> you should try accessing it from the main <code>np</code> namespace then. If an item is also missing from the main namespace, then you’re using a private member. You should either use the existing API or, in case it’s infeasible, reach out to us with a request to restore the removed entry.</p> </section> <section id="numpy-core-namespace"> <h3>numpy.core namespace</h3> <p>The <code>np.core</code> namespace is now officially private and has been renamed to <code>np._core</code>. The user should never fetch members from the <code>_core</code> directly - instead the main namespace should be used to access the attribute in question. The layout of the <code>_core</code> module might change in the future without notice, contrary to public modules which adhere to the deprecation period policy. If an item is also missing from the main namespace, then you should either use the existing API or, in case it’s infeasible, reach out to us with a request to restore the removed entry.</p> </section> <section id="ndarray-and-scalar-methods"> <h3>ndarray and scalar methods</h3> <p>A few methods from <code>np.ndarray</code> and <code>np.generic</code> scalar classes have been removed. The table below provides replacements for the removed members:</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>expired member</p></th> <th class="head"><p>migration guideline</p></th> </tr> </thead>  <tr>
<td><p>newbyteorder</p></td> <td><p>Use <code>arr.view(arr.dtype.newbyteorder(order))</code> instead.</p></td> </tr> <tr>
<td><p>ptp</p></td> <td><p>Use <code>np.ptp(arr, ...)</code> instead.</p></td> </tr> <tr>
<td><p>setitem</p></td> <td><p>Use <code>arr[index] = value</code> instead.</p></td> </tr>  </table> </div> </section> <section id="numpy-strings-namespace"> <h3>numpy.strings namespace</h3> <p>A new <a class="reference internal" href="reference/routines.strings.html#module-numpy.strings" title="numpy.strings"><code>numpy.strings</code></a> namespace has been created, where most of the string operations are implemented as ufuncs. The old <a class="reference internal" href="reference/routines.char.html#module-numpy.char" title="numpy.char"><code>numpy.char</code></a> namespace still is available, and, wherever possible, uses the new ufuncs for greater performance. We recommend using the <a class="reference internal" href="reference/routines.strings.html#module-numpy.strings" title="numpy.strings"><code>strings</code></a> functions going forward. The <a class="reference internal" href="reference/routines.char.html#module-numpy.char" title="numpy.char"><code>char</code></a> namespace may be deprecated in the future.</p> </section> </section> <section id="other-changes"> <h2>Other changes</h2> <section id="note-about-pickled-files"> <h3>Note about pickled files</h3> <p>NumPy 2.0 is designed to load pickle files created with NumPy 1.26, and vice versa. For versions 1.25 and earlier loading NumPy 2.0 pickle file will throw an exception.</p> </section> <section id="adapting-to-changes-in-the-copy-keyword"> <h3>Adapting to changes in the <code>copy</code> keyword</h3> <p>The <a class="reference internal" href="https://numpy.org/doc/2.0/release/2.0.0-notes.html#copy-keyword-changes-2-0"><span class="std std-ref">copy keyword behavior changes</span></a> in <a class="reference internal" href="reference/generated/numpy.asarray.html#numpy.asarray" title="numpy.asarray"><code>asarray</code></a>, <a class="reference internal" href="reference/generated/numpy.array.html#numpy.array" title="numpy.array"><code>array</code></a> and <a class="reference internal" href="reference/generated/numpy.ndarray.__array__.html#numpy.ndarray.__array__" title="numpy.ndarray.__array__"><code>ndarray.__array__</code></a> may require these changes:</p> <ul class="simple"> <li>Code using <code>np.array(..., copy=False)</code> can in most cases be changed to <code>np.asarray(...)</code>. Older code tended to use <code>np.array</code> like this because it had less overhead than the default <code>np.asarray</code> copy-if-needed behavior. This is no longer true, and <code>np.asarray</code> is the preferred function.</li> <li>For code that explicitly needs to pass <code>None</code>/<code>False</code> meaning “copy if needed” in a way that’s compatible with NumPy 1.x and 2.x, see <a class="reference external" href="https://github.com/scipy/scipy/pull/20172">scipy#20172</a> for an example of how to do so.</li> <li>
<p>For any <code>__array__</code> method on a non-NumPy array-like object, <code>dtype=None</code> and <code>copy=None</code> keywords must be added to the signature - this will work with older NumPy versions as well (although older numpy versions will never pass in <code>copy</code> keyword). If the keywords are added to the <code>__array__</code> signature, then for:</p> <ul> <li>
<code>copy=True</code> and any <code>dtype</code> value always return a new copy,</li> <li>
<code>copy=None</code> create a copy if required (for example by <code>dtype</code>),</li> <li>
<code>copy=False</code> a copy must never be made. If a copy is needed to return a numpy array or satisfy <code>dtype</code>, then raise an exception (<code>ValueError</code>).</li> </ul> </li> </ul> </section> <section id="writing-numpy-version-dependent-code"> <h3>Writing numpy-version-dependent code</h3> <p>It should be fairly rare to have to write code that explicitly branches on the <code>numpy</code> version - in most cases, code can be rewritten to be compatible with 1.x and 2.0 at the same time. However, if it is necessary, here is a suggested code pattern to use, using <a class="reference internal" href="reference/generated/numpy.lib.numpyversion.html#numpy.lib.NumpyVersion" title="numpy.lib.NumpyVersion"><code>numpy.lib.NumpyVersion</code></a>:</p> <pre data-language="python"># example with AxisError, which is no longer available in
# the main namespace in 2.0, and not available in the
# `exceptions` namespace in &lt;1.25.0 (example uses &lt;2.0.0b1
# for illustrative purposes):
if np.lib.NumpyVersion(np.__version__) &gt;= '2.0.0b1':
    from numpy.exceptions import AxisError
else:
    from numpy import AxisError
</pre> <p>This pattern will work correctly including with NumPy release candidates, which is important during the 2.0.0 release period.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/numpy_2_0_migration_guide.html" class="_attribution-link">https://numpy.org/doc/2.0/numpy_2_0_migration_guide.html</a>
  </p>
</div>
