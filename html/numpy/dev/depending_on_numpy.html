<section id="for-downstream-package-authors"> <h1 id="id1">For downstream package authors</h1> <p>This document aims to explain some best practices for authoring a package that depends on NumPy.</p> <section id="understanding-numpy-s-versioning-and-api-abi-stability"> <h2>Understanding NumPy’s versioning and API/ABI stability</h2> <p>NumPy uses a standard, <a class="pep reference external" href="https://peps.python.org/pep-0440/" id="index-0"><strong>PEP 440</strong></a> compliant, versioning scheme: <code>major.minor.bugfix</code>. A <em>major</em> release is highly unusual and if it happens it will most likely indicate an ABI break. NumPy 1.xx releases happened from 2006 to 2023; NumPy 2.0 in early 2024 is the first release which changed the ABI (minor ABI breaks for corner cases may have happened a few times in minor releases). <em>Minor</em> versions are released regularly, typically every 6 months. Minor versions contain new features, deprecations, and removals of previously deprecated code. <em>Bugfix</em> releases are made even more frequently; they do not contain any new features or deprecations.</p> <p>It is important to know that NumPy, like Python itself and most other well known scientific Python projects, does <strong>not</strong> use semantic versioning. Instead, backwards incompatible API changes require deprecation warnings for at least two releases. For more details, see <a class="reference external" href="https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23" title="(in NumPy Enhancement Proposals)"><span>NEP 23 — Backwards compatibility and deprecation policy</span></a>.</p> <p>NumPy has both a Python API and a C API. The C API can be used directly or via Cython, f2py, or other such tools. If your package uses the C API, then ABI (application binary interface) stability of NumPy is important. NumPy’s ABI is forward but not backward compatible. This means: binaries compiled against a given target version of NumPy’s C API will still run correctly with newer NumPy versions, but not with older versions.</p> </section> <section id="testing-against-the-numpy-main-branch-or-pre-releases"> <h2 id="testing-prereleases">Testing against the NumPy main branch or pre-releases</h2> <p>For large, actively maintained packages that depend on NumPy, we recommend testing against the development version of NumPy in CI. To make this easy, nightly builds are provided as wheels at <a class="reference external" href="https://anaconda.org/scientific-python-nightly-wheels/">https://anaconda.org/scientific-python-nightly-wheels/</a>. Example install command:</p> <pre data-language="python">pip install -U --pre --only-binary :all: -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple numpy
</pre> <p>This helps detect regressions in NumPy that need fixing before the next NumPy release. Furthermore, we recommend to raise errors on warnings in CI for this job, either all warnings or otherwise at least <code>DeprecationWarning</code> and <code>FutureWarning</code>. This gives you an early warning about changes in NumPy to adapt your code.</p> <p>If you want to test your own wheel builds against the latest NumPy nightly build and you’re using <code>cibuildwheel</code>, you may need something like this in your CI config file:</p> <pre data-language="python">CIBW_ENVIRONMENT: "PIP_PRE=1 PIP_EXTRA_INDEX_URL=https://pypi.anaconda.org/scientific-python-nightly-wheels/simple"
</pre> </section> <section id="adding-a-dependency-on-numpy"> <h2 id="depending-on-numpy">Adding a dependency on NumPy</h2> <section id="build-time-dependency"> <h3>Build-time dependency</h3> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Before NumPy 1.25, the NumPy C-API was <em>not</em> exposed in a backwards compatible way by default. This means that when compiling with a NumPy version earlier than 1.25 you have to compile with the oldest version you wish to support. This can be done by using <a class="reference external" href="https://github.com/scipy/oldest-supported-numpy/">oldest-supported-numpy</a>. Please see the <a class="reference external" href="https://numpy.org/doc/1.24/dev/depending_on_numpy.html">NumPy 1.24 documentation</a>.</p> </div> <p>If a package either uses the NumPy C API directly or it uses some other tool that depends on it like Cython or Pythran, NumPy is a <em>build-time</em> dependency of the package.</p> <p>By default, NumPy will expose an API that is backwards compatible with the oldest NumPy version that supports the currently oldest compatible Python version. NumPy 1.25.0 supports Python 3.9 and higher and NumPy 1.19 is the first version to support Python 3.9. Thus, we guarantee that, when using defaults, NumPy 1.25 will expose a C-API compatible with NumPy 1.19. (the exact version is set within NumPy-internal header files).</p> <p>NumPy is also forward compatible for all minor releases, but a major release will require recompilation (see NumPy 2.0-specific advice further down).</p> <p>The default behavior can be customized for example by adding:</p> <pre data-language="python">#define NPY_TARGET_VERSION NPY_1_22_API_VERSION
</pre> <p>before including any NumPy headers (or the equivalent <code>-D</code> compiler flag) in every extension module that requires the NumPy C-API. This is mainly useful if you need to use newly added API at the cost of not being compatible with older versions.</p> <p>If for some reason you wish to compile for the currently installed NumPy version by default you can add:</p> <pre data-language="python">#ifndef NPY_TARGET_VERSION
    #define NPY_TARGET_VERSION NPY_API_VERSION
#endif
</pre> <p>Which allows a user to override the default via <code>-DNPY_TARGET_VERSION</code>. This define must be consistent for each extension module (use of <code>import_array()</code>) and also applies to the umath module.</p> <p>When you compile against NumPy, you should add the proper version restrictions to your <code>pyproject.toml</code> (see PEP 517). Since your extension will not be compatible with a new major release of NumPy and may not be compatible with very old versions.</p> <p>For conda-forge packages, please see <a class="reference external" href="https://conda-forge.org/docs/maintainer/knowledge_base.html#building-against-numpy">here</a>.</p> <p>as of now, it is usually as easy as including:</p> <pre data-language="python">host:
  - numpy
run:
  - {{ pin_compatible('numpy') }}
</pre> </section> <section id="runtime-dependency-version-ranges"> <h3>Runtime dependency &amp; version ranges</h3> <p>NumPy itself and many core scientific Python packages have agreed on a schedule for dropping support for old Python and NumPy versions: <a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span>NEP 29 — Recommend Python and NumPy version support as a community policy standard</span></a>. We recommend all packages depending on NumPy to follow the recommendations in NEP 29.</p> <p>For <em>run-time dependencies</em>, specify version bounds using <code>install_requires</code> in <code>setup.py</code> (assuming you use <code>numpy.distutils</code> or <code>setuptools</code> to build).</p> <p>Most libraries that rely on NumPy will not need to set an upper version bound: NumPy is careful to preserve backward-compatibility.</p> <p>That said, if you are (a) a project that is guaranteed to release frequently, (b) use a large part of NumPy’s API surface, and (c) is worried that changes in NumPy may break your code, you can set an upper bound of <code>&lt;MAJOR.MINOR + N</code> with N no less than 3, and <code>MAJOR.MINOR</code> being the current release of NumPy <a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>*<span class="fn-bracket">]</span></a>. If you use the NumPy C API (directly or via Cython), you can also pin the current major version to prevent ABI breakage. Note that setting an upper bound on NumPy may <a class="reference external" href="https://iscinumpy.dev/post/bound-version-constraints/">affect the ability of your library to be installed alongside other, newer packages</a>.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id3" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">*</a><span class="fn-bracket">]</span></span> <p>The reason for setting <code>N=3</code> is that NumPy will, on the rare occasion where it makes breaking changes, raise warnings for at least two releases. (NumPy releases about once every six months, so this translates to a window of at least a year; hence the subsequent requirement that your project releases at least on that cadence.)</p> </aside> </aside> <div class="admonition note"> <p class="admonition-title">Note</p> <p>SciPy has more documentation on how it builds wheels and deals with its build-time and runtime dependencies <a class="reference external" href="https://scipy.github.io/devdocs/dev/core-dev/index.html#distributing">here</a>.</p> <p>NumPy and SciPy wheel build CI may also be useful as a reference, it can be found <a class="reference external" href="https://github.com/MacPython/numpy-wheels">here for NumPy</a> and <a class="reference external" href="https://github.com/MacPython/scipy-wheels">here for SciPy</a>.</p> </div> </section> <section id="numpy-2-0-specific-advice"> <h3 id="numpy-2-abi-handling">NumPy 2.0-specific advice</h3> <p>NumPy 2.0 is an ABI-breaking release, however it does contain support for building wheels that work on both 2.0 and 1.xx releases. It’s important to understand that:</p> <ol class="arabic simple"> <li>When you build wheels for your package using a NumPy 1.xx version at build time, those <strong>will not work</strong> with NumPy 2.0.</li> <li>When you build wheels for your package using a NumPy 2.x version at build time, those <strong>will work</strong> with NumPy 1.xx.</li> </ol> <p>The first time the NumPy ABI for 2.0 is guaranteed to be stable will be the release of the first release candidate for 2.0 (i.e., 2.0.0rc1). Our advice for handling your dependency on NumPy is as follows:</p> <ol class="arabic simple"> <li>In the main (development) branch of your package, do not add any constraints.</li> <li>If you rely on the NumPy C API (e.g. via direct use in C/C++, or via Cython code that uses NumPy), add a <code>numpy&lt;2.0</code> requirement in your package’s dependency metadata for releases / in release branches. Do this until numpy <code>2.0.0rc1</code> is released and you can target that. <em>Rationale: the NumPy C ABI will change in 2.0, so any compiled extension modules that rely on NumPy will break; they need to be recompiled.</em>
</li> <li>If you rely on a large API surface from NumPy’s Python API, also consider adding the same <code>numpy&lt;2.0</code> requirement to your metadata until you are sure your code is updated for changes in 2.0 (i.e., when you’ve tested things work against <code>2.0.0rc1</code>). <em>Rationale: we will do a significant API cleanup, with many aliases and deprecated/non-recommended objects being removed (see, e.g.,</em> <a class="reference internal" href="../numpy_2_0_migration_guide.html#numpy-2-migration-guide"><span class="std std-ref">NumPy 2.0 migration guide</span></a> <em>and</em> <a class="reference external" href="https://numpy.org/neps/nep-0052-python-api-cleanup.html#nep52" title="(in NumPy Enhancement Proposals)"><span>NEP 52 — Python API cleanup for NumPy 2.0</span></a>), <em>so unless you only use modern/recommended functions and objects, your code is likely to require at least some adjustments.</em>
</li> <li>Plan to do a release of your own packages which depend on <code>numpy</code> shortly after the first NumPy 2.0 release candidate is released (probably around 1 Feb 2024). <em>Rationale: at that point, you can release packages that will work with both 2.0 and 1.X, and hence your own end users will not be seeing much/any disruption (you want</em> <code>pip install mypackage</code> <em>to continue working on the day NumPy 2.0 is released).</em>
</li> <li>Once <code>2.0.0rc1</code> is available, you can adjust your metadata in <code>pyproject.toml</code> in the way outlined below.</li> </ol> <p>There are two cases: you need to keep compatibility with numpy 1.xx while also supporting 2.0, or you are able to drop numpy 1.xx support for new releases of your package and support &gt;=2.0 only. The latter is simpler, but may be more restrictive for your users. In that case, simply add <code>numpy&gt;=2.0</code> (or <code>numpy&gt;=2.0.0rc1</code>) to your build and runtime requirements and you’re good to go. We’ll focus on the “keep compatibility with 1.xx and 2.x” now, which is a little more involved.</p> <p><em>Example for a package using the NumPy C API (via C/Cython/etc.) which wants to support NumPy 1.23.5 and up</em>:</p> <pre data-language="ini">[build-system]
build-backend = ...
requires = [
    # Note for packagers: this constraint is specific to wheels
    # for PyPI; it is also supported to build against 1.xx still.
    # If you do so, please ensure to include a `numpy&lt;2.0`
    # runtime requirement for those binary packages.
    "numpy&gt;=2.0.0rc1",
    ...
]

[project]
dependencies = [
    "numpy&gt;=1.23.5",
]
</pre> <p>We recommend that you have at least one CI job which builds/installs via a wheel, and then runs tests against the oldest numpy version that the package supports. For example:</p> <pre data-language="yaml">- name: Build wheel via wheel, then install it
  run: |
    python -m build  # This will pull in numpy 2.0 in an isolated env
    python -m pip install dist/*.whl

- name: Test against oldest supported numpy version
  run: |
    python -m pip install numpy==1.23.5
    # now run test suite
</pre> <p>The above only works once NumPy 2.0 is available on PyPI. If you want to test against a NumPy 2.0-dev wheel, you have to use a numpy nightly build (see <a class="reference internal" href="#testing-prereleases"><span class="std std-ref">this section</span></a> higher up) or build numpy from source.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/dev/depending_on_numpy.html" class="_attribution-link">https://numpy.org/doc/2.0/dev/depending_on_numpy.html</a>
  </p>
</div>
