<section id="setting-up-and-using-your-development-environment"> <h1 id="development-environment">Setting up and using your development environment</h1> <section id="recommended-development-setup"> <h2 id="id1">Recommended development setup</h2> <p>Since NumPy contains parts written in C and Cython that need to be compiled before use, make sure you have the necessary compilers and Python development headers installed - see <a class="reference internal" href="../building/index.html#building-from-source"><span class="std std-ref">Building from source</span></a>. Building NumPy as of version <code>2.0</code> requires C11 and C++17 compliant compilers.</p> <p>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in <a class="reference external" href="https://scikit-image.org/docs/stable/gitwash/index.html#using-git" title="(in skimage v0.23.2)"><span>Working with scikit-image source code</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are having trouble building NumPy from source or setting up your local development environment, you can try to build NumPy with GitHub Codespaces. It allows you to create the correct development environment right in your browser, reducing the need to install local development environments and deal with incompatible dependencies.</p> <p>If you have good internet connectivity and want a temporary set-up, it is often faster to work on NumPy in a Codespaces environment. For documentation on how to get started with Codespaces, see <a class="reference external" href="https://docs.github.com/en/codespaces">the Codespaces docs</a>. When creating a codespace for the <code>numpy/numpy</code> repository, the default 2-core machine type works; 4-core will build and work a bit faster (but of course at a cost of halving your number of free usage hours). Once your codespace has started, you can run <code>conda activate numpy-dev</code> and your development environment is completely set up - you can then follow the relevant parts of the NumPy documentation to build, test, develop, write docs, and contribute to NumPy.</p> </div> </section> <section id="using-virtual-environments"> <h2>Using virtual environments</h2> <p>A frequently asked question is “How do I set up a development version of NumPy in parallel to a released version that I use to do my job/research?”.</p> <p>One simple way to achieve this is to install the released version in site-packages, by using pip or conda for example, and set up the development version in a virtual environment.</p> <p>If you use conda, we recommend creating a separate virtual environment for numpy development using the <code>environment.yml</code> file in the root of the repo (this will create the environment and install all development dependencies at once):</p> <pre data-language="python">$ conda env create -f environment.yml  # `mamba` works too for this command
$ conda activate numpy-dev
</pre> <p>If you installed Python some other way than conda, first install <a class="reference external" href="https://virtualenv.pypa.io/">virtualenv</a> (optionally use <a class="reference external" href="https://doughellmann.com/projects/virtualenvwrapper/">virtualenvwrapper</a>), then create your virtualenv (named <code>numpy-dev</code> here), activate it, and install all project dependencies with:</p> <pre data-language="python">$ virtualenv numpy-dev
$ source numpy-dev/bin/activate # activate virtual environment
$ python -m pip install -r requirements/all_requirements.txt
</pre> <p>Now, whenever you want to switch to the virtual environment, you can use the command <code>source numpy-dev/bin/activate</code>, and <code>deactivate</code> to exit from the virtual environment and back to your previous shell.</p> </section> <section id="building-from-source"> <h2>Building from source</h2> <p>See <a class="reference internal" href="../building/index.html#building-from-source"><span class="std std-ref">Building from source</span></a>.</p> </section> <section id="testing-builds"> <h2 id="id2">Testing builds</h2> <p>Before running the tests, first install the test dependencies:</p> <pre data-language="python">$ python -m pip install -r requirements/test_requirements.txt
$ python -m pip install asv # only for running benchmarks
</pre> <p>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., use the <a class="reference external" href="https://github.com/scientific-python/spin">spin</a> utility. To run tests, do one of:</p> <pre data-language="python">$ spin test -v
$ spin test numpy/random  # to run the tests in a specific module
$ spin test -v -t numpy/_core/tests/test_nditer.py::test_iter_c_order
</pre> <p>This builds NumPy first, so the first time it may take a few minutes.</p> <p>You can also use <code>spin bench</code> for benchmarking. See <code>spin --help</code> for more command line options.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the above commands result in <code>RuntimeError: Cannot parse version 0+untagged.xxxxx</code>, run <code>git pull upstream main --tags</code>.</p> </div> <p>Additional arguments may be forwarded to <code>pytest</code> by passing the extra arguments after a bare <code>--</code>. For example, to run a test method with the <code>--pdb</code> flag forwarded to the target, run the following:</p> <pre data-language="python">$ spin test -t numpy/tests/test_scripts.py::test_f2py -- --pdb
</pre> <p>You can also <a class="reference external" href="https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests">match test names using python operators</a> by passing the <code>-k</code> argument to pytest:</p> <pre data-language="python">$ spin test -v -t numpy/_core/tests/test_multiarray.py -- -k "MatMul and not vector"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Remember that all tests of NumPy should pass before committing your changes.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some of the tests in the test suite require a large amount of memory, and are skipped if your system does not have enough.</p> </div> </section> <section id="other-build-options"> <h2>Other build options</h2> <p>For more options including selecting compilers, setting custom compiler flags and controlling parallelism, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/building/compilers_and_options.html" title="(in SciPy v1.13.1)"><span>Compiler selection and customizing a build</span></a> (from the SciPy documentation.)</p> </section> <section id="running-tests"> <h2>Running tests</h2> <p>Besides using <code>spin</code>, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</p> <pre data-language="python">&gt;&gt;&gt; np.test()  
&gt;&gt;&gt; np.test('full')   # Also run tests marked as slow
&gt;&gt;&gt; np.test('full', verbose=2)   # Additionally print test name/file

An example of a successful test :
``4686 passed, 362 skipped, 9 xfailed, 5 warnings in 213.99 seconds``
</pre> <p>Or a similar way from the command line:</p> <pre data-language="python">$ python -c "import numpy as np; np.test()"
</pre> <p>Tests can also be run with <code>pytest numpy</code>, however then the NumPy-specific plugin is not found which causes strange side effects.</p> <p>Running individual test files can be useful; it’s much faster than running the whole test suite or that of a whole module (example: <code>np.random.test()</code>). This can be done with:</p> <pre data-language="python">$ python path_to_testfile/test_file.py
</pre> <p>That also takes extra arguments, like <code>--pdb</code> which drops you into the Python debugger when a test fails or an exception is raised.</p> <p>Running tests with <a class="reference external" href="https://tox.readthedocs.io/">tox</a> is also supported. For example, to build NumPy and run the test suite with Python 3.9, use:</p> <pre data-language="python">$ tox -e py39
</pre> <p>For more extensive information, see <a class="reference internal" href="../reference/testing.html#testing-guidelines"><span class="std std-ref">Testing guidelines</span></a>.</p> <p>Note: do not run the tests from the root directory of your numpy git repo without <code>spin</code>, that will result in strange test errors.</p> </section> <section id="running-linting"> <h2>Running linting</h2> <p>Lint checks can be performed on newly added lines of Python code.</p> <p>Install all dependent packages using pip:</p> <pre data-language="python">$ python -m pip install -r requirements/linter_requirements.txt
</pre> <p>To run lint checks before committing new code, run:</p> <pre data-language="python">$ python tools/linter.py
</pre> <p>To check all changes in newly added Python code of current branch with target branch, run:</p> <pre data-language="python">$ python tools/linter.py --branch main
</pre> <p>If there are no errors, the script exits with no message. In case of errors, check the error message for details:</p> <pre data-language="python">$ python tools/linter.py --branch main
./numpy/_core/tests/test_scalarmath.py:34:5: E303 too many blank lines (3)
1       E303 too many blank lines (3)
</pre> <p>It is advisable to run lint checks before pushing commits to a remote branch since the linter runs as part of the CI pipeline.</p> <p>For more details on Style Guidelines:</p> <ul class="simple"> <li><a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">Python Style Guide</a></li> <li><a class="reference external" href="https://numpy.org/neps/nep-0045-c_style_guide.html">C Style Guide</a></li> </ul> </section> <section id="rebuilding-cleaning-the-workspace"> <h2>Rebuilding &amp; cleaning the workspace</h2> <p>Rebuilding NumPy after making changes to compiled code can be done with the same build command as you used previously - only the changed files will be re-built. Doing a full build, which sometimes is necessary, requires cleaning the workspace first. The standard way of doing this is (<em>note: deletes any uncommitted files!</em>):</p> <pre data-language="python">$ git clean -xdf
</pre> <p>When you want to discard all changes and go back to the last commit in the repo, use one of:</p> <pre data-language="python">$ git checkout .
$ git reset --hard
</pre> </section> <section id="debugging"> <h2 id="id3">Debugging</h2> <p>Another frequently asked question is “How do I debug C code inside NumPy?”. First, ensure that you have gdb installed on your system with the Python extensions (often the default on Linux). You can see which version of Python is running inside gdb to verify your setup:</p> <pre data-language="python">(gdb) python
&gt;import sys
&gt;print(sys.version_info)
&gt;end
sys.version_info(major=3, minor=7, micro=0, releaselevel='final', serial=0)
</pre> <p>Most python builds do not include debug symbols and are built with compiler optimizations enabled. To get the best debugging experience using a debug build of Python is encouraged, see <a class="reference internal" href="development_advanced_debugging.html#advanced-debugging"><span class="std std-ref">Advanced debugging tools</span></a>.</p> <p>In terms of debugging, NumPy also needs to be built in a debug mode. You need to use <code>debug</code> build type and disable optimizations to make sure <code>-O0</code> flag is used during object building. Note that NumPy should NOT be installed in your environment before you build with the <code>spin build</code> command.</p> <p>To generate source-level debug information within the build process run:</p> <pre data-language="python">$ spin build --clean -- -Dbuildtype=debug -Ddisable-optimization=true
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In case you are using conda environment be aware that conda sets <code>CFLAGS</code> and <code>CXXFLAGS</code> automatically, and they will include the <code>-O2</code> flag by default. You can safely use <code>unset CFLAGS &amp;&amp; unset CXXFLAGS</code> to avoid them or provide them at the beginning of the <code>spin</code> command: <code>CFLAGS="-O0 -g" CXXFLAGS="-O0 -g"</code>. Alternatively, to take control of these variables more permanently, you can create <code>env_vars.sh</code> file in the <code>&lt;path-to-conda-envs&gt;/numpy-dev/etc/conda/activate.d</code> directory. In this file you can export <code>CFLAGS</code> and <code>CXXFLAGS</code> variables. For complete instructions please refer to <a class="reference external" href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#saving-environment-variables">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#saving-environment-variables</a>.</p> </div> <p>Next you need to write a Python script that invokes the C code whose execution you want to debug. For instance <code>mytest.py</code>:</p> <pre data-language="python">import numpy as np
x = np.arange(5)
np.empty_like(x)
</pre> <p>Note that your test file needs to be outside the NumPy clone you have. Now, you can run:</p> <pre data-language="python">$ spin gdb /path/to/mytest.py
</pre> <p>In case you are using clang toolchain:</p> <pre data-language="python">$ spin lldb /path/to/mytest.py
</pre> <p>And then in the debugger:</p> <pre data-language="python">(gdb) break array_empty_like
(gdb) run
</pre> <p>lldb counterpart:</p> <pre data-language="python">(lldb) breakpoint set --name array_empty_like
(lldb) run
</pre> <p>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use <code>py-list</code>, to see the python traceback, use <code>py-bt</code>. For more details, see <a class="reference external" href="https://wiki.python.org/moin/DebuggingWithGdb">DebuggingWithGdb</a>. Here are some commonly used commands:</p> <ul class="simple"> <li>
<code>list</code>: List specified function or line.</li> <li>
<code>next</code>: Step program, proceeding through subroutine calls.</li> <li>
<code>step</code>: Continue program being debugged, after signal or breakpoint.</li> <li>
<code>print</code>: Print value of expression EXP.</li> </ul> <p>Rich support for Python debugging requires that the <code>python-gdb.py</code> script distributed with Python is installed in a path where gdb can find it. If you installed your Python build from your system package manager, you likely do not need to manually do anything. However, if you built Python from source, you will likely need to create a <code>.gdbinit</code> file in your home directory pointing gdb at the location of your Python installation. For example, a version of python installed via <a class="reference external" href="https://github.com/pyenv/pyenv">pyenv</a> needs a <code>.gdbinit</code> file with the following contents:</p> <pre data-language="text">add-auto-load-safe-path ~/.pyenv
</pre> <p>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as <code>python-dbg</code>) is highly recommended.</p> </section> <section id="understanding-the-code-getting-started"> <h2>Understanding the code &amp; getting started</h2> <p>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren’t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it’s totally fine to ping us if something has sat without a response for about two to four weeks.</p> <p>So go ahead and pick something that annoys or confuses you about NumPy, experiment with the code, hang around for discussions or go through the reference documents to try to fix it. Things will fall in place and soon you’ll have a pretty good understanding of the project as a whole. Good Luck!</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/dev/development_environment.html" class="_attribution-link">https://numpy.org/doc/2.0/dev/development_environment.html</a>
  </p>
</div>
