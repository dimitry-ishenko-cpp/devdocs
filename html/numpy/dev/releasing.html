<section id="releasing-a-version"> <h1>Releasing a version</h1> <p>The following guides include detailed information on how to prepare a NumPy release.</p> <section id="how-to-prepare-a-release"> <h2 id="prepare-release">How to prepare a release</h2> <p>These instructions give an overview of what is necessary to build binary releases for NumPy.</p> <section id="current-build-and-release-info"> <h3>Current build and release info</h3> <p>Useful info can be found in the following locations:</p> <ul class="simple"> <li>
<p><strong>Source tree</strong></p> <ul> <li><a class="reference external" href="https://github.com/numpy/numpy/blob/main/INSTALL.rst">INSTALL.rst</a></li> <li><a class="reference external" href="https://github.com/numpy/numpy/blob/main/pavement.py">pavement.py</a></li> </ul> </li> <li>
<p><strong>NumPy docs</strong></p> <ul> <li><a class="github reference external" href="https://github.com/numpy/numpy/blob/main/doc/HOWTO_RELEASE.rst">numpy/numpy</a></li> <li><a class="github reference external" href="https://github.com/numpy/numpy/blob/main/doc/RELEASE_WALKTHROUGH.rst">numpy/numpy</a></li> <li><a class="github reference external" href="https://github.com/numpy/numpy/blob/main/doc/BRANCH_WALKTHROUGH.rst">numpy/numpy</a></li> </ul> </li> <li>
<p><strong>Release scripts</strong></p> <ul> <li><a class="github reference external" href="https://github.com/numpy/numpy-vendor">numpy/numpy-vendor</a></li> </ul> </li> </ul> </section> <section id="supported-platforms-and-versions"> <h3>Supported platforms and versions</h3> <p><a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 29</span></a> outlines which Python versions are supported; For the first half of 2020, this will be Python &gt;= 3.6. We test NumPy against all these versions every time we merge code to main. Binary installers may be available for a subset of these versions (see below).</p> <ul> <li>
<p><strong>OS X</strong></p> <p>OS X versions &gt;= 10.9 are supported, for Python version support see <a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 29</span></a>. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this <a class="reference external" href="https://github.com/MacPython/wiki/wiki/Spinning-wheels">OSX wheel building summary</a> for details.</p> </li> <li>
<p><strong>Windows</strong></p> <p>We build 32- and 64-bit wheels on Windows. Windows 7, 8 and 10 are supported. We build NumPy using the <a class="reference external" href="https://mingwpy.github.io">mingw-w64 toolchain</a>, <a class="reference external" href="https://cibuildwheel.readthedocs.io/en/stable/">cibuildwheels</a> and GitHub actions.</p> </li> </ul> <ul> <li>
<p><strong>Linux</strong></p> <p>We build and ship <a class="reference external" href="https://www.python.org/dev/peps/pep-0513">manylinux2014</a> wheels for NumPy. Many Linux distributions include their own binary builds of NumPy.</p> </li> <li>
<p><strong>BSD / Solaris</strong></p> <p>No binaries are provided, but successful builds on Solaris and BSD have been reported.</p> </li> </ul> </section> <section id="tool-chain"> <h3>Tool chain</h3> <p>We build all our wheels on cloud infrastructure - so this list of compilers is for information and debugging builds locally. See the <code>.travis.yml</code> script in the <a class="reference external" href="https://github.com/MacPython/numpy-wheels">numpy wheels</a> repo for an outdated source of the build recipes using multibuild.</p> <section id="compilers"> <h4>Compilers</h4> <p>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</p> <ul class="simple"> <li>OS X builds on travis currently use <code>clang</code>. It appears that binary wheels for OSX &gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</li> <li>Windows builds use the <a class="reference external" href="https://mingwpy.github.io">mingw-w64 toolchain</a>;</li> <li>Manylinux2014 wheels use the gcc provided on the Manylinux docker images.</li> </ul> <p>You will need Cython for building the binaries. Cython compiles the <code>.pyx</code> files in the NumPy distribution to <code>.c</code> files.</p> </section> <section id="openblas"> <h4>OpenBLAS</h4> <p>All the wheels link to a version of <a class="reference external" href="https://github.com/xianyi/OpenBLAS">OpenBLAS</a> supplied via the <a class="reference external" href="https://github.com/MacPython/openblas-libs">openblas-libs</a> repo. The shared object (or DLL) is shipped with in the wheel, renamed to prevent name collisions with other OpenBLAS shared objects that may exist in the filesystem.</p> </section> <section id="building-source-archives-and-wheels"> <h4>Building source archives and wheels</h4> <p>The NumPy wheels and sdist are now built using cibuildwheel with github actions.</p> </section> <section id="building-docs"> <h4>Building docs</h4> <p>We are no longer building <code>PDF</code> files. All that will be needed is</p> <ul class="simple"> <li>virtualenv (pip).</li> </ul> <p>The other requirements will be filled automatically during the documentation build process.</p> </section> <section id="uploading-to-pypi"> <h4>Uploading to PyPI</h4> <p>The only application needed for uploading is</p> <ul class="simple"> <li>twine (pip).</li> </ul> <p>You will also need a PyPI token, which is best kept on a keyring. See the twine <a class="reference external" href="https://twine.readthedocs.io/en/stable/#keyring-support">keyring</a> documentation for how to do that.</p> </section> <section id="generating-author-pr-lists"> <h4>Generating author/PR lists</h4> <p>You will need a personal access token <a class="reference external" href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/</a> so that scripts can access the github NumPy repository.</p> <ul class="simple"> <li>gitpython (pip)</li> <li>pygithub (pip)</li> </ul> </section> </section> <section id="what-is-released"> <h3>What is released</h3> <ul class="simple"> <li>
<p><strong>Wheels</strong> We currently support Python 3.8-3.10 on Windows, OSX, and Linux.</p> <ul> <li>Windows: 32-bit and 64-bit wheels built using Github actions;</li> <li>OSX: x64_86 and arm64 OSX wheels built using Github actions;</li> <li>Linux: x64_86 and aarch64 Manylinux2014 wheels built using Github actions.</li> </ul> </li> <li>
<strong>Other</strong> Release notes and changelog</li> <li>
<strong>Source distribution</strong> We build source releases in the .tar.gz format.</li> </ul> </section> <section id="release-process"> <h3>Release process</h3> <section id="agree-on-a-release-schedule"> <h4>Agree on a release schedule</h4> <p>A typical release schedule is one beta, two release candidates and a final release. It’s best to discuss the timing on the mailing list first, in order for people to get their commits in on time, get doc wiki edits merged, etc. After a date is set, create a new maintenance/x.y.z branch, add new empty release notes for the next version in the main branch and update the Trac Milestones.</p> </section> <section id="make-sure-current-branch-builds-a-package-correctly"> <h4>Make sure current branch builds a package correctly</h4> <p>The CI builds wheels when a PR header begins with <code>REL</code>. Your last PR before releasing should be so marked and all the tests should pass. You can also do:</p> <pre data-language="python">git clean -fxdq
python setup.py bdist_wheel
python setup.py sdist
</pre> <p>For details of the build process itself, it is best to read the Step-by-Step Directions below.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The following steps are repeated for the beta(s), release candidates(s) and the final release.</p> </div> </section> <section id="check-deprecations"> <h4>Check deprecations</h4> <p>Before <a class="reference internal" href="#branching"><span class="std std-ref">the release branch is made</span></a>, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning what version the code will be removed.</p> </section> <section id="check-the-c-api-version-number"> <h4>Check the C API version number</h4> <p>The C API version needs to be tracked in three places</p> <ul class="simple"> <li>numpy/_core/meson.build</li> <li>numpy/_core/code_generators/cversions.txt</li> <li>numpy/_core/include/numpy/numpyconfig.h</li> </ul> <p>There are three steps to the process.</p> <ol class="arabic"> <li>If the API has changed, increment the C_API_VERSION in numpy/core/meson.build. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</li> <li>
<p>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/_core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/_core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</p> <p>If steps 1 and 2 are done correctly, compiling the release should not give a warning “API mismatch detect at the beginning of the build”.</p> </li> <li>The numpy/_core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</li> </ol> <p>The C ABI version number in numpy/_core/meson.build should only be updated for a major release.</p> </section> <section id="check-the-release-notes"> <h4>Check the release notes</h4> <p>Use <a class="reference external" href="https://pypi.org/project/towncrier/">towncrier</a> to build the release note and commit the changes. This will remove all the fragments from <code>doc/release/upcoming_changes</code> and add <code>doc/release/&lt;version&gt;-note.rst</code>.:</p> <pre data-language="python">towncrier build --version "&lt;version&gt;"
git commit -m"Create release note"
</pre> <p>Check that the release notes are up-to-date.</p> <p>Update the release notes with a Highlights section. Mention some of the following:</p> <ul class="simple"> <li>major new features</li> <li>deprecated and removed features</li> <li>supported Python versions</li> <li>for SciPy, supported NumPy version(s)</li> <li>outlook for the near future</li> </ul> </section> </section> </section> <section id="step-by-step-directions"> <h2>Step-by-step directions</h2> <p>This is a walkthrough of the NumPy 1.21.0 release on Linux, modified for building with GitHub Actions and cibuildwheels and uploading to the <a class="reference external" href="https://anaconda.org/multibuild-wheels-staging/numpy">anaconda.org staging repository for NumPy</a>. The commands can be copied into the command line, but be sure to replace 1.21.0 by the correct version. This should be read together with the <a class="reference internal" href="#prepare-release"><span class="std std-ref">general release guide</span></a>.</p> <section id="facility-preparation"> <h3>Facility preparation</h3> <p>Before beginning to make a release, use the <code>requirements/*_requirements.txt</code> files to ensure that you have the needed software. Most software can be installed with pip, but some will require apt-get, dnf, or whatever your system uses for software. You will also need a GitHub personal access token (PAT) to push the documentation. There are a few ways to streamline things:</p> <ul class="simple"> <li>Git can be set up to use a keyring to store your GitHub personal access token. Search online for the details.</li> <li>You can use the <code>keyring</code> app to store the PyPI password for twine. See the online twine documentation for details.</li> </ul> </section> <section id="prior-to-release"> <h3>Prior to release</h3> <section id="add-drop-python-versions"> <h4>Add/drop Python versions</h4> <p>When adding or dropping Python versions, three files need to be edited:</p> <ul class="simple"> <li>.github/workflows/wheels.yml # for github cibuildwheel</li> <li>.travis.yml # for cibuildwheel aarch64 builds</li> <li>setup.py # for classifier and minimum version check.</li> </ul> <p>Make these changes in an ordinary PR against main and backport if necessary. Using the <code>BLD:</code> prefix (build label) for the commit summary will cause the wheel builds to be run so that the changes will be tested, We currently release wheels for new Python versions after the first Python rc once manylinux and cibuildwheel support it. For Python 3.11 we were able to release within a week of the rc1 announcement.</p> </section> <section id="backport-pull-requests"> <h4>Backport pull requests</h4> <p>Changes that have been marked for this release must be backported to the maintenance/1.21.x branch.</p> </section> </section> <section id="make-a-release-pr"> <h3>Make a release PR</h3> <p>Five documents usually need to be updated or created for the release PR:</p> <ul class="simple"> <li>The changelog</li> <li>The release-notes</li> <li>The <code>.mailmap</code> file</li> <li>The <code>pyproject.toml</code> file</li> <li>The <code>pyproject.toml.setuppy</code> file # 1.26.x only</li> </ul> <p>These changes should be made in an ordinary PR against the maintenance branch. The commit message should contain a <code>[wheel build]</code> directive to test if the wheels build. Other small, miscellaneous fixes may be part of this PR. The commit message might be something like:</p> <pre data-language="python">REL: Prepare for the NumPy 1.20.0 release

- Create 1.20.0-changelog.rst.
- Update 1.20.0-notes.rst.
- Update .mailmap.
- Update pyproject.toml
- Update pyproject.toml.setuppy

[wheel build]
</pre> <section id="generate-the-changelog"> <h4>Generate the changelog</h4> <p>The changelog is generated using the changelog tool:</p> <pre data-language="python">$ spin changelog $GITHUB v1.20.0..maintenance/1.21.x &gt; doc/changelog/1.21.0-changelog.rst
</pre> <p>where <code>GITHUB</code> contains your GitHub access token. The text will need to be checked for non-standard contributor names and dependabot entries removed. It is also a good idea to remove any links that may be present in the PR titles as they don’t translate well to markdown, replace them with monospaced text. The non-standard contributor names should be fixed by updating the <code>.mailmap</code> file, which is a lot of work. It is best to make several trial runs before reaching this point and ping the malefactors using a GitHub issue to get the needed information.</p> </section> <section id="finish-the-release-notes"> <h4>Finish the release notes</h4> <p>If there are any release notes snippets in <code>doc/release/upcoming_changes/</code>, run <code>spin docs</code> to build the docs, incorporate the contents of the generated <code>doc/source/release/notes-towncrier.rst</code> file into the release notes file (e.g., <code>doc/source/release/2.3.4-notes.rst</code>), and delete the now-processed snippets in <code>doc/release/upcoming_changes/</code>. This is safe to do multiple times during a release cycle.</p> <p>The generated release note will always need some fixups, the introduction will need to be written, and significant changes should be called out. For patch releases the changelog text may also be appended, but not for the initial release as it is too long. Check previous release notes to see how this is done.</p> </section> <section id="set-the-release-version"> <h4>Set the release version</h4> <p>Check the <code>pyproject.toml</code> and <code>pyproject.toml.setuppy</code> files and set the release version if needed:</p> <pre data-language="python">$ gvim pyproject.toml pyproject.toml.setuppy
</pre> </section> <section id="check-the-pavement-py-and-doc-source-release-rst-files"> <h4>Check the <code>pavement.py</code> and <code>doc/source/release.rst</code> files</h4> <p>Check that the <code>pavement.py</code> file points to the correct release notes. It should have been updated after the last release, but if not, fix it now. Also make sure that the notes have an entry in the <code>release.rst</code> file:</p> <pre data-language="python">$ gvim pavement.py doc/source/release.rst
</pre> </section> </section> <section id="release-walkthrough"> <h3>Release walkthrough</h3> <p>Note that in the code snippets below, <code>upstream</code> refers to the root repository on GitHub and <code>origin</code> to its fork in your personal GitHub repositories. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit <code>.git/config</code> and add <code>upstream</code> if it isn’t already present.</p> <section id="prepare-the-release-commit"> <h4>1. Prepare the release commit</h4> <p>Checkout the branch for the release, make sure it is up to date, and clean the repository:</p> <pre data-language="python">$ git checkout maintenance/1.21.x
$ git pull upstream maintenance/1.21.x
$ git submodule update
$ git clean -xdfq
</pre> <p>Sanity check:</p> <pre data-language="python">$ python3 -m spin test -m full
</pre> <p>Tag the release and push the tag. This requires write permission for the numpy repository:</p> <pre data-language="python">$ git tag -a -s v1.21.0 -m"NumPy 1.21.0 release"
$ git push upstream v1.21.0
</pre> <p>If you need to delete the tag due to error:</p> <pre data-language="python">$ git tag -d v1.21.0
$ git push --delete upstream v1.21.0
</pre> </section> <section id="build-wheels"> <h4>2. Build wheels</h4> <p>Tagging the build at the beginning of this process will trigger a wheel build via cibuildwheel and upload wheels and an sdist to the staging repo. The CI run on github actions (for all x86-based and macOS arm64 wheels) takes about 1 1/4 hours. The CI runs on cirrus (for aarch64 and M1) take less time. You can check for uploaded files at the <a class="reference external" href="https://anaconda.org/multibuild-wheels-staging/numpy/files">staging repository</a>, but note that it is not closely synched with what you see of the running jobs.</p> <p>If you wish to manually trigger a wheel build, you can do so:</p> <ul class="simple"> <li>On github actions -&gt; <a class="reference external" href="https://github.com/numpy/numpy/actions/workflows/wheels.yml">Wheel builder</a> there is a “Run workflow” button, click on it and choose the tag to build</li> <li>On Cirrus we don’t currently have an easy way to manually trigger builds and uploads.</li> </ul> <p>If a wheel build fails for unrelated reasons, you can rerun it individually:</p> <ul class="simple"> <li>On github actions select <a class="reference external" href="https://github.com/numpy/numpy/actions/workflows/wheels.yml">Wheel builder</a> click on the commit that contains the build you want to rerun. On the left there is a list of wheel builds, select the one you want to rerun and on the resulting page hit the counterclockwise arrows button.</li> <li>On cirrus we haven’t figured it out.</li> </ul> </section> <section id="download-wheels"> <h4>3. Download wheels</h4> <p>When the wheels have all been successfully built and staged, download them from the Anaconda staging directory using the <code>tools/download-wheels.py</code> script:</p> <pre data-language="python">$ cd ../numpy
$ mkdir -p release/installers
$ python3 tools/download-wheels.py 1.21.0
</pre> </section> <section id="generate-the-readme-files"> <h4>4. Generate the README files</h4> <p>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</p> <pre data-language="python">$ paver write_release
</pre> </section> <section id="upload-to-pypi"> <h4>5. Upload to PyPI</h4> <p>Upload to PyPI using <code>twine</code>. A recent version of <code>twine</code> of is needed after recent PyPI changes, version <code>3.4.1</code> was used here:</p> <pre data-language="python">$ cd ../numpy
$ twine upload release/installers/*.whl
$ twine upload release/installers/numpy-1.21.0.tar.gz  # Upload last.
</pre> <p>If one of the commands breaks in the middle, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems that might occur if pip users access the files while this is in process, causing pip to build from source rather than downloading a binary wheel. PyPI only allows a single source distribution, here we have chosen the zip archive.</p> </section> <section id="upload-files-to-github"> <h4>6. Upload files to GitHub</h4> <p>Go to <a class="github reference external" href="https://github.com/numpy/numpy/releases">numpy/numpy</a>, there should be a <code>v1.21.0
tag</code>, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads. Start by editing the <code>release/README.md</code> that is translated from the rst version using pandoc. Things that will need fixing: PR lines from the changelog, if included, are wrapped and need unwrapping, links should be changed to monospaced text. Then copy the contents to the clipboard and paste them into the text window. It may take several tries to get it look right. Then</p> <ul class="simple"> <li>Upload <code>release/installers/numpy-1.21.0.tar.gz</code> as a binary file.</li> <li>Upload <code>release/README.rst</code> as a binary file.</li> <li>Upload <code>doc/changelog/1.21.0-changelog.rst</code> as a binary file.</li> <li>Check the pre-release button if this is a pre-releases.</li> <li>Hit the <code>{Publish,Update} release</code> button at the bottom.</li> </ul> </section> <section id="upload-documents-to-numpy-org-skip-for-prereleases"> <h4>7. Upload documents to numpy.org (skip for prereleases)</h4> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You will need a GitHub personal access token to push the update.</p> </div> <p>This step is only needed for final releases and can be skipped for pre-releases and most patch releases. <code>make merge-doc</code> clones the <code>numpy/doc</code> repo into <code>doc/build/merge</code> and updates it with the new documentation:</p> <pre data-language="python">$ git clean -xdfq
$ git co v1.21.0
$ rm -rf doc/build  # want version to be current
$ python -m spin docs merge-doc --build
$ pushd doc/build/merge
</pre> <p>If the release series is a new one, you will need to add a new section to the <code>doc/build/merge/index.html</code> front page just after the “insert here” comment:</p> <pre data-language="python">$ gvim index.html +/'insert here'
</pre> <p>Further, update the version-switcher json file to add the new release and update the version marked <code>(stable)</code>:</p> <pre data-language="python">$ gvim _static/versions.json
</pre> <p>Otherwise, only the <code>zip</code> link should be updated with the new tag name. Since we are no longer generating <code>pdf</code> files, remove the line for the <code>pdf</code> files if present:</p> <pre data-language="python">$ gvim index.html +/'tag v1.21'
</pre> <p>You can “test run” the new documentation in a browser to make sure the links work:</p> <pre data-language="python">$ firefox index.html  # or google-chrome, etc.
</pre> <p>Update the stable link and update:</p> <pre data-language="python">$ ln -sfn 1.21 stable
$ ls -l  # check the link
</pre> <p>Once everything seems satisfactory, update, commit and upload the changes:</p> <pre data-language="python">$ python3 update.py
$ git commit -a -m"Add documentation for v1.21.0"
$ git push
$ popd
</pre> </section> <section id="reset-the-maintenance-branch-into-a-development-state-skip-for-prereleases"> <h4>8. Reset the maintenance branch into a development state (skip for prereleases)</h4> <p>Create release notes for next release and edit them to set the version. These notes will be a skeleton and have little content:</p> <pre data-language="python">$ cp doc/source/release/template.rst doc/source/release/1.21.1-notes.rst
$ gvim doc/source/release/1.21.1-notes.rst
$ git add doc/source/release/1.21.1-notes.rst
</pre> <p>Add new release notes to the documentation release list and update the <code>RELEASE_NOTES</code> variable in <code>pavement.py</code>:</p> <pre data-language="python">$ gvim doc/source/release.rst pavement.py
</pre> <p>Update the <code>version</code> in <code>pyproject.toml</code> and <code>pyproject.toml.setuppy</code>:</p> <pre data-language="python">$ gvim pyproject.toml pyproject.toml.setuppy
</pre> <p>Commit the result:</p> <pre data-language="python">$ git commit -a -m"MAINT: prepare 1.21.x for further development"
$ git push origin HEAD
</pre> <p>Go to GitHub and make a PR. It should be merged quickly.</p> </section> <section id="announce-the-release-on-numpy-org-skip-for-prereleases"> <h4>9. Announce the release on numpy.org (skip for prereleases)</h4> <p>This assumes that you have forked <a class="github reference external" href="https://github.com/numpy/numpy.org">numpy/numpy.org</a>:</p> <pre data-language="python">$ cd ../numpy.org
$ git checkout main
$ git pull upstream main
$ git checkout -b announce-numpy-1.21.0
$ gvim content/en/news.md
</pre> <ul class="simple"> <li>For all releases, go to the bottom of the page and add a one line link. Look to the previous links for example.</li> <li>For the <code>*.0</code> release in a cycle, add a new section at the top with a short description of the new features and point the news link to it.</li> </ul> <p>commit and push:</p> <pre data-language="python">$ git commit -a -m"announce the NumPy 1.21.0 release"
$ git push origin HEAD
</pre> <p>Go to GitHub and make a PR.</p> </section> <section id="announce-to-mailing-lists"> <h4>10. Announce to mailing lists</h4> <p>The release should be announced on the numpy-discussion, scipy-devel, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</p> </section> <section id="post-release-update-main-skip-for-prereleases"> <h4>11. Post-release update main (skip for prereleases)</h4> <p>Checkout main and forward port the documentation changes:</p> <pre data-language="python">$ git checkout -b post-1.21.0-release-update
$ git checkout maintenance/1.21.x doc/source/release/1.21.0-notes.rst
$ git checkout maintenance/1.21.x doc/changelog/1.21.0-changelog.rst
$ git checkout maintenance/1.21.x .mailmap  # only if updated for release.
$ gvim doc/source/release.rst  # Add link to new notes
$ git status  # check status before commit
$ git commit -a -m"MAINT: Update main after 1.21.0 release."
$ git push origin HEAD
</pre> <p>Go to GitHub and make a PR.</p> </section> <section id="update-oldest-supported-numpy"> <h4>12. Update oldest-supported-numpy</h4> <p>If this release is the first one to support a new Python version, or the first to provide wheels for a new platform or PyPy version, the version pinnings in <a class="github reference external" href="https://github.com/scipy/oldest-supported-numpy">scipy/oldest-supported-numpy</a> should be updated. Either submit a PR with changes to <code>setup.cfg</code> there, or open an issue with info on needed changes.</p> </section> </section> </section> <section id="branch-walkthrough"> <h2 id="branching">Branch walkthrough</h2> <p>This guide contains a walkthrough of branching NumPy 1.21.x on Linux. The commands can be copied into the command line, but be sure to replace 1.21 and 1.22 by the correct versions. It is good practice to make <code>.mailmap</code> as current as possible before making the branch, that may take several weeks.</p> <p>This should be read together with the <a class="reference internal" href="#prepare-release"><span class="std std-ref">general release guide</span></a>.</p> <section id="id2"> <h3>Branching</h3> <section id="make-the-branch"> <h4>Make the branch</h4> <p>This is only needed when starting a new maintenance branch. Because NumPy now depends on tags to determine the version, the start of a new development cycle in the main branch needs an annotated tag. That is done as follows:</p> <pre data-language="python">$ git checkout main
$ git pull upstream main
$ git commit --allow-empty -m'REL: Begin NumPy 1.22.0 development'
$ git push upstream HEAD
</pre> <p>If the push fails because new PRs have been merged, do:</p> <pre data-language="python">$ git pull --rebase upstream
</pre> <p>and repeat the push. Once the push succeeds, tag it:</p> <pre data-language="python">$ git tag -a -s v1.22.0.dev0 -m'Begin NumPy 1.22.0 development'
$ git push upstream v1.22.0.dev0
</pre> <p>then make the new branch and push it:</p> <pre data-language="python">$ git branch maintenance/1.21.x HEAD^
$ git push upstream maintenance/1.21.x
</pre> </section> <section id="prepare-the-main-branch-for-further-development"> <h4>Prepare the main branch for further development</h4> <p>Make a PR branch to prepare main for further development:</p> <pre data-language="python">$ git checkout -b 'prepare-main-for-1.22.0-development' v1.22.0.dev0
</pre> <p>Delete the release note fragments:</p> <pre data-language="python">$ git rm doc/release/upcoming_changes/[0-9]*.*.rst
</pre> <p>Create the new release notes skeleton and add to index:</p> <pre data-language="python">$ cp doc/source/release/template.rst doc/source/release/1.22.0-notes.rst
$ gvim doc/source/release/1.22.0-notes.rst  # put the correct version
$ git add doc/source/release/1.22.0-notes.rst
$ gvim doc/source/release.rst  # add new notes to notes index
$ git add doc/source/release.rst
</pre> <p>Update <code>pavement.py</code> and update the <code>RELEASE_NOTES</code> variable to point to the new notes:</p> <pre data-language="python">$ gvim pavement.py
$ git add pavement.py
</pre> <p>Update <code>cversions.txt</code> to add current release. There should be no new hash to worry about at this early point, just add a comment following previous practice:</p> <pre data-language="python">$ gvim numpy/_core/code_generators/cversions.txt
$ git add numpy/_core/code_generators/cversions.txt
</pre> <p>Check your work, commit it, and push:</p> <pre data-language="python">$ git status  # check work
$ git commit -m'REL: Prepare main for NumPy 1.22.0 development'
$ git push origin HEAD
</pre> <p>Now make a pull request.</p> </section> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/dev/releasing.html" class="_attribution-link">https://numpy.org/doc/2.0/dev/releasing.html</a>
  </p>
</div>
