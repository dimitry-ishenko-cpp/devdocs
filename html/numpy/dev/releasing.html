<h1>Releasing a version</h1> <section id="how-to-prepare-a-release"> <h2>How to Prepare a Release</h2> <p>This file gives an overview of what is necessary to build binary releases for NumPy.</p> <section id="current-build-and-release-info"> <h3>Current build and release info</h3> <p>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</p> <section id="source-tree"> <h4>Source tree</h4> <ul class="simple"> <li>INSTALL.rst.txt</li> <li>pavement.py</li> </ul> </section> <section id="numpy-docs"> <h4>NumPy Docs</h4> <ul class="simple"> <li><a class="reference external" href="https://github.com/numpy/numpy/blob/main/doc/HOWTO_RELEASE.rst.txt">https://github.com/numpy/numpy/blob/main/doc/HOWTO_RELEASE.rst.txt</a></li> </ul> </section> <section id="scipy-org-wiki"> <h4>SciPy.org wiki</h4> <ul class="simple"> <li>
<a class="reference external" href="https://www.scipy.org/Installing_SciPy">https://www.scipy.org/Installing_SciPy</a> and links on that page.</li> </ul> </section> <section id="release-scripts"> <h4>Release Scripts</h4> <ul class="simple"> <li><a class="reference external" href="https://github.com/numpy/numpy-vendor">https://github.com/numpy/numpy-vendor</a></li> </ul> </section> </section> <section id="supported-platforms-and-versions"> <h3>Supported platforms and versions</h3> <p><a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 29</span></a> outlines which Python versions are supported; For the first half of 2020, this will be Python &gt;= 3.6. We test NumPy against all these versions every time we merge code to main. Binary installers may be available for a subset of these versions (see below).</p> <section id="os-x"> <h4>OS X</h4> <p>OS X versions &gt;= 10.9 are supported, for Python version support see <a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span class="xref std std-ref">NEP 29</span></a>. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this <a class="reference external" href="https://github.com/MacPython/wiki/wiki/Spinning-wheels">OSX wheel building summary</a> for details.</p> </section> <section id="windows"> <h4>Windows</h4> <p>We build 32- and 64-bit wheels on Windows. Windows 7, 8 and 10 are supported. We build NumPy using the <a class="reference external" href="https://mingwpy.github.io">mingw-w64 toolchain</a> on Appveyor.</p> </section> <section id="linux"> <h4>Linux</h4> <p>We build and ship <a class="reference external" href="https://www.python.org/dev/peps/pep-0513">manylinux1</a> wheels for NumPy. Many Linux distributions include their own binary builds of NumPy.</p> </section> <section id="bsd-solaris"> <h4>BSD / Solaris</h4> <p>No binaries are provided, but successful builds on Solaris and BSD have been reported.</p> </section> </section> <section id="tool-chain"> <h3>Tool chain</h3> <p>We build all our wheels on cloud infrastructure - so this list of compilers is for information and debugging builds locally. See the <code>.travis.yml</code> script in the <a class="reference external" href="https://github.com/MacPython/numpy-wheels">numpy wheels</a> repo for the definitive source of the build recipes. Packages that are available using pip are noted.</p> <section id="compilers"> <h4>Compilers</h4> <p>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</p> <ul class="simple"> <li>OS X builds on travis currently use <code>clang</code>. It appears that binary wheels for OSX &gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</li> <li>Windows builds use the <a class="reference external" href="https://mingwpy.github.io">mingw-w64 toolchain</a>;</li> <li>Manylinux1 wheels use the gcc provided on the Manylinux docker images.</li> </ul> <p>You will need Cython for building the binaries. Cython compiles the <code>.pyx</code> files in the NumPy distribution to <code>.c</code> files.</p> </section> <section id="openblas"> <h4>OpenBLAS</h4> <p>All the wheels link to a version of <a class="reference external" href="https://github.com/xianyi/OpenBLAS">OpenBLAS</a> supplied via the <a class="reference external" href="https://github.com/MacPython/openblas-libs">openblas-libs</a> repo. The shared object (or DLL) is shipped with in the wheel, renamed to prevent name collisions with other OpenBLAS shared objects that may exist in the filesystem.</p> </section> <section id="building-source-archives-and-wheels"> <h4>Building source archives and wheels</h4> <p>You will need write permission for numpy-wheels in order to trigger wheel builds.</p> <ul class="simple"> <li>Python(s) from <a class="reference external" href="https://python.org">python.org</a> or linux distro.</li> <li>cython (pip)</li> <li>virtualenv (pip)</li> <li>Paver (pip)</li> <li>pandoc <a class="reference external" href="https://www.pandoc.org">pandoc.org</a> or linux distro.</li> <li>numpy-wheels <a class="reference external" href="https://github.com/MacPython/numpy-wheels">https://github.com/MacPython/numpy-wheels</a> (clone)</li> </ul> </section> <section id="building-docs"> <h4>Building docs</h4> <p>Building the documents requires a number of latex <code>.sty</code> files. Install them all to avoid aggravation.</p> <ul class="simple"> <li>Sphinx (pip)</li> <li>numpydoc (pip)</li> <li>Matplotlib</li> <li>Texlive (or MikTeX on Windows)</li> </ul> </section> <section id="uploading-to-pypi"> <h4>Uploading to PyPI</h4> <ul class="simple"> <li>terryfy <a class="reference external" href="https://github.com/MacPython/terryfy">https://github.com/MacPython/terryfy</a> (clone).</li> <li>beautifulsoup4 (pip)</li> <li>delocate (pip)</li> <li>auditwheel (pip)</li> <li>twine (pip)</li> </ul> </section> <section id="generating-author-pr-lists"> <h4>Generating author/pr lists</h4> <p>You will need a personal access token <a class="reference external" href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/</a> so that scripts can access the github NumPy repository.</p> <ul class="simple"> <li>gitpython (pip)</li> <li>pygithub (pip)</li> </ul> </section> <section id="virtualenv"> <h4>Virtualenv</h4> <p>Virtualenv is a very useful tool to keep several versions of packages around. It is also used in the Paver script to build the docs.</p> </section> </section> <section id="what-is-released"> <h3>What is released</h3> <section id="wheels"> <h4>Wheels</h4> <p>We currently support Python 3.8-3.10 on Windows, OSX, and Linux</p> <ul class="simple"> <li>Windows: 32-bit and 64-bit wheels built using Appveyor;</li> <li>OSX: x64_86 OSX wheels built using travis-ci;</li> <li>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</li> </ul> <p>See the <a class="reference external" href="https://github.com/MacPython/numpy-wheels">numpy wheels</a> building repository for more detail.</p> </section> <section id="other"> <h4>Other</h4> <ul class="simple"> <li>Release Notes</li> <li>Changelog</li> </ul> </section> <section id="source-distribution"> <h4>Source distribution</h4> <p>We build source releases in both .zip and .tar.gz formats.</p> </section> </section> <section id="release-process"> <h3>Release process</h3> <section id="agree-on-a-release-schedule"> <h4>Agree on a release schedule</h4> <p>A typical release schedule is one beta, two release candidates and a final release. It’s best to discuss the timing on the mailing list first, in order for people to get their commits in on time, get doc wiki edits merged, etc. After a date is set, create a new maintenance/x.y.z branch, add new empty release notes for the next version in the main branch and update the Trac Milestones.</p> </section> <section id="make-sure-current-branch-builds-a-package-correctly"> <h4>Make sure current branch builds a package correctly</h4> <pre data-language="python">git clean -fxd
python setup.py bdist_wheel
python setup.py sdist
</pre> <p>For details of the build process itself, it is best to read the pavement.py script.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The following steps are repeated for the beta(s), release candidates(s) and the final release.</p> </div> </section> <section id="check-deprecations"> <h4>Check deprecations</h4> <p>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</p> </section> <section id="check-the-c-api-version-number"> <h4>Check the C API version number</h4> <p>The C API version needs to be tracked in three places</p> <ul class="simple"> <li>numpy/core/setup_common.py</li> <li>numpy/core/code_generators/cversions.txt</li> <li>numpy/core/include/numpy/numpyconfig.h</li> </ul> <p>There are three steps to the process.</p> <ol class="arabic"> <li>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</li> <li>
<p>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</p> <p>If steps 1 and 2 are done correctly, compiling the release should not give a warning “API mismatch detect at the beginning of the build”.</p> </li> <li>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</li> </ol> <p>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</p> </section> <section id="check-the-release-notes"> <h4>Check the release notes</h4> <p>Use <a class="reference external" href="https://pypi.org/project/towncrier/">towncrier</a> to build the release note and commit the changes. This will remove all the fragments from <code>doc/release/upcoming_changes</code> and add <code>doc/release/&lt;version&gt;-note.rst</code>.</p>  <p>towncrier build –version “&lt;version&gt;” git commit -m”Create release note”</p>  <p>Check that the release notes are up-to-date.</p> <p>Update the release notes with a Highlights section. Mention some of the following:</p>  <ul class="simple"> <li>major new features</li> <li>deprecated and removed features</li> <li>supported Python versions</li> <li>for SciPy, supported NumPy version(s)</li> <li>outlook for the near future</li> </ul>  </section> <section id="update-the-release-status-and-create-a-release-tag"> <h4>Update the release status and create a release “tag”</h4> <p>Identify the commit hash of the release, e.g. 1b2e1d63ff:</p> <pre data-language="python">git co 1b2e1d63ff # gives warning about detached head
</pre> <p>First, change/check the following variables in <code>pavement.py</code> depending on the release version:</p> <pre data-language="python">RELEASE_NOTES = 'doc/release/1.7.0-notes.rst'
LOG_START = 'v1.6.0'
LOG_END = 'maintenance/1.7.x'
</pre> <p>Do any other changes. When you are ready to release, do the following changes:</p> <pre data-language="python">diff --git a/setup.py b/setup.py
index b1f53e3..8b36dbe 100755
--- a/setup.py
+++ b/setup.py
@@ -57,7 +57,7 @@ PLATFORMS           = ["Windows", "Linux", "Solaris", "Mac OS-
 MAJOR               = 1
 MINOR               = 7
 MICRO               = 0
-ISRELEASED          = False
+ISRELEASED          = True
 VERSION             = '%d.%d.%drc1' % (MAJOR, MINOR, MICRO)

 # Return the git revision as a string
</pre> <p>And make sure the <code>VERSION</code> variable is set properly.</p> <p>Now you can make the release commit and tag. We recommend you don’t push the commit or tag immediately, just in case you need to do more cleanup. We prefer to defer the push of the tag until we’re confident this is the exact form of the released code (see: <a class="reference internal" href="#push-tag-and-commit"><span class="std std-ref">Push the release tag and commit</span></a>):</p>  <p>git commit -s -m “REL: Release.” setup.py git tag -s &lt;version&gt;</p>  <p>The <code>-s</code> flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</p> <p>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</p> <p>See: <a class="reference external" href="https://github.com/scipy/scipy/issues/4919">https://github.com/scipy/scipy/issues/4919</a> for a discussion of signing release tags, and <a class="reference external" href="https://keyring.debian.org/creating-key.html">https://keyring.debian.org/creating-key.html</a> for instructions on creating a GPG key if you do not have one.</p> <p>To make your key more readily identifiable as you, consider sending your key to public keyservers, with a command such as:</p> <pre data-language="python">gpg --send-keys &lt;yourkeyid&gt;
</pre> </section> <section id="update-the-version-of-the-main-branch"> <h4>Update the version of the main branch</h4> <p>Increment the release number in setup.py. Release candidates should have “rc1” (or “rc2”, “rcN”) appended to the X.Y.Z format.</p> <p>Also create a new version hash in cversions.txt and a corresponding version define NPY_x_y_API_VERSION in numpyconfig.h</p> </section> <section id="trigger-the-wheel-builds"> <h4>Trigger the wheel builds</h4> <p>See the <a class="reference external" href="https://github.com/MacPython/numpy-wheels">numpy wheels</a> repository.</p> <p>In that repository edit the files:</p> <ul class="simple"> <li><code>azure/posix.yml</code></li> <li>
<code>azure/windows.yml</code>.</li> </ul> <p>In both cases, set the <code>BUILD_COMMIT</code> variable to the current release tag - e.g. <code>v1.19.0</code>:</p> <pre data-language="python">$ gvim azure/posix.yml azure/windows.yml
$ git commit -a
$ git push upstream HEAD
</pre> <p>Make sure that the release tag has been pushed.</p> <p>Trigger a build by pushing a commit of your edits to the repository. Note that you can do this on a branch, but it must be pushed upstream to the <code>MacPython/numpy-wheels</code> repository to trigger uploads since only that repo has the appropriate tokens to allow uploads.</p> <p>The wheels, once built, appear at <a class="reference external" href="https://anaconda.org/multibuild-wheels-staging/numpy">https://anaconda.org/multibuild-wheels-staging/numpy</a></p> </section> <section id="make-the-release"> <h4>Make the release</h4> <p>Build the changelog and notes for upload with:</p> <pre data-language="python">paver write_release
</pre> </section> <section id="build-and-archive-documentation"> <h4>Build and archive documentation</h4> <p>Do:</p> <pre data-language="python">cd doc/
make dist
</pre> <p>to check that the documentation is in a buildable state. Then, after tagging, create an archive of the documentation in the numpy/doc repo:</p> <pre data-language="python"># This checks out github.com/numpy/doc and adds (``git add``) the
# documentation to the checked out repo.
make merge-doc
# Now edit the ``index.html`` file in the repo to reflect the new content.
# If the documentation is for a non-patch release (e.g. 1.19 -&gt; 1.20),
# make sure to update the ``stable`` symlink to point to the new directory.
ln -sfn &lt;latest_stable_directory&gt; stable
# Commit the changes
git -C build/merge commit -am "Add documentation for &lt;version&gt;"
# Push to numpy/doc repo
git -C build/merge push
</pre> </section> <section id="update-pypi"> <h4>Update PyPI</h4> <p>The wheels and source should be uploaded to PyPI.</p> <p>You should upload the wheels first, and the source formats last, to make sure that pip users don’t accidentally get a source install when they were expecting a binary wheel.</p> <p>You can do this automatically using the <code>wheel-uploader</code> script from <a class="reference external" href="https://github.com/MacPython/terryfy">https://github.com/MacPython/terryfy</a>. Here is the recommended incantation for downloading all the Windows, Manylinux, OSX wheels and uploading to PyPI.</p> <pre data-language="python">NPY_WHLS=~/wheelhouse   # local directory to cache wheel downloads
CDN_URL=https://anaconda.org/multibuild-wheels-staging/numpy/files
wheel-uploader -u $CDN_URL -w $NPY_WHLS -v -s -t win numpy 1.11.1rc1
wheel-uploader -u $CDN_URL -w warehouse -v -s -t macosx numpy 1.11.1rc1
wheel-uploader -u $CDN_URL -w warehouse -v -s -t manylinux1 numpy 1.11.1rc1
</pre> <p>The <code>-v</code> flag gives verbose feedback, <code>-s</code> causes the script to sign the wheels with your GPG key before upload. Don’t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</p> <p>There are two ways to update the source release on PyPI, the first one is:</p> <pre data-language="python">$ git clean -fxd  # to be safe
$ python setup.py sdist --formats=gztar,zip  # to check
# python setup.py sdist --formats=gztar,zip upload --sign
</pre> <p>This will ask for your key PGP passphrase, in order to sign the built source packages.</p> <p>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</p> </section> <section id="push-the-release-tag-and-commit"> <h4 id="push-tag-and-commit">Push the release tag and commit</h4> <p>Finally, now you are confident this tag correctly defines the source code that you released you can push the tag and release commit up to github:</p> <pre data-language="python">git push  # Push release commit
git push upstream &lt;version&gt;  # Push tag named &lt;version&gt;
</pre> <p>where <code>upstream</code> points to the main <a class="reference external" href="https://github.com/numpy/numpy.git">https://github.com/numpy/numpy.git</a> repository.</p> </section> <section id="update-scipy-org"> <h4>Update scipy.org</h4> <p>A release announcement with a link to the download site should be placed in the sidebar of the front page of scipy.org.</p> <p>The scipy.org should be a PR at <a class="reference external" href="https://github.com/scipy/scipy.org">https://github.com/scipy/scipy.org</a>. The file that needs modification is <code>www/index.rst</code>. Search for <code>News</code>.</p> </section> <section id="update-oldest-supported-numpy"> <h4>Update oldest-supported-numpy</h4> <p>If this release is the first one to support a new Python version, or the first to provide wheels for a new platform or PyPy version, the version pinnings in <a class="reference external" href="https://github.com/scipy/oldest-supported-numpy">https://github.com/scipy/oldest-supported-numpy</a> should be updated. Either submit a PR with changes to <code>setup.cfg</code> there, or open an issue with info on needed changes.</p> </section> <section id="announce-to-the-lists"> <h4>Announce to the lists</h4> <p>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</p> <p>During the beta/RC phase, an explicit request for testing the binaries with several other libraries (SciPy/Matplotlib/Pygame) should be posted on the mailing list.</p> </section> <section id="announce-to-linux-weekly-news"> <h4>Announce to Linux Weekly News</h4> <p>Email the editor of LWN to let them know of the release. Directions at: <a class="reference external" href="https://lwn.net/op/FAQ.lwn#contact">https://lwn.net/op/FAQ.lwn#contact</a></p> </section> <section id="after-the-final-release"> <h4>After the final release</h4> <p>After the final release is announced, a few administrative tasks are left to be done:</p>  <ul class="simple"> <li>Forward port changes in the release branch to release notes and release scripts, if any, to main branch.</li> <li>Update the Milestones in Trac.</li> </ul>  </section> </section> </section> <section id="step-by-step-directions"> <h2>Step-by-Step Directions</h2> <p>This file contains a walkthrough of the NumPy 1.21.0 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.21.0 by the correct version. This should be read together with the general directions in <code>releasing</code>.</p> <section id="facility-preparation"> <h3>Facility Preparation</h3> <p>Before beginning to make a release, use the <code>*_requirements.txt</code> files to ensure that you have the needed software. Most software can be installed with pip, but some will require apt-get, dnf, or whatever your system uses for software. Note that at this time the documentation cannot be built with Python 3.10, for that use 3.8-3.9 instead. You will also need a GitHub personal access token (PAT) to push the documentation. There are a few ways to streamline things.</p> <ul class="simple"> <li>Git can be set up to use a keyring to store your GitHub personal access token. Search online for the details.</li> <li>You can use the <code>keyring</code> app to store the PyPI password for twine. See the online twine documentation for details.</li> </ul> </section> <section id="release-preparation"> <h3>Release Preparation</h3> <section id="backport-pull-requests"> <h4>Backport Pull Requests</h4> <p>Changes that have been marked for this release must be backported to the maintenance/1.21.x branch.</p> </section> <section id="update-release-documentation"> <h4>Update Release documentation</h4> <p>Four documents usually need to be updated or created before making a release:</p> <ul class="simple"> <li>The changelog</li> <li>The release-notes</li> <li>The <code>.mailmap</code> file</li> <li>The <code>doc/source/release.rst</code> file</li> </ul> <p>These changes should be made as an ordinary PR against the maintenance branch. After release all files except <code>doc/source/release.rst</code> will need to be forward ported to the main branch.</p> <section id="generate-the-changelog"> <h5>Generate the changelog</h5> <p>The changelog is generated using the changelog tool:</p> <pre data-language="python">$ python tools/changelog.py $GITHUB v1.20.0..maintenance/1.21.x &gt; doc/changelog/1.21.0-changelog.rst
</pre> <p>where <code>GITHUB</code> contains your GitHub access token. The text will need to be checked for non-standard contributor names and dependabot entries removed. It is also a good idea to remove any links that may be present in the PR titles as they don’t translate well to markdown, replace them with monospaced text. The non-standard contributor names should be fixed by updating the <code>.mailmap</code> file, which is a lot of work. It is best to make several trial runs before reaching this point and ping the malefactors using a GitHub issue to get the needed information.</p> </section> <section id="finish-the-release-notes"> <h5>Finish the release notes</h5> <p>If this is the first release in a series the release note is generated, see the release note in <code>doc/release/upcoming_changes/README.rst</code> to see how to do this. Generating the release notes will also delete all the news fragment files in <code>doc/release/upcoming_changes/</code>.</p> <p>The generated release note will always need some fixups, the introduction will need to be written, and significant changes should be called out. For patch releases the changelog text may also be appended, but not for the initial release as it is too long. Check previous release notes to see how this is done. Note that the <code>:orphan:</code> markup at the top, if present, will need changing to <code>.. currentmodule:: numpy</code> and the <code>doc/source/release.rst</code> index file will need updating.</p> </section> <section id="check-the-pavement-py-file"> <h5>Check the pavement.py file</h5> <p>Check that the pavement.py file points to the correct release notes. It should have been updated after the last release, but if not, fix it now:</p> <pre data-language="python">$gvim pavement.py
</pre> </section> </section> </section> <section id="release-walkthrough"> <h3>Release Walkthrough</h3> <p>Note that in the code snippets below, <code>upstream</code> refers to the root repository on GitHub and <code>origin</code> to its fork in your personal GitHub repositories. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit <code>.git/config</code> and add <code>upstream</code> if it isn’t already present.</p> <section id="prepare-the-release-commit"> <h4>Prepare the release commit</h4> <p>Checkout the branch for the release, make sure it is up to date, and clean the repository:</p> <pre data-language="python">$ git checkout maintenance/1.21.x
$ git pull upstream maintenance/1.21.x
$ git submodule update
$ git clean -xdfq
</pre> <p>Sanity check:</p> <pre data-language="python">$ python3 runtests.py -m "full"
</pre> <p>Tag the release and push the tag. This requires write permission for the numpy repository:</p> <pre data-language="python">$ git tag -a -s v1.21.0 -m"NumPy 1.21.0 release"
$ git push upstream v1.21.0
</pre> </section> <section id="build-source-releases"> <h4>Build source releases</h4> <p>Paver is used to build the source releases. It will create the <code>release</code> and <code>release/installers</code> directories and put the <code>*.zip</code> and <code>*.tar.gz</code> source releases in the latter.</p> <pre data-language="python">$ paver sdist  # sdist will do a git clean -xdfq, so we omit that
</pre> </section> <section id="build-wheels-via-macpython-numpy-wheels"> <h4>Build wheels via MacPython/numpy-wheels</h4> <p>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from <a class="reference external" href="https://github.com/MacPython/numpy-wheels">https://github.com/MacPython/numpy-wheels</a>. If this is the first release in a series, start with a pull as the repo may have been accessed and changed by someone else, then create a new branch for the series. If the branch already exists skip this:</p> <pre data-language="python">$ cd ../numpy-wheels
$ git checkout main
$ git pull upstream main
$ git branch v1.21.x
</pre> <p>Checkout the new branch and edit the <code>azure-pipelines.yml</code> and <code>.travis.yml</code> files to make sure they have the correct version, and put in the commit hash for the <code>REL</code> commit created above for <code>BUILD_COMMIT</code> variable. The <code>azure/posix.yml</code> and <code>.travis.yml</code> files may also need the Cython versions updated to keep up with Python releases, but generally just do:</p> <pre data-language="python">$ git checkout v1.21.x
$ gvim azure-pipelines.yml .travis.yml
$ git commit -a -m"NumPy 1.21.0 release."
$ git push upstream HEAD
</pre> <p>Now wait. If you get nervous at the amount of time taken – the builds can take a while – you can check the build progress by following the links provided at <a class="reference external" href="https://github.com/MacPython/numpy-wheels">https://github.com/MacPython/numpy-wheels</a> to check the build status. Check if all the needed wheels have been built and uploaded to the staging repository before proceeding.</p> <p>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to rerun them. You will need to be logged in under ‘numpy’ to do this on azure.</p> </section> <section id="build-wheels-via-cibuildwheel"> <h4>Build wheels via cibuildwheel</h4> <p>Tagging the build at the beginning of this process will trigger a wheel build via cibuildwheel and upload wheels and an sdist to the staging area. The CI run on github actions (for all x86-based and macOS arm64 wheels) takes about 1 1/4 hours. The CI run on travis (for aarch64) takes less time.</p> <p>If you wish to manually trigger a wheel build, you can do so:</p> <ul class="simple"> <li>On github actions -&gt; <a class="reference external" href="https://github.com/numpy/numpy/actions/workflows/wheels.yml">Wheel builder</a> there is a “Run workflow” button, click on it and choose the tag to build</li> <li>On <a class="reference external" href="https://app.travis-ci.com/github/numpy/numpy">travis</a> there is a “More Options” button, click on it and choose a branch to build. There does not appear to be an option to build a tag.</li> </ul> </section> <section id="download-wheels"> <h4>Download wheels</h4> <p>When the wheels have all been successfully built and staged, download them from the Anaconda staging directory using the <code>tools/download-wheels.py</code> script:</p> <pre data-language="python">$ cd ../numpy
$ python3 tools/download-wheels.py 1.21.0
</pre> </section> <section id="generate-the-readme-files"> <h4>Generate the README files</h4> <p>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</p> <pre data-language="python">$ paver write_release
</pre> </section> <section id="reset-the-maintenance-branch-into-a-development-state-skip-for-prereleases"> <h4>Reset the maintenance branch into a development state (skip for prereleases)</h4> <p>Create release notes for next release and edit them to set the version. These notes will be a skeleton and have little content:</p> <pre data-language="python">$ cp doc/source/release/template.rst doc/source/release/1.21.1-notes.rst
$ gvim doc/source/release/1.21.1-notes.rst
$ git add doc/source/release/1.21.1-notes.rst
</pre> <p>Add new release notes to the documentation release list and update the <code>RELEASE_NOTES</code> variable in <code>pavement.py</code>.</p>  <p>$ gvim doc/source/release.rst pavement.py</p>  <p>Commit the result:</p> <pre data-language="python">$ git commit -a -m"REL: prepare 1.21.x for further development"
$ git push upstream HEAD
</pre> </section> <section id="upload-to-pypi"> <h4>Upload to PyPI</h4> <p>Upload to PyPI using <code>twine</code>. A recent version of <code>twine</code> of is needed after recent PyPI changes, version <code>3.4.1</code> was used here:</p> <pre data-language="python">$ cd ../numpy
$ twine upload release/installers/*.whl
$ twine upload release/installers/numpy-1.21.0.zip  # Upload last.
</pre> <p>If one of the commands breaks in the middle, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems that might occur if pip users access the files while this is in process, causing pip to build from source rather than downloading a binary wheel. PyPI only allows a single source distribution, here we have chosen the zip archive.</p> </section> <section id="upload-files-to-github"> <h4>Upload files to github</h4> <p>Go to <a class="reference external" href="https://github.com/numpy/numpy/releases">https://github.com/numpy/numpy/releases</a>, there should be a <code>v1.21.0
tag</code>, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads. Start by editing the <code>release/README.md</code> that is translated from the rst version using pandoc. Things that will need fixing: PR lines from the changelog, if included, are wrapped and need unwrapping, links should be changed to monospaced text. Then copy the contents to the clipboard and paste them into the text window. It may take several tries to get it look right. Then</p> <ul class="simple"> <li>Upload <code>release/installers/numpy-1.21.0.tar.gz</code> as a binary file.</li> <li>Upload <code>release/installers/numpy-1.21.0.zip</code> as a binary file.</li> <li>Upload <code>release/README.rst</code> as a binary file.</li> <li>Upload <code>doc/changelog/1.21.0-changelog.rst</code> as a binary file.</li> <li>Check the pre-release button if this is a pre-releases.</li> <li>Hit the <code>{Publish,Update} release</code> button at the bottom.</li> </ul> </section> <section id="upload-documents-to-numpy-org-skip-for-prereleases"> <h4>Upload documents to numpy.org (skip for prereleases)</h4> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You will need a GitHub personal access token to push the update.</p> </div> <p>This step is only needed for final releases and can be skipped for pre-releases and most patch releases. <code>make merge-doc</code> clones the <code>numpy/doc</code> repo into <code>doc/build/merge</code> and updates it with the new documentation. If you already have a numpy installed, you need to locally install the new NumPy version so that document generation will use the correct NumPy. This is because <code>make
dist</code> does not correctly set up the path. Note that Python 3.10 cannot be used for generating the docs as it has no <code>easy_install</code>, use 3.9 or 3.8 instead:</p> <pre data-language="python">$ pushd doc
$ make dist
$ make merge-doc
$ pushd build/merge
</pre> <p>If the release series is a new one, you will need to add a new section to the <code>doc/build/merge/index.html</code> front page just after the “insert here” comment:</p> <pre data-language="python">$ gvim index.html +/'insert here'
</pre> <p>Further, update the version-switcher json file to add the new release and update the version marked <code>(stable)</code>:</p> <pre data-language="python">$ gvim _static/versions.json
</pre> <p>Otherwise, only the <code>zip</code> and <code>pdf</code> links should be updated with the new tag name:</p> <pre data-language="python">$ gvim index.html +/'tag v1.21'
</pre> <p>You can “test run” the new documentation in a browser to make sure the links work:</p> <pre data-language="python">$ firefox index.html  # or google-chrome, etc.
</pre> <p>Update the stable link and update:</p> <pre data-language="python">$ ln -sfn 1.21 stable
$ ls -l  # check the link
</pre> <p>Once everything seems satisfactory, update, commit and upload the changes:</p> <pre data-language="python">$ python3 update.py
$ git commit -a -m"Add documentation for v1.21.0"
$ git push
$ popd
$ popd
</pre> </section> <section id="announce-the-release-on-numpy-org-skip-for-prereleases"> <h4>Announce the release on numpy.org (skip for prereleases)</h4> <p>This assumes that you have forked <a class="reference external" href="https://github.com/numpy/numpy.org">https://github.com/numpy/numpy.org</a>:</p> <pre data-language="python">$ cd ../numpy.org
$ git checkout master
$ git pull upstream master
$ git checkout -b announce-numpy-1.21.0
$ gvim content/en/news.md
</pre> <ul class="simple"> <li>For all releases, go to the bottom of the page and add a one line link. Look to the previous links for example.</li> <li>For the <code>*.0</code> release in a cycle, add a new section at the top with a short description of the new features and point the news link to it.</li> </ul> <p>commit and push:</p> <pre data-language="python">$ git commit -a -m"announce the NumPy 1.21.0 release"
$ git push origin HEAD
</pre> <p>Go to your Github fork and make a pull request.</p> </section> <section id="announce-to-mailing-lists"> <h4>Announce to mailing lists</h4> <p>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</p> </section> <section id="post-release-tasks-skip-for-prereleases"> <h4>Post-Release Tasks (skip for prereleases)</h4> <p>Checkout main and forward port the documentation changes:</p> <pre data-language="python">$ git checkout -b post-1.21.0-release-update
$ git checkout maintenance/1.21.x doc/source/release/1.21.0-notes.rst
$ git checkout maintenance/1.21.x doc/changelog/1.21.0-changelog.rst
$ git checkout maintenance/1.21.x .mailmap  # only if updated for release.
$ gvim doc/source/release.rst  # Add link to new notes
$ git add doc/changelog/1.21.0-changelog.rst doc/source/release/1.21.0-notes.rst
$ git status  # check status before commit
$ git commit -a -m"REL: Update main after 1.21.0 release."
$ git push origin HEAD
</pre> <p>Go to GitHub and make a PR.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/dev/releasing.html" class="_attribution-link">https://numpy.org/doc/1.23/dev/releasing.html</a>
  </p>
</div>
