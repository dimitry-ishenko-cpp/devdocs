<section id="data-types"> <h1 id="basics-types">Data types</h1> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../reference/arrays.dtypes.html#arrays-dtypes"><span class="std std-ref">Data type objects</span></a></p> </div> <section id="array-types-and-conversions-between-types"> <h2>Array types and conversions between types</h2> <p>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array’s data-type.</p> <p>NumPy numerical types are instances of <a class="reference internal" href="../reference/generated/numpy.dtype.html#numpy.dtype" title="numpy.dtype"><code>numpy.dtype</code></a> (data-type) objects, each having unique characteristics. Once you have imported NumPy using <code>import
numpy as np</code> you can create arrays with a specified dtype using the scalar types in the numpy top-level API, e.g. <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bool" title="numpy.bool"><code>numpy.bool</code></a>, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.float32" title="numpy.float32"><code>numpy.float32</code></a>, etc.</p> <p>These scalar types as arguments to the dtype keyword that many numpy functions or methods accept. For example:</p> <pre data-language="python">&gt;&gt;&gt; z = np.arange(3, dtype=np.uint8)
&gt;&gt;&gt; z
array([0, 1, 2], dtype=uint8)
</pre> <p>Array types can also be referred to by character codes, for example:</p> <pre data-language="python">&gt;&gt;&gt; np.array([1, 2, 3], dtype='f')
array([1.,  2.,  3.], dtype=float32)
&gt;&gt;&gt; np.array([1, 2, 3], dtype='d')
array([1.,  2.,  3.], dtype=float64)
</pre> <p>See <a class="reference internal" href="../reference/arrays.dtypes.html#arrays-dtypes-constructing"><span class="std std-ref">Specifying and constructing data types</span></a> for more information about specifying and constructing data type objects, including how to specify parameters like the byte order.</p> <p>To convert the type of an array, use the .astype() method. For example:</p> <pre data-language="python">&gt;&gt;&gt; z.astype(np.float64)                 
array([0.,  1.,  2.])
</pre> <p>Note that, above, we could have used the <em>Python</em> float object as a dtype instead of <a class="reference internal" href="../reference/arrays.scalars.html#numpy.float64" title="numpy.float64"><code>numpy.float64</code></a>. NumPy knows that <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code>int</code></a> refers to <a class="reference internal" href="../reference/arrays.scalars.html#numpy.int_" title="numpy.int_"><code>numpy.int_</code></a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code>bool</code></a> means <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bool" title="numpy.bool"><code>numpy.bool</code></a>, that <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code>float</code></a> is <a class="reference internal" href="../reference/arrays.scalars.html#numpy.float64" title="numpy.float64"><code>numpy.float64</code></a> and <a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.12)"><code>complex</code></a> is <a class="reference internal" href="../reference/arrays.scalars.html#numpy.complex128" title="numpy.complex128"><code>numpy.complex128</code></a>. The other data-types do not have Python equivalents.</p> <p>To determine the type of an array, look at the dtype attribute:</p> <pre data-language="python">&gt;&gt;&gt; z.dtype
dtype('uint8')
</pre> <p>dtype objects also contain information about the type, such as its bit-width and its byte-order. The data type can also be used indirectly to query properties of the type, such as whether it is an integer:</p> <pre data-language="python">&gt;&gt;&gt; d = np.dtype(int64)
&gt;&gt;&gt; d
dtype('int64')

&gt;&gt;&gt; np.issubdtype(d, np.integer)
True

&gt;&gt;&gt; np.issubdtype(d, np.floating)
False
</pre> <section id="numerical-data-types"> <h3>Numerical Data Types</h3> <p>There are 5 basic numerical types representing booleans (<code>bool</code>), integers (<code>int</code>), unsigned integers (<code>uint</code>) floating point (<code>float</code>) and <code>complex</code>. A basic numerical type name combined with a numeric bitsize defines a concrete type. The bitsize is the number of bits that are needed to represent a single value in memory. For example, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.float64" title="numpy.float64"><code>numpy.float64</code></a> is a 64 bit floating point data type. Some types, such as <a class="reference internal" href="../reference/arrays.scalars.html#numpy.int_" title="numpy.int_"><code>numpy.int_</code></a> and <a class="reference internal" href="../reference/arrays.scalars.html#numpy.intp" title="numpy.intp"><code>numpy.intp</code></a>, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit CPU architectures). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</p> </section> <section id="data-types-for-strings-and-bytes"> <h3>Data Types for Strings and Bytes</h3> <p>In addition to numerical types, NumPy also supports storing unicode strings, via the <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a> dtype (<code>U</code> character code), null-terminated byte sequences via <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a> (<code>S</code> character code), and arbitrary byte sequences, via <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a> (<code>V</code> character code).</p> <p>All of the above are <em>fixed-width</em> data types. They are parameterized by a width, in either bytes or unicode points, that a single data element in the array must fit inside. This means that storing an array of byte sequences or strings using this dtype requires knowing or calculating the sizes of the longest text or byte sequence in advance.</p> <p>As an example, we can create an array storing the words <code>"hello"</code> and <code>"world!"</code>:</p> <pre data-language="python">&gt;&gt;&gt; np.array(["hello", "world!"])
array(['hello', 'world!'], dtype='&lt;U6')
</pre> <p>Here the data type is detected as a unicode string that is a maximum of 6 code points long, enough to store both entries without truncation. If we specify a shorter or longer data type, the string is either truncated or zero-padded to fit in the specified width:</p> <pre data-language="python">&gt;&gt;&gt; np.array(["hello", "world!"], dtype="U5")
array(['hello', 'world'], dtype='&lt;U5')
&gt;&gt;&gt; np.array(["hello", "world!"], dtype="U7")
array(['hello', 'world!'], dtype='&lt;U7')
</pre> <p>We can see the zero-padding a little more clearly if we use the bytes data type and ask NumPy to print out the bytes in the array buffer:</p> <pre data-language="python">&gt;&gt;&gt; np.array(["hello", "world"], dtype="S7").tobytes()
b'hello\x00\x00world\x00\x00'
</pre> <p>Each entry is padded with two extra null bytes. Note however that NumPy cannot tell the difference between intentionally stored trailing nulls and padding nulls:</p> <pre data-language="python">&gt;&gt;&gt; x = [b"hello\0\0", b"world"]
&gt;&gt;&gt; a = np.array(x, dtype="S7")
&gt;&gt;&gt; print(a[0])
b"hello"
&gt;&gt;&gt; a[0] == x[0]
False
</pre> <p>If you need to store and round-trip any trailing null bytes, you will need to use an unstructured void data type:</p> <pre data-language="python">&gt;&gt;&gt; a = np.array(x, dtype="V7")
&gt;&gt;&gt; a
array([b'\x68\x65\x6C\x6C\x6F\x00\x00', b'\x77\x6F\x72\x6C\x64\x00\x00'],
      dtype='|V7')
&gt;&gt;&gt; a[0] == np.void(x[0])
True
</pre> <p>Advanced types, not listed above, are explored in section <a class="reference internal" href="basics.rec.html#structured-arrays"><span class="std std-ref">Structured arrays</span></a>.</p> </section> </section> <section id="relationship-between-numpy-data-types-and-c-data-data-types"> <h2 id="canonical-python-and-c-types">Relationship Between NumPy Data Types and C Data Data Types</h2> <p>NumPy provides both bit sized type names and names based on the names of C types. Since the definition of C types are platform dependent, this means the explicitly bit sized should be preferred to avoid platform-dependent behavior in programs using NumPy.</p> <p>To ease integration with C code, where it is more natural to refer to platform-dependent C types, NumPy also provides type aliases that correspond to the C types for the platform. Some dtypes have trailing underscore to avoid confusion with builtin python type names, such as <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bool_" title="numpy.bool_"><code>numpy.bool_</code></a>.</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>Canonical Python API name</p></th> <th class="head"><p>Python API “C-like” name</p></th> <th class="head"><p>Actual C type</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.bool" title="numpy.bool"><code>numpy.bool</code></a> or <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bool_" title="numpy.bool_"><code>numpy.bool_</code></a></p></td> <td><p>N/A</p></td> <td><p><code>bool</code> (defined in <code>stdbool.h</code>)</p></td> <td><p>Boolean (True or False) stored as a byte.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.int8" title="numpy.int8"><code>numpy.int8</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.byte" title="numpy.byte"><code>numpy.byte</code></a></p></td> <td><p><code>signed char</code></p></td> <td><p>Platform-defined integer type with 8 bits.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uint8" title="numpy.uint8"><code>numpy.uint8</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.ubyte" title="numpy.ubyte"><code>numpy.ubyte</code></a></p></td> <td><p><code>unsigned char</code></p></td> <td><p>Platform-defined integer type with 8 bits without sign.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.int16" title="numpy.int16"><code>numpy.int16</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.short" title="numpy.short"><code>numpy.short</code></a></p></td> <td><p><code>short</code></p></td> <td><p>Platform-defined integer type with 16 bits.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uint16" title="numpy.uint16"><code>numpy.uint16</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.ushort" title="numpy.ushort"><code>numpy.ushort</code></a></p></td> <td><p><code>unsigned short</code></p></td> <td><p>Platform-defined integer type with 16 bits without sign.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.int32" title="numpy.int32"><code>numpy.int32</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.intc" title="numpy.intc"><code>numpy.intc</code></a></p></td> <td><p><code>int</code></p></td> <td><p>Platform-defined integer type with 32 bits.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uint32" title="numpy.uint32"><code>numpy.uint32</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uintc" title="numpy.uintc"><code>numpy.uintc</code></a></p></td> <td><p><code>unsigned int</code></p></td> <td><p>Platform-defined integer type with 32 bits without sign.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.intp" title="numpy.intp"><code>numpy.intp</code></a></p></td> <td><p>N/A</p></td> <td><p><code>ssize_t</code>/<code>Py_ssize_t</code></p></td> <td><p>Platform-defined integer of size <code>size_t</code>; used e.g. for sizes.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uintp" title="numpy.uintp"><code>numpy.uintp</code></a></p></td> <td><p>N/A</p></td> <td><p><code>size_t</code></p></td> <td><p>Platform-defined integer type capable of storing the maximum allocation size.</p></td> </tr> <tr>
<td><p>N/A</p></td> <td><p><code>'p'</code></p></td> <td><p><code>intptr_t</code></p></td> <td><p>Guaranteed to hold pointers. Character code only (Python and C).</p></td> </tr> <tr>
<td><p>N/A</p></td> <td><p><code>'P'</code></p></td> <td><p><code>uintptr_t</code></p></td> <td><p>Guaranteed to hold pointers. Character code only (Python and C).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.int32" title="numpy.int32"><code>numpy.int32</code></a> or <a class="reference internal" href="../reference/arrays.scalars.html#numpy.int64" title="numpy.int64"><code>numpy.int64</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.long" title="numpy.long"><code>numpy.long</code></a></p></td> <td><p><code>long</code></p></td> <td><p>Platform-defined integer type with at least 32 bits.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.uint32" title="numpy.uint32"><code>numpy.uint32</code></a> or <a class="reference internal" href="../reference/arrays.scalars.html#numpy.uint64" title="numpy.uint64"><code>numpy.uint64</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.ulong" title="numpy.ulong"><code>numpy.ulong</code></a></p></td> <td><p><code>unsigned long</code></p></td> <td><p>Platform-defined integer type with at least 32 bits without sign.</p></td> </tr> <tr>
<td><p>N/A</p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.longlong" title="numpy.longlong"><code>numpy.longlong</code></a></p></td> <td><p><code>long long</code></p></td> <td><p>Platform-defined integer type with at least 64 bits.</p></td> </tr> <tr>
<td><p>N/A</p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.ulonglong" title="numpy.ulonglong"><code>numpy.ulonglong</code></a></p></td> <td><p><code>unsigned long long</code></p></td> <td><p>Platform-defined integer type with at least 64 bits without sign.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.float16" title="numpy.float16"><code>numpy.float16</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.half" title="numpy.half"><code>numpy.half</code></a></p></td> <td><p>N/A</p></td> <td><p>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.float32" title="numpy.float32"><code>numpy.float32</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.single" title="numpy.single"><code>numpy.single</code></a></p></td> <td><p><code>float</code></p></td> <td><p>Platform-defined single precision float: typically sign bit, 8 bits exponent, 23 bits mantissa.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.float64" title="numpy.float64"><code>numpy.float64</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.double" title="numpy.double"><code>numpy.double</code></a></p></td> <td><p><code>double</code></p></td> <td><p>Platform-defined double precision float: typically sign bit, 11 bits exponent, 52 bits mantissa.</p></td> </tr> <tr>
<td><p><code>numpy.float96</code> or <code>numpy.float128</code></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.longdouble" title="numpy.longdouble"><code>numpy.longdouble</code></a></p></td> <td><p><code>long double</code></p></td> <td><p>Platform-defined extended-precision float.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.complex64" title="numpy.complex64"><code>numpy.complex64</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.csingle" title="numpy.csingle"><code>numpy.csingle</code></a></p></td> <td><p><code>float complex</code></p></td> <td><p>Complex number, represented by two single-precision floats (real and imaginary components).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.complex128" title="numpy.complex128"><code>numpy.complex128</code></a></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.cdouble" title="numpy.cdouble"><code>numpy.cdouble</code></a></p></td> <td><p><code>double complex</code></p></td> <td><p>Complex number, represented by two double-precision floats (real and imaginary components).</p></td> </tr> <tr>
<td><p><code>numpy.complex192</code> or <code>numpy.complex256</code></p></td> <td><p><a class="reference internal" href="../reference/arrays.scalars.html#numpy.clongdouble" title="numpy.clongdouble"><code>numpy.clongdouble</code></a></p></td> <td><p><code>long double complex</code></p></td> <td><p>Complex number, represented by two extended-precision floats (real and imaginary components).</p></td> </tr>  </table> </div> <p>Since many of these have platform-dependent definitions, a set of fixed-size aliases are provided (See <a class="reference internal" href="../reference/arrays.scalars.html#sized-aliases"><span class="std std-ref">Sized aliases</span></a>).</p> </section> <section id="array-scalars"> <h2>Array scalars</h2> <p>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype). Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples). There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g., <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code>int</code></a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code>float</code></a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.12)"><code>complex</code></a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code>str</code></a>).</p> <p>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. <code>int16</code>). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</p> </section> <section id="overflow-errors"> <h2 id="id1">Overflow errors</h2> <p>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, <a class="reference internal" href="../reference/generated/numpy.power.html#numpy.power" title="numpy.power"><code>numpy.power</code></a> evaluates <code>100 ** 9</code> correctly for 64-bit integers, but gives -1486618624 (incorrect) for a 32-bit integer.</p> <pre data-language="python">&gt;&gt;&gt; np.power(100, 9, dtype=np.int64)
1000000000000000000
&gt;&gt;&gt; np.power(100, 9, dtype=np.int32)
-1486618624
</pre> <p>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python’s <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code>int</code></a>. Unlike NumPy, the size of Python’s <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code>int</code></a> is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</p> <p>NumPy provides <a class="reference internal" href="../reference/generated/numpy.iinfo.html#numpy.iinfo" title="numpy.iinfo"><code>numpy.iinfo</code></a> and <a class="reference internal" href="../reference/generated/numpy.finfo.html#numpy.finfo" title="numpy.finfo"><code>numpy.finfo</code></a> to verify the minimum or maximum values of NumPy integer and floating point values respectively</p> <pre data-language="python">&gt;&gt;&gt; np.iinfo(int) # Bounds of the default integer on this system.
iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)
&gt;&gt;&gt; np.iinfo(np.int32) # Bounds of a 32-bit integer
iinfo(min=-2147483648, max=2147483647, dtype=int32)
&gt;&gt;&gt; np.iinfo(np.int64) # Bounds of a 64-bit integer
iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)
</pre> <p>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</p> <pre data-language="python">&gt;&gt;&gt; np.power(100, 100, dtype=np.int64) # Incorrect even with 64-bit int
0
&gt;&gt;&gt; np.power(100, 100, dtype=np.float64)
1e+200
</pre> </section> <section id="extended-precision"> <h2>Extended precision</h2> <p>Python’s floating-point numbers are usually 64-bit floating-point numbers, nearly equivalent to <a class="reference internal" href="../reference/arrays.scalars.html#numpy.float64" title="numpy.float64"><code>numpy.float64</code></a>. In some unusual situations it may be useful to use floating-point numbers with more precision. Whether this is possible in numpy depends on the hardware and on the development environment: specifically, x86 machines provide hardware floating-point with 80-bit precision, and while most C compilers provide this as their <code>long double</code> type, MSVC (standard for Windows builds) makes <code>long double</code> identical to <code>double</code> (64 bits). NumPy makes the compiler’s <code>long double</code> available as <a class="reference internal" href="../reference/arrays.scalars.html#numpy.longdouble" title="numpy.longdouble"><code>numpy.longdouble</code></a> (and <code>np.clongdouble</code> for the complex numbers). You can find out what your numpy provides with <code>np.finfo(np.longdouble)</code>.</p> <p>NumPy does not provide a dtype with more precision than C’s <code>long double</code>; in particular, the 128-bit IEEE quad precision data type (FORTRAN’s <code>REAL*16</code>) is not available.</p> <p>For efficient memory alignment, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.longdouble" title="numpy.longdouble"><code>numpy.longdouble</code></a> is usually stored padded with zero bits, either to 96 or 128 bits. Which is more efficient depends on hardware and development environment; typically on 32-bit systems they are padded to 96 bits, while on 64-bit systems they are typically padded to 128 bits. <code>np.longdouble</code> is padded to the system default; <code>np.float96</code> and <code>np.float128</code> are provided for users who want specific padding. In spite of the names, <code>np.float96</code> and <code>np.float128</code> provide only as much precision as <code>np.longdouble</code>, that is, 80 bits on most x86 machines and 64 bits in standard Windows builds.</p> <p>Be warned that even if <a class="reference internal" href="../reference/arrays.scalars.html#numpy.longdouble" title="numpy.longdouble"><code>numpy.longdouble</code></a> offers more precision than python <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code>float</code></a>, it is easy to lose that extra precision, since python often forces values to pass through <code>float</code>. For example, the <code>%</code> formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value <code>1 + np.finfo(np.longdouble).eps</code>.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/user/basics.types.html" class="_attribution-link">https://numpy.org/doc/2.0/user/basics.types.html</a>
  </p>
</div>
