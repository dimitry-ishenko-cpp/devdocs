<section id="working-with-arrays-of-strings-and-bytes"> <h1 id="basics-strings">Working with Arrays of Strings And Bytes</h1> <p>While NumPy is primarily a numerical library, it is often convenient to work with NumPy arrays of strings or bytes. The two most common use cases are:</p> <ul class="simple"> <li>Working with data loaded or memory-mapped from a data file, where one or more of the fields in the data is a string or bytestring, and the maximum length of the field is known ahead of time. This often is used for a name or label field.</li> <li>Using NumPy indexing and broadcasting with arrays of Python strings of unknown length, which may or may not have data defined for every value.</li> </ul> <p>For the first use case, NumPy provides the fixed-width <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a>, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a> and <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a> data types. For the second use case, numpy provides <a class="reference internal" href="../reference/routines.dtypes.html#numpy.dtypes.StringDType" title="numpy.dtypes.StringDType"><code>numpy.dtypes.StringDType</code></a>. Below we describe how to work with both fixed-width and variable-width string arrays, how to convert between the two representations, and provide some advice for most efficiently working with string data in NumPy.</p> <section id="fixed-width-data-types"> <h2>Fixed-width data types</h2> <p>Before NumPy 2.0, the fixed-width <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a>, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a>, and <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a> data types were the only types available for working with strings and bytestrings in NumPy. For this reason, they are used as the default dtype for strings and bytestrings, respectively:</p> <pre data-language="python">&gt;&gt;&gt; np.array(["hello", "world"])
array(['hello', 'world'], dtype='&lt;U5')
</pre> <p>Here the detected data type is <code>'&lt;U5'</code>, or little-endian unicode string data, with a maximum length of 5 unicode code points.</p> <p>Similarly for bytestrings:</p> <pre data-language="python">&gt;&gt;&gt; np.array([b"hello", b"world"])
array([b'hello', b'world'], dtype='|S5')
</pre> <p>Since this is a one-byte encoding, the byteorder is <code>‘|’</code> (not applicable), and the data type detected is a maximum 5 character bytestring.</p> <p>You can also use <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a> to represent bytestrings:</p> <pre data-language="python">&gt;&gt;&gt; np.array([b"hello", b"world"]).astype(np.void)
array([b'\x68\x65\x6C\x6C\x6F', b'\x77\x6F\x72\x6C\x64'], dtype='|V5')
</pre> <p>This is most useful when working with byte streams that are not well represented as bytestrings, and instead are better thought of as collections of 8-bit integers.</p> </section> <section id="variable-width-strings"> <h2 id="stringdtype">Variable-width strings</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="../reference/routines.dtypes.html#numpy.dtypes.StringDType" title="numpy.dtypes.StringDType"><code>numpy.dtypes.StringDType</code></a> is a new addition to NumPy, implemented using the new support in NumPy for flexible user-defined data types and is not as extensively tested in production workflows as the older NumPy data types.</p> </div> <p>Often, real-world string data does not have a predictable length. In these cases it is awkward to use fixed-width strings, since storing all the data without truncation requires knowing the length of the longest string one would like to store in the array before the array is created.</p> <p>To support situations like this, NumPy provides <a class="reference internal" href="../reference/routines.dtypes.html#numpy.dtypes.StringDType" title="numpy.dtypes.StringDType"><code>numpy.dtypes.StringDType</code></a>, which stores variable-width string data in a UTF-8 encoding in a NumPy array:</p> <pre data-language="python">&gt;&gt;&gt; from numpy.dtypes import StringDType
&gt;&gt;&gt; data = ["this is a longer string", "short string"]
&gt;&gt;&gt; arr = np.array(data, dtype=StringDType())
&gt;&gt;&gt; arr
array(['this is a longer string', 'short string'], dtype=StringDType())
</pre> <p>Note that unlike fixed-width strings, <code>StringDType</code> is not parameterized by the maximum length of an array element, arbitrarily long or short strings can live in the same array without needing to reserve storage for padding bytes in the short strings.</p> <p>Also note that unlike fixed-width strings and most other NumPy data types, <code>StringDType</code> does not store the string data in the “main” <code>ndarray</code> data buffer. Instead, the array buffer is used to store metadata about where the string data are stored in memory. This difference means that code expecting the array buffer to contain string data will not function correctly, and will need to be updated to support <code>StringDType</code>.</p> <section id="missing-data-support"> <h3>Missing data support</h3> <p>Often string datasets are not complete, and a special label is needed to indicate that a value is missing. By default <code>StringDType</code> does not have any special support for missing values, besides the fact that empty strings are used to populate empty arrays:</p> <pre data-language="python">&gt;&gt;&gt; np.empty(3, dtype=StringDType())
array(['', '', ''], dtype=StringDType())
</pre> <p>Optionally, you can pass create an instance of <code>StringDType</code> with support for missing values by passing <code>na_object</code> as a keyword argument for the initializer:</p> <pre data-language="python">&gt;&gt;&gt; dt = StringDType(na_object=None)
&gt;&gt;&gt; arr = np.array(["this array has", None, "as an entry"], dtype=dt)
&gt;&gt;&gt; arr
array(['this array has', None, 'as an entry'],
      dtype=StringDType(na_object=None))
&gt;&gt;&gt; arr[1] is None
True
</pre> <p>The <code>na_object</code> can be any arbitrary python object. Common choices are <a class="reference internal" href="../reference/constants.html#numpy.nan" title="numpy.nan"><code>numpy.nan</code></a>, <code>float('nan')</code>, <code>None</code>, an object specifically intended to represent missing data like <code>pandas.NA</code>, or a (hopefully) unique string like <code>"__placeholder__"</code>.</p> <p>NumPy has special handling for NaN-like sentinels and string sentinels.</p> <section id="nan-like-missing-data-sentinels"> <h4>NaN-like Missing Data Sentinels</h4> <p>A NaN-like sentinel returns itself as the result of arithmetic operations. This includes the python <code>nan</code> float and the Pandas missing data sentinel <code>pd.NA</code>. NaN-like sentinels inherit these behaviors in string operations. This means that, for example, the result of addition with any other string is the sentinel:</p> <pre data-language="python">&gt;&gt;&gt; dt = StringDType(na_object=np.nan)
&gt;&gt;&gt; arr = np.array(["hello", np.nan, "world"], dtype=dt)
&gt;&gt;&gt; arr + arr
array(['hellohello', nan, 'worldworld'], dtype=StringDType(na_object=nan))
</pre> <p>Following the behavior of <code>nan</code> in float arrays, NaN-like sentinels sort to the end of the array:</p> <pre data-language="python">&gt;&gt;&gt; np.sort(arr)
array(['hello', 'world', nan], dtype=StringDType(na_object=nan))
</pre> </section> <section id="string-missing-data-sentinels"> <h4>String Missing Data Sentinels</h4> <p>A string missing data value is an instance of <code>str</code> or subtype of <code>str</code>. If such an array is passed to a string operation or a cast, “missing” entries are treated as if they have a value given by the string sentinel. Comparison operations similarly use the sentinel value directly for missing entries.</p> </section> <section id="other-sentinels"> <h4>Other Sentinels</h4> <p>Other objects, such as <code>None</code> are also supported as missing data sentinels. If any missing data are present in an array using such a sentinel, then string operations will raise an error:</p> <pre data-language="python">&gt;&gt;&gt; dt = StringDType(na_object=None)
&gt;&gt;&gt; arr = np.array(["this array has", None, "as an entry"])
&gt;&gt;&gt; np.sort(arr)
Traceback (most recent call last):
...
TypeError: '&lt;' not supported between instances of 'NoneType' and 'str'
</pre> </section> </section> <section id="coercing-non-strings"> <h3>Coercing Non-strings</h3> <p>By default, non-string data are coerced to strings:</p> <pre data-language="python">&gt;&gt;&gt; np.array([1, object(), 3.4], dtype=StringDType())
array(['1', '&lt;object object at 0x7faa2497dde0&gt;', '3.4'], dtype=StringDType())
</pre> <p>If this behavior is not desired, an instance of the DType can be created that disables string coercion by setting <code>coerce=False</code> in the initializer:</p> <pre data-language="python">&gt;&gt;&gt; np.array([1, object(), 3.4], dtype=StringDType(coerce=False))
Traceback (most recent call last):
...
ValueError: StringDType only allows string data when string coercion is disabled.
</pre> <p>This allows strict data validation in the same pass over the data NumPy uses to create the array. Setting <code>coerce=True</code> recovers the default behavior allowing coercion to strings.</p> </section> <section id="casting-to-and-from-fixed-width-strings"> <h3>Casting To and From Fixed-Width Strings</h3> <p><code>StringDType</code> supports round-trip casts between <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a>, <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a>, and <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a>. Casting to a fixed-width string is most useful when strings need to be memory-mapped in an ndarray or when a fixed-width string is needed for reading and writing to a columnar data format with a known maximum string length.</p> <p>In all cases, casting to a fixed-width string requires specifying the maximum allowed string length:</p> <pre data-language="python">&gt;&gt;&gt; arr = np.array(["hello", "world"], dtype=StringDType())
&gt;&gt;&gt; arr.astype(np.str_)  
Traceback (most recent call last):
...
TypeError: Casting from StringDType to a fixed-width dtype with an
unspecified size is not currently supported, specify an explicit
size for the output dtype instead.

The above exception was the direct cause of the following
exception:

TypeError: cannot cast dtype StringDType() to &lt;class 'numpy.dtypes.StrDType'&gt;.
&gt;&gt;&gt; arr.astype("U5")
array(['hello', 'world'], dtype='&lt;U5')
</pre> <p>The <a class="reference internal" href="../reference/arrays.scalars.html#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a> cast is most useful for string data that is known to contain only ASCII characters, as characters outside this range cannot be represented in a single byte in the UTF-8 encoding and are rejected.</p> <p>Any valid unicode string can be cast to <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a>, although since <a class="reference internal" href="../reference/arrays.scalars.html#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a> uses a 32-bit UCS4 encoding for all characters, this will often waste memory for real-world textual data that can be well-represented by a more memory-efficient encoding.</p> <p>Additionally, any valid unicode string can be cast to <a class="reference internal" href="../reference/arrays.scalars.html#numpy.void" title="numpy.void"><code>numpy.void</code></a>, storing the UTF-8 bytes directly in the output array:</p> <pre data-language="python">&gt;&gt;&gt; arr = np.array(["hello", "world"], dtype=StringDType())
&gt;&gt;&gt; arr.astype("V5")
array([b'\x68\x65\x6C\x6C\x6F', b'\x77\x6F\x72\x6C\x64'], dtype='|V5')
</pre> <p>Care must be taken to ensure that the output array has enough space for the UTF-8 bytes in the string, since the size of a UTF-8 bytestream in bytes is not necessarily the same as the number of characters in the string.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/user/basics.strings.html" class="_attribution-link">https://numpy.org/doc/2.0/user/basics.strings.html</a>
  </p>
</div>
