<h1 id="id1">For downstream package authors</h1> <p>This document aims to explain some best practices for authoring a package that depends on NumPy.</p> <section id="understanding-numpy-s-versioning-and-api-abi-stability"> <h2>Understanding NumPy’s versioning and API/ABI stability</h2> <p>NumPy uses a standard, <a class="pep reference external" href="https://peps.python.org/pep-0440/" id="index-0"><strong>PEP 440</strong></a> compliant, versioning scheme: <code>major.minor.bugfix</code>. A <em>major</em> release is highly unusual (NumPy is still at version <code>1.xx</code>) and if it happens it will likely indicate an ABI break. <em>Minor</em> versions are released regularly, typically every 6 months. Minor versions contain new features, deprecations, and removals of previously deprecated code. <em>Bugfix</em> releases are made even more frequently; they do not contain any new features or deprecations.</p> <p>It is important to know that NumPy, like Python itself and most other well known scientific Python projects, does <strong>not</strong> use semantic versioning. Instead, backwards incompatible API changes require deprecation warnings for at least two releases. For more details, see <a class="reference external" href="https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23" title="(in NumPy Enhancement Proposals)"><span>NEP 23 — Backwards compatibility and deprecation policy</span></a>.</p> <p>NumPy has both a Python API and a C API. The C API can be used directly or via Cython, f2py, or other such tools. If your package uses the C API, then ABI (application binary interface) stability of NumPy is important. NumPy’s ABI is forward but not backward compatible. This means: binaries compiled against a given version of NumPy will still run correctly with newer NumPy versions, but not with older versions.</p> </section> <section id="testing-against-the-numpy-main-branch-or-pre-releases"> <h2>Testing against the NumPy main branch or pre-releases</h2> <p>For large, actively maintained packages that depend on NumPy, we recommend testing against the development version of NumPy in CI. To make this easy, nightly builds are provided as wheels at <a class="reference external" href="https://anaconda.org/scipy-wheels-nightly/">https://anaconda.org/scipy-wheels-nightly/</a>. This helps detect regressions in NumPy that need fixing before the next NumPy release. Furthermore, we recommend to raise errors on warnings in CI for this job, either all warnings or otherwise at least <code>DeprecationWarning</code> and <code>FutureWarning</code>. This gives you an early warning about changes in NumPy to adapt your code.</p> </section> <section id="adding-a-dependency-on-numpy"> <h2>Adding a dependency on NumPy</h2> <section id="build-time-dependency"> <h3>Build-time dependency</h3> <p>If a package either uses the NumPy C API directly or it uses some other tool that depends on it like Cython or Pythran, NumPy is a <em>build-time</em> dependency of the package. Because the NumPy ABI is only forward compatible, you must build your own binaries (wheels or other package formats) against the lowest NumPy version that you support (or an even older version).</p> <p>Picking the correct NumPy version to build against for each Python version and platform can get complicated. There are a couple of ways to do this. Build-time dependencies are specified in <code>pyproject.toml</code> (see PEP 517), which is the file used to build wheels by PEP 517 compliant tools (e.g., when using <code>pip wheel</code>).</p> <p>You can specify everything manually in <code>pyproject.toml</code>, or you can instead rely on the <a class="reference external" href="https://github.com/scipy/oldest-supported-numpy/">oldest-supported-numpy</a> metapackage. <code>oldest-supported-numpy</code> will specify the correct NumPy version at build time for wheels, taking into account Python version, Python implementation (CPython or PyPy), operating system and hardware platform. It will specify the oldest NumPy version that supports that combination of characteristics. Note: for platforms for which NumPy provides wheels on PyPI, it will be the first version with wheels (even if some older NumPy version happens to build).</p> <p>For conda-forge it’s a little less complicated: there’s dedicated handling for NumPy in build-time and runtime dependencies, so typically this is enough (see <a class="reference external" href="https://conda-forge.org/docs/maintainer/knowledge_base.html#building-against-numpy">here</a> for docs):</p> <pre data-language="python">host:
  - numpy
run:
  - {{ pin_compatible('numpy') }}
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>pip</code> has <code>--no-use-pep517</code> and <code>--no-build-isolation</code> flags that may ignore <code>pyproject.toml</code> or treat it differently - if users use those flags, they are responsible for installing the correct build dependencies themselves.</p> <p><code>conda</code> will always use <code>-no-build-isolation</code>; dependencies for conda builds are given in the conda recipe (<code>meta.yaml</code>), the ones in <code>pyproject.toml</code> have no effect.</p> <p>Please do not use <code>setup_requires</code> (it is deprecated and may invoke <code>easy_install</code>).</p> </div> <p>Because for NumPy you have to care about ABI compatibility, you specify the version with <code>==</code> to the lowest supported version. For your other build dependencies you can probably be looser, however it’s still important to set lower and upper bounds for each dependency. It’s fine to specify either a range or a specific version for a dependency like <code>wheel</code> or <code>setuptools</code>. It’s recommended to set the upper bound of the range to the latest already released version of <code>wheel</code> and <code>setuptools</code> - this prevents future releases from breaking your packages on PyPI.</p> </section> <section id="runtime-dependency-version-ranges"> <h3>Runtime dependency &amp; version ranges</h3> <p>NumPy itself and many core scientific Python packages have agreed on a schedule for dropping support for old Python and NumPy versions: <a class="reference external" href="https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29" title="(in NumPy Enhancement Proposals)"><span>NEP 29 — Recommend Python and NumPy version support as a community policy standard</span></a>. We recommend all packages depending on NumPy to follow the recommendations in NEP 29.</p> <p>For <em>run-time dependencies</em>, specify version bounds using <code>install_requires</code> in <code>setup.py</code> (assuming you use <code>numpy.distutils</code> or <code>setuptools</code> to build).</p> <p>Most libraries that rely on NumPy will not need to set an upper version bound: NumPy is careful to preserve backward-compatibility.</p> <p>That said, if you are (a) a project that is guaranteed to release frequently, (b) use a large part of NumPy’s API surface, and (c) is worried that changes in NumPy may break your code, you can set an upper bound of <code>&lt;MAJOR.MINOR + N</code> with N no less than 3, and <code>MAJOR.MINOR</code> being the current release of NumPy <a class="footnote-reference brackets" href="#id3" id="id2">*</a>. If you use the NumPy C API (directly or via Cython), you can also pin the current major version to prevent ABI breakage. Note that setting an upper bound on NumPy may <a class="reference external" href="https://iscinumpy.dev/post/bound-version-constraints/">affect the ability of your library to be installed alongside other, newer packages</a>.</p> <dl class="footnote brackets"> <dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id2">*</a></span></dt> <dd>
<p>The reason for setting <code>N=3</code> is that NumPy will, on the rare occasion where it makes breaking changes, raise warnings for at least two releases. (NumPy releases about once every six months, so this translates to a window of at least a year; hence the subsequent requirement that your project releases at least on that cadence.)</p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>SciPy has more documentation on how it builds wheels and deals with its build-time and runtime dependencies <a class="reference external" href="https://scipy.github.io/devdocs/dev/core-dev/index.html#distributing">here</a>.</p> <p>NumPy and SciPy wheel build CI may also be useful as a reference, it can be found <a class="reference external" href="https://github.com/MacPython/numpy-wheels">here for NumPy</a> and <a class="reference external" href="https://github.com/MacPython/scipy-wheels">here for SciPy</a>.</p> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/user/depending_on_numpy.html" class="_attribution-link">https://numpy.org/doc/1.23/user/depending_on_numpy.html</a>
  </p>
</div>
