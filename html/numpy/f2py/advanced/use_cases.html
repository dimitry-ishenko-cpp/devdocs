<section id="advanced-f2py-use-cases"> <h1>Advanced F2PY use cases</h1> <section id="adding-user-defined-functions-to-f2py-generated-modules"> <h2>Adding user-defined functions to F2PY generated modules</h2> <p>User-defined Python C/API functions can be defined inside signature files using <code>usercode</code> and <code>pymethoddef</code> statements (they must be used inside the <code>python module</code> block). For example, the following signature file <code>spam.pyf</code></p> <pre data-language="python">!    -*- f90 -*-
python module spam
    usercode '''
  static char doc_spam_system[] = "Execute a shell command.";
  static PyObject *spam_system(PyObject *self, PyObject *args)
  {
    char *command;
    int sts;

    if (!PyArg_ParseTuple(args, "s", &amp;command))
        return NULL;
    sts = system(command);
    return Py_BuildValue("i", sts);
  }
    '''
    pymethoddef '''
    {"system",  spam_system, METH_VARARGS, doc_spam_system},
    '''
end python module spam
</pre> <p>wraps the C library function <code>system()</code>:</p> <pre data-language="python">f2py -c spam.pyf
</pre> <p>In Python this can then be used as:</p> <pre data-language="python">&gt;&gt;&gt; import spam
&gt;&gt;&gt; status = spam.system('whoami')
pearu
&gt;&gt;&gt; status = spam.system('blah')
sh: line 1: blah: command not found
</pre> </section> <section id="adding-user-defined-variables"> <h2>Adding user-defined variables</h2> <p>The following example illustrates how to add user-defined variables to a F2PY generated extension module by modifying the dictionary of a F2PY generated module. Consider the following signature file (compiled with <code>f2py -c var.pyf</code>):</p> <pre data-language="fortran">!    -*- f90 -*-
python module var
  usercode '''
    int BAR = 5;
  '''
  interface
    usercode '''
      PyDict_SetItemString(d,"BAR",PyInt_FromLong(BAR));
    '''
  end interface
end python module
</pre> <p>Notice that the second <code>usercode</code> statement must be defined inside an <code>interface</code> block and the module dictionary is available through the variable <code>d</code> (see <code>varmodule.c</code> generated by <code>f2py var.pyf</code> for additional details).</p> <p>Usage in Python:</p> <pre data-language="python">&gt;&gt;&gt; import var
&gt;&gt;&gt; var.BAR
5
</pre> </section> <section id="dealing-with-kind-specifiers"> <h2>Dealing with KIND specifiers</h2> <p>Currently, F2PY can handle only <code>&lt;type spec&gt;(kind=&lt;kindselector&gt;)</code> declarations where <code>&lt;kindselector&gt;</code> is a numeric integer (e.g. 1, 2, 4,â€¦), but not a function call <code>KIND(..)</code> or any other expression. F2PY needs to know what would be the corresponding C type and a general solution for that would be too complicated to implement.</p> <p>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &lt;Fortran type&gt; to &lt;C type&gt; maps. For example, if Fortran 90 code contains:</p> <pre data-language="python">REAL(kind=KIND(0.0D0)) ...
</pre> <p>then create a mapping file containing a Python dictionary:</p> <pre data-language="python">{'real': {'KIND(0.0D0)': 'double'}}
</pre> <p>for instance.</p> <p>Use the <code>--f2cmap</code> command-line option to pass the file name to F2PY. By default, F2PY assumes file name is <code>.f2py_f2cmap</code> in the current working directory.</p> <p>More generally, the f2cmap file must contain a dictionary with items:</p> <pre data-language="python">&lt;Fortran typespec&gt; : {&lt;selector_expr&gt;:&lt;C type&gt;}
</pre> <p>that defines mapping between Fortran type:</p> <pre data-language="python">&lt;Fortran typespec&gt;([kind=]&lt;selector_expr&gt;)
</pre> <p>and the corresponding &lt;C type&gt;. The &lt;C type&gt; can be one of the following:</p> <pre data-language="python">double
float
long_double
char
signed_char
unsigned_char
short
unsigned_short
int
long
long_long
unsigned
complex_float
complex_double
complex_long_double
string
</pre> <p>For example, for a Fortran file <code>func1.f</code> containing:</p> <pre data-language="fortran">      subroutine func1(n, x, res)
        use, intrinsic :: iso_fortran_env, only: int64, real64
        implicit none
        integer(int64), intent(in) :: n
        real(real64), intent(in) :: x(n)
        real(real64), intent(out) :: res
Cf2py   intent(hide) :: n
        res = sum(x)
      end
</pre> <p>In order to convert <code>int64</code> and <code>real64</code> to valid <code>C</code> data types, a <code>.f2py_f2cmap</code> file with the following content can be created in the current directory:</p> <pre data-language="python">dict(real=dict(real64='double'), integer=dict(int64='long long'))
</pre> <p>and create the module as usual. F2PY checks if a <code>.f2py_f2cmap</code> file is present in the current directory and will use it to map <code>KIND</code> specifiers to <code>C</code> data types.</p> <pre data-language="sh">f2py -c func1.f -m func1
</pre> <p>Alternatively, the mapping file can be saved with any other name, for example <code>mapfile.txt</code>, and this information can be passed to F2PY by using the <code>--f2cmap</code> option.</p> <pre data-language="sh">f2py -c func1.f -m func1 --f2cmap mapfile.txt
</pre> <p>For more information, see F2Py source code <code>numpy/f2py/capi_maps.py</code>.</p> </section> <section id="character-strings"> <h2 id="id1">Character strings</h2> <section id="assumed-length-character-strings"> <h3>Assumed length character strings</h3> <p>In Fortran, assumed length character string arguments are declared as <code>character*(*)</code> or <code>character(len=*)</code>, that is, the length of such arguments are determined by the actual string arguments at runtime. For <code>intent(in)</code> arguments, this lack of length information poses no problems for f2py to construct functional wrapper functions. However, for <code>intent(out)</code> arguments, the lack of length information is problematic for f2py generated wrappers because there is no size information available for creating memory buffers for such arguments and F2PY assumes the length is 0. Depending on how the length of assumed length character strings are specified, there exist ways to workaround this problem, as exemplified below.</p> <p>If the length of the <code>character*(*)</code> output argument is determined by the state of other input arguments, the required connection can be established in a signature file or within a f2py-comment by adding an extra declaration for the corresponding argument that specifies the length in character selector part. For example, consider a Fortran file <code>asterisk1.f90</code>:</p> <pre data-language="python">subroutine foo1(s)
  character*(*), intent(out) :: s
  !f2py character(f2py_len=12) s
  s = "123456789A12"
end subroutine foo1
</pre> <p>Compile it with <code>f2py -c asterisk1.f90 -m asterisk1</code> and then in Python:</p> <pre data-language="python">&gt;&gt;&gt; import asterisk1
&gt;&gt;&gt; asterisk1.foo1()
b'123456789A12'
</pre> <p>Notice that the extra declaration <code>character(f2py_len=12) s</code> is interpreted only by f2py and in the <code>f2py_len=</code> specification one can use C-expressions as a length value.</p> <p>In the following example:</p> <pre data-language="python">subroutine foo2(s, n)
  character(len=*), intent(out) :: s
  integer, intent(in) :: n
  !f2py character(f2py_len=n), depend(n) :: s
  s = "123456789A123456789B"(1:n)
end subroutine foo2
</pre> <p>the length of the output assumed length string depends on an input argument <code>n</code>, after wrapping with F2PY, in Python:</p> <pre data-language="python">&gt;&gt;&gt; import asterisk
&gt;&gt;&gt; asterisk.foo2(2)
b'12'
&gt;&gt;&gt; asterisk.foo2(12)
b'123456789A12'
&gt;&gt;&gt; 
</pre> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/f2py/advanced/use_cases.html" class="_attribution-link">https://numpy.org/doc/2.0/f2py/advanced/use_cases.html</a>
  </p>
</div>
