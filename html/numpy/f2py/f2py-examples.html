<section id="f2py-examples"> <h1 id="id1">F2PY examples</h1> <p>Below are some examples of F2PY usage. This list is not comprehensive, but can be used as a starting point when wrapping your own code.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The best place to look for examples is the <a class="reference external" href="https://github.com/numpy/numpy/issues?q=is%3Aissue+label%3A%22component%3A+numpy.f2py%22+is%3Aclosed">NumPy issue tracker</a>, or the test cases for <code>f2py</code>. Some more use cases are in <a class="reference internal" href="advanced/boilerplating.html#f2py-boilerplating"><span class="std std-ref">Boilerplate reduction and templating</span></a>.</p> </div> <section id="f2py-walkthrough-a-basic-extension-module"> <h2>F2PY walkthrough: a basic extension module</h2> <section id="creating-source-for-a-basic-extension-module"> <h3>Creating source for a basic extension module</h3> <p>Consider the following subroutine, contained in a file named <code>add.f</code></p> <pre data-language="fortran">C
      SUBROUTINE ZADD(A,B,C,N)
C
      DOUBLE COMPLEX A(*)
      DOUBLE COMPLEX B(*)
      DOUBLE COMPLEX C(*)
      INTEGER N
      DO 20 J = 1, N
         C(J) = A(J)+B(J)
 20   CONTINUE
      END
</pre> <p>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</p> <pre data-language="python">python -m numpy.f2py -m add add.f
</pre> <p>This command will produce an extension module named <code>addmodule.c</code> in the current directory. This extension module can now be compiled and used from Python just like any other extension module.</p> </section> <section id="creating-a-compiled-extension-module"> <h3>Creating a compiled extension module</h3> <p>You can also get f2py to both compile <code>add.f</code> along with the produced extension module leaving only a shared-library extension file that can be imported from Python:</p> <pre data-language="python">python -m numpy.f2py -c -m add add.f
</pre> <p>This command produces a Python extension module compatible with your platform. This module may then be imported from Python. It will contain a method for each subroutine in <code>add</code>. The docstring of each method contains information about how the module method may be called:</p> <pre data-language="python">&gt;&gt;&gt; import add
&gt;&gt;&gt; print(add.zadd.__doc__)
zadd(a,b,c,n)

Wrapper for ``zadd``.

Parameters
----------
a : input rank-1 array('D') with bounds (*)
b : input rank-1 array('D') with bounds (*)
c : input rank-1 array('D') with bounds (*)
n : input int
</pre> </section> <section id="improving-the-basic-interface"> <h3>Improving the basic interface</h3> <p>The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments are converted to NumPy arrays and the integer argument should be mapped to a <code>C</code> integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because <code>f2py</code> knows nothing about the semantics of the arguments (such that <code>C</code> is an output and <code>n</code> should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</p> <pre data-language="python">&gt;&gt;&gt; add.zadd([1, 2, 3], [1, 2], [3, 4], 1000)
</pre> <p>will cause a program crash on most systems. Under the hood, the lists are being converted to arrays but then the underlying <code>add</code> function is told to cycle way beyond the borders of the allocated memory.</p> <p>In order to improve the interface, <code>f2py</code> supports directives. This is accomplished by constructing a signature file. It is usually best to start from the interfaces that <code>f2py</code> produces in that file, which correspond to the default behavior. To get <code>f2py</code> to generate the interface file use the <code>-h</code> option:</p> <pre data-language="python">python -m numpy.f2py -h add.pyf -m add add.f
</pre> <p>This command creates the <code>add.pyf</code> file in the current directory. The section of this file corresponding to <code>zadd</code> is:</p> <pre data-language="fortran">subroutine zadd(a,b,c,n) ! in :add:add.f
   double complex dimension(*) :: a
   double complex dimension(*) :: b
   double complex dimension(*) :: c
   integer :: n
end subroutine zadd
</pre> <p>By placing intent directives and checking code, the interface can be cleaned up quite a bit so the Python module method is both easier to use and more robust to malformed inputs.</p> <pre data-language="fortran">subroutine zadd(a,b,c,n) ! in :add:add.f
   double complex dimension(n) :: a
   double complex dimension(n) :: b
   double complex intent(out),dimension(n) :: c
   integer intent(hide),depend(a) :: n=len(a)
end subroutine zadd
</pre> <p>The intent directive, intent(out) is used to tell f2py that <code>c</code> is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, <code>n</code>, but instead to get it from the size of <code>a</code>. The depend( <code>a</code> ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won’t try to create the variable n until the variable a is created).</p> <p>After modifying <code>add.pyf</code>, the new Python module file can be generated by compiling both <code>add.f</code> and <code>add.pyf</code>:</p> <pre data-language="python">python -m numpy.f2py -c add.pyf add.f
</pre> <p>The new interface’s docstring is:</p> <pre data-language="python">&gt;&gt;&gt; import add
&gt;&gt;&gt; print(add.zadd.__doc__)
c = zadd(a,b)

Wrapper for ``zadd``.

Parameters
----------
a : input rank-1 array('D') with bounds (n)
b : input rank-1 array('D') with bounds (n)

Returns
-------
c : rank-1 array('D') with bounds (n)
</pre> <p>Now, the function can be called in a much more robust way:</p> <pre data-language="python">&gt;&gt;&gt; add.zadd([1, 2, 3], [4, 5, 6])
array([5.+0.j, 7.+0.j, 9.+0.j])
</pre> <p>Notice the automatic conversion to the correct format that occurred.</p> </section> <section id="inserting-directives-in-fortran-source"> <h3>Inserting directives in Fortran source</h3> <p>The robust interface of the previous section can also be generated automatically by placing the variable directives as special comments in the original Fortran code.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For projects where the Fortran code is being actively developed, this may be preferred.</p> </div> <p>Thus, if the source code is modified to contain:</p> <pre data-language="fortran">C
      SUBROUTINE ZADD(A,B,C,N)
C
CF2PY INTENT(OUT) :: C
CF2PY INTENT(HIDE) :: N
CF2PY DOUBLE COMPLEX :: A(N)
CF2PY DOUBLE COMPLEX :: B(N)
CF2PY DOUBLE COMPLEX :: C(N)
      DOUBLE COMPLEX A(*)
      DOUBLE COMPLEX B(*)
      DOUBLE COMPLEX C(*)
      INTEGER N
      DO 20 J = 1, N
         C(J) = A(J) + B(J)
 20   CONTINUE
      END
</pre> <p>Then, one can compile the extension module using:</p> <pre data-language="python">python -m numpy.f2py -c -m add add.f
</pre> <p>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained <code>A(N)</code> instead of <code>A(*)</code> and so forth with <code>B</code> and <code>C</code>, then nearly the same interface can be obtained by placing the <code>INTENT(OUT) :: C</code> comment line in the source code. The only difference is that <code>N</code> would be an optional input that would default to the length of <code>A</code>.</p> </section> </section> <section id="a-filtering-example"> <h2>A filtering example</h2> <p>This example shows a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example.</p> <pre data-language="fortran">C
      SUBROUTINE DFILTER2D(A,B,M,N)
C
      DOUBLE PRECISION A(M,N)
      DOUBLE PRECISION B(M,N)
      INTEGER N, M
CF2PY INTENT(OUT) :: B
CF2PY INTENT(HIDE) :: N
CF2PY INTENT(HIDE) :: M
      DO 20 I = 2,M-1
         DO 40 J = 2,N-1
            B(I,J) = A(I,J) +
     &amp;           (A(I-1,J)+A(I+1,J) +
     &amp;           A(I,J-1)+A(I,J+1) )*0.5D0 +
     &amp;           (A(I-1,J-1) + A(I-1,J+1) +
     &amp;           A(I+1,J-1) + A(I+1,J+1))*0.25D0
 40      CONTINUE
 20   CONTINUE
      END
</pre> <p>This code can be compiled and linked into an extension module named filter using:</p> <pre data-language="python">python -m numpy.f2py -c -m filter filter.f
</pre> <p>This will produce an extension module in the current directory with a method named <code>dfilter2d</code> that returns a filtered version of the input.</p> </section> <section id="depends-keyword-example"> <h2>
<code>depends</code> keyword example</h2> <p>Consider the following code, saved in the file <code>myroutine.f90</code>:</p> <pre data-language="fortran">subroutine s(n, m, c, x)
	implicit none
  	integer, intent(in) :: n, m
  	real(kind=8), intent(out), dimension(n,m) :: x
  	real(kind=8), intent(in) :: c(:)

	x = 0.0d0
	x(1, 1) = c(1)

end subroutine s
</pre> <p>Wrapping this with <code>python -m numpy.f2py -c myroutine.f90 -m myroutine</code>, we can do the following in Python:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import myroutine
&gt;&gt;&gt; x = myroutine.s(2, 3, np.array([5, 6, 7]))
&gt;&gt;&gt; x
array([[5., 0., 0.],
   [0., 0., 0.]])
</pre> <p>Now, instead of generating the extension module directly, we will create a signature file for this subroutine first. This is a common pattern for multi-step extension module generation. In this case, after running</p> <pre data-language="python">python -m numpy.f2py myroutine.f90 -m myroutine -h myroutine.pyf
</pre> <p>the following signature file is generated:</p> <pre data-language="fortran">!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module myroutine ! in 
    interface  ! in :myroutine
        subroutine s(n,m,c,x) ! in :myroutine:myroutine.f90
            integer intent(in) :: n
            integer intent(in) :: m
            real(kind=8) dimension(:),intent(in) :: c
            real(kind=8) dimension(n,m),intent(out),depend(m,n) :: x
        end subroutine s
    end interface 
end python module myroutine

! This file was auto-generated with f2py (version:1.23.0.dev0+120.g4da01f42d).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
</pre> <p>Now, if we run <code>python -m numpy.f2py -c myroutine.pyf myroutine.f90</code> we see an error; note that the signature file included a <code>depend(m,n)</code> statement for <code>x</code> which is not necessary. Indeed, editing the file above to read</p> <pre data-language="fortran">!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module myroutine ! in 
    interface  ! in :myroutine
        subroutine s(n,m,c,x) ! in :myroutine:myroutine.f90
            integer intent(in) :: n
            integer intent(in) :: m
            real(kind=8) dimension(:),intent(in) :: c
            real(kind=8) dimension(n,m),intent(out) :: x
        end subroutine s
    end interface 
end python module myroutine

! This file was auto-generated with f2py (version:1.23.0.dev0+120.g4da01f42d).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
</pre> <p>and running <code>f2py -c myroutine.pyf myroutine.f90</code> yields correct results.</p> </section> <section id="read-more"> <h2>Read more</h2> <ul class="simple"> <li><a class="reference external" href="https://scipy.github.io/old-wiki/pages/Cookbook/f2py_and_NumPy.html">Wrapping C codes using f2py</a></li> <li><a class="reference external" href="https://scipy-cookbook.readthedocs.io/items/F2Py.html">F2py section on the SciPy Cookbook</a></li> <li><a class="reference external" href="http://websrv.cs.umt.edu/isis/index.php/F2py_example">F2py example: Interactive System for Ice sheet Simulation</a></li> <li><a class="reference external" href="https://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html">“Interfacing With Other Languages” section on the SciPy Cookbook.</a></li> </ul> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/f2py/f2py-examples.html" class="_attribution-link">https://numpy.org/doc/2.0/f2py/f2py-examples.html</a>
  </p>
</div>
