<h1 id="options-phases">5.11. Options related to a particular phase</h1>
<div class="_sphinx"> <div itemprop="articleBody">    <h2 id="replacing-phases">5.11.1. Replacing the program for one or more phases</h2> <p id="options-related-to-a-particular-phase">You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the <code>ghc</code> has wired into it. For example, you might want to try a different assembler. The following options allow you to change the external program used for a given compilation phase:</p> <dl class="ghc-flag"> <dt id="ghc-flag--pgmL ⟨cmd⟩">
<code>-pgmL ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the literate pre-processor.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmP ⟨cmd⟩">
<code>-pgmP ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the C pre-processor (with <code>-cpp</code> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmc ⟨cmd⟩">
<code>-pgmc ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the C compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmcxx ⟨cmd⟩">
<code>-pgmcxx ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the C++ compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlo ⟨cmd⟩">
<code>-pgmlo ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the LLVM optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlc ⟨cmd⟩">
<code>-pgmlc ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the LLVM compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgms ⟨cmd⟩">
<code>-pgms ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the splitter.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgma ⟨cmd⟩">
<code>-pgma ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the assembler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgml ⟨cmd⟩">
<code>-pgml ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the linker.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlm ⟨cmd⟩">
<code>-pgmlm ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmdll ⟨cmd⟩">
<code>-pgmdll ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the DLL generator.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmF ⟨cmd⟩">
<code>-pgmF ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the pre-processor (with <a class="reference internal" href="#ghc-flag--F"><code>-F</code></a> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmotool ⟨cmd⟩">
<code>-pgmotool ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the program to inspect mach-o dynamic libraries and executables to read the dynamic library dependencies. We will compute the necessary <code>runpath``s to embed for the dependencies based on the
result of the ``otool</code> call.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgminstall_name_tool ⟨cmd⟩">
<code>-pgminstall_name_tool ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the program to inject <code>runpath``s into mach-o dynamic
libraries and executables.  As detected by the ``otool</code> call.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmwindres ⟨cmd⟩">
<code>-pgmwindres ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program <code>windres</code>, which is supplied with a GHC installation. See <code>-fno-embed-manifest</code> in <a class="reference internal" href="#options-linker"><span class="std std-ref">Options affecting linking</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlibtool ⟨cmd⟩">
<code>-pgmlibtool ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the libtool command (when using <a class="reference internal" href="#ghc-flag--staticlib"><code>-staticlib</code></a> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmi ⟨cmd⟩">
<code>-pgmi ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the external interpreter command (see <a class="reference internal" href="ghci.html#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>). Default: <code>ghc-iserv-prof</code> if <a class="reference internal" href="profiling.html#ghc-flag--prof"><code>-prof</code></a> is enabled, <code>ghc-iserv-dyn</code> if <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> is enabled, or <code>ghc-iserv</code> otherwise.</p> </dd>
</dl>   <h2 id="forcing-options-through">5.11.2. Forcing options to a particular phase</h2> <p id="forcing-options-to-a-particular-phase">Options can be forced through to a particular compilation phase, using the following flags:</p> <dl class="ghc-flag"> <dt id="ghc-flag--optL ⟨option⟩">
<code>-optL ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the literate pre-processor</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optP ⟨option⟩">
<code>-optP ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to CPP (makes sense only if <code>-cpp</code> is also on).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optF ⟨option⟩">
<code>-optF ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the custom pre-processor (see <a class="reference internal" href="#pre-processor"><span class="std std-ref">Options affecting a Haskell pre-processor</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optc ⟨option⟩">
<code>-optc ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the C compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmc-supports-no-pie">
<code>-pgmc-supports-no-pie</code> </dt> <dd>
<p>Does the same thing as <code>-pgml-supports-no-pie</code>, which replaced it.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgml-supports-no-pie">
<code>-pgml-supports-no-pie</code> </dt> <dd>
<p>When <code>-pgml</code> is used, GHC by default will never pass the <code>-no-pie</code> command line flag. The rationale is that it is not known whether the specified compiler used for linking (recall we use a C compiler to invoke the linker on our behalf) will support it. This flag can be used to indicate that <code>-no-pie</code> is supported. It has to be passed after <code>-pgml</code>.</p> <p>This flag is not necessary when <code>-pgmc</code> is not used, since GHC remembers whether the default C compiler supports <code>-no-pie</code> in an internal settings file.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optcxx ⟨option⟩">
<code>-optcxx ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the C++ compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optlo ⟨option⟩">
<code>-optlo ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the LLVM optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optlc ⟨option⟩">
<code>-optlc ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the LLVM compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--opta ⟨option⟩">
<code>-opta ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the assembler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optl ⟨option⟩">
<code>-optl ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the linker.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optlm ⟨option⟩">
<code>-optlm ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the linker when merging object files. In the case of a standard <code>ld</code>-style linker this should generally include the <code>-r</code> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optdll ⟨option⟩">
<code>-optdll ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the DLL generator.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optwindres ⟨option⟩">
<code>-optwindres ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to <code>windres</code> when embedding manifests on Windows. See <code>-fno-embed-manifest</code> in <a class="reference internal" href="#options-linker"><span class="std std-ref">Options affecting linking</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--opti ⟨option⟩">
<code>-opti ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the interpreter sub-process (see <a class="reference internal" href="ghci.html#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>). A common use for this is to pass RTS options e.g., <code>-opti+RTS -opti-A64m</code>, or to enable verbosity with <code>-opti-v</code> to see what messages are being exchanged by GHC and the interpreter.</p> </dd>
</dl> <p>So, for example, to force an <code>-Ewurble</code> option to the assembler, you would tell the driver <code>-opta-Ewurble</code> (the dash before the E is required).</p> <p>GHC is itself a Haskell program, so if you need to pass options directly to GHC’s runtime system you can enclose them in <code>+RTS ... -RTS</code> (see <a class="reference internal" href="runtime_control.html#runtime-control"><span class="std std-ref">Runtime system (RTS) options</span></a>).</p>   <h2 id="c-pre-processor">5.11.3. Options affecting the C pre-processor</h2> <dl class="extension" id="options-affecting-the-c-pre-processor"> <dt id="extension-CPP">
<code>CPP</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>The <a class="reference internal" href="#extension-CPP"><code>CPP</code></a> language extension enables the C pre-processor. This can be turned into a command-line flag by prefixing it with <code>-X</code>; For example:</p> <pre data-language="sh">$ ghc -XCPP foo.hs
</pre> <p>The <a class="reference internal" href="#extension-CPP"><code>CPP</code></a> language extension can also be enabled using the <a class="reference internal" href="exts/pragmas.html#language-pragma"><span class="std std-ref">LANGUAGE</span></a> pragma; For example:</p> <pre data-language="haskell">{-# LANGUAGE CPP #-}
</pre> </dd>
</dl> <dl class="ghc-flag" id="index-2"> <dt id="ghc-flag--cpp">
<code>-cpp</code> </dt> <dd>
<p>The C pre-processor <strong class="command">cpp</strong> is run over your Haskell code if the <code>-cpp</code> option or <code>-XCPP</code> extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn’t need it.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--D⟨symbol⟩[=⟨value⟩]">
<code>-D⟨symbol⟩[=⟨value⟩]</code> </dt> <dd>
<p>Define macro ⟨symbol⟩ in the usual way. When no value is given, the value is taken to be <code>1</code>. For instance, <code>-DUSE_MYLIB</code> is equivalent to <code>-DUSE_MYLIB=1</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><a class="reference internal" href="#ghc-flag--D%E2%9F%A8symbol%E2%9F%A9%5B=%E2%9F%A8value%E2%9F%A9%5D"><code>-D⟨symbol⟩[=⟨value⟩]</code></a> does <em>not</em> affect <code>-D</code> macros passed to the C compiler when compiling an unregisterised build! In this case use the <code>-optc-Dfoo</code> hack… (see <a class="reference internal" href="#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>).</p> </div> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--U⟨symbol⟩">
<code>-U⟨symbol⟩</code> </dt> <dd>
<p>Undefine macro ⟨symbol⟩ in the usual way.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--I⟨dir⟩">
<code>-I⟨dir⟩</code> </dt> <dd>
<p>Specify a directory in which to look for <code>#include</code> files, in the usual C way.</p> </dd>
</dl> <p>The GHC driver pre-defines several macros when processing Haskell source code (<code>.hs</code> or <code>.lhs</code> files).</p>  <h3 id="id1">5.11.3.1. Standard CPP macros</h3> <p id="standard-cpp-macros">The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</p> <pre data-language="sh">$ ghc -E -optP-dM -cpp foo.hs
$ cat foo.hspp
</pre> <p>(you need a file <code>foo.hs</code>, but it isn’t actually used).</p> <dl class="docutils"> <dt>
<code>__GLASGOW_HASKELL__</code> </dt> <dd>
<p class="first" id="index-3">For version <code>x.y.z</code> of GHC, the value of <code>__GLASGOW_HASKELL__</code> is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, <code>__GLASGOW_HASKELL__==602</code>). More information in <a class="reference internal" href="intro.html#version-numbering"><span class="std std-ref">GHC version numbering policy</span></a>.</p> <p>With any luck, <code>__GLASGOW_HASKELL__</code> will be undefined in all other implementations that support C-style pre-processing.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The comparable symbols for other systems are: <code>__HUGS__</code> for Hugs, <code>__NHC__</code> for nhc98, and <code>__HBC__</code> for hbc).</p> </div> <p class="last">NB. This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </dd> <dt>
<code>__GLASGOW_HASKELL_FULL_VERSION__</code> </dt>  <dt id="index-4">
<code>__GLASGOW_HASKELL_PATCHLEVEL1__; __GLASGOW_HASKELL_PATCHLEVEL2__</code> </dt> <dd>
<p class="first" id="index-6">These macros are available starting with GHC 7.10.1.</p> <p>For three-part GHC version numbers <code>x.y.z</code>, the value of <code>__GLASGOW_HASKELL_PATCHLEVEL1__</code> is the integer ⟨z⟩.</p> <p>For four-part GHC version numbers <code>x.y.z.z'</code>, the value of <code>__GLASGOW_HASKELL_PATCHLEVEL1__</code> is the integer ⟨z⟩ while the value of <code>__GLASGOW_HASKELL_PATCHLEVEL2__</code> is set to the integer ⟨z’⟩.</p> <p>These macros are provided for allowing finer granularity than is provided by <code>__GLASGOW_HASKELL__</code>. Usually, this should not be necessary as it’s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</p> <div class="last admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </div> </dd> <dt>
<code>MIN_VERSION_GLASGOW_HASKELL(x,y,z,z')</code> </dt> <dd>
<p class="first" id="index-7">This macro is available starting with GHC 7.10.1.</p> <p>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version <code>x.y.z.z'</code> or later.</p> <p>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define <code>MIN_VERSION_GLASGOW_HASKELL</code> is required, the presence of the <code>MIN_VERSION_GLASGOW_HASKELL</code> macro needs to be ensured before it is called, e.g.:</p> <pre data-language="c">#if defined(MIN_VERSION_GLASGOW_HASKELL)
#if MIN_VERSION_GLASGOW_HASKELL(7,10,2,0)
/* code that applies only to GHC 7.10.2 or later */
#endif
#endif
</pre> <div class="last admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </div> </dd> <dt>
<code>__GLASGOW_HASKELL_TH__</code> </dt> <dd>
<p class="first last" id="index-8">This is set to <code>1</code> when the compiler supports Template Haskell, and to <code>0</code> when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</p> </dd> <dt>
<code>__GLASGOW_HASKELL_LLVM__</code> </dt> <dd>
<p class="first last" id="index-9">Only defined when <code>:ghc-flag:</code>-fllvm` is specified. When GHC is using version <code>x.y.z</code> of LLVM, the value of <code>__GLASGOW_HASKELL_LLVM__</code> is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example when using version 3.7 of LLVM, <code>__GLASGOW_HASKELL_LLVM__==307</code>).</p> </dd> <dt>
<code>__PARALLEL_HASKELL__</code> </dt> <dd>
<p class="first last" id="index-10">Only defined when <code>-parallel</code> is in use! This symbol is defined when pre-processing Haskell (input) and pre-processing C (GHC output).</p> </dd> <dt>
<code>os_HOST_OS=1</code> </dt> <dd>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. <code>linux</code>, <code>mingw32</code> for Windows, <code>solaris</code>, etc.).</dd> <dt>
<code>arch_HOST_ARCH=1</code> </dt> <dd>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. <code>i386</code>, <code>x86_64</code>, <code>powerpc</code>, <code>sparc</code>, etc.).</dd> <dt>
<code>VERSION_pkgname</code> </dt> <dd>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of <code>pkgname</code> that is exposed for module import. It is identical in behavior to the <code>VERSION_pkgname</code> macros that Cabal defines.</dd> <dt>
<code>MIN_VERSION_pkgname(x,y,z)</code> </dt> <dd>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is <code>x.y.z</code> or later. It is identical in behavior to the <code>MIN_VERSION_pkgname</code> macros that Cabal defines.</dd> </dl>   <h3 id="cpp-string-gaps">5.11.3.2. CPP and string gaps</h3> <p id="cpp-and-string-gaps">A small word of warning: <a class="reference internal" href="#ghc-flag--cpp"><code>-cpp</code></a> is not friendly to “string gaps”. In other words, strings such as the following:</p> <pre data-language="haskell">strmod = "\
\ p \
\ "
</pre> <p>don’t work with <a class="reference internal" href="#ghc-flag--cpp"><code>-cpp</code></a>; <strong class="command">/usr/bin/cpp</strong> elides the backslash-newline pairs.</p> <p>However, it appears that if you add a space at the end of the line, then <code>cpp</code> (at least GNU <code>cpp</code> and possibly other <code>cpp</code>s) leaves the backslash-space pairs alone and the string gap works as expected.</p>    <h2 id="pre-processor">5.11.4. Options affecting a Haskell pre-processor</h2> <dl class="ghc-flag" id="options-affecting-a-haskell-pre-processor"> <dt id="ghc-flag--F">
<code>-F</code> </dt> <dd>
<p>A custom pre-processor is run over your Haskell source file only if the <code>-F</code> option is given.</p> <p>Running a custom pre-processor at compile-time is in some settings appropriate and useful. The <code>-F</code> option lets you run a pre-processor as part of the overall GHC compilation pipeline, which has the advantage over running a Haskell pre-processor separately in that it works in interpreted mode and you can continue to take reap the benefits of GHC’s recompilation checker.</p> <p>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</p> <p>Use <a class="reference internal" href="#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9"><code>-pgmF ⟨cmd⟩</code></a> to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</p> <p>Additional arguments to the pre-processor can be passed in using the <a class="reference internal" href="#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9"><code>-optF ⟨option⟩</code></a> option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</p> <p>An example of a pre-processor is to convert your source files to the input encoding that GHC expects, i.e. create a script <code>convert.sh</code> containing the lines:</p> <pre data-language="sh">#!/bin/sh
( echo "{-# LINE 1 \"$2\" #-}" ; iconv -f l1 -t utf-8 $2 ) &gt; $3
</pre> <p>and pass <code>-F -pgmF convert.sh</code> to GHC. The <code>-f l1</code> option tells iconv to convert your Latin-1 file, supplied in argument <code>$2</code>, while the “-t utf-8” options tell iconv to return a UTF-8 encoded file. The result is redirected into argument <code>$3</code>. The <code>echo "{-# LINE 1 \"$2\" #-}"</code> just makes sure that your error positions are reported as in the original source file.</p> </dd>
</dl>   <h2 id="options-codegen">5.11.5. Options affecting code generation</h2> <dl class="ghc-flag" id="options-affecting-code-generation"> <dt id="ghc-flag--fasm">
<code>-fasm</code> </dt> <dd>
<p>Use GHC’s <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> rather than compiling via LLVM. <code>-fasm</code> is the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fllvm">
<code>-fllvm</code> </dt> <dd>
<p>Compile via <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM</span></a> instead of using the native code generator. This will generally take slightly longer than the native code generator to compile. Produced code is generally the same speed or faster than the other two code generators. Compiling via LLVM requires LLVM’s <strong class="command">opt</strong> and <strong class="command">llc</strong> executables to be in <code id="index-13">PATH</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Note that this GHC release expects an LLVM version between 10 and 14.</p> </div> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-code">
<code>-fno-code</code> </dt> <dd>
<p>Omit code generation (and all later phases) altogether. This is useful if you’re only interested in type checking code.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fwrite-interface">
<code>-fwrite-interface</code> </dt> <dd>
<p>Always write interface files. GHC will normally write interface files automatically, but this flag is useful with <a class="reference internal" href="#ghc-flag--fno-code"><code>-fno-code</code></a>, which normally suppresses generation of interface files. This is useful if you want to type check over multiple runs of GHC without compiling dependencies.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fobject-code">
<code>-fobject-code</code> </dt> <dd>
<p>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fbyte-code">
<code>-fbyte-code</code> </dt> <dd>
<p>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of <a class="reference internal" href="#ghc-flag--fobject-code"><code>-fobject-code</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fPIC">
<code>-fPIC</code> </dt> <dd>
<p>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexternal-dynamic-refs">
<code>-fexternal-dynamic-refs</code> </dt> <dd>
<p>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fPIE">
<code>-fPIE</code> </dt> <dd>
<p>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use <a class="reference internal" href="#ghc-flag--no-pie"><code>-pie</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-dynamic</code> </dt> <dd>
<p>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining <a class="reference internal" href="using.html#ghc-flag--shared"><code>-shared</code></a> with this flag relating to linking in the RTS under Linux. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10352">#10352</a>.</p> <p>Note that using this option when linking causes GHC to link against shared libraries.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynamic-too">
<code>-dynamic-too</code> </dt> <dd>
<p>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding <code>-dynamic -osuf dyn_o -hisuf dyn_hi</code>.</p> <p>Although it is equivalent to running GHC twice, using <code>-dynamic-too</code> is more efficient, because the earlier phases of the compiler up to code generation are performed just once.</p> <p>When using <code>-dynamic-too</code>, the options <code>-dyno</code>, <code>-dynosuf</code>, and <code>-dynhisuf</code> are the counterparts of <code>-o</code>, <code>-osuf</code>, and <code>-hisuf</code> respectively, but applying to the dynamic compilation.</p> <p><code>-dynamic-too</code> is ignored if <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> is also specified.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--split-objs">
<code>-split-objs</code> </dt> <dd>
<p>When using this option, the object file is split into many smaller objects. This feature is used when building libraries, so that a program statically linked against the library will pull in less of the library.</p> <p>Since this uses platform specific techniques, it may not be available on all target platforms. See the <a class="reference internal" href="using.html#ghc-flag---print-object-splitting-supported"><code>--print-object-splitting-supported</code></a> flag to check whether your GHC supports object splitting.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexpose-internal-symbols">
<code>-fexpose-internal-symbols</code> </dt> <dd>
<p>Request that GHC emits verbose symbol tables which include local symbols for module-internal functions. These can be useful for tools like <a class="reference external" href="https://perf.wiki.kernel.org/">perf</a> but increase object file sizes. This is implied by <a class="reference internal" href="debug-info.html#ghc-flag--g"><code>-g2</code></a> and above.</p> <p><a class="reference internal" href="#ghc-flag--fexpose-internal-symbols"><code>-fno-expose-internal-symbols</code></a> suppresses all non-global symbol table entries, resulting in smaller object file sizes at the expense of debuggability.</p> </dd>
</dl>   <h2 id="options-linker">5.11.6. Options affecting linking</h2> <p id="options-affecting-linking">GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (<code>-lm</code> math library, for example).</p> <dl class="ghc-flag"> <dt id="ghc-flag--l ⟨lib⟩">
<code>-l ⟨lib⟩</code> </dt> <dd>
<p>Link in the ⟨lib⟩ library. On Unix systems, this will be in a file called <code>lib<em>lib</em>.a</code> or <code>lib<em>lib</em>.so</code> which resides somewhere on the library directories path.</p> <p>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general <code>-l ⟨foo⟩</code> should come <em>before</em> <code>-l ⟨bar⟩</code> on the command line.</p> <p>There’s one other gotcha to bear in mind when using external libraries: if the library contains a <code>main()</code> function, then this will be a link conflict with GHC’s own <code>main()</code> function (eg. <code>libf2c</code> and <code>libl</code> have their own <code>main()</code>s).</p> <p>You can use an external main function if you initialize the RTS manually and pass <code>-no-hs-main</code>. See also <a class="reference internal" href="exts/ffi.html#using-own-main"><span class="std std-ref">Using your own main()</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-link">
<code>-no-link</code> </dt> <dd>
<p>Omits the link step.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--c">
<code>-c</code> </dt> <dd>
<p>Omits the link step. This option can be used with <a class="reference internal" href="using.html#ghc-flag---make"><code>--make</code></a> to avoid the automatic linking that takes place if the program contains a <code>Main</code> module.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--package ⟨name⟩">
<code>-package ⟨name⟩</code> </dt> <dd>
<p>If you are using a Haskell “package” (see <a class="reference internal" href="packages.html#packages"><span class="std std-ref">Packages</span></a>), don’t forget to add the relevant <code>-package</code> option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the <code>-package</code> option will likely result in several pages of link errors.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--framework ⟨name⟩">
<code>-framework ⟨name⟩</code> </dt> <dd>
<p>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the <code>-framework</code> option for Apple’s Linker. Please note that frameworks and packages are two different things - frameworks don’t contain any Haskell code. Rather, they are Apple’s way of packaging shared libraries. To link to Apple’s “Carbon” API, for example, you’d use <code>-framework Carbon</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--staticlib">
<code>-staticlib</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#ghc-flag--flink-rts"><code>-flink-rts</code></a></td> </tr>  </table> <p>Link all passed files into a static library suitable for linking. To control the name, use the <a class="reference internal" href="#"><code>-o ⟨file⟩</code></a> option as usual. The default name is <code>liba.a</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--L ⟨dir⟩">
<code>-L ⟨dir⟩</code> </dt> <dd>
<p>Where to find user-supplied libraries… Prepend the directory ⟨dir⟩ to the library directories path.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fuse-rpaths">
<code>-fuse-rpaths</code> </dt> <dd>
<p>This flag is enabled by default and will set the rpath of the linked object to the library directories of dependent packages.</p> <p>When building binaries to distribute it can be useful to pass your own linker options to control the rpath and disable the automatic injection of rpath entries by disabling this flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--framework-path ⟨dir⟩">
<code>-framework-path ⟨dir⟩</code> </dt> <dd>
<p>On Darwin/OS X/iOS only, prepend the directory ⟨dir⟩ to the framework directories path. This option corresponds to the <code>-F</code> option for Apple’s Linker (<code>-F</code> already means something else for GHC).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--split-sections">
<code>-split-sections</code> </dt> <dd>
<p>Place each generated function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section’s name in the output file.</p> <p>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--static">
<code>-static</code> </dt> <dd>
<p>Tell the linker to avoid shared Haskell libraries, if possible. This is the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynamic">
<code>-dynamic</code> </dt> <dd>
<p>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see <a class="reference internal" href="using.html#ghc-flag--shared"><code>-shared</code></a>). See <a class="reference internal" href="shared_libs.html#using-shared-libs"><span class="std std-ref">Using shared libraries</span></a> on how to create them.</p> <p>Note that this option also has an effect on code generation (see above).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--shared">
<code>-shared</code> </dt> <dd>
<p>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</p> <p>The flags <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> and <a class="reference internal" href="#ghc-flag--static"><code>-static</code></a> control whether the resulting shared object links statically or dynamically to Haskell package libraries given as <a class="reference internal" href="#"><code>-package ⟨pkg⟩</code></a> option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</p> <p>Object files linked into shared objects must be compiled with <a class="reference internal" href="#ghc-flag--fPIC"><code>-fPIC</code></a>, see <a class="reference internal" href="#options-codegen"><span class="std std-ref">Options affecting code generation</span></a></p> <p>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linking against this package. See <a class="reference internal" href="packages.html#building-packages"><span class="std std-ref">shared object name mangling</span></a> for details.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynload">
<code>-dynload</code> </dt> <dd>
<p>This flag selects one of a number of modes for finding shared libraries at runtime. See <a class="reference internal" href="shared_libs.html#finding-shared-libs"><span class="std std-ref">Finding shared libraries at runtime</span></a> for a description of each mode.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--flink-rts">
<code>-flink-rts</code> </dt> <dd>
<p>When linking shared libraries (<a class="reference internal" href="using.html#ghc-flag--shared"><code>-shared</code></a>) GHC does not automatically link the RTS. This is to allow choosing the RTS flavour (<a class="reference internal" href="#ghc-flag--threaded"><code>-threaded</code></a>, <a class="reference internal" href="#ghc-flag--eventlog"><code>-eventlog</code></a>, etc) when linking an executable. However when the shared library is the intended product it is useful to be able to reverse this default. See <a class="reference internal" href="shared_libs.html#shared-libraries-c-api"><span class="std std-ref">Shared libraries that export a C API</span></a> for an usage example.</p> <p>When linking a static library (<a class="reference internal" href="#ghc-flag--staticlib"><code>-staticlib</code></a>) GHC links the RTS automatically, you can reverse this behaviour by reversing this flag: <code>-fno-link-rts</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--main-is ⟨thing⟩">
<code>-main-is ⟨thing⟩</code> </dt> <dd>
<p id="index-15">The normal rule in Haskell is that your program must supply a <code>main</code> function in module <code>Main</code>. When testing, it is often convenient to change which function is the “main” one, and the <code>-main-is</code> flag allows you to do so. The ⟨thing⟩ can be one of:</p> <ul class="simple"> <li>A lower-case identifier <code>foo</code>. GHC assumes that the main function is <code>Main.foo</code>.</li> <li>A module name <code>A</code>. GHC assumes that the main function is <code>A.main</code>.</li> <li>A qualified name <code>A.foo</code>. GHC assumes that the main function is <code>A.foo</code>.</li> </ul> <p>Strictly speaking, <code>-main-is</code> is not a link-phase flag at all; it has no effect on the link step. The flag must be specified when compiling the module containing the specified main function (e.g. module <code>A</code> in the latter two items above). It has no effect for other modules, and hence can safely be given to <code>ghc --make</code>. However, if all the modules are otherwise up to date, you may need to force recompilation both of the module where the new “main” is, and of the module where the “main” function used to be; <code>ghc</code> is not clever enough to figure out that they both need recompiling. You can force recompilation by removing the object file, or by using the <a class="reference internal" href="separate_compilation.html#ghc-flag--fforce-recomp"><code>-fforce-recomp</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-hs-main">
<code>-no-hs-main</code> </dt> <dd>
<p id="index-16">In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of <code>main()</code> at link-time, you will have to. To signal that to the compiler when linking, use <code>-no-hs-main</code>. See also <a class="reference internal" href="exts/ffi.html#using-own-main"><span class="std std-ref">Using your own main()</span></a>.</p> <p>Notice that since the command-line passed to the linker is rather involved, you probably want to use <code>ghc</code> to do the final link of your `mixed-language’ application. This is not a requirement though, just try linking once with <a class="reference internal" href="using.html#ghc-flag--v"><code>-v</code></a> on to see what options the driver passes through to the linker.</p> <p>The <code>-no-hs-main</code> flag can also be used to persuade the compiler to do the link step in <a class="reference internal" href="using.html#ghc-flag---make"><code>--make</code></a> mode when there is no Haskell <code>Main</code> module present (normally the compiler will not attempt linking when there is no <code>Main</code>).</p> <p>The flags <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> and <a class="reference internal" href="#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=⟨opts⟩</code></a> have no effect when used with <a class="reference internal" href="#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>, because they are implemented by changing the definition of <code>main</code> that GHC generates. See <a class="reference internal" href="exts/ffi.html#using-own-main"><span class="std std-ref">Using your own main()</span></a> for how to get the effect of <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> and <a class="reference internal" href="#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=⟨opts⟩</code></a> when using your own <code>main</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--debug">
<code>-debug</code> </dt> <dd>
<p>Link the program with a debugging version of the runtime system. The debugging runtime turns on numerous assertions and sanity checks, and provides extra options for producing debugging output at runtime (run the program with <code>+RTS -?</code> to see a list).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--threaded">
<code>-threaded</code> </dt> <dd>
<p>Link the program with the “threaded” version of the runtime system. The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded.</p> <p>Note that you do <em>not</em> need <code>-threaded</code> in order to use concurrency; the single-threaded runtime supports concurrency between Haskell threads just fine.</p> <p>The threaded runtime system provides the following benefits:</p> <ul class="simple"> <li>It enables the <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See <a class="reference internal" href="using-concurrent.html#using-smp"><span class="std std-ref">Using SMP parallelism</span></a>.</li> <li>If a thread makes a foreign call (and the call is not marked <code>unsafe</code>), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, <code>foreign export</code>ed Haskell functions may be called from multiple OS threads simultaneously. See <a class="reference internal" href="exts/ffi.html#ffi-threads"><span class="std std-ref">Multi-threading and the FFI</span></a>.</li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--eventlog">
<code>-eventlog</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">Unconditionally enabled with 9.4 and later</td> </tr>  </table> <p>Link the program with the “eventlog” version of the runtime system. A program linked in this way can generate a runtime trace of events (such as thread start/stop) to a binary file <code><em>program</em>.eventlog</code>, which can then be interpreted later by various tools. See <a class="reference internal" href="runtime_control.html#rts-eventlog"><span class="std std-ref">Tracing</span></a> for more information.</p> <p>Note that as of GHC 9.4 and later eventlog support is included in the RTS by default and the <a class="reference internal" href="#ghc-flag--eventlog"><code>-eventlog</code></a> is deprecated.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]">
<code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">some</td> </tr>  </table> <p>This option affects the processing of RTS control options given either on the command line or via the <a class="reference internal" href="runtime_control.html#envvar-GHCRTS" id="index-17"><code>GHCRTS</code></a> environment variable. There are five possibilities:</p> <dl class="docutils"> <dt>
<code>-rtsopts=none</code> </dt> <dd>Disable all processing of RTS options. If <code>+RTS</code> appears anywhere on the command line, then the program will abort with an error message. If the <code>GHCRTS</code> environment variable is set, then the program will emit a warning message, <code>GHCRTS</code> will be ignored, and the program will run as normal.</dd> <dt>
<code>-rtsopts=ignore</code> </dt> <dd>Disables all processing of RTS options. Unlike <code>none</code> this treats all RTS flags appearing on the command line the same way as regular arguments. (Passing them on to your program as arguments). <code>GHCRTS</code> options will be processed normally.</dd> <dt>
<code>-rtsopts=ignoreAll</code> </dt> <dd>Same as <code>ignore</code> but also ignores <code>GHCRTS</code>.</dd> <dt>
<code>-rtsopts=some</code> </dt> <dd>[this is the default setting] Enable only the “safe” RTS options: (Currently only <code>-?</code> and <code>--info</code>.) Any other RTS options on the command line or in the <code>GHCRTS</code> environment variable causes the program with to abort with an error message.</dd> <dt>
<code>-rtsopts=all or just -rtsopts</code> </dt> <dd>Enable <em>all</em> RTS option processing, both on the command line and through the <code>GHCRTS</code> environment variable.</dd> </dl> <p>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to <code>-rtsopts=some</code>.</p> <p>Note that <code>-rtsopts</code> has no effect when used with <a class="reference internal" href="#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>; see <a class="reference internal" href="exts/ffi.html#using-own-main"><span class="std std-ref">Using your own main()</span></a> for details.</p> <p><code>-rtsopts</code> does not affect RTS options passed via <code>-with-rtsopts</code>; those are used regardless of <code>-rtsopts</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--with-rtsopts=⟨opts⟩">
<code>-with-rtsopts=⟨opts⟩</code> </dt> <dd>
<p>This option allows you to set the default RTS options at link-time. For example, <code>-with-rtsopts="-H128m"</code> sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the <code>-rtsopts</code> option, the user might not have the ability to change RTS options at run-time, in which case <code>-with-rtsopts</code> would be the <em>only</em> way to set them.)</p> <p>Use the runtime flag <a class="reference internal" href="runtime_control.html#rts-flag---info"><code>--info</code></a> on the executable program to see the options set with <code>-with-rtsopts</code>.</p> <p>Note that <code>-with-rtsopts</code> has no effect when used with <code>-no-hs-main</code>; see <a class="reference internal" href="exts/ffi.html#using-own-main"><span class="std std-ref">Using your own main()</span></a> for details.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-rtsopts-suggestions">
<code>-no-rtsopts-suggestions</code> </dt> <dd>
<p>This option disables RTS suggestions about linking with <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either <code>-rtsopts</code> or <code>-no-rtsopts-suggestions</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-gen-manifest">
<code>-fno-gen-manifest</code> </dt> <dd>
<p>On Windows, GHC normally generates a manifest file when linking a binary. The manifest is placed in the file <code><em>prog</em>.exe.manifest`</code> where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the “installer detection” in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing “install”, “setup” or “patch”). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</p> <p>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don’t depend on the user having disabled installer detection.</p> <p>The <code>-fno-gen-manifest</code> disables generation of the manifest file. One reason to do this would be if you had a manifest file of your own, for example.</p> <p>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</p> <p><a class="reference internal" href="#ghc-flag--fno-gen-manifest"><code>-fno-gen-manifest</code></a> also implies <a class="reference internal" href="#ghc-flag--fno-embed-manifest"><code>-fno-embed-manifest</code></a>, see below.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-embed-manifest">
<code>-fno-embed-manifest</code> </dt> <dd>
<p id="index-18">The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running <strong class="command">windres</strong>; to see exactly what GHC does to embed the manifest, use the <a class="reference internal" href="using.html#ghc-flag--v"><code>-v</code></a> flag. A GHC installation comes with its own copy of <code>windres</code> for this reason.</p> <p>See also <a class="reference internal" href="#ghc-flag--pgmwindres%20%E2%9F%A8cmd%E2%9F%A9"><code>-pgmwindres ⟨cmd⟩</code></a> (<a class="reference internal" href="#replacing-phases"><span class="std std-ref">Replacing the program for one or more phases</span></a>) and <a class="reference internal" href="#ghc-flag--optwindres%20%E2%9F%A8option%E2%9F%A9"><code>-optwindres ⟨option⟩</code></a> (<a class="reference internal" href="#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-shared-implib">
<code>-fno-shared-implib</code> </dt> <dd>
<p>DLLs on Windows are typically linked to by linking to a corresponding <code>.lib</code> or <code>.dll.a</code> — the so-called import library. GHC will typically generate such a file for every DLL you create by compiling in <a class="reference internal" href="using.html#ghc-flag--shared"><code>-shared</code></a> mode. However, sometimes you don’t want to pay the disk-space cost of creating this import library, which can be substantial — it might require as much space as the code itself, as Haskell DLLs tend to export lots of symbols.</p> <p>As long as you are happy to only be able to link to the DLL using <code>GetProcAddress</code> and friends, you can supply the <a class="reference internal" href="#ghc-flag--fno-shared-implib"><code>-fno-shared-implib</code></a> flag to disable the creation of the import library entirely.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dylib-install-name ⟨path⟩">
<code>-dylib-install-name ⟨path⟩</code> </dt> <dd>
<p>On Darwin/OS X, dynamic libraries are stamped at build time with an “install name”, which is the ultimate install path of the library file. Any libraries or executables that subsequently link against it will pick up that path as their runtime search location for it. By default, ghc sets the install name to the location where the library is built. This option allows you to override it with the specified file path. (It passes <code>-install_name</code> to Apple’s linker.) Ignored on other platforms.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--rdynamic">
<code>-rdynamic</code> </dt> <dd>
<p>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using <code>-optl -rdynamic</code> on Linux, and <code>-optl -export-all-symbols</code> on Windows.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fwhole-archive-hs-libs">
<code>-fwhole-archive-hs-libs</code> </dt> <dd>
<p>When linking a binary executable, this inserts the flag <code>-Wl,--whole-archive</code> before any <code>-l</code> flags for Haskell libraries, and <code>-Wl,--no-whole-archive</code> afterwards (on OS X, the flag is <code>-Wl,-all_load</code>, there is no equivalent for <code>-Wl,--no-whole-archive</code>). This flag also disables the use of <code>-Wl,--gc-sections</code> (<code>-Wl,-dead_strip</code> on OS X).</p> <p>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren’t referenced by any other code linked into the executable. If you’re using <code>-fwhole-archive-hs-libs</code>, you probably also want <code>-rdynamic</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pie">
<code>-pie</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.2</td> </tr>  </table> <p>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with <a class="reference internal" href="#ghc-flag--fPIE"><code>-fPIE</code></a>.</p> <p>Position independent executables are required by some platforms as they enable address-space layout randomization (ASLR), a common security measure. They can also be useful as they can be dynamically loaded and used as shared libraries by other executables.</p> <p>Position independent executables should be dynamically-linked (e.g. built with <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> and only loaded into other dynamically-linked executables to ensure that only one <code>libHSrts</code> is present if loaded into the address space of another Haskell process.</p> <p>Also, you may need to use the <a class="reference internal" href="#ghc-flag--rdynamic"><code>-rdynamic</code></a> flag to ensure that that symbols are not dropped from your PIE objects.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-pie">
<code>-no-pie</code> </dt> <dd>
<p>If required, the C compiler will still produce a PIE. Otherwise, this is the default. Refer to -pie for more information about PIEs.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fkeep-cafs">
<code>-fkeep-cafs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8.1</td> </tr>  </table> <p>Disables the RTS’s normal behaviour of garbage-collecting CAFs (Constant Applicative Forms, in other words top-level expressions). This option is useful for specialised applications that do runtime dynamic linking, where code dynamically linked in the future might require the value of a CAF that would otherwise be garbage-collected.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcompact-unwind">
<code>-fcompact-unwind</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4.1</td> </tr>  </table> <p>This instructs the linker to produce an executable that supports Apple’s compact unwinding sections. These are used by C++ and Objective-C code to unwind the stack when an exception occurs.</p> <p>In theory, the older <code>__eh_frame</code> section should also be usable for this purpose, but this does not always work.</p> </dd>
</dl>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/phases.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/phases.html</a>
  </p>
</div>
