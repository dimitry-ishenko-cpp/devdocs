<h1 id="id1">8. Profiling</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="profiling">  <p id="index-0">GHC comes with a time and space profiling system, so that you can answer questions like “why is my program so slow?”, or “why is my program using so much memory?”. We’ll start by describing how to do time profiling.</p> <p>Time profiling a program is a three-step process:</p> <ol class="arabic"> <li>Re-compile your program for profiling with the <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a> option, and probably one of the options for adding automatic annotations: <a class="reference internal" href="#ghc-flag-fprof-late"><code>-fprof-late</code></a> is the recommended option.</li> <li>
<p>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with <code>+RTS -p</code> (see <a class="reference internal" href="#rts-flag-p"><code>-p</code></a>), which generates a file named <code><em>prog</em>.prof</code> where ⟨prog⟩ is the name of your program (without the <code>.exe</code> extension, if you are on Windows).</p> <p>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</p> </li> <li>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</li> </ol> <p>The time profiler measures the CPU time taken by the Haskell code in your application. In particular time taken by safe foreign calls is not tracked by the profiler (see <a class="reference internal" href="#prof-foreign-calls"><span class="std std-ref">Profiling and foreign calls</span></a>).</p> <section id="cost-centres-and-cost-centre-stacks"> <h2 id="cost-centres">
<span class="section-number">8.1. </span>Cost centres and cost-centre stacks</h2> <p>GHC’s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</p> <p>Let’s take a look at an example:</p> <pre data-language="haskell">main = print (fib 30)
fib n = if n &lt; 2 then 1 else fib (n-1) + fib (n-2)
</pre> <p>Compile and run this program as follows:</p> <pre data-language="none">$ ghc -prof -fprof-auto -rtsopts Main.hs
$ ./Main +RTS -p
121393
$
</pre> <p>When a GHC-compiled program is run with the <a class="reference internal" href="#rts-flag-p"><code>-p</code></a> RTS option, it generates a file called <code>prog.prof</code>. In this case, the file will contain something like this:</p> <pre data-language="none">        Wed Oct 12 16:14 2011 Time and Allocation Profiling Report  (Final)

           Main +RTS -p -RTS

        total time  =        0.68 secs   (34 ticks @ 20 ms)
        total alloc = 204,677,844 bytes  (excludes profiling overheads)

COST CENTRE MODULE  %time %alloc

fib         Main    100.0  100.0


                                                      individual     inherited
COST CENTRE MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN        MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF        GHC.IO.Handle.FD        128           0    0.0    0.0     0.0    0.0
 CAF        GHC.IO.Encoding.Iconv   120           0    0.0    0.0     0.0    0.0
 CAF        GHC.Conc.Signal         110           0    0.0    0.0     0.0    0.0
 CAF        Main                    108           0    0.0    0.0   100.0  100.0
  main      Main                    204           1    0.0    0.0   100.0  100.0
   fib      Main                    205     2692537  100.0  100.0   100.0  100.0
</pre> <p>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn’t the same as the amount of <em>live</em> memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in <a class="reference internal" href="#prof-heap"><span class="std std-ref">Profiling memory usage</span></a>).</p> <p>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely <code>fib</code>, and it was responsible for 100% of both the time and allocation costs of the program.</p> <p>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to <code>fib</code> came from <code>main</code>.</p> <p>The time and allocation incurred by a given part of the program is displayed in two ways: “individual”, which are the costs incurred by the code covered by this cost centre stack alone, and “inherited”, which includes the costs incurred by all the children of this node.</p> <p>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</p> <pre data-language="haskell">main = print (f 30 + g 30)
  where
    f n  = fib n
    g n  = fib (n `div` 2)

fib n = if n &lt; 2 then 1 else fib (n-1) + fib (n-2)
</pre> <p>Compile and run this program as before, and take a look at the new profiling results:</p> <pre data-language="none">COST CENTRE MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN        MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF        GHC.IO.Handle.FD        128           0    0.0    0.0     0.0    0.0
 CAF        GHC.IO.Encoding.Iconv   120           0    0.0    0.0     0.0    0.0
 CAF        GHC.Conc.Signal         110           0    0.0    0.0     0.0    0.0
 CAF        Main                    108           0    0.0    0.0   100.0  100.0
  main      Main                    204           1    0.0    0.0   100.0  100.0
   main.g   Main                    207           1    0.0    0.0     0.0    0.1
    fib     Main                    208        1973    0.0    0.1     0.0    0.1
   main.f   Main                    205           1    0.0    0.0   100.0   99.9
    fib     Main                    206     2692537  100.0   99.9   100.0   99.9
</pre> <p>Now although we had two calls to <code>fib</code> in the program, it is immediately clear that it was the call from <code>f</code> which took all the time. The functions <code>f</code> and <code>g</code> which are defined in the <code>where</code> clause in <code>main</code> are given their own cost centres, <code>main.f</code> and <code>main.g</code> respectively.</p> <p>The actual meaning of the various columns in the output is:</p>  <p>The number of times this particular point in the call tree was entered.</p> <p>The percentage of the total run time of the program spent at this point in the call tree.</p> <p>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</p> <p>The percentage of the total run time of the program spent below this point in the call tree.</p> <p>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</p>  <p>In addition you can use the <a class="reference internal" href="#rts-flag-P"><code>-P</code></a> RTS option to get the following additional information:</p> <dl class="simple"> <dt>
<code>ticks</code> </dt>
<dd>
<p>The raw number of time “ticks” which were attributed to this cost-centre; from this, we get the <code>%time</code> figure mentioned above.</p> </dd> <dt>
<code>bytes</code> </dt>
<dd>
<p>Number of bytes allocated in the heap while in this cost-centre; again, this is the raw number from which we get the <code>%alloc</code> figure mentioned above.</p> </dd> </dl> <p>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn’t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller <a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p> <section id="inserting-cost-centres-by-hand"> <h3 id="scc-pragma">
<span class="section-number">8.1.1. </span>Inserting cost centres by hand</h3> <p>Cost centres are just program annotations. When you say <code>-fprof-auto</code> to the compiler, it automatically inserts a cost centre annotation around every binding not marked INLINE in your program, but you are entirely free to add cost centre annotations yourself. Be careful adding too many cost-centre annotations as the optimiser is careful to not move them around or remove them, which can severly affect how your program is optimised and hence the runtime performance!</p> <p>The syntax of a cost centre annotation for expressions is</p> <pre data-language="haskell">{-# SCC "name" #-} &lt;expression&gt;
</pre> <p>where <code>"name"</code> is an arbitrary string, that will become the name of your cost centre as it appears in the profiling output, and <code>&lt;expression&gt;</code> is any Haskell expression. An <code>SCC</code> annotation extends as far to the right as possible when parsing, having the same precedence as lambda abstractions, let expressions, and conditionals. Additionally, an annotation may not appear in a position where it would change the grouping of subexpressions:</p> <pre data-language="haskell">a = 1 / 2 / 2                          -- accepted (a=0.25)
b = 1 / {-# SCC "name" #-} 2 / 2       -- rejected (instead of b=1.0)
</pre> <p>This restriction is required to maintain the property that inserting a pragma, just like inserting a comment, does not have unintended effects on the semantics of the program, in accordance with <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0176-scc-parsing.rst">GHC Proposal #176</a>.</p> <p>SCC stands for “Set Cost Centre”. The double quotes can be omitted if <code>name</code> is a Haskell identifier starting with a lowercase letter, for example:</p> <pre data-language="haskell">{-# SCC id #-} &lt;expression&gt;
</pre> <p>Cost centre annotations can also appear in the top-level or in a declaration context. In that case you need to pass a function name defined in the same module or scope with the annotation. Example:</p> <pre data-language="haskell">f x y = ...
  where
    g z = ...
    {-# SCC g #-}

{-# SCC f #-}
</pre> <p>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</p> <pre data-language="haskell">f x y = ...
{-# SCC f "cost_centre_name" #-}
</pre> <p>Here is an example of a program with a couple of SCCs:</p> <pre data-language="haskell">main :: IO ()
main = do let xs = [1..1000000]
          let ys = [1..2000000]
          print $ {-# SCC last_xs #-} last xs
          print $ {-# SCC last_init_xs #-} last (init xs)
          print $ {-# SCC last_ys #-} last ys
          print $ {-# SCC last_init_ys #-} last (init ys)
</pre> <p>which gives this profile when run:</p> <pre data-language="none">COST CENTRE     MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN            MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF            GHC.IO.Handle.FD        130           0    0.0    0.0     0.0    0.0
 CAF            GHC.IO.Encoding.Iconv   122           0    0.0    0.0     0.0    0.0
 CAF            GHC.Conc.Signal         111           0    0.0    0.0     0.0    0.0
 CAF            Main                    108           0    0.0    0.0   100.0  100.0
  main          Main                    204           1    0.0    0.0   100.0  100.0
   last_init_ys Main                    210           1   25.0   27.4    25.0   27.4
   main.ys      Main                    209           1   25.0   39.2    25.0   39.2
   last_ys      Main                    208           1   12.5    0.0    12.5    0.0
   last_init_xs Main                    207           1   12.5   13.7    12.5   13.7
   main.xs      Main                    206           1   18.8   19.6    18.8   19.6
   last_xs      Main                    205           1    6.2    0.0     6.2    0.0
</pre> </section> <section id="rules-for-attributing-costs"> <h3 id="prof-rules">
<span class="section-number">8.1.2. </span>Rules for attributing costs</h3> <p>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</p> <p>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, <code>{-# SCC c -#} E</code>, the cost centre <code>c</code> is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</p> <p>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and <em>appends</em> it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</p> <p>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are “created” when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (“Constant Applicative Form”). GHC assigns every CAF in a module a stack consisting of the single cost centre <code>M.CAF</code>, where <code>M</code> is the name of the module. It is also possible to give each CAF a different stack, using the option <a class="reference internal" href="#ghc-flag-fprof-cafs"><code>-fprof-cafs</code></a>. This is especially useful when compiling with <a class="reference internal" href="using-optimisation.html#ghc-flag-ffull-laziness"><code>-ffull-laziness</code></a> (as is default with <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code>-O</code></a> and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (<a class="reference internal" href="debugging.html#ghc-flag-ddump-simpl"><code>-ddump-simpl</code></a>) in order to determine what these CAFs correspond to.</p> </section> </section> <section id="profiling-and-foreign-calls"> <h2 id="index-1">
<span class="section-number">8.2. </span>Profiling and foreign calls</h2> <p>Simply put, the profiler includes time spent in unsafe foreign calls but ignores time taken in safe foreign calls. For example, time spent blocked on IO operations (e.g. <code>getLine</code>) is not accounted for in the profile as <code>getLine</code> is implemented using a safe foreign call.</p> <p>The profiler estimates CPU time, for Haskell threads within the program only. In particular, time “taken” by the program in blocking safe foreign calls is not accounted for in time profiles. The runtime has the notion of a virtual processor which is known as a “capability”. Haskell threads are run on capabilities, and the profiler samples the capabilities in order to determine what is being executed at a certain time. When a safe foreign call is executed, it’s run outside the context of a capability; hence the sampling does not account for the time taken. Whilst the safe call is executed, other Haskell threads are free to run on the capability, and their cost will be attributed to the profiler. When the safe call is finished, the blocked, descheduled thread can be resumed and rescheduled.</p> <p>However, the time taken by blocking on unsafe foreign calls is accounted for in the profile. This happens because unsafe foreign calls are executed by the same capability their calling Haskell thread is running on. Therefore, an unsafe foreign call will block the entire capability whilst it is running, and any time the capability is sampled the “cost” of the foreign call will be attributed to the calling cost-centre stack.</p> <p>However, do note that you are not supposed to use unsafe foreign calls for any operations which do block! Do not be tempted to replace your safe foreign calls with unsafe calls just so they appear in the profile. This prevents GC from happening until the foreign call returns, which can be catastrophic for performance.</p> </section> <section id="compiler-options-for-profiling"> <h2 id="prof-compiler-options">
<span class="section-number">8.3. </span>Compiler options for profiling</h2> <dl class="std ghc-flag" id="index-2"> <dt class="sig sig-object std" id="ghc-flag-prof">
<code>-prof</code> </dt> <dd>
<p>To make use of the profiling system <em>all</em> modules must be compiled and linked with the <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a> option. Any <code>SCC</code> annotations you’ve put in your source will spring to life.</p> <p>Without a <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a> option, your <code>SCC</code>s are ignored; so you can compile <code>SCC</code>-laden code without changing it.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fno-prof-count-entries">
<code>-fno-prof-count-entries</code> </dt> <dd>
<p>Tells GHC not to collect information about how often functions are entered at runtime (the “entries” column of the time profile), for this module. This tends to make the profiled code run faster, and hence closer to the speed of the unprofiled code, because GHC is able to optimise more aggressively if it doesn’t have to maintain correct entry counts. This option can be useful if you aren’t interested in the entry counts (for example, if you only intend to do heap profiling).</p> </dd>
</dl> <p>There are a few other profiling-related compilation options. Use them <em>in addition to</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. These do not have to be used consistently for all modules in a program.</p> <section id="automatically-placing-cost-centres"> <h3>
<span class="section-number">8.3.1. </span>Automatically placing cost-centres</h3> <p>GHC has a number of flags for automatically inserting cost-centres into the compiled program. Use these options carefully because inserting too many cost-centres in the wrong places will mean the optimiser will be less effective and the runtime behaviour of your profiled program will be different to that of the unprofiled one.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-callers-name">
<code>-fprof-callers=⟨name⟩</code> </dt> <dd>
<p>Automatically enclose all occurrences of the named function in an <code>SCC</code>. Note that these cost-centres are added late in compilation (after simplification) and consequently the names may be slightly different than they appear in the source program (e.g. a call to <code>f</code> may inlined with its wrapper, resulting in an occurrence of its worker, <code>$wf</code>).</p> <p>In addition to plain module-qualified names (e.g. <code>GHC.Base.map</code>), ⟨name⟩ also accepts a small globbing language using <code>*</code> as a wildcard symbol:</p> <pre data-language="none">pattern    := &lt;module&gt; '.' &lt;identifier&gt;
module     := '*'
            | &lt;Haskell module name&gt;
identifier := &lt;ident_char&gt;
ident
</pre> <p>For instance, the following are all valid patterns:</p>  <ul class="simple"> <li><code>Data.List.map</code></li> <li><code>*.map</code></li> <li><code>*.parse*</code></li> <li><code>*.&lt;\*&gt;</code></li> </ul>  <p>The <code>*</code> character can be used literally by escaping (e.g. <code>\*</code>).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-auto">
<code>-fprof-auto</code> </dt> <dd>
<p><em>All</em> bindings not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a>, whether exported or not, top level or nested, will be given automatic <code>SCC</code> annotations. Functions marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a> must be given a cost centre manually.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-auto-top">
<code>-fprof-auto-top</code> </dt> <dd>
<p id="index-3">GHC will automatically add <code>SCC</code> annotations for all top-level bindings not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a>. If you want a cost centre on an <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a> function, you have to add it manually.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-auto-exported">
<code>-fprof-auto-exported</code> </dt> <dd>
<p id="index-4">GHC will automatically add <code>SCC</code> annotations for all exported functions not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a>. If you want a cost centre on an <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code>INLINE</code></a> function, you have to add it manually.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-auto-calls">
<code>-fprof-auto-calls</code> </dt> <dd>
<p>Adds an automatic <code>SCC</code> annotation to all <em>call sites</em>. This is particularly useful when using profiling for the purposes of generating stack traces; see the function <a class="reference external" href="../libraries/base-4.21.0.0-8e62/debug-trace.html#v:traceShow">Debug.Trace.traceShow</a>, or the <a class="reference internal" href="runtime_control.html#rts-flag-xc"><code>-xc</code></a> RTS flag (<a class="reference internal" href="runtime_control.html#rts-options-debugging"><span class="std std-ref">RTS options for Haskell program coverage</span></a>) for more details.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-late">
<code>-fprof-late</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.4.1</p> </dd> </dl> <p>Adds an automatic <code>SCC</code> annotation to all top level bindings which might perform work. This is done late in the compilation pipeline after the optimizer has run and unfoldings have been created. This means these cost centres will not interfere with core-level optimizations and the resulting profile will be closer to the performance profile of an optimized non-profiled executable.</p> <p>While the results of this are generally informative, some of the compiler internal names will leak into the profile. Further if a function is inlined into a use site it’s costs will be counted against the caller’s cost center.</p> <p>For example if we have this code:</p> <pre data-language="haskell">{-# INLINE mysum #-}
mysum = sum
main = print $ mysum [1..9999999]
</pre> <p>Then <code>mysum</code> will not show up in the profile since it will be inlined into main and therefore it’s associated costs will be attributed to mains implicit cost centre.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-late-inline">
<code>-fprof-late-inline</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.4.1</p> </dd> </dl> <p>Adds an automatic <code>SCC</code> annotation to all top level bindings late in the core pipeline after the optimizer has run. This is the same as <a class="reference internal" href="#ghc-flag-fprof-late"><code>-fprof-late</code></a> except that cost centers are included in some unfoldings.</p> <p>The result of which is that cost centers <em>can</em> inhibit core optimizations to some degree at use sites after inlining. Further there can be significant overhead from cost centres added to small functions if they are inlined often.</p> <p>You can try this mode if <a class="reference internal" href="#ghc-flag-fprof-late"><code>-fprof-late</code></a> results in a profile that’s too hard to interpret.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-late-overloaded">
<code>-fprof-late-overloaded</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.10.1</p> </dd> </dl> <p>Adds an automatic <code>SCC</code> annotation to all <em>overloaded</em> top level bindings late in the compilation pipeline after the optimizer has run and unfoldings have been created. This means these cost centres will not interfere with core-level optimizations and the resulting profile will be closer to the performance profile of an optimized non-profiled executable.</p> <p>This flag can help determine which top level bindings encountered during a program’s execution are still overloaded after inlining and specialization.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-late-overloaded-calls">
<code>-fprof-late-overloaded-calls</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.10.1</p> </dd> </dl> <p>Adds an automatic <code>SCC</code> annotation to all call sites that include dictionary arguments late in the compilation pipeline after the optimizer has run and unfoldings have been created. This means these cost centres will not interfere with core-level optimizations and the resulting profile will be closer to the performance profile of an optimized non-profiled executable.</p> <p>This flag is potentially more useful than <a class="reference internal" href="#ghc-flag-fprof-late-overloaded"><code>-fprof-late-overloaded</code></a> since it will also add <code>SCC</code> annotations to call sites of imported overloaded functions.</p> <p>Some overloaded calls may not be annotated, specifically in cases where the optimizer turns an overloaded function into a join point. Calls to such functions will not be wrapped in <code>SCC</code> annotations, since it would make them non-tail calls, which is a requirement for join points. Instead, <code>SCC</code> annotations are added around the body of overloaded join variables and given distinct names (<code>join-rhs-&lt;var&gt;</code>) to avoid confusion.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-cafs">
<code>-fprof-cafs</code> </dt> <dd>
<p>The costs of all CAFs in a module are usually attributed to one “big” CAF cost-centre. With this option, all CAFs get their own cost-centre. An “if all else fails” option…</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprof-manual">
<code>-fprof-manual</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>on</p> </dd> </dl> <p>Process (or ignore) manual <code>SCC</code> annotations. Can be helpful to ignore annotations from libraries which are not desired.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-auto-all">
<code>-auto-all</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-auto"><code>-fprof-auto</code></a></p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-auto">
<code>-auto</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-auto-exported"><code>-fprof-auto-exported</code></a></p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-caf-all">
<code>-caf-all</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-cafs"><code>-fprof-cafs</code></a></p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-no-auto-all">
<code>-no-auto-all</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-auto-calls"><code>-fno-prof-auto</code></a></p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-no-auto">
<code>-no-auto</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-auto-calls"><code>-fno-prof-auto</code></a></p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-no-caf-all">
<code>-no-caf-all</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-cafs"><code>-fno-prof-cafs</code></a></p> </dd>
</dl> </section> </section> <section id="time-and-allocation-profiling"> <h2 id="prof-time-options">
<span class="section-number">8.4. </span>Time and allocation profiling</h2> <p>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between <code>+RTS ... -RTS</code> as usual):</p> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-p">
<code>-p</code> </dt> <dt class="sig sig-object std" id="rts-flag-P">
<code>-P</code> </dt> <dt class="sig sig-object std" id="rts-flag-pa">
<code>-pa</code> </dt> <dd>
<p id="index-5">The <a class="reference internal" href="#rts-flag-p"><code>-p</code></a> option produces a standard <em>time profile</em> report. It is written into the file <code>&lt;stem&gt;.prof</code>; the stem is taken to be the program name by default, but can be overridden by the <a class="reference internal" href="#rts-flag-po-stem"><code>-po
⟨stem⟩</code></a> flag.</p> <p>The <a class="reference internal" href="#rts-flag-P"><code>-P</code></a> option produces a more detailed report containing the actual time and allocation data as well. (Not used much.)</p> <p>The <a class="reference internal" href="#rts-flag-pa"><code>-pa</code></a> option produces the most detailed report containing all cost centres in addition to the actual time and allocation data.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-pj">
<code>-pj</code> </dt> <dd>
<p>The <a class="reference internal" href="#rts-flag-pj"><code>-pj</code></a> option produces a time/allocation profile report in JSON format written into the file <code>&lt;program&gt;.prof</code>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-po-stem">
<code>-po ⟨stem⟩</code> </dt> <dd>
<p>The <a class="reference internal" href="#rts-flag-po-stem"><code>-po ⟨stem⟩</code></a> option overrides the stem used to form the output file paths for the cost-centre profiler (see <a class="reference internal" href="#rts-flag-p"><code>-p</code></a> and <a class="reference internal" href="#rts-flag-pj"><code>-pj</code></a> flags above) and heap profiler (see <a class="reference internal" href="runtime_control.html#rts-flag-h"><code>-h</code></a>).</p> <p>For instance, running a program with <code>+RTS -h -p -pohello-world</code> would produce a heap profile named <code>hello-world.hp</code> and a cost-centre profile named <code>hello-world.prof</code>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-V-secs">
<code>-V ⟨secs⟩</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>0.001 when profiling, and 0.01 otherwise</p> </dd> </dl> <p>Sets the interval that the RTS clock ticks at, which is also the sampling interval of the time and allocation profile. The default is 0.001 seconds when profiling, and 0.01 otherwise. The runtime uses a single timer signal to count ticks; this timer signal is used to control the context switch timer (<a class="reference internal" href="using-concurrent.html#using-concurrent"><span class="std std-ref">Using Concurrent Haskell</span></a>) and the heap profiling timer <a class="reference internal" href="#rts-options-heap-prof"><span class="std std-ref">RTS options for heap profiling</span></a>. Also, the time profiler uses the RTS timer signal directly to record time profiling samples.</p> <p>Normally, setting the <a class="reference internal" href="#rts-flag-V-secs"><code>-V ⟨secs⟩</code></a> option directly is not necessary: the resolution of the RTS timer is adjusted automatically if a short interval is requested with the <a class="reference internal" href="using-concurrent.html#rts-flag-C-s"><code>-C ⟨s⟩</code></a> or <a class="reference internal" href="#rts-flag-i-secs"><code>-i
⟨secs⟩</code></a> options. However, setting <a class="reference internal" href="#rts-flag-V-secs"><code>-V ⟨secs⟩</code></a> is required in order to increase the resolution of the time profiler.</p> <p>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-xc">
<code>-xc</code> </dt> <dd>
<p>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious <code>Prelude.head: empty list</code> error. See <a class="reference internal" href="runtime_control.html#rts-options-debugging"><span class="std std-ref">RTS options for Haskell program coverage</span></a>.</p> </dd>
</dl> <section id="json-profile-format"> <h3>
<span class="section-number">8.4.1. </span>JSON profile format</h3> <p>profile in a machine-readable JSON format. The JSON file can be directly loaded into <a class="reference external" href="https://www.speedscope.app/">speedscope.app</a> to interactively view the profile.</p> <p>The top-level object of this format has the following properties,</p> <dl class="simple"> <dt>
<code>program (string)</code> </dt>
<dd>
<p>The name of the program</p> </dd> <dt>
<code>arguments (list of strings)</code> </dt>
<dd>
<p>The command line arguments passed to the program</p> </dd> <dt>
<code>rts_arguments (list of strings)</code> </dt>
<dd>
<p>The command line arguments passed to the runtime system</p> </dd> <dt>
<code>initial_capabilities (integral number)</code> </dt>
<dd>
<p>How many capabilities the program was started with (e.g. using the <a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code>-N ⟨x⟩</code></a> option). Note that the number of capabilities may change during execution due to the <code>setNumCapabilities</code> function.</p> </dd> <dt>
<code>total_time (number)</code> </dt>
<dd>
<p>The total wall time of the program’s execution in seconds.</p> </dd> <dt>
<code>total_ticks (integral number)</code> </dt>
<dd>
<p>How many profiler “ticks” elapsed over the course of the program’s execution.</p> </dd> <dt>
<code>end_time (number)</code> </dt>
<dd>
<p>The approximate time when the program finished execution as a UNIX epoch timestamp.</p> </dd> <dt>
<code>tick_interval (float)</code> </dt>
<dd>
<p>How much time between profiler ticks.</p> </dd> <dt>
<code>total_alloc (integer)</code> </dt>
<dd>
<p>The cumulative allocations of the program in bytes.</p> </dd> <dt>
<code>cost_centres (list of objects)</code> </dt>
<dd>
<p>A list of the program’s cost centres</p> </dd> <dt>
<code>profile (object)</code> </dt>
<dd>
<p>The profile tree itself</p> </dd> </dl> <p>Each entry in <code>cost_centres</code> is an object describing a cost-centre of the program having the following properties,</p> <dl class="simple"> <dt>
<code>id (integral number)</code> </dt>
<dd>
<p>A unique identifier used to refer to the cost-centre</p> </dd> <dt>
<code>is_caf (boolean)</code> </dt>
<dd>
<p>Whether the cost-centre is a Constant Applicative Form (CAF)</p> </dd> <dt>
<code>label (string)</code> </dt>
<dd>
<p>A descriptive string roughly identifying the cost-centre.</p> </dd> <dt>
<code>src_loc (string)</code> </dt>
<dd>
<p>A string describing the source span enclosing the cost-centre.</p> </dd> </dl> <p>The profile data itself is described by the <code>profile</code> field, which contains a tree-like object (which we’ll call a “cost-centre stack” here) with the following properties,</p> <dl class="simple"> <dt>
<code>id (integral number)</code> </dt>
<dd>
<p>The <code>id</code> of a cost-centre listed in the <code>cost_centres</code> list.</p> </dd> <dt>
<code>entries (integral number)</code> </dt>
<dd>
<p>How many times was this cost-centre entered?</p> </dd> <dt>
<code>ticks (integral number)</code> </dt>
<dd>
<p>How many ticks was the program’s execution inside of this cost-centre? This does not include child cost-centres.</p> </dd> <dt>
<code>alloc (integral number)</code> </dt>
<dd>
<p>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</p> </dd> <dt>
<code>children (list)</code> </dt>
<dd>
<p>A list containing child cost-centre stacks.</p> </dd> </dl> <p>For instance, a simple profile might look like this,</p> <pre data-language="json">{
  "program": "Main",
  "arguments": [
    "nofib/shootout/n-body/Main",
    "50000"
  ],
  "rts_arguments": [
    "-pj",
    "-hy"
  ],
  "end_time": "Thu Feb 23 17:15 2017",
  "initial_capabilities": 0,
  "total_time": 1.7,
  "total_ticks": 1700,
  "tick_interval": 1000,
  "total_alloc": 3770785728,
  "cost_centres": [
    {
      "id": 168,
      "label": "IDLE",
      "module": "IDLE",
      "src_loc": "&lt;built-in&gt;",
      "is_caf": false
    },
    {
      "id": 156,
      "label": "CAF",
      "module": "GHC.Integer.Logarithms.Internals",
      "src_loc": "&lt;entire-module&gt;",
      "is_caf": true
    },
    {
      "id": 155,
      "label": "CAF",
      "module": "GHC.Integer.Logarithms",
      "src_loc": "&lt;entire-module&gt;",
      "is_caf": true
    },
    {
      "id": 154,
      "label": "CAF",
      "module": "GHC.Event.Array",
      "src_loc": "&lt;entire-module&gt;",
      "is_caf": true
    }
  ],
  "profile": {
    "id": 162,
    "entries": 0,
    "alloc": 688,
    "ticks": 0,
    "children": [
      {
        "id": 1,
        "entries": 0,
        "alloc": 208,
        "ticks": 0,
        "children": [
          {
            "id": 22,
            "entries": 1,
            "alloc": 80,
            "ticks": 0,
            "children": []
          }
        ]
      },
      {
        "id": 42,
        "entries": 1,
        "alloc": 1632,
        "ticks": 0,
        "children": []
      }
    ]
  }
}
</pre> </section> <section id="eventlog-profile-format"> <h3>
<span class="section-number">8.4.2. </span>Eventlog profile format</h3> <p>In addition to the <code>.prof</code> and <code>.json</code> formats the cost centre definitions and samples are also emitted to the <a class="reference internal" href="runtime_control.html#rts-eventlog"><span class="std std-ref">eventlog</span></a>. The format of the events is specified in the <a class="reference internal" href="eventlog-formats.html#eventlog-encodings"><span class="std std-ref">eventlog encodings</span></a> section.</p> </section> </section> <section id="profiling-memory-usage"> <h2 id="prof-heap">
<span class="section-number">8.5. </span>Profiling memory usage</h2> <p>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</p> <p>Heap profiling differs from time profiling in the fact that is not always necessary to use the profiling runtime to generate a heap profile. There are two heap profiling modes (<a class="reference internal" href="runtime_control.html#rts-flag-hT"><code>-hT</code></a> and <a class="reference internal" href="#rts-flag-hi"><code>-hi</code></a> <a class="footnote-reference brackets" href="#id5" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>) which are always available.</p> <p>To generate a heap profile from your program:</p> <ol class="arabic"> <li>Assuming you need the profiling runtime, compile the program for profiling (<a class="reference internal" href="#prof-compiler-options"><span class="std std-ref">Compiler options for profiling</span></a>).</li> <li>
<p>Run it with one of the heap profiling options described below (eg. <a class="reference internal" href="#rts-flag-hc"><code>-hc</code></a> for a basic producer profile) and enable the eventlog using <a class="reference internal" href="runtime_control.html#rts-flag-l-flags"><code>-l</code></a>.</p> <p>Heap samples will be emitted to the GHC event log (see <a class="reference internal" href="eventlog-formats.html#heap-profiler-events"><span class="std std-ref">Heap profiler event log output</span></a> for details about event format).</p> </li> <li>Render the heap profile using <a class="reference external" href="https://hackage.haskell.org/package/eventlog2html">eventlog2html</a>. This produces an HTML file which contains the visualised profile.</li> <li>Open the rendered interactive profile in your web browser.</li> </ol> <p>For example, here is a heap profile produced of using eventlog profiling on GHC compiling the Cabal library. You can read a lot more about eventlog2html on the website.</p> <img alt="_images/eventlog_profile.png" src="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/_images/eventlog_profile.png"> <p>Note that there is the legacy <code><em>prog</em>.hp</code> format which has been deprecated in favour of eventlog based profiling. In order to render the legacy format, the steps are as follows.</p> <ol class="arabic simple" start="3"> <li>Run <strong class="command">hp2ps</strong> to produce a Postscript file, <code><em>prog</em>.ps</code>. The <strong class="command">hp2ps</strong> utility is described in detail in <a class="reference internal" href="#hp2ps"><span class="std std-ref">hp2ps – Rendering heap profiles to PostScript</span></a>.</li> <li>Display the heap profile using a postscript viewer such as Ghostview, or print it out on a Postscript-capable printer.</li> </ol> <p>For example, here is a heap profile produced for the <code>sphere</code> program from GHC’s <code>nofib</code> benchmark suite,</p> <img alt="_images/prof_scc.svg" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgd2lkdGg9IjgxMC42MjUiCiAgIGhlaWdodD0iNTQwLjYyNSIKICAgdmlld0JveD0iMCAwIDgxMC42MjUgNTQwLjYyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0icHJvZl9zY2Muc3ZnIj48bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE4Ij48cmRmOlJERj48Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPjxkYzp0aXRsZT48L2RjOnRpdGxlPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmcwogICAgIGlkPSJkZWZzNiIgLz48c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MTYiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTA1MSIKICAgICBpZD0ibmFtZWR2aWV3NCIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgZml0LW1hcmdpbi10b3A9IjAiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSIwIgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjAiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjAiCiAgICAgaW5rc2NhcGU6em9vbT0iMC42MzQ2MjE4NSIKICAgICBpbmtzY2FwZTpjeD0iMjA4LjA5MTc3IgogICAgIGlua3NjYXBlOmN5PSIxNzcuOTU4OTIiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI1IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0iZzEwIiAvPjxnCiAgICAgaWQ9ImcxMCIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlua3NjYXBlOmxhYmVsPSJpbmtfZXh0X1hYWFhYWCIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLjI1LC0xLjI1LDAsOTQ1LjMxMjUsNjMwLjMxMjUpIj48ZwogICAgICAgaWQ9ImcxMiIKICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMC4xLDAuMSkiPjxwYXRoCiAgICAgICAgIGQ9Im0gNzIwLDEwODAgNDMyMCwwIDAsNjQ4MCAtNDMyMCwwIDAsLTY0ODAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgxNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDQ3OTAsMTEzMCAyMDAsMCAwLDYzODAgLTIwMCwwIDAsLTYzODAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgxNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzE4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNDg1LDc0NSkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA5Ljk5NjAwMDMgMTYuNjY3OTk5IDE5LjMzMjAwMSAyNi4wMDQgMjkuMzQgMzYuMDEyMDAxIDQyLjY4Mzk5OCA0OS4zNTU5OTkgNTIuNjkyMDAxIDU5LjcwMDAwMSA2OC4zNjM5OTggNzUuNjk1OTk5IDgzLjY5OTk5NyA4Ny4wMzYwMDMgOTEuMDMxOTk4IDk3LjcwNDAwMiAyNDguMzAwNCAyNTQuOTcyNCAyNTguMzA4NDEgMjY0Ljk4MDQxIDI3MS42NTI0IDI3OC4zMjQ0IDI4MS42NjA0IDI4OC4zMzI0IDI5NC4zMzI0IDI5Ny42Njg0IDMwNC4zNDAzOSAzMTAuMzQwMzkgMzEzLjY3NjM5IDMxOS42NzYzOSAzMjMuMDEyMzkgMzI5LjAxMjM5IDMzNS42ODQzOSAzNDEuNjg0MzkgMzQ4LjM1NjQxIDM1NS4wMjg0MSAzNjEuNzAwNDEgNTEzLjI3NDc4IDUyMC42MDY4MSA1MjQuNjAyNzggNTI3LjI2Njc4IDUzMC42MDI3OCA1MzkuOTM4NzggNTQ1LjkzODc4IDU0OS4yNzQ3OCA1NTUuOTQ2NzggNTYyLjYxODc3IDU2NS45NTQ3NyA1NzIuNjI2NzcgNTc5LjI5ODgzIDU4Mi42MzQ4MyA1ODkuMzA2ODIgNTk1Ljk3ODgyIDU5OS4zMTQ4MiA2MDUuOTg2ODIgNjEyLjY1ODgxIDYxOS4zMzA4MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMjIiPk1haW4gMTAwICtSVFMgLWhjOSw2NjEgYnl0ZXMgeCBzZWNvbmRzRnJpIE9jdCAyIDE1OjAxIDIwMTU8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwtNDA5Mi4yOSIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgyNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzI2IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNzcsMzM5LjAxMSkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjgiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1IDEwLjU2IDE1LjU2IDIxLjEyMDAwMSAyNi42OCAzMi4yNDAwMDIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjMwIj5zZWNvbmRzPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIC00MCwwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMzQiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCw3Nyw3MTcuOTUpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDM2Ij48dHNwYW4KICAgICAgICAgICAgIHg9IjAgNS41NTk5OTk5IDguMzQwMDAwMiIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMzgiPjAuMDwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNjQ4OS45NiAtNDAsMCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzQyIgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNzcsNjU1Ljk0NSkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0NDQiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgOC4zNDAwMDAyIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW40NiI+MC4xPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDkyMCw1ODY5LjkxIC00MCwwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnNTAiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCw3Nyw1OTMuOTQxKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQ1MiI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDUuNTU5OTk5OSA4LjM0MDAwMDIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjU0Ij4wLjE8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDUyNDkuODcgLTQwLDAiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9Imc1OCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDc3LDUzMS45MzcpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDYwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgNS41NTk5OTk5IDguMzQwMDAwMiIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuNjIiPjAuMjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNDYyOS44MyAtNDAsMCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGg2NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzY2IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNzcsNDY5LjkzMikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0NjgiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgOC4zNDAwMDAyIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW43MCI+MC4yPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDkyMCw0MDA5Ljc5IC00MCwwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDcyIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnNzQiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCw3Nyw0MDcuOTI4KSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQ3NiI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDUuNTU5OTk5OSA4LjM0MDAwMDIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3Bhbjc4Ij4wLjI8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMzgyMCwwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDgwIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnODIiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQ1MC4xMDEsNzE2KSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQ4NCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDUuNTU5OTk5OSAxMC41NiAxMy4zNCAxOC45IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW44NiI+Ynl0ZXM8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCw0MCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGg4OCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzkwIgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsOTIsNzI2LjU2KSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQ5MiI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDUuNTU5OTk5OSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuOTQiPjBrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDE0MjcuNzYsNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDk2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnOTgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwxNDIuNzc2LDcyNi41NikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MTAwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgNS41NTk5OTk5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4xMDIiPjVrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDE5MzUuNTIsNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEwNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzEwNiIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDE5My41NTIsNzMyLjEyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQxMDgiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgMTEuMTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjExMCI+MTBrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDI0NDMuMjksNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDExMiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzExNCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDI0NC4zMjksNzMyLjEyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQxMTYiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgMTEuMTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjExOCI+MTVrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDI5NTEuMDUsNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEyMCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzEyMiIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDI5NS4xMDUsNzMyLjEyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQxMjQiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgMTEuMTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjEyNiI+MjBrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDM0NTguODEsNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEyOCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzEzMCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDM0NS44ODEsNzMyLjEyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQxMzIiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgMTEuMTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjEzNCI+MjVrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDM5NjYuNTcsNzExMCAwLDQwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEzNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzEzOCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDM5Ni42NTcsNzMyLjEyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQxNDAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCA1LjU1OTk5OTkgMTEuMTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjE0MiI+MzBrPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDEwMzEuOTEsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMTQ0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMTAzMS45MSwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgxNDYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcxNDgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwxMDUuMTkxLDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDE1MCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDcuNzgwMDAwMiAxMy44OSAyMS4xMTAwMDEgMjcuNzgwMDAxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4xNTIiPk9USEVSPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDEyMTMuODEsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMzMzMzMzM7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMTU0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMTIxMy44MSwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgxNTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcxNTgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwxMjMuMzgxLDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDE2MCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDMuMzI5OTk5OSA4Ljg5MDAwMDMgMTQuNDUgMjAuMDEgMjMuMzQgMjYuMTIwMDAxIDI5LjQ1MDAwMSAzNS4wMDk5OTggNDAuMDA5OTk4IDQ1LjU3IDUxLjEzMDAwMSA1My4zNDk5OTggNTguMzQ5OTk4IDYzLjkxIDY2LjEyOTk5NyA2OC45MTAwMDQgNzIuMjM5OTk4IDc3LjgwMDAwMyA4Mi44MDAwMDMgODUuNTgwMDAyIDg4LjM2MDAwMSA5MS4xMzk5OTkgOTQuNDcwMDAxIDEwMC4wMyAxMDUuMDMgMTA3LjgxIDExMC41OSAxMTMuMzciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjE2MiI+KDExMil0cmFjZXBpeGVsL3JheS5mL3JheS8uLi48L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMTM5NS43MSwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6Izk5OTk5OTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgxNjQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAxMzk1LjcxLDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDE2NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzE2OCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDE0MS41NzEsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MTcwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyOC4zNCAzMy45MDAwMDIgMzkuNDU5OTk5IDQ1LjAyIDQ4LjM0OTk5OCA1My45MSA1Ni4xMzAwMDEgNjEuNjg5OTk5IDY0LjQ3MDAwMSA3MC4wMjk5OTkgNzMuMzYwMDAxIDc4LjM2MDAwMSA4My45MTk5OTggODguOTE5OTk4IDkxLjY5OTk5NyA5NC40ODAwMDMgOTcuMjYwMDAyIDEwMC41OSAxMDYuMTUgMTExLjE1IDExNi43MSAxMTkuNDkgMTIyLjI3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4xNzIiPigxMjIpc3BoZXJlaW50ZXJzZWN0L3RyYWNlLi4uPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDE1NzcuNjIsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMTc0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMTU3Ny42MiwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgxNzYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcxNzgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwxNTkuNzYyLDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDE4MCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDMuMzI5OTk5OSA4Ljg5MDAwMDMgMTQuNDUgMjAuMDEgMjMuMzQgMjYuNjcgMzIuMjMgMzcuNzkwMDAxIDQwLjU3IDQ2LjEzMDAwMSA0OC4zNDk5OTggNTMuOTEgNTkuNDcwMDAxIDYyLjI1IDY3LjgwOTk5OCA3My4zNzAwMDMgNzUuNTg5OTk2IDc4LjM3MDAwMyA4MS4xNTAwMDIgODQuNDgwMDAzIDkwLjA0MDAwMSA5NS41OTk5OTggOTguMzc5OTk3IDEwMy45NCAxMDYuMTYgMTExLjE2IDExMy45NCAxMTYuNzIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjE4MiI+KDE4MylyYmcuZWlnaHRfYml0L3JiZy9waXguLi48L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMTc1OS41MiwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgxODQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAxNzU5LjUyLDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDE4NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzE4OCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDE3Ny45NTIsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MTkwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyOC45IDMxLjEyMDAwMSAzNi4xMTk5OTkgNDEuNjggNDMuOTAwMDAyIDQ4LjkwMDAwMiA1MS42OCA1Ny4yNDAwMDIgNjIuNzk5OTk5IDcxLjEyOTk5NyA3My45MTAwMDQgNzcuMjM5OTk4IDgyLjgwMDAwMyA4OC4zNjAwMDEgOTEuMTM5OTk5IDk5LjQ3MDAwMSAxMDUuMDMgMTA3LjI1IDExMi44MSAxMTUuNTkgMTE4LjM3IDEyMS4xNSAxMjMuOTMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjE5MiI+KDEwOClwaXhlbHMvcHBtL3J1bi9tYWluLlwuLi48L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMTk0MS40MywyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzY2NjY2NjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgxOTQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAxOTQxLjQzLDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDE5NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzE5OCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDE5Ni4xNDMsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjAwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyOC4zNCAzMy45MDAwMDIgMzguOTAwMDAyIDQ0LjQ1OTk5OSA1MC4wMiA1NS41ODAwMDIgNTguMzYwMDAxIDYzLjM2MDAwMSA2OC45MTk5OTggNzMuOTE5OTk4IDc4LjkxOTk5OCA4NC40ODAwMDMgOTIuODA5OTk4IDk1LjU4OTk5NiAxMDAuNTkgMTA2LjE1IDExMS43MSAxMTcuMjcgMTIyLjgzIDEyNS42MSAxMzEuMTcgMTMzLjk1IDEzNi43MyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMjAyIj4oMjIxKXZlY2FkZC92ZWNzdW0vc2hhZGUuZC4uLjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSAyMTIzLjMzLDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDIwNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDIxMjMuMzMsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMjA2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMjA4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsMjE0LjMzMywyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQyMTAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDIwLjAxIDIzLjM0IDI4LjM0IDMzLjkwMDAwMiAzOC45MDAwMDIgNDMuOTAwMDAyIDQ4LjkwMDAwMiA1NC40NTk5OTkgNTYuNjggNjIuMjQwMDAyIDY1LjAxOTk5NyA3MC4wMTk5OTcgNzUuNTgwMDAyIDgzLjkxMDAwNCA4OS40NzAwMDEgOTUuMDI5OTk5IDk4LjM2MDAwMSAxMDMuOTIgMTEyLjI1IDExNy4yNSAxMjAuMDMgMTI1LjAzIDEzMC4wMyAxMzIuODEgMTM1LjU5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4yMTIiPigxNDcpdmVjc2NhbGUvY2FtcGFyYW1zLnNjLi4uPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDIzMDUuMjQsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNiMmIyYjI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMjE0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMjMwNS4yNCwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgyMTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcyMTgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwyMzIuNTI0LDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDIyMCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDMuMzI5OTk5OSA4Ljg5MDAwMDMgMTQuNDUgMjAuMDEgMjMuMzQgMjguMzQgMzMuOTAwMDAyIDM4LjkwMDAwMiA0My45MDAwMDIgNDguOTAwMDAyIDU0LjQ1OTk5OSA1Ni42OCA2Mi4yNDAwMDIgNjUuMDE5OTk3IDcwLjAxOTk5NyA3NS41ODAwMDIgODMuOTEwMDA0IDg5LjQ3MDAwMSA5NS4wMjk5OTkgOTguMzYwMDAxIDEwMy45MiAxMTIuMjUgMTE3LjI1IDEyMC4wMyAxMjUuMDMgMTMwLjAzIDEzMi44MSAxMzUuNTkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjIyMiI+KDE1Nyl2ZWNzY2FsZS9jYW1wYXJhbXMuc2MuLi48L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMjQ4Ny4xNCwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgyMjQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAyNDg3LjE0LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDIyNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzIyOCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDI1MC43MTQsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjMwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyOC4zNCAzMy45MDAwMDIgMzguOTAwMDAyIDQzLjkwMDAwMiA0OS40NTk5OTkgNTUuMDIgNTcuNzk5OTk5IDYyLjc5OTk5OSA2OC4zNjAwMDEgNzYuNjkwMDAyIDgyLjI1IDg3LjgwOTk5OCA5MS4xMzk5OTkgOTYuNjk5OTk3IDEwNS4wMyAxMTAuMDMgMTEyLjgxIDExNS41OSAxMTcuODEgMTIxLjE0IDEyNi4xNCAxMjguOTIgMTMxLjciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjIzMiI+KDE0MCl2ZWNzdWIvY2FtcGFyYW1zLmZpcnMuLi48L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMjY2OS4wNSwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6I2NjY2NjYztmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgyMzQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAyNjY5LjA1LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDIzNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzIzOCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDI2OC45MDUsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjQwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyNi42NyAzMi4yMyAzNy43OTAwMDEgNDAuNTcgNDYuMTMwMDAxIDQ4LjM0OTk5OCA1My4zNDk5OTggNTguOTEgNjEuMTMwMDAxIDY2LjEyOTk5NyA2OC45MTAwMDQgNzQuNDcwMDAxIDgwLjAyOTk5OSA4OC4zNjAwMDEgOTEuMTM5OTk5IDk0LjQ3MDAwMSAxMDAuMDMgMTA1LjU5IDEwOC4zNyAxMTYuNyAxMjIuMjYgMTI1LjA0IDEyNy44MiIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMjQyIj4oMTEwKXJiZy9waXhlbHMvcHBtL3J1bi9tYS4uLjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSAyODUwLjk1LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDI0NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDI4NTAuOTUsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMjQ2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMjQ4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsMjg3LjA5NSwyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQyNTAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDE3Ljc4MDAwMSAyNS41NTk5OTkgMzIuNzc5OTk5IDQwIDQyLjc3OTk5OSA0NS41NjAwMDEgNTMuMzQgNTYuMTE5OTk5IDYyLjc5MDAwMSA2OC4zNDk5OTggNzMuMzQ5OTk4IDc4LjkxMDAwNCA4NC40NzAwMDEgODYuNjkwMDAyIDkyLjI1IDk3LjgwOTk5OCAxMDAuNTkgMTAzLjM3IDEwOC4zNyAxMTMuOTMgMTE5LjQ5IDEyNC40OSAxMjcuMjcgMTM0LjQ5MDAxIDE0MS4xNiIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMjUyIj4oODApR0hDLklPLkVuY29kaW5nLkljb252LkNBRjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSAzMDMyLjg2LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojMzMzMzMzO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDI1NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDMwMzIuODYsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMjU2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMjU4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsMzA1LjI4NiwyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQyNjAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDIwLjAxIDIzLjM0IDI4LjM0IDMzLjkwMDAwMiAzOC45MDAwMDIgNDMuOTAwMDAyIDQ5LjQ1OTk5OSA1Ny43OTAwMDEgNjAuNTcgNjguOTAwMDAyIDc0LjQ1OTk5OSA3Ni42OCA4Mi4yMzk5OTggODUuMDE5OTk3IDkyLjIzOTk5OCA5OC45MTAwMDQiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjI2MiI+KDIxNyl2ZWNzdW0vTWFpbi5DQUY8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMzIxNC43NiwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6Izk5OTk5OTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgyNjQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAzMjE0Ljc2LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDI2NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzI2OCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDMyMy40NzYsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MjcwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAyMC4wMSAyMy4zNCAyNi4xMjAwMDEgMzEuNjggMzYuNjggMzkuNDU5OTk5IDQ0LjQ1OTk5OSA1MC4wMiA1NS41ODAwMDIgNjEuMTM5OTk5IDY0LjQ3MDAwMSA3MC4wMjk5OTkgNzUuMDI5OTk5IDc3LjgwOTk5OCA4Ni4xMzk5OTkgOTEuNjk5OTk3IDkzLjkxOTk5OCA5OS40ODAwMDMgMTAyLjI2IDEwOS40OCAxMTYuMTUiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjI3MiI+KDExOSl0ZXN0c3BoZXJlcy9NYWluLkNBRjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSAzMzk2LjY3LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDI3NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDMzOTYuNjcsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMjc2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMjc4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsMzQxLjY2NywyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQyODAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDIwLjAxIDIzLjM0IDI4LjM0IDMzLjkwMDAwMiAzOS40NTk5OTkgNDUuMDIgNTAuNTgwMDAyIDUzLjM2MDAwMSA1Ni4xMzk5OTkgNTkuNDcwMDAxIDY1LjAyOTk5OSA3MC4wMjk5OTkgNzUuNTg5OTk2IDgxLjE1MDAwMiA4My4zNzAwMDMgODguMzcwMDAzIDkzLjkzIDk2LjE1MDAwMiA5OC45MyAxMDIuMjYgMTA3LjgyIDExMi44MiAxMTUuNiAxMTguMzggMTIxLjE2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4yODIiPigxODUpc2hhZGUvdHJhY2VwaXhlbC9yYXkuLi4uPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDM1NzguNTcsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMjg0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMzU3OC41NywyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgyODYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcyODgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwzNTkuODU3LDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDI5MCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDMuMzI5OTk5OSA4Ljg5MDAwMDMgMTQuNDUgMjAuMDEgMjMuMzQgMjYuNjcgMzIuMjMgMzcuMjMgNDAuMDA5OTk4IDQzLjM0IDQ4LjkwMDAwMiA1NC40NTk5OTkgNTcuMjQwMDAyIDY1LjU3IDcxLjEyOTk5NyA3My4zNDk5OTggNzguOTEwMDA0IDgxLjY5MDAwMiA4NC40NzAwMDEgODcuMjUgOTUuNTgwMDAyIDEwMS4xNCAxMDMuMzYgMTA4LjkyIDExMS43IDEyMC4wMyAxMjIuODEgMTI1LjU5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4yOTIiPigxMDkpcmF5L3J1bi9tYWluLlwvbWFpbi9NLi4uPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDM3NjAuNDgsMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiM2NjY2NjY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMjk0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gMzc2MC40OCwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgyOTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PGcKICAgICAgICAgaWQ9ImcyOTgiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMTAsMTApIj48dGV4dAogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTEsMCwzNzguMDQ4LDI3Ny43NzIpIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTBweDtmb250LWZhbWlseTpIZWx2ZXRpY2E7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpIZWx2ZXRpY2E7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBpZD0idGV4dDMwMCI+PHRzcGFuCiAgICAgICAgICAgICB4PSIwIDMuMzI5OTk5OSA4Ljg5MDAwMDMgMTQuNDUgMjAuMDEgMjMuMzQgMzEuNjcgMzcuMjMgMzkuNDUwMDAxIDQ1LjAwOTk5OCA0Ny43OTAwMDEgNTUuMDA5OTk4IDYxLjY4IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4zMDIiPigxMDMpTWFpbi5DQUY8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gMzk0Mi4zOCwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzMDQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSAzOTQyLjM4LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDMwNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzMwOCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDM5Ni4yMzgsMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MzEwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAxNy43ODAwMDEgMjUuNTU5OTk5IDMyLjc3OTk5OSA0MCA0Mi43Nzk5OTkgNTAgNTUuNTYwMDAxIDYxLjExOTk5OSA2Ni4xMjAwMDMgNjguOTAwMDAyIDc1LjU3IDc3Ljc5MDAwMSA4My4zNDk5OTggODguOTEwMDA0IDk0LjQ3MDAwMSA5Ni42OTAwMDIgOTkuNDcwMDAxIDEwNi42OSAxMTMuMzYiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgICAgIGlkPSJ0c3BhbjMxMiI+KDg0KUdIQy5Db25jLlNpZ25hbC5DQUY8L3RzcGFuPjwvdGV4dD4KPC9nPjxwYXRoCiAgICAgICAgIGQ9Im0gNDEyNC4yOSwyODI3LjcyIDE0MCwwIDAsMTQwIC0xNDAsMCAwLC0xNDAgeiIKICAgICAgICAgc3R5bGU9ImZpbGw6I2IyYjJiMjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzMTQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA0MTI0LjI5LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDMxNiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48ZwogICAgICAgICBpZD0iZzMxOCIKICAgICAgICAgdHJhbnNmb3JtPSJzY2FsZSgxMCwxMCkiPjx0ZXh0CiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwtMSwwLDQxNC40MjksMjc3Ljc3MikiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMHB4O2ZvbnQtZmFtaWx5OkhlbHZldGljYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkhlbHZldGljYTt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGlkPSJ0ZXh0MzIwIj48dHNwYW4KICAgICAgICAgICAgIHg9IjAgMy4zMjk5OTk5IDguODkwMDAwMyAxNC40NSAxNy43ODAwMDEgMjUuNTU5OTk5IDMyLjc3OTk5OSA0MCA0Mi43Nzk5OTkgNDUuNTYwMDAxIDUzLjM0IDU2LjExOTk5OSA2My4zNCA2OC45MDAwMDIgNzQuNDU5OTk5IDgwLjAxOTk5NyA4Mi4yMzk5OTggODcuODAwMDAzIDkwLjU4MDAwMiA5Ni42OTAwMDIgMTAzLjkxIDEwNi42OSAxMTMuOTEgMTIwLjU4IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgICAgICBpZD0idHNwYW4zMjIiPig3NylHSEMuSU8uSGFuZGxlLkZELkNBRjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSA0MzA2LjE5LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojODA4MDgwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDMyNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDQzMDYuMTksMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMzI2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMzI4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNDMyLjYxOSwyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQzMzAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDE3Ljc4MDAwMSAyNS41NTk5OTkgMzIuNzc5OTk5IDQwIDQyLjc3OTk5OSA0NS41NjAwMDEgNTMuMzQgNTYuMTE5OTk5IDYyLjc5MDAwMSA2OC4zNDk5OTggNzMuMzQ5OTk4IDc4LjkxMDAwNCA4NC40NzAwMDEgODYuNjkwMDAyIDkyLjI1IDk3LjgwOTk5OCAxMDAuNTkgMTA3LjgxIDExNC40OCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMzMyIj4oOTIpR0hDLklPLkVuY29kaW5nLkNBRjwvdHNwYW4+PC90ZXh0Pgo8L2c+PHBhdGgKICAgICAgICAgZD0ibSA0NDg4LjA5LDI4MjcuNzIgMTQwLDAgMCwxNDAgLTE0MCwwIDAsLTE0MCB6IgogICAgICAgICBzdHlsZT0iZmlsbDojY2NjY2NjO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDMzNCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDQ0ODguMDksMjgyNy43MiAxNDAsMCAwLDE0MCAtMTQwLDAgMCwtMTQwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMzM2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxnCiAgICAgICAgIGlkPSJnMzM4IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDEwLDEwKSI+PHRleHQKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLC0xLC0xLDAsNDUwLjgwOSwyNzcuNzcyKSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEwcHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246SGVsdmV0aWNhO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgaWQ9InRleHQzNDAiPjx0c3BhbgogICAgICAgICAgICAgeD0iMCAzLjMyOTk5OTkgOC44OTAwMDAzIDE0LjQ1IDE3Ljc4MDAwMSAyNC40NTAwMDEgMjcuMjMgMzQuNDUwMDAxIDQxLjY2OTk5OCA0OC4zNCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICAgICAgaWQ9InRzcGFuMzQyIj4oNTQpUElOTkVEPC90c3Bhbj48L3RleHQ+CjwvZz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsLTQwOTIuMjggMTcuMDYzLDYyMC4wNCA1MS45OTIsMTI0MC4wOCBMIDkyNC4wNjMsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzNDQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLC00MDkyLjI4IDE3LjA2Myw2MjAuMDQgNTEuOTkyLDEyNDAuMDggTCA5MjQuMDYzLDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzNDYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNC4wNjMsLTExMTYuMDggTCA5ODkuMDU1LDQ4NzcuODQgOTM3LjA2MywzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDMwLjg3MSw2MjAuMDQgMzguMTg0LDEyNDAuMDggTCA5MjQuMDYzLDU5OTMuOTIgOTIwLDcxMTAiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMzMzMzMzM7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMzQ4IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDQuMDYzLC0xMTE2LjA4IEwgOTg5LjA1NSw0ODc3Ljg0IDkzNy4wNjMsMzYzNy43NiA5MjAsMzAxNy43MiBsIDAsMCAzMC44NzEsNjIwLjA0IDM4LjE4NCwxMjQwLjA4IEwgOTI0LjA2Myw1OTkzLjkyIDkyMCw3MTEwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMzUwIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDQuMDYzLC0xMTE2LjA4IEwgOTg5LjA1NSw0ODc3Ljg0IDk1MC44NzEsMzYzNy43NiA5MjAsMzAxNy43MiBsIDAsMCA0NS40OTYsNjIwLjA0IDIzLjU1OSwxMjQwLjA4IEwgOTI0LjA2Myw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojOTk5OTk5O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDM1MiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA0LjA2MywtMTExNi4wOCBMIDk4OS4wNTUsNDg3Ny44NCA5NTAuODcxLDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgNDUuNDk2LDYyMC4wNCAyMy41NTksMTI0MC4wOCBMIDkyNC4wNjMsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDM1NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA0LjA2MywtMTExNi4wOCBMIDk4OS4wNTUsNDg3Ny44NCA5NjUuNDk2LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgNDUuNDk2LDYyMC4wNCBMIDEwMDUuMyw0ODc3Ljg0IDkyNS42ODgsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzNTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNC4wNjMsLTExMTYuMDggTCA5ODkuMDU1LDQ4NzcuODQgOTY1LjQ5NiwzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDQ1LjQ5Niw2MjAuMDQgTCAxMDA1LjMsNDg3Ny44NCA5MjUuNjg4LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzNTgiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNS42ODgsLTExMTYuMDggTCAxMDA1LjMsNDg3Ny44NCA5NjUuNDk2LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgNjAuMTE3LDYyMC4wNCAyNy42MjMsMTI0MC4wOCBMIDkyOC4xMjUsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzNjAiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNS42ODgsLTExMTYuMDggTCAxMDA1LjMsNDg3Ny44NCA5NjUuNDk2LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgNjAuMTE3LDYyMC4wNCAyNy42MjMsMTI0MC4wOCBMIDkyOC4xMjUsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDM2MiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA4LjEyNSwtMTExNi4wOCBMIDEwMDcuNzQsNDg3Ny44NCA5ODAuMTE3LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgNjAuMTE3LDYyMC4wNCA0Ny4xMjMsMTI0MC4wOCBMIDkyOC4xMjUsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzY2NjY2NjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzNjQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgOC4xMjUsLTExMTYuMDggTCAxMDA3Ljc0LDQ4NzcuODQgOTgwLjExNywzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDYwLjExNyw2MjAuMDQgNDcuMTIzLDEyNDAuMDggTCA5MjguMTI1LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzNjYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgOC4xMjUsLTExMTYuMDggTCAxMDI3LjI0LDQ4NzcuODQgOTgwLjExNywzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDY4LjI0Miw2MjAuMDQgNDcuMTE4LDEyNDAuMDggTCA5MzYuMjUsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzNjgiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgOC4xMjUsLTExMTYuMDggTCAxMDI3LjI0LDQ4NzcuODQgOTgwLjExNywzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDY4LjI0Miw2MjAuMDQgNDcuMTE4LDEyNDAuMDggTCA5MzYuMjUsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDM3MCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCAxNi4yNSwtMTExNi4wOCA5OS4xMSwtMTExNi4wOCBMIDk4OC4yNDIsMzYzNy43NiA5MjAsMzAxNy43MiBsIDAsMCA3Ni4zNjcsNjIwLjA0IDQ3LjEyMywxMjQwLjA4IEwgOTQ0LjM3MSw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojYjJiMmIyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDM3MiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCAxNi4yNSwtMTExNi4wOCA5OS4xMSwtMTExNi4wOCBMIDk4OC4yNDIsMzYzNy43NiA5MjAsMzAxNy43MiBsIDAsMCA3Ni4zNjcsNjIwLjA0IDQ3LjEyMywxMjQwLjA4IEwgOTQ0LjM3MSw1OTkzLjkyIDkyMCw3MTEwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMzc0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIEwgOTQ0LjM3MSw1OTkzLjkyIDEwNDMuNDksNDg3Ny44NCA5OTYuMzY3LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgODQuNDksNjIwLjA0IDQ3LjEyLDEyNDAuMDggTCA5NTIuNDk2LDU5OTMuOTIgOTIwLDcxMTAiCiAgICAgICAgIHN0eWxlPSJmaWxsOiM4MDgwODA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoMzc2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIEwgOTQ0LjM3MSw1OTkzLjkyIDEwNDMuNDksNDg3Ny44NCA5OTYuMzY3LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgODQuNDksNjIwLjA0IDQ3LjEyLDEyNDAuMDggTCA5NTIuNDk2LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzNzgiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgMzIuNDk2LC0xMTE2LjA4IDk5LjExNCwtMTExNi4wOCAtNDcuMTIsLTEyNDAuMDggLTg0LjQ5LC02MjAuMDQgMCwwIDg0LjQ5LDYyMC4wNCA2Ny40MywxMjQwLjA4IEwgOTY0LjY4NCw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojY2NjY2NjO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDM4MCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCAzMi40OTYsLTExMTYuMDggOTkuMTE0LC0xMTE2LjA4IC00Ny4xMiwtMTI0MC4wOCAtODQuNDksLTYyMC4wNCAwLDAgODQuNDksNjIwLjA0IDY3LjQzLDEyNDAuMDggTCA5NjQuNjg0LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzODIiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNDQuNjg0LC0xMTE2LjA4IDEwNy4yMzYsLTExMTYuMDggLTY3LjQzLC0xMjQwLjA4IC04NC40OSwtNjIwLjA0IDAsMCA5Ni42OCw2MjAuMDQgNjcuNDMsMTI0MC4wOCBMIDk3Ni44NzEsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzODQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNDQuNjg0LC0xMTE2LjA4IDEwNy4yMzYsLTExMTYuMDggLTY3LjQzLC0xMjQwLjA4IC04NC40OSwtNjIwLjA0IDAsMCA5Ni42OCw2MjAuMDQgNjcuNDMsMTI0MC4wOCBMIDk3Ni44NzEsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDM4NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA1Ni44NzEsLTExMTYuMDggMTA3LjIzOSwtMTExNi4wOCAtNjcuNDMsLTEyNDAuMDggLTk2LjY4LC02MjAuMDQgMCwwIDEwOC44Niw2MjAuMDQgNjcuNDQsMTI0MC4wOCBMIDk4OS4wNTUsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzMzMzMzMztmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzODgiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgNTYuODcxLC0xMTE2LjA4IDEwNy4yMzksLTExMTYuMDggLTY3LjQzLC0xMjQwLjA4IC05Ni42OCwtNjIwLjA0IDAsMCAxMDguODYsNjIwLjA0IDY3LjQ0LDEyNDAuMDggTCA5ODkuMDU1LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGgzOTAiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgTCA5ODkuMDU1LDU5OTMuOTIgMTA5Ni4zLDQ4NzcuODQgMTAyOC44NiwzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDEyMS44Niw2MjAuMDQgNjcuNDMsMTI0MC4wOCBMIDEwMDIuMDUsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6Izk5OTk5OTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGgzOTIiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgTCA5ODkuMDU1LDU5OTMuOTIgMTA5Ni4zLDQ4NzcuODQgMTAyOC44NiwzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDEyMS44Niw2MjAuMDQgNjcuNDMsMTI0MC4wOCBMIDEwMDIuMDUsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDM5NCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA4Mi4wNSwtMTExNi4wOCAxMDcuMjQsLTExMTYuMDggLTY3LjQzLC0xMjQwLjA4IC0xMjEuODYsLTYyMC4wNCAwLDAgMTYyLjQ4LDYyMC4wNCAzMC4wNiwxMjQwLjA4IEwgMTAwMi4wNSw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDM5NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCA4Mi4wNSwtMTExNi4wOCAxMDcuMjQsLTExMTYuMDggLTY3LjQzLC0xMjQwLjA4IC0xMjEuODYsLTYyMC4wNCAwLDAgMTYyLjQ4LDYyMC4wNCAzMC4wNiwxMjQwLjA4IEwgMTAwMi4wNSw1OTkzLjkyIDkyMCw3MTEwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoMzk4IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDgyLjA1LC0xMTE2LjA4IDExMC40OSwtMTExNi4wOCAtMzAuMDYsLTEyNDAuMDggLTE2Mi40OCwtNjIwLjA0IDAsMCAxOTEuNzMsNjIwLjA0IDI4LjQzLDEyNDAuMDggTCAxMDI5LjY4LDU5OTMuOTIgOTIwLDcxMTAiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoNDAwIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDgyLjA1LC0xMTE2LjA4IDExMC40OSwtMTExNi4wOCAtMzAuMDYsLTEyNDAuMDggLTE2Mi40OCwtNjIwLjA0IDAsMCAxOTEuNzMsNjIwLjA0IDI4LjQzLDEyNDAuMDggTCAxMDI5LjY4LDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGg0MDIiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgMTA5LjY4LC0xMTE2LjA4IDExMC40OCwtMTExNi4wOCAtMjguNDMsLTEyNDAuMDggLTE5MS43MywtNjIwLjA0IDAsMCAyMjMuNDEsNjIwLjA0IDI4LjQ0LDEyNDAuMDggTCAxMDYxLjM2LDU5OTMuOTIgOTIwLDcxMTAiCiAgICAgICAgIHN0eWxlPSJmaWxsOiM2NjY2NjY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgIGlkPSJwYXRoNDA0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDEwOS42OCwtMTExNi4wOCAxMTAuNDgsLTExMTYuMDggLTI4LjQzLC0xMjQwLjA4IC0xOTEuNzMsLTYyMC4wNCAwLDAgMjIzLjQxLDYyMC4wNCAyOC40NCwxMjQwLjA4IEwgMTA2MS4zNiw1OTkzLjkyIDkyMCw3MTEwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoNDA2IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjxwYXRoCiAgICAgICAgIGQ9Im0gOTIwLDcxMTAgMCwwIDE0MS4zNiwtMTExNi4wOCAxMTAuNDksLTExMTYuMDggLTI4LjQ0LC0xMjQwLjA4IC0yMjMuNDEsLTYyMC4wNCAwLDAgMjg4LjQxLDYyMC4wNCAyOC40MywxMjQwLjA4IEwgMTEyNi4zNiw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDQwOCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCAxNDEuMzYsLTExMTYuMDggMTEwLjQ5LC0xMTE2LjA4IC0yOC40NCwtMTI0MC4wOCAtMjIzLjQxLC02MjAuMDQgMCwwIDI4OC40MSw2MjAuMDQgMjguNDMsMTI0MC4wOCBMIDExMjYuMzYsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDQxMCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCAyMDYuMzYsLTExMTYuMDggMTEwLjQ4LC0xMTE2LjA4IC0yOC40MywtMTI0MC4wOCAtMjg4LjQxLC02MjAuMDQgMCwwIDM1Ny40Niw2MjAuMDQgMjguNDQsMTI0MC4wOCBMIDExOTUuNDEsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6I2IyYjJiMjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGg0MTIiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgMjA2LjM2LC0xMTE2LjA4IDExMC40OCwtMTExNi4wOCAtMjguNDMsLTEyNDAuMDggLTI4OC40MSwtNjIwLjA0IDAsMCAzNTcuNDYsNjIwLjA0IDI4LjQ0LDEyNDAuMDggTCAxMTk1LjQxLDU5OTMuOTIgOTIwLDcxMTAgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgaWQ9InBhdGg0MTQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgTCAxMTk1LjQxLDU5OTMuOTIgMTMwNS45LDQ4NzcuODQgMTI3Ny40NiwzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDQ2OC43Nyw2MjAuMDQgMjguNDMsMTI0MC4wOCBMIDEzMDYuNzEsNTk5My45MiA5MjAsNzExMCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgaWQ9InBhdGg0MTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+PHBhdGgKICAgICAgICAgZD0ibSA5MjAsNzExMCAwLDAgTCAxMTk1LjQxLDU5OTMuOTIgMTMwNS45LDQ4NzcuODQgMTI3Ny40NiwzNjM3Ljc2IDkyMCwzMDE3LjcyIGwgMCwwIDQ2OC43Nyw2MjAuMDQgMjguNDMsMTI0MC4wOCBMIDEzMDYuNzEsNTk5My45MiA5MjAsNzExMCBaIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDQxOCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCBMIDEzMDYuNzEsNTk5My45MiAxNDE3LjIsNDg3Ny44NCAxMzg4Ljc3LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgMzc5MS41Nyw2MjAuMDQgTCA0NzQwLDQ4NzcuODQgNDYyOS41MSw1OTkzLjkyIDkyMCw3MTEwIgogICAgICAgICBzdHlsZT0iZmlsbDojY2NjY2NjO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICBpZD0icGF0aDQyMCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz48cGF0aAogICAgICAgICBkPSJtIDkyMCw3MTEwIDAsMCBMIDEzMDYuNzEsNTk5My45MiAxNDE3LjIsNDg3Ny44NCAxMzg4Ljc3LDM2MzcuNzYgOTIwLDMwMTcuNzIgbCAwLDAgMzc5MS41Nyw2MjAuMDQgTCA0NzQwLDQ4NzcuODQgNDYyOS41MSw1OTkzLjkyIDkyMCw3MTEwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJwYXRoNDIyIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPjwvZz48L2c+PC9zdmc+"><p>Note that there might be a big difference between the OS reported memory usage of your program and the amount of live data as reported by heap profiling. The reasons for the difference are explained in <a class="reference internal" href="hints.html#hints-os-memory"><span class="std std-ref">Understanding how OS memory usage corresponds to live data</span></a>.</p> <section id="rts-options-for-heap-profiling"> <h3 id="rts-options-heap-prof">
<span class="section-number">8.5.1. </span>RTS options for heap profiling</h3> <p>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</p> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hT">
<code>-hT</code> </dt> <dd>
<p>Breaks down the graph by heap closure type. This does not require the profiling runtime.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hc">
<code>-hc</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Breaks down the graph by the cost-centre stack which produced the data.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hm">
<code>-hm</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Break down the live heap by the module containing the code which produced the data.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hd">
<code>-hd</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Breaks down the graph by closure description. For actual data, the description is just the constructor name, for other closures it is a compiler-generated string identifying the closure.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hy">
<code>-hy</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Breaks down the graph by type. For closures which have function type or unknown/polymorphic type, the string will represent an approximation to the actual type.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-he">
<code>-he</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.10.1</p> </dd> </dl> <p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Break down the graph by era.</p> <p>Each closure is tagged with the era in which it is created. Eras start at 1 and can be set in your program to domain specific values using functions from <code>GHC.Profiling.Eras</code> or incremented automatically by the <a class="reference internal" href="#rts-flag-automatic-era-increment"><code>--automatic-era-increment</code></a>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hr">
<code>-hr</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Break down the graph by retainer set. Retainer profiling is described in more detail below (<a class="reference internal" href="#retainer-prof"><span class="std std-ref">Retainer Profiling</span></a>).</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hb">
<code>-hb</code> </dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Break down the graph by biography. Biographical profiling is described in more detail below (<a class="reference internal" href="#biography-prof"><span class="std std-ref">Biographical Profiling</span></a>).</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-hi">
<code>-hi</code> </dt> <dd>
<p>Break down the graph by the address of the info table of a closure. For this to produce useful output the program must have been compiled with <a class="reference internal" href="debug-info.html#ghc-flag-finfo-table-map"><code>-finfo-table-map</code></a> but it does not require the profiling runtime.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-l</span>
</dt> <dd>
<p id="index-6">Emit profile samples to the <a class="reference internal" href="runtime_control.html#rts-eventlog"><span class="std std-ref">GHC event log</span></a>. This format is both more expressive than the old <code>.hp</code> format and can be correlated with other events over the program’s runtime. See <a class="reference internal" href="eventlog-formats.html#heap-profiler-events"><span class="std std-ref">Heap profiler event log output</span></a> for details on the produced event structure.</p> </dd>
</dl> <p>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</p> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hc</span><span class="sig-prename descclassname"> ⟨name⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures produced by cost-centre stacks with one of the specified cost centres at the top.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hC</span><span class="sig-prename descclassname"> ⟨name⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures produced by cost-centre stacks with one of the specified cost centres anywhere in the stack.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hm</span><span class="sig-prename descclassname"> ⟨module⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures produced by the specified modules.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hd</span><span class="sig-prename descclassname"> ⟨desc⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures with the specified description strings.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hy</span><span class="sig-prename descclassname"> ⟨type⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures with the specified types.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-he</span><span class="sig-prename descclassname"> ⟨era⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to the specified era.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hr</span><span class="sig-prename descclassname"> ⟨cc⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures with retainer sets containing cost-centre stacks with one of the specified cost centres at the top.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std"> <span class="sig-name descname">-hb</span><span class="sig-prename descclassname"> ⟨bio⟩</span>
</dt> <dd>
<p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a>. Restrict the profile to closures with one of the specified biographies, where ⟨bio⟩ is one of <code>lag</code>, <code>drag</code>, <code>void</code>, or <code>use</code>.</p> </dd>
</dl> <p>For example, the following options will generate a retainer profile restricted to <code>Branch</code> and <code>Leaf</code> constructors:</p> <pre data-language="none">prog +RTS -hr -hdBranch,Leaf
</pre> <p>There can only be one “break-down” option (eg. <a class="reference internal" href="#rts-flag-hr"><code>-hr</code></a> in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn’t currently support mixing the <a class="reference internal" href="#rts-flag-hr"><code>-hr</code></a> and <a class="reference internal" href="#rts-flag-hb"><code>-hb</code></a> options.</p> <p>There are three more options which relate to heap profiling:</p> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-i-secs">
<code>-i ⟨secs⟩</code> </dt> <dd>
<p>Set the profiling (sampling) interval to ⟨secs⟩ seconds (the default is 0.1 second). Fractions are allowed: for example <code>-i0.2</code> will get 5 samples per second. This only affects heap profiling; time profiles are always sampled with the frequency of the RTS clock. See <a class="reference internal" href="#prof-time-options"><span class="std std-ref">Time and allocation profiling</span></a> for changing that.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-no-automatic-heap-samples">
<code>--no-automatic-heap-samples</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.2.1</p> </dd> </dl> <p>Don’t start heap profiling from the start of program execution. If this option is enabled, it’s expected that the user will manually start heap profiling or request specific samples using functions from <code>GHC.Profiling</code>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-no-automatic-time-samples">
<code>--no-automatic-time-samples</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.10.1</p> </dd> </dl> <p>Don’t start time profiling from the start of program execution. If this option is enabled, it’s expected that the user will manually start time profiling or request specific samples using functions from <code>GHC.Profiling</code>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-automatic-era-increment">
<code>--automatic-era-increment</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.10.1</p> </dd> </dl> <p>Increment the era by 1 on each major garbage collection. This is used in conjunction with <a class="reference internal" href="#rts-flag-he"><code>-he</code></a>.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-null-eventlog-writer">
<code>--null-eventlog-writer</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.2.2</p> </dd> </dl> <p>Don’t output eventlog to file, only configure tracing events. Meant to be used with customized event log writer.</p> </dd>
</dl> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-L-num">
<code>-L ⟨num⟩</code> </dt> <dd>
<p>Sets the maximum length of a cost-centre stack name in a heap profile. Defaults to 25.</p> </dd>
</dl> </section> <section id="retainer-profiling"> <h3 id="retainer-prof">
<span class="section-number">8.5.2. </span>Retainer Profiling</h3> <p>Retainer profiling is designed to help answer questions like “why is this data being retained?”. We start by defining what we mean by a retainer:</p>  <p>A retainer is either the system stack, an unevaluated closure (thunk), or an explicitly mutable object.</p>  <p>In particular, constructors are <em>not</em> retainers.</p> <p>An object <code>B</code> retains object <code>A</code> if (i) <code>B</code> is a retainer object and (ii) object <code>A</code> can be reached by recursively following pointers starting from object <code>B</code>, but not meeting any other retainer objects on the way. Each live object is retained by one or more retainer objects, collectively called its retainer set, or its retainer set, or its retainers.</p> <p>When retainer profiling is requested by giving the program the <code>-hr</code> option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file <code>prog.prof</code>.</p> <p>Retainer profiling requires multiple passes over the live heap in order to discover the full retainer set for each object, which can be quite slow. So we set a limit on the maximum size of a retainer set, where all retainer sets larger than the maximum retainer set size are replaced by the special set <code>MANY</code>. The maximum set size defaults to 8 and can be altered with the <a class="reference internal" href="#rts-flag-R-size"><code>-R ⟨size⟩</code></a> RTS option:</p> <dl class="std rts-flag"> <dt class="sig sig-object std" id="rts-flag-R-size">
<code>-R ⟨size⟩</code> </dt> <dd>
<p>Restrict the number of elements in a retainer set to ⟨size⟩ (default 8).</p> </dd>
</dl> <section id="hints-for-using-retainer-profiling"> <h4>
<span class="section-number">8.5.2.1. </span>Hints for using retainer profiling</h4> <p>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using <code>seq</code> or strictness annotations on data constructor fields.</p> <p>Often a particular data structure is being retained by a chain of unevaluated closures, only the nearest of which will be reported by retainer profiling - for example <code>A</code> retains <code>B</code>, <code>B</code> retains <code>C</code>, and <code>C</code> retains a large structure. There might be a large number of <code>B</code>s but only a single <code>A</code>, so <code>A</code> is really the one we’re interested in eliminating. However, retainer profiling will in this case report <code>B</code> as the retainer of the large structure. To move further up the chain of retainers, we can ask for another retainer profile but this time restrict the profile to <code>B</code> objects, so we get a profile of the retainers of <code>B</code>:</p> <pre data-language="none">prog +RTS -hr -hcB
</pre> <p>This trick isn’t foolproof, because there might be other <code>B</code> closures in the heap which aren’t the retainers we are interested in, but we’ve found this to be a useful technique in most cases.</p> </section> </section> <section id="precise-retainer-analysis"> <h3>
<span class="section-number">8.5.3. </span>Precise Retainer Analysis</h3> <p>If you want to precisely answer questions about why a certain type of closure is retained then it is worthwhile using <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc-debug">ghc-debug</a> which has a terminal interface which can be used to easily answer queries such as, what is retaining a certain closure.</p> </section> <section id="biographical-profiling"> <h3 id="biography-prof">
<span class="section-number">8.5.4. </span>Biographical Profiling</h3> <p>A typical heap object may be in one of the following four states at each point in its lifetime:</p> <ul class="simple"> <li>The lag stage, which is the time between creation and the first use of the object,</li> <li>the use stage, which lasts from the first use until the last use of the object, and</li> <li>The drag stage, which lasts from the final use until the last reference to the object is dropped.</li> <li>An object which is never used is said to be in the void state for its whole lifetime.</li> </ul> <p>A biographical heap profile displays the portion of the live heap in each of the four states listed above. Usually the most interesting states are the void and drag states: live heap in these states is more likely to be wasted space than heap in the lag or use states.</p> <p>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</p> <pre data-language="none">prog +RTS -hc -hbdrag,void
</pre> <p>Once you know the producer or the type of the heap in the drag or void states, the next step is usually to find the retainer(s):</p> <pre data-language="none">prog +RTS -hr -hccc...
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</p> </div> </section> <section id="actual-memory-residency"> <h3 id="mem-residency">
<span class="section-number">8.5.5. </span>Actual memory residency</h3> <p>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. <code>ps</code> or <code>top</code> on Unix, or the Task Manager on Windows). There are several reasons for this:</p> <ul class="simple"> <li>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</li> <li>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require <span class="math notranslate nohighlight">\(3L\)</span> bytes of memory, where <span class="math notranslate nohighlight">\(L\)</span> is the amount of live data. This is because by default (see the RTS <a class="reference internal" href="runtime_control.html#rts-flag-F-factor"><code>-F ⟨factor⟩</code></a> option) we allow the old generation to grow to twice its size (<span class="math notranslate nohighlight">\(2L\)</span>) before collecting it, and we require additionally <span class="math notranslate nohighlight">\(L\)</span> bytes to copy the live data into. When using compacting collection (see the <a class="reference internal" href="runtime_control.html#rts-flag-c"><code>-c</code></a> option), this is reduced to <span class="math notranslate nohighlight">\(2L\)</span>, and can further be reduced by tweaking the <a class="reference internal" href="runtime_control.html#rts-flag-F-factor"><code>-F
⟨factor⟩</code></a> option. Also add the size of the allocation area (see <a class="reference internal" href="runtime_control.html#rts-flag-A-size"><code>-A
⟨size⟩</code></a>).</li> <li>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and <code>mmap()</code>'d memory are not counted in the heap profile.</li> </ul> <p>For more discussion about understanding how understanding process residency see <a class="reference internal" href="hints.html#hints-os-memory"><span class="std std-ref">Understanding how OS memory usage corresponds to live data</span></a>.</p> </section> </section> <section id="hp2ps-rendering-heap-profiles-to-postscript"> <h2 id="hp2ps">
<span class="section-number">8.6. </span><code>hp2ps</code> – Rendering heap profiles to PostScript</h2> <p id="index-7">Usage:</p> <pre data-language="none">hp2ps [flags] [&lt;file&gt;[.hp]]
</pre> <p>The program <strong class="command">hp2ps</strong> program converts a <code>.hp</code> file produced by the <code>-h&lt;break-down&gt;</code> runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by <strong class="command">hp2ps</strong> has a <code>.hp</code> extension. The PostScript output is written to <code><em>file</em>@.ps</code>. If <code>&lt;file&gt;</code> is omitted entirely, then the program behaves as a filter.</p> <p><strong class="command">hp2ps</strong> is distributed in <code>ghc/utils/hp2ps</code> in a GHC source distribution. It was originally developed by Dave Wakeling as part of the HBC/LML heap profiler.</p> <p>The flags are:</p> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-d">
<code>-d</code> </dt> <dd>
<p>In order to make graphs more readable, <code>hp2ps</code> sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The <code>-d</code> option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-b">
<code>-b</code> </dt> <dd>
<p>Normally, <code>hp2ps</code> puts the title of the graph in a small box at the top of the page. However, if the JOB string is too long to fit in a small box (more than 35 characters), then <code>hp2ps</code> will choose to use a big box instead. The <code>-b</code> option forces <code>hp2ps</code> to use a big box.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-efloat-in-mm-pt">
<code>-e⟨float⟩[in|mm|pt]</code> </dt> <dd>
<p>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and <code>hp2ps</code> arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The <code>-e</code> option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki’s dvi-to-PostScript converter <code>dvips</code>.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-g">
<code>-g</code> </dt> <dd>
<p>Create output suitable for the <code>gs</code> PostScript previewer (or similar). In this case the graph is printed in portrait mode without scaling. The output is unsuitable for a laser printer.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-l">
<code>-l</code> </dt> <dd>
<p>Normally a profile is limited to 20 bands with additional identifiers being grouped into an <code>OTHER</code> band. The <code>-l</code> flag removes this 20 band and limit, producing as many bands as necessary. No key is produced as it won’t fit!. It is useful for creation time profiles with many bands.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-mint">
<code>-m⟨int⟩</code> </dt> <dd>
<p>Normally a profile is limited to 20 bands with additional identifiers being grouped into an <code>OTHER</code> band. The <code>-m</code> flag specifies an alternative band limit (the maximum is 20).</p> <p><code>-m0</code> requests the band limit to be removed. As many bands as necessary are produced. However no key is produced as it won’t fit! It is useful for displaying creation time profiles with many bands.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-p">
<code>-p</code> </dt> <dd>
<p>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The <code>-p</code> flag causes the graph to be drawn using the parameters determined by a previous run of <code>hp2ps</code> on <code>file</code>. These are extracted from <code>file@.aux</code>.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-s">
<code>-s</code> </dt> <dd>
<p>Use a small box for the title.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-tfloat">
<code>-t⟨float⟩</code> </dt> <dd>
<p>Normally trace elements which sum to a total of less than 1% of the profile are removed from the profile. The <code>-t</code> option allows this percentage to be modified (maximum 5%).</p> <p><code>-t0</code> requests no trace elements to be removed from the profile, ensuring that all the data will be displayed.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-c">
<code>-c</code> </dt> <dd>
<p>Generate colour output.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-y">
<code>-y</code> </dt> <dd>
<p>Ignore marks.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-hp2ps-0">
<code>-?</code> </dt> <dd>
<p>Print out usage information.</p> </dd>
</dl> </section> <section id="profiling-parallel-and-concurrent-programs"> <h2 id="prof-threaded">
<span class="section-number">8.7. </span>Profiling Parallel and Concurrent Programs</h2> <p>Combining <a class="reference internal" href="phases.html#ghc-flag--single-threaded"><code>-threaded</code></a> and <a class="reference internal" href="#ghc-flag-prof"><code>-prof</code></a> is perfectly fine, and indeed it is possible to profile a program running on multiple processors with the RTS <a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code>-N ⟨x⟩</code></a> option. <a class="footnote-reference brackets" href="#id7" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p> <p>Some caveats apply, however. In the current implementation, a profiled program is likely to scale much less well than the unprofiled program, because the profiling implementation uses some shared data structures which require locking in the runtime system. Furthermore, the memory allocation statistics collected by the profiled program are stored in shared memory but <em>not</em> locked (for speed), which means that these figures might be inaccurate for parallel programs.</p> <p>We strongly recommend that you use <a class="reference internal" href="#ghc-flag-fno-prof-count-entries"><code>-fno-prof-count-entries</code></a> when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</p> <p>We also recommend using <a class="reference external" href="https://www.haskell.org/haskellwiki/ThreadScope">ThreadScope</a> for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</p> </section> <section id="observing-code-coverage"> <h2 id="hpc">
<span class="section-number">8.8. </span>Observing Code Coverage</h2> <p id="index-8">Code coverage tools allow a programmer to determine what parts of their code have been actually executed, and which parts have never actually been invoked. GHC has an option for generating instrumented code that records code coverage as part of the Haskell Program Coverage (HPC) toolkit, which is included with GHC. HPC tools can be used to render the generated code coverage information into human understandable format.</p> <p>Correctly instrumented code provides coverage information of two kinds: source coverage and boolean-control coverage. Source coverage is the extent to which every part of the program was used, measured at three different levels: declarations (both top-level and local), alternatives (among several equations or case branches) and expressions (at every level). Boolean coverage is the extent to which each of the values True and False is obtained in every syntactic boolean context (ie. guard, condition, qualifier).</p> <p>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (<code>hpc report</code>) and sources with color mark-up (<code>hpc markup</code>). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</p> <section id="a-small-example-reciprocation"> <h3>
<span class="section-number">8.8.1. </span>A small example: Reciprocation</h3> <p>For an example we have a program, called <code>Recip.hs</code>, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</p> <pre data-language="haskell">reciprocal :: Int -&gt; (String, Int)
reciprocal n | n &gt; 1 = ('0' : '.' : digits, recur)
             | otherwise = error
              "attempting to compute reciprocal of number &lt;= 1"
  where
  (digits, recur) = divide n 1 []
divide :: Int -&gt; Int -&gt; [Int] -&gt; (String, Int)
divide n c cs | c `elem` cs = ([], position c cs)
              | r == 0      = (show q, 0)
              | r /= 0      = (show q ++ digits, recur)
  where
  (q, r) = (c*10) `quotRem` n
  (digits, recur) = divide n r (c:cs)

position :: Int -&gt; [Int] -&gt; Int
position n (x:xs) | n==x      = 1
                  | otherwise = 1 + position n xs

showRecip :: Int -&gt; String
showRecip n =
  "1/" ++ show n ++ " = " ++
  if r==0 then d else take p d ++ "(" ++ drop p d ++ ")"
  where
  p = length d - r
  (d, r) = reciprocal n

main = do
  number &lt;- readLn
  putStrLn (showRecip number)
  main
</pre> <p>HPC instrumentation is enabled with the <a class="reference internal" href="#ghc-flag-fhpc"><code>-fhpc</code></a> flag:</p> <pre data-language="sh">$ ghc -fhpc Recip.hs
</pre> <p>GHC creates a subdirectory <code>.hpc</code> in the current directory, and puts HPC index (<code>.mix</code>) files in there, one for each module compiled. You don’t need to worry about these files: they contain information needed by the <code>hpc</code> tool to generate the coverage data for compiled modules after the program is run.</p> <pre data-language="sh">$ ./Recip
1/3
= 0.(3)
</pre> <p>Running the program generates a file with the <code>.tix</code> suffix, in this case <code>Recip.tix</code>, which contains the coverage data for this run of the program. The program may be run multiple times (e.g. with different test data), and the coverage data from the separate runs is accumulated in the <code>.tix</code> file. This behaviour can be controlled with the <a class="reference internal" href="runtime_control.html#rts-flag-read-tix-file-yes-no"><code>--read-tix-file=&lt;yes|no&gt;</code></a> You can control where the <code>.tix</code> file is generated using the environment variable <a class="reference internal" href="#envvar-HPCTIXFILE" id="index-9"><code>HPCTIXFILE</code></a>.</p> <dl class="std envvar"> <dt class="sig sig-object std" id="envvar-HPCTIXFILE">
<code>HPCTIXFILE</code> </dt> <dd>
<p>Set the HPC <code>.tix</code> file output path.</p> </dd>
</dl> <p>Having run the program, we can generate a textual summary of coverage:</p> <pre data-language="none">$ hpc report Recip
 80% expressions used (81/101)
 12% boolean coverage (1/8)
      14% guards (1/7), 3 always True,
                        1 always False,
                        2 unevaluated
       0% 'if' conditions (0/1), 1 always False
     100% qualifiers (0/0)
 55% alternatives used (5/9)
100% local declarations used (9/9)
100% top-level declarations used (5/5)
</pre> <p>We can also generate a marked-up version of the source.</p> <pre data-language="none">$ hpc markup Recip
writing Recip.hs.html
</pre> <p>This generates one file per Haskell module, and 4 index files, <code>hpc_index.html</code>, <code>hpc_index_alt.html</code>, <code>hpc_index_exp.html</code>, <code>hpc_index_fun.html</code>.</p> </section> <section id="options-for-instrumenting-code-for-coverage"> <h3>
<span class="section-number">8.8.2. </span>Options for instrumenting code for coverage</h3> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fhpc">
<code>-fhpc</code> </dt> <dd>
<p>Enable code coverage for the current module or modules being compiled.</p> <p>Modules compiled with this option can be freely mixed with modules compiled without it; indeed, most libraries will typically be compiled without <a class="reference internal" href="#ghc-flag-fhpc"><code>-fhpc</code></a>. When the program is run, coverage data will only be generated for those modules that were compiled with <a class="reference internal" href="#ghc-flag-fhpc"><code>-fhpc</code></a>, and the <strong class="command">hpc</strong> tool will only show information about those modules.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-hpcdirdir">
<code>-hpcdir⟨dir⟩</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>.hpc</p> </dd> </dl> <p>Override the directory where GHC places the HPC index (<code>.mix</code>) files used by <code>hpc</code> to understand program structure.</p> </dd>
</dl> </section> <section id="the-hpc-toolkit"> <h3>
<span class="section-number">8.8.3. </span>The hpc toolkit</h3> <p>The hpc command has several sub-commands:</p> <pre data-language="none">$ hpc
Usage: hpc COMMAND ...

Commands:
  help        Display help for hpc or a single command
Reporting Coverage:
  report      Output textual report about program coverage
  markup      Markup Haskell source with program coverage
Processing Coverage files:
  sum         Sum multiple .tix files in a single .tix file
  combine     Combine two .tix files in a single .tix file
  map         Map a function over a single .tix file
Coverage Overlays:
  overlay     Generate a .tix file from an overlay file
  draft       Generate draft overlay that provides 100% coverage
Others:
  show        Show .tix file in readable, verbose format
  version     Display version for hpc
</pre> <p>In general, these options act on a <code>.tix</code> file after an instrumented binary has generated it.</p> <p>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the <code>.tix</code> file is in the same top-level directory. You can use the flag <code>--srcdir</code> to use <code>hpc</code> for any other directory, and use <code>--srcdir</code> multiple times to analyse programs compiled from difference locations, as is typical for packages.</p> <p>We now explain in more details the major modes of hpc.</p> <section id="hpc-report"> <h4>
<span class="section-number">8.8.3.1. </span>hpc report</h4> <p><code>hpc report</code> gives a textual report of coverage. By default, all modules and packages are considered in generating report, unless include or exclude are used. The report is a summary unless the <code>--per-module</code> flag is used. The <code>--xml-output</code> option allows for tools to use hpc to glean coverage.</p> <pre data-language="none">$ hpc help report
Usage: hpc report [OPTION] .. &lt;TIX_FILE&gt; [&lt;MODULE&gt; [&lt;MODULE&gt; ..]]

Options:

    --per-module                  show module level detail
    --decl-list                   show unused decls
    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir's
                                  [rarely used]
    --xml-output                  show output in XML
</pre> </section> <section id="hpc-markup"> <h4>
<span class="section-number">8.8.3.2. </span>hpc markup</h4> <p><code>hpc markup</code> marks up source files into colored html.</p> <pre data-language="none">$ hpc help markup
Usage: hpc markup [OPTION] .. &lt;TIX_FILE&gt; [&lt;MODULE&gt; [&lt;MODULE&gt; ..]]

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir's
                                  [rarely used]
    --fun-entry-count             show top-level function entry counts
    --highlight-covered           highlight covered code, rather that code gaps
    --destdir=DIR                 path to write output to
</pre> </section> <section id="hpc-sum"> <h4>
<span class="section-number">8.8.3.3. </span>hpc sum</h4> <p><code>hpc sum</code> adds together any number of <code>.tix</code> files into a single <code>.tix</code> file. <code>hpc sum</code> does not change the original <code>.tix</code> file; it generates a new <code>.tix</code> file.</p> <pre data-language="none">$ hpc help sum
Usage: hpc sum [OPTION] .. &lt;TIX_FILE&gt; [&lt;TIX_FILE&gt; [&lt;TIX_FILE&gt; ..]]
Sum multiple .tix files in a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --union                       use the union of the module namespace (default is intersection)
</pre> </section> <section id="hpc-combine"> <h4>
<span class="section-number">8.8.3.4. </span>hpc combine</h4> <p><code>hpc combine</code> is the swiss army knife of <code>hpc</code>. It can be used to take the difference between <code>.tix</code> files, to subtract one <code>.tix</code> file from another, or to add two <code>.tix</code> files. hpc combine does not change the original <code>.tix</code> file; it generates a new <code>.tix</code> file.</p> <pre data-language="none">$ hpc help combine
Usage: hpc combine [OPTION] .. &lt;TIX_FILE&gt; &lt;TIX_FILE&gt;
Combine two .tix files in a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --function=FUNCTION           combine .tix files with join function, default = ADD
                                  FUNCTION = ADD | DIFF | SUB
    --union                       use the union of the module namespace (default is intersection)
</pre> </section> <section id="hpc-map"> <h4>
<span class="section-number">8.8.3.5. </span>hpc map</h4> <p>hpc map inverts or zeros a <code>.tix</code> file. hpc map does not change the original <code>.tix</code> file; it generates a new <code>.tix</code> file.</p> <pre data-language="none">$ hpc help map
Usage: hpc map [OPTION] .. &lt;TIX_FILE&gt;
Map a function over a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --function=FUNCTION           apply function to .tix files, default = ID
                                  FUNCTION = ID | INV | ZERO
    --union                       use the union of the module namespace (default is intersection)
</pre> </section> <section id="hpc-overlay-and-hpc-draft"> <h4>
<span class="section-number">8.8.3.6. </span>hpc overlay and hpc draft</h4> <p>Overlays are an experimental feature of HPC, a textual description of coverage. hpc draft is used to generate a draft overlay from a .tix file, and hpc overlay generates a .tix files from an overlay.</p> <pre data-language="none">% hpc help overlay
Usage: hpc overlay [OPTION] .. &lt;OVERLAY_FILE&gt; [&lt;OVERLAY_FILE&gt; [...]]

Options:

    --srcdir=DIR   path to source directory of .hs files
                   multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir's
                                  [rarely used]
    --output=FILE  output FILE
% hpc help draft
Usage: hpc draft [OPTION] .. &lt;TIX_FILE&gt;

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir's
                                  [rarely used]
    --output=FILE                 output FILE
</pre> </section> </section> <section id="caveats-and-shortcomings-of-haskell-program-coverage"> <h3>
<span class="section-number">8.8.4. </span>Caveats and Shortcomings of Haskell Program Coverage</h3> <p>HPC does not attempt to lock the <code>.tix</code> file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the <code>.tix</code> file generated; at runtime, the name of the generated <code>.tix</code> file can be changed using <a class="reference internal" href="#envvar-HPCTIXFILE" id="index-10"><code>HPCTIXFILE</code></a>; the name of the <code>.tix</code> file will also change if you rename the binary. HPC does not work with GHCi.</p> </section> </section> <section id="using-ticky-ticky-profiling-for-implementors"> <h2 id="ticky-ticky">
<span class="section-number">8.9. </span>Using “ticky-ticky” profiling (for implementors)</h2> <dl class="std ghc-flag" id="index-11"> <dt class="sig sig-object std" id="ghc-flag-ticky">
<code>-ticky</code> </dt> <dd>
<p>Enable ticky-ticky profiling. By default this only tracks the allocations <em>by</em> each closure type. See <a class="reference internal" href="#ghc-flag-ticky-allocd"><code>-ticky-allocd</code></a> to keep track of allocations <em>of</em> each closure type as well.</p> </dd>
</dl> <p>GHC’s ticky-ticky profiler provides a low-level facility for tracking entry and allocation counts of particular individual closures. Ticky-ticky profiling requires a certain familiarity with GHC internals, so it is best suited for expert users, but can provide an invaluable precise insight into the allocation behaviour of your programs.</p> <p>Getting started with ticky profiling consists of three steps.</p> <ol class="arabic simple"> <li>Add the <code>-ticky</code> flag when compiling a Haskell module to enable “ticky-ticky” profiling of that module. This makes GHC emit performance-counting instructions in every STG function.</li> <li>Add <code>-ticky</code> to the command line when linking, so that you link against a version of the runtime system that allows you to display the results. In fact, in the link phase -ticky implies -debug, so you get the debug version of the runtime system too.</li> <li>Then when running your program you can collect the results of the profiling in two ways.</li> </ol>  <ul class="simple"> <li>Using the eventlog, the <a class="reference internal" href="runtime_control.html#rts-flag-l-flags"><code>-lT</code></a> flag will emit ticky samples to the eventlog periodically. This has the advantage of being able to resolve dynamic behaviors over the program’s lifetime. See <a class="reference internal" href="eventlog-formats.html#ticky-event-format"><span class="std std-ref">Ticky counters</span></a> for details on the event types reported. The ticky information can be rendered into an interactive table using eventlog2html.</li> <li>A legacy textual format is emitted using the <a class="reference internal" href="runtime_control.html#rts-flag-r-file"><code>-r ⟨file⟩</code></a> flag. This produces a textual table containing information about how much each counter ticked throughout the duration of the program.</li> </ul>  <section id="additional-ticky-flags"> <h3>
<span class="section-number">8.9.1. </span>Additional Ticky Flags</h3> <p>There are some additional flags which can be used to increase the number of ticky counters and the quality of the profile.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ticky-allocd">
<code>-ticky-allocd</code> </dt> <dd>
<p>Keep track of how much each closure type is allocated.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ticky-dyn-thunk">
<code>-ticky-dyn-thunk</code> </dt> <dd>
<p>Track allocations of dynamic thunks.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ticky-LNE">
<code>-ticky-LNE</code> </dt> <dd>
<p>These are not allocated, and can be very performance sensitive so we usually don’t want to run ticky counters for these to avoid even worse performance for tickied builds.</p> <p>But sometimes having information about these binders is critical. So we have a flag to ticky them anyway.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ticky-tag-checks">
<code>-ticky-tag-checks</code> </dt> <dd>
<p>These dummy counters contain:</p> <ul class="simple"> <li>The number of avoided tag checks in the entry count.</li> <li>“infer” as the argument string to distinguish them from regular counters.</li> <li>The name of the variable we are casing on, as well as a unique to represent the inspection site as one variable might be cased on multiple times. The unique comes first with the variable coming at the end. Like this: <code>u10_s98c (Main) at nofib/spectral/simple/Main.hs:677:1 in u10</code> where <code>u10</code> is the variable and <code>u10_s98c</code> the unique associated with the inspection site.</li> </ul> <p>Note that these counters are currently not processed well be eventlog2html. So if you want to check them you will have to use the text based interface.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ticky-ap-thunk">
<code>-ticky-ap-thunk</code> </dt> <dd>
<p>This allows us to get accurate entry counters for code like <code>f x y</code> at the cost of code size. We do this but not using the precomputed standard AP thunk code.</p> </dd>
</dl> <p>GHC’s ticky-ticky profiler provides a low-level facility for tracking entry and allocation counts of particular individual closures. Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling">overview of the profiling options</a>, which includes a link to the ticky-ticky profiling page.</p> <p>Note that ticky-ticky samples can be emitted in two formats: the eventlog, using the <a class="reference internal" href="runtime_control.html#rts-flag-l-flags"><code>-lT</code></a> event type, and a plain text summary format, using the <a class="reference internal" href="runtime_control.html#rts-flag-r-file"><code>-r ⟨file⟩</code></a> option. The former has the advantage of being able to resolve dynamic behaviors over the program’s lifetime. See <a class="reference internal" href="eventlog-formats.html#ticky-event-format"><span class="std std-ref">Ticky counters</span></a> for details on the event types reported.</p> </section> <section id="understanding-the-output-of-ticky-ticky-profiles"> <h3>
<span class="section-number">8.9.2. </span>Understanding the Output of Ticky-Ticky profiles</h3> <p>Once you have your rendered profile then you can begin to understand the allocation behaviour of your program. There are two classes of ticky-ticky counters.</p> <p>Name-specific counters</p>  <p>Each “name-specific counter” is associated with a name that is defined in the result of the optimiser. For each such name, there are three possible counters: entries, heap allocation by the named thing, and heap used to allocate that named thing.</p>  <p>Global counters</p>  <p>Each “global counter” describes some aspect of the entire program execution. For example, one global counter tracks total heap allocation; another tracks allocation for PAPs.</p>  <p>In general you are probably interested mostly in the name-specific counters as these can provided detailed information about where allocates how much in your program.</p> </section> <section id="information-about-name-specific-counters"> <h3>
<span class="section-number">8.9.3. </span>Information about name-specific counters</h3> <p>Name-specific counters provide the following information about a closure.</p> <ul class="simple"> <li>Entries - How many times the closure was entered.</li> <li>Allocs - How much (in bytes) is allocated <em>by</em> that closure.</li> <li>Allod - How often the closure is allocated.</li> <li>FVs - The free variables captured by that closure.</li> <li>Args - The arguments that closure takes.</li> </ul> <p>The FVs and Args information is encoded using a small DSL.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Classification</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><code>+</code></p></td> <td><p>dictionary</p></td> </tr> <tr>
<td><p><code>\&gt;</code></p></td> <td><p>function</p></td> </tr> <tr>
<td><p><code>{C,I,F,D,W}</code></p></td> <td><p>char, int, float, double, word</p></td> </tr> <tr>
<td><p><code>{c,i,f,d,w}</code></p></td> <td><p>unboxed ditto</p></td> </tr> <tr>
<td><p><code>T</code></p></td> <td><p>unboxed tuple</p></td> </tr> <tr>
<td><p><code>P</code></p></td> <td><p>other primitive type</p></td> </tr> <tr>
<td><p><code>p</code></p></td> <td><p>unboxed primitive type</p></td> </tr> <tr>
<td><p><code>L</code></p></td> <td><p>list</p></td> </tr> <tr>
<td><p><code>E</code></p></td> <td><p>enumeration type</p></td> </tr> <tr>
<td><p><code>S</code></p></td> <td><p>single-constructor type</p></td> </tr> <tr>
<td><p><code>M</code></p></td> <td><p>multi-constructor type</p></td> </tr> <tr>
<td><p><code>.</code></p></td> <td><p>other type</p></td> </tr> <tr>
<td><p><code>-</code></p></td> <td><p>reserved for others to mark as “uninteresting”</p></td> </tr>  </table> <p>In particular note that you can use the ticky profiler to see any function calls to dictionary arguments by searching the profile for the <code>+</code> classifier. This indicates that the function has failed to specialise for one reason or another.</p> </section> <section id="examples"> <h3>
<span class="section-number">8.9.4. </span>Examples</h3> <p>A typical use of ticky-ticky would be to generate a ticky report using the eventlog by evoking an application with RTS arguments like this:</p> <p><code>app &lt;args&gt; +RTS -l-augT</code></p> <p>This will produce an eventlog file which contains results from ticky counters. This file can be manually inspected like any regular eventlog. However for ticky-ticky eventlog2html has good support for producing tables from these logs.</p> <p>With an up to date version of eventlog2html this can be simply done by invoking eventlog2html on the produced eventlog. In the example above the invocation would then be <code>eventlog2html app.eventlog</code> Which will produce a searchable and sortable table containing all the ticky counters in the log.</p> </section> <section id="notes-about-ticky-profiling"> <h3>
<span class="section-number">8.9.5. </span>Notes about ticky profiling</h3> <ul class="simple"> <li>You can mix together modules compiled with and without <code>-ticky</code> but you will miss out on allocations and counts from uninstrumented modules in the profile.</li> <li>Linking with the <code>-ticky</code> has a quite severe performance impact on your program. <code>-ticky</code> implies using the unoptimised <code>-debug</code> RTS. Therefore <code>-ticky</code> shouldn’t be used for production builds.</li> <li>Building with <code>-ticky</code> doesn’t affect core optimisations of your program as the counters are inserted after the STG pipeline. At which point most optimizations have already been run.</li> <li>When using the eventlog it is possible to combine together ticky-ticky and IPE based profiling as each ticky counter definition has an associated info table. This address can be looked up in the IPE map so that further information (such as source location) can be determined about that closure.</li> <li>Global ticky counters are only available in the textual ticky output (<code>+RTS -r</code>). But this mode has some limitations (e.g. on column widths) and will contain raw json output in some columns. For this reason using an eventlog-based approach should be prefered if possible.</li> </ul> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id5" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span> <p><a class="reference internal" href="#rts-flag-hi"><code>-hi</code></a> profiling is avaible with the normal runtime but you will need to compile with <a class="reference internal" href="debug-info.html#ghc-flag-finfo-table-map"><code>-finfo-table-map</code></a> to interpret the results.</p> </aside> <aside class="footnote brackets" id="id6" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span> <p>Note that this policy has changed slightly in GHC 7.4.1 relative to earlier versions, and may yet change further, feedback is welcome.</p> </aside> <aside class="footnote brackets" id="id7" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span> <p>This feature was added in GHC 7.4.1.</p> </aside> </aside> </section> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/profiling.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/profiling.html</a>
  </p>
</div>
