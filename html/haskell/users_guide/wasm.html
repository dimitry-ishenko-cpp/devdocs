<h1 id="wasm">15. Using the GHC WebAssembly backend</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="using-the-ghc-webassembly-backend">  <section id="what-does-the-webassembly-backend-mean"> <h2 id="wasm-clarify">
<span class="section-number">15.1. </span>What does the WebAssembly “backend” mean</h2> <p>In order to compile Haskell to wasm, you need a custom GHC build that targets wasm. There isn’t a GHC option which allows you to use a stock GHC installed via <code>ghcup</code> or <code>stack</code> to generate wasm. That’s because GHC is still a single-target compiler, so each GHC build is only capable of compiling code that runs on a single architecture and operating system.</p> <p>So, the term GHC wasm backend isn’t the same sense as the unregisterised/LLVM/NCG backends. It merely describes GHC’s support as a cross compiler that targets wasm, and more specifically, <code>wasm32-wasi</code>.</p> <p>The generated wasm module makes use of a few post-MVP extensions that are supported by default in latest releases of Chrome/Firefox/Safari/<a class="reference external" href="https://wasmtime.dev">wasmtime</a>. The wasm module uses <a class="reference external" href="https://wasi.dev">WASI</a> as the system call layer, so it’s supported by any wasm engine that implements WASI (including browsers, which can provide the WASI layer via JavaScript).</p> </section> <section id="setting-up-the-ghc-wasm-backend"> <h2 id="wasm-setup">
<span class="section-number">15.2. </span>Setting up the GHC wasm backend</h2> <p>The wasm backend is still a tech preview and not included in the official bindists yet. If you are using x86_64-linux, you can follow the “getting started” subsections in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc-wasm-meta">ghc-wasm-meta</a> to quickly set up the GHC wasm backend using the nightly artifacts.</p> <p>It’s also possible to build the GHC wasm backend manually, if your host system is one of {x86_64,aarch64}-{linux,darwin}. Refer to the <code>ghc-wasm-meta</code> readme for detailed instructions.</p> </section> <section id="using-the-ghc-wasm-backend-to-compile-link-code"> <h2 id="wasm-compile">
<span class="section-number">15.3. </span>Using the GHC wasm backend to compile &amp; link code</h2> <p>Once the GHC wasm backend is set up, you can use it to compile and link code. The compiler executables follow the cross compiler linking convention, so you need to call <code>wasm32-wasi-ghc</code>, <code>wasm32-wasi-ghc-pkg</code> and <code>wasm32-wasi-hsc2hs</code> instead of <code>ghc</code>, <code>ghc-pkg</code> and <code>hsc2hs</code>.</p> <p>You can also use the <code>--with-compiler=</code>, <code>--with-hc-pkg=</code> and <code>--with-hsc2hs</code> flags of <code>cabal</code> to build cabal projects. The <code>wasm32-wasi-cabal</code> wrapper script set up by the <code>ghc-wasm-meta</code> installer does this automatically for you, but using flags manually also works with stock <code>cabal</code> installations. When <code>cabal</code> builds an executable component, that executable will be built as a wasm module, and you can use <code>cabal list-bin exe:foo</code> to find the wasm module’s location in the build directory.</p> </section> <section id="running-the-ghc-wasm-backends-output"> <h2 id="wasm-run">
<span class="section-number">15.4. </span>Running the GHC wasm backend’s output</h2> <p>Once you have a wasm module, you can run it with a dedicated wasm engine like <code>wasmtime</code>, or inside the browsers.</p> <p>To run it with <code>wasmtime</code>, you can simply do:</p> <pre data-language="sh">$ wasmtime run foo.wasm
</pre> <p>Just like native executables, you can pass command line arguments, and also RTS options, as long as it’s built with <code>-rtsopts</code>:</p> <pre data-language="sh">$ wasmtime run foo.wasm --bar +RTS --nonmoving-gc -RTS
</pre> <p>You can also mount some host directory into it:</p> <pre data-language="sh">$ wasmtime run --mapdir /::$PWD foo.wasm
</pre> <p>As long as the filesystem capability is provided, in addition to filesystem I/O in Haskell code, you can use the RTS eventlog and profiling functionality, then inspect the report files:</p> <pre data-language="sh">$ wasmtime run --mapdir /::$PWD foo.wasm +RTS -hc -l -RTS
</pre> </section> <section id="javascript-ffi-in-the-wasm-backend"> <h2 id="wasm-jsffi">
<span class="section-number">15.5. </span>JavaScript FFI in the wasm backend</h2> <p>The GHC wasm backend supports the JavaScript FFI feature. For Haskell projects that are meant to be run in JavaScript environments like browsers or nodejs, the JavaScript FFI enables:</p> <ul class="simple"> <li>Calling JavaScript from Haskell via foreign imports and vice versa via foreign exports.</li> <li>Representing JavaScript values as first-class garbage collected Haskell values on the Haskell heap.</li> <li>Blocking for asynchronous JavaScript computation in a single Haskell thread without blocking the entire runtime.</li> <li>Not paying for JavaScript when not using it, the same toolchain still generates self-contained <code>wasm32-wasi</code> modules by default.</li> </ul> <p>The JavaScript FFI as implemented in the GHC wasm backend is pioneered by the asterius project and heavily inspired by GHCJS, the predecessor of the GHC JavaScript backend. Despite some similarities, it still differs from the GHC JavaScript backend’s implementation significantly. The rest of this guide is a canonical reference for the GHC wasm backend’s JavaScript FFI, which we’ll now abbreviate as JSFFI.</p> <section id="marshalable-types-and-jsval"> <h3 id="wasm-jsffi-types">
<span class="section-number">15.5.1. </span>Marshalable types and <code>JSVal</code>
</h3> <p>JSFFI supports all boxed marshalable foreign types in C FFI:</p> <ul class="simple"> <li><code>Bool</code></li> <li><code>Char</code></li> <li>
<code>Int</code> / <code>Word</code>
</li> <li>
<code>Int8</code> / <code>Int16</code> / <code>Int32</code> / <code>Int64</code>
</li> <li>
<code>Word8</code> / <code>Word16</code> / <code>Word32</code> / <code>Word64</code>
</li> <li>
<code>Ptr</code> / <code>FunPtr</code> / <code>StablePtr</code>
</li> <li>
<code>Float</code> / <code>Double</code>
</li> </ul> <p>The above types and their <code>newtype</code>s can be used as argument/result types in JSFFI. Some caveats to keep in mind:</p> <ul class="simple"> <li>
<code>Bool</code> is marshaled to <code>0</code> / <code>1</code> instead of <code>false</code> / <code>true</code> in JavaScript. This is affected by implementation details of JSFFI, which is layered on top of C FFI and shares some characteristics of C FFI. It should be fine in most cases, since implicit conversion to <code>boolean</code> happens when it’s used as a boolean. It’s also fine to pass a JavaScript <code>boolean</code> into Haskell, since it’ll be implicitly converted to a number first.</li> <li>Likewise, <code>Char</code> is marshaled to 32-bit integer that represents its Unicode code point. Do not pass a single character JavaScript <code>string</code> as <code>Char</code>, since implicit conversion to number results in <code>NaN</code>! If you absolutely need to use <code>Char</code> as a JSFFI argument/result type, you’re in charge of handling <code>Char</code>s as code points. Most likely you only need to marshal between Haskell <code>String</code> or <code>Text</code> and JavaScript <code>string</code>s, for which there already exist conversion functions.</li> <li>64-bit integer types are marshaled to JavaScript <code>bigint</code>s. In JavaScript, mixing <code>bigint</code> and regular numbers in arithmetic results in type errors, so keep this in mind. As for <code>Int</code> / <code>Word</code>, they are 32-bit since the GHC wasm backend is based on <code>wasm32</code> .</li> <li>JSFFI doesn’t support unboxed foreign types like <code>Int#</code>, <code>ByteArray#</code>, etc, even when <code>UnliftedFFITypes</code> is enabled.</li> </ul> <p>In addition to the above types, JSFFI supports the <code>JSVal</code> type and its <code>newtype</code>s as argument/result types. <code>JSVal</code> is defined in <code>GHC.Wasm.Prim</code> in <code>ghc-experimental</code>, which represents an opaque reference to a JavaScript value.</p> <p><code>JSVal</code>s are first-class Haskell values on the Haskell heap. You can get them via foreign import results or foreign export arguments, store them in Haskell data structures and pass them between Haskell/JavaScript. They are garbage-collected by the GHC RTS:</p> <ul class="simple"> <li>There can be multiple <code>JSVal</code>s that point to the same JavaScript value. As long as there’s at least one <code>JSVal</code> still alive on the Haskell heap, that JavaScript value will still be alive on the JavaScript heap.</li> <li>If there’s no longer any live <code>JSVal</code> that points to the JavaScript value, then after Haskell garbage collection, the runtime no longer retain any reference to it, allowing the JavaScript runtime to eventually garbage collect it as well.</li> </ul> <p>In addition to garbage collection, <code>GHC.Wasm.Prim</code> also exports <code>freeJSVal :: JSVal -&gt; IO ()</code>, allowing the user to drop the JavaScript reference from the runtime eagerly. You’re encouraged to make use of <code>freeJSVal</code> when you’re sure about a <code>JSVal</code>’s lifetime, especially for the temporary <code>JSVal</code>s. This will help reducing the memory footprint at runtime.</p> <p>Note that <code>freeJSVal</code> is not idempotent and it’s only safe to call it exactly once or not at all. Once it’s called, any subsequent usage of that <code>JSVal</code> results in a runtime panic.</p> </section> <section id="foreign-imports"> <h3 id="wasm-jsffi-import">
<span class="section-number">15.5.2. </span>Foreign imports</h3> <p>One can embed a JavaScript code snippet in a foreign import declaration and call that piece of JavaScript code by calling the foreign import function:</p> <pre data-language="haskell">import GHC.Wasm.Prim

foreign import javascript unsafe "console.log($1)"
  js_print :: JSString -&gt; IO ()

foreign import javascript unsafe "typeof $1 === 'object'"
  js_is_obj :: JSVal -&gt; Bool

foreign import javascript unsafe "let acc = 1; for (let i = 1; i &lt;= $1; ++i) acc *= i; return acc;"
  js_fac :: Word -&gt; Word
</pre> <p>A JSFFI import code snippet can be either a single JavaScript expression or a series of JavaScript statements as function body, in which case you can use <code>return</code> to return the import result value. The import code snippet has access to:</p> <ul class="simple"> <li>The import argument values, bound to arguments <code>$1</code>, <code>$2</code>, etc.</li> <li>The <code>__export</code> binding, which contain all wasm module exports. For instance, you could use <code>__exports.memory</code> to access the <code>WebAssembly.Memory</code> object and use it to copy blobs between the Haskell/JavaScript side. The <code>memory</code> export exists by default.</li> <li>The full Web API that exists in the JavaScript global scope.</li> </ul> <p>There are two kinds of JSFFI imports: synchronous/asynchronous imports. <code>unsafe</code> indicates synchronous imports, which has the following caveats:</p> <ul class="simple"> <li>The calling thread as well as the entire runtime blocks on waiting for the import result.</li> <li>If the JavaScript code throws, the runtime crashes with the same error. A JavaScript exception cannot be handled as a Haskell exception here, so you need to use a JavaScript <code>catch</code> explicitly shall the need arise.</li> <li>Like <code>unsafe</code> C imports, re-entrance is not supported, the imported foreign code must not call into Haskell again. Doing so would result in a runtime panic.</li> </ul> <p>When a JSFFI import is marked as <code>safe</code> / <code>interruptible</code> or lacks safety annotation, then it’s treated as an asynchronous import. The asynchronous JSFFI imports combine the Haskell concurrency model and the JavaScript event loop, allowing Haskell code to work with async JavaScript computation without blocking the entire runtime.</p> <pre data-language="haskell">import Control.Exception

foreign import javascript safe "new Promise(res =&gt; setTimeout(res, $1))"
  js_sleep :: Int -&gt; IO ()

sleep :: Int -&gt; IO ()
sleep t = evaluate =&lt;&lt; js_sleep t

foreign import javascript safe "const r = await fetch($1); return r.text();"
  js_fetch :: JSString -&gt; IO JSString
</pre> <p>Asynchronous import code is wrapped in async JavaScript functions, therefore <code>await</code> is also supported. Async JavaScript functions always return <code>Promise</code>s, and you can also explicitly create and return a <code>Promise</code> that resolves to the final result of the async computation.</p> <p>When an asynchronous JSFFI import is called, the Haskell function returns immediately once the async JavaScript function returns a <code>Promise</code>. The value returned by the Haskell function is a thunk. When the thunk is evaluated later, the evaluating thread is suspended by the runtime, and resumed when the <code>Promise</code> actually resolves or rejects.</p> <p>Compared to synchronous JSFFI imports, asynchronous JSFFI imports have the following notable pros/cons:</p> <ul class="simple"> <li>Waiting for the result only blocks a single Haskell thread, other threads can still make progress and garbage collection may still happen.</li> <li>If the <code>Promise</code> rejects, Haskell code can catch JavaScript errors as <code>JSException</code>s.</li> <li>Re-entrance is supported. The JavaScript code may call into Haskell again and vice versa.</li> <li>Of course, it has higher overhead than synchronous JSFFI imports.</li> </ul> <p>Using thunks to encapsulate <code>Promise</code> result allows cheaper concurrency without even needing to fork Haskell threads just for waiting for a bunch of async calls to return. Just like lazy I/O, the convenience comes with caveat, you need to take some care to force the result thunk before closing the underlying resource. And even if the result type is <code>()</code>, it’s still a thunk that needs to be explicitly forced to ensure the <code>Promise</code> has actually resolved, so you likely need to write a worker/wrapper function pair for cases like <code>sleep</code>.</p> <p>There’s also a special kind of JSFFI import that allow converting a callable <code>JSVal</code> to a Haskell function:</p> <pre data-language="haskell">type Logger = JSString -&gt; IO ()

type JSFunction = JSVal

foreign import javascript unsafe "s =&gt; console.log(s)"
  js_logger :: JSFunction

foreign import javascript unsafe "dynamic"
  js_logger_to_hs :: JSFunction -&gt; Logger
</pre> <p>Much like <code>foreign import ccall "dynamic"</code> which wraps a C function pointer as a Haskell function, <code>foreign import javascript "dynamic"</code> wraps a <code>JSVal</code> that represent a JavaScript function as a Haskell function. The returned Haskell function retains the reference to that <code>JSVal</code>, and the <code>unsafe</code> / <code>safe</code> annotation indicates whether that JavaScript function is synchronous or asynchronous.</p> <p>Of course, without <code>foreign import javascript "dynamic"</code>, one could still easily implement similar functionality:</p> <pre data-language="haskell">foreign import javascript unsafe "$1($2)"
  js_logger_to_hs :: JSFunction -&gt; JSString -&gt; IO ()
</pre> <p>And that’s how it’s implemented under the hood. It’s handled as a JSFFI import with an auto-generated code snippet that calls the first argument, passing the rest of arguments.</p> </section> <section id="foreign-exports"> <h3 id="wasm-jsffi-export">
<span class="section-number">15.5.3. </span>Foreign exports</h3> <p>One can use <code>foreign export javascript</code> to export a top-level Haskell binding as a wasm module export which can be called in JavaScript:</p> <pre data-language="haskell">foreign export javascript "my_fib"
  fib :: Word -&gt; Word
</pre> <p>Give <code>fib :: Word -&gt; Word</code>, the above declaration exports <code>fib</code> as <code>my_fib</code>. It is a wasm module export function without any JavaScript wrapper, and as long as the wasm instance is properly initialized, you can call <code>await instance.exports.my_fib(10)</code> to invoke the exported Haskell function and get the result.</p> <p>Unlike JSFFI imports which have synchronous/asynchronous flavors, JSFFI exports are always asynchronous. Calling them always return a <code>Promise</code> in JavaScript that needs to be <code>await</code>ed for the real result. If the Haskell function throws, the <code>Promise</code> is rejected with a <code>WebAssembly.RuntimeError</code>, and the <code>message</code> field contains a JavaScript string of the Haskell exception.</p> <p>Above is the static flavor of JSFFI exports. It’s also possible to export a dynamically created Haskell function closure as a JavaScript function and obtain its <code>JSVal</code>:</p> <pre data-language="haskell">type BinOp a = a -&gt; a -&gt; a

foreign import javascript "wrapper"
  js_func_from_hs :: BinOp Int -&gt; IO JSVal
</pre> <p>This is also much like <code>foreign import ccall "wrapper"</code>, which wraps a Haskell function closure as a C function pointer. Note that <code>unsafe</code> / <code>safe</code> annotation is ignored here, since the <code>JSVal</code> that represent the exported function is always returned synchronously, but it is always an asynchronous JavaScript function, just like static JSFFI exports.</p> <p>The <code>JSVal</code> callbacks created by dynamic JSFFI exports can be passed to the rest of JavaScript world to be invoked later. But wait, didn’t we say earlier that <code>JSVal</code>s are garbage collected? Isn’t a use-after-free trap waiting ahead of the road, when the <code>JSVal</code> is collected in Haskell but the JavaScript callback is invoked later?</p> <p>So, normal <code>JSVal</code>s created by JSFFI import results or JSFFI export arguments only manage a single kind of resource: the JavaScript value it refers to. But <code>JSVal</code>s created by dynamic JSFFI exports manage two kinds of resources: the JavaScript callback it refers to, as well as a stable pointer that retains the Haskell function closure. If this <code>JSVal</code> is garbage collected, the Haskell runtime no longer retains the JavaScript callback, but the JavaScript side may still hold that callback and intends to call it later, so the Haskell function closure is still retained by default.</p> <p>Still, the runtime can gradually drop these retainers by using <code>FinalizerRegistry</code> to invoke the finalizers to free the underlying stable pointers once the JavaScript callbacks are recycled.</p> <p>One last corner case is cyclic reference between the two heaps: if a JavaScript callback is retained only by <code>JSVal</code> and that <code>JSVal</code> is retained only by a Haskell function closure that gets exported, this creates a cyclic reference that can’t be automatically recycled. This is a fundamental limit of the GHC wasm backend today since the Haskell heap lives in the linear memory, distinct from the host JavaScript heap, and coordination between two heaps is always a non-trivial challenge. However, one can still use <code>freeJSVal</code> to break the cycle. When <code>freeJSVal</code> is applied to a <code>JSVal</code> that represents a JavaScript callback created by a dynamic JSFFI export, both kinds of resources are freed at once: the JavaScript callback, as well as the Haskell function closure.</p> </section> <section id="detect-whether-jsffi-is-being-used"> <h3 id="wasm-jsffi-flag">
<span class="section-number">15.5.4. </span>Detect whether JSFFI is being used</h3> <p>If you’re writing a Haskell library, you may want to detect whether the final linked module involves JSFFI logic, or is it still a self-contained <code>wasm32-wasi</code> module. One obvious reason is <code>wasi</code> implementations in JavaScript environments are often incomplete and lack certain features (e.g. the <code>poll_oneoff</code> syscall), so it makes sense to dispatch code.</p> <p><code>GHC.Wasm.Prim</code> exports <code>isJSFFIUsed :: Bool</code> that can be used for this purpose. As long as there’s a single JSFFI import/export or anything involving <code>JSVal</code> linked into the final wasm module, it will be <code>True</code>. It is <code>False</code> if and only if the user code has absolutely no transitive dependency on anything related to JSFFI, in which case the linked wasm module will be a self-contained <code>wasm32-wasi</code> module. If something compiles fine with the GHC wasm backend before JSFFI feature is merged, but <code>isJSFFIUsed</code> is still <code>True</code>, then it’s definitely a bug.</p> </section> <section id="interaction-with-async-exception"> <h3 id="wasm-jsffi-async-exception">
<span class="section-number">15.5.5. </span>Interaction with async exception</h3> <p>When a thread is blocked waiting for an async JSFFI import call to return, it can be interrupted by a Haskell async exception, with some caveats:</p> <ul class="simple"> <li>The async exception would not magically cancel the <code>Promise</code>. In general, JavaScript <code>Promise</code>s aren’t cancelable anyway. There do exist third-party <code>Promise</code> libraries to provide a “cancel” interface, which only guarantees all <code>.then()</code> continuations registered on that <code>Promise</code> will no longer be invoked. For simplicity of implementation, we aren’t using those for the time being.</li> <li>Normally, <code>throwTo</code> would block until the async exception has been delivered. In the case of JSFFI, <code>throwTo</code> would always return successfully immediately, while the target thread is still left in a suspended state. The target thread will only be waken up when the <code>Promise</code> actually resolves or rejects, though the <code>Promise</code> result will be discarded at that point.</li> </ul> <p>The current way async exceptions are handled in JSFFI is subject to change though. Ideally, once the exception is delivered, the target thread can be waken up immediately and continue execution, and the pending <code>Promise</code> will drop reference to that thread and no longer invoke any continuations.</p> </section> <section id="interaction-with-c-ffi"> <h3 id="wasm-jsffi-cffi">
<span class="section-number">15.5.6. </span>Interaction with C FFI</h3> <p>User code can take advantage of JSFFI and C FFI together, and make use of third party C/C++ code as long as they work on <code>wasm32-wasi</code>. However, there is an important limitation to keep in mind when it comes to the interaction between JSFFI and C FFI:</p> <p>A Haskell thread cannot force an async JSFFI import thunk when it represents a Haskell function exported via C FFI. Doing so would throw <code>WouldBlockException</code>.</p> <p>For example, suppose we’re using the Haskell bindings of a certain C library, and some of the C functions expect callers to pass a C function pointer as the callback argument. Yes, we can use <code>foreign import ccall "wrapper"</code> to wrap a Haskell function closure and pass it to that C function. The wrapped Haskell function can even call sync JSFFI imports, but it cannot call an async JSFFI import and block on the result.</p> <p>The other direction is fine. Regardless of whether a C import is <code>unsafe</code> or <code>safe</code>, it can be called in a Haskell thread that represents a Haskell function exported to JavaScript. Do keep in mind that we’re using the single-threaded runtime at the moment, so other than supporting re-entrancy, <code>safe</code> C calls don’t offer extra advantage than <code>unsafe</code>.</p> <p>As mentioned before, JSFFI is layered on top of C FFI under the hood, and they share the same C symbol namespace. In most cases, the JSFFI related symbols are auto-generated so they can’t collide, but for each <code>foreign export javascript "my_func"</code>, there will be a <code>my_func</code> externally visible C symbol, so you need to take a bit of care not to duplicate symbol with the C side.</p> </section> <section id="the-javascript-api"> <h3 id="wasm-jsffi-jsapi">
<span class="section-number">15.5.7. </span>The JavaScript API</h3> <p>When linking a wasm module that makes use of JSFFI, correct link-time arguments must be passed to GHC and this needs to be adjusted on a per-project basis:</p> <pre data-language="haskell">ghc -no-hs-main -optl-mexec-model=reactor -optl-Wl,--export=my_func
</pre> <p>Why?</p> <p>Consider the case <code>ghc hello.hs</code> where <code>hello.hs</code> is just a good old <code>main = putStrLn "hello world"</code>. By default, ghc exports <code>main</code> as a C function, compiles and links a little C stub file that contain the actual <code>main</code> that initializes the runtime and call the Haskell <code>main</code>, and <code>clang</code> would link everything as a <code>wasm32-wasi</code> command module.</p> <p>Conceptually, a <code>wasm32-wasi</code> command module is like an executable, with a single entry point and meant to be invoked only once and then exits. But certain link-time arguments can tell <code>clang</code> to target a <code>wasm32-wasi</code> reactor module instead. A reactor module is a bit like a shared library: it has internal functions as well as user-defined entry points, and once it’s initialized, the entry points can be called as many times as the user wants.</p> <p>Given the nature of JSFFI, if a project uses JSFFI, then it surely is meant to target a <code>wasm32-wasi</code> reactor module. And there’s no sensible default entry point, not even <code>main</code>, you need to explicitly pass the export names you need via link-time arguments, otherwise those exports will be absent from the resulting wasm module due to linker dead code elimination.</p> <p>Now, suppose a wasm module has already been linked and it makes use of JSFFI. This wasm module will contain <code>ghc_wasm_jsffi</code> custom sections, and the section payloads include information like JSFFI import code snippets and function arities. The next step is calling a small post-linker script, which will parse the wasm module and emit a JavaScript module. The <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/utils/jsffi/post-link.mjs">post-linker</a> is written in nodejs, though the resulting JavaScript module has nothing nodejs specific and work in browsers as well.</p> <pre data-language="sh">$ $(wasm32-wasi-ghc --print-libdir)/post-link.mjs -i hello.wasm -o hello.js
</pre> <p>The generated JavaScript module contains a default export which is a function. The function takes an <code>__exports</code> argument and generates the <code>ghc_wasm_jsffi</code> wasm imports. There is knot-tying going on here: only after a wasm module is instantiated, you can access its exports, but the <code>ghc_wasm_jsffi</code> imports required for instantiation need access to the exports! JavaScript is not a lazy language, but we can achieve knot-tying less elegantly by using mutation:</p> <pre data-language="javascript">let __exports = {};

const { instance } = await WebAssembly.instantiateStreaming(
  fetch(wasm_url),
  {
    ghc_wasm_jsffi: (await import(js_url)).default(__exports),
    wasi_snapshot_preview1: ...
  }
);

Object.assign(__exports, wasm_instance.exports);
</pre> <p>This way, the <code>ghc_wasm_jsffi</code> imports will have access to all exports of the wasm instance.</p> <p>After the wasm instance is created, initialization needs to be done:</p> <pre data-language="javascript">wasi.initialize(wasm_instance);
</pre> <p>The <code>wasm32-wasi</code> reactor module ABI defines the <code>_initialize</code> export function, which is auto generated at link time and it must be called exactly once before any other wasm exports can be called. The correct way to call it depends on the wasi implementation provider in JavaScript.</p> <p>Finally, in JavaScript, you can use <code>await __exports.my_func()</code> to call your exported <code>my_func</code> function and get its result, pass arguments, do error handling, etc etc.</p> </section> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/wasm.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/wasm.html</a>
  </p>
</div>
