<h1>6.10.2. Equality constraints and Coercible constraint</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="equality-constraints-and-coercible-constraint">  <section id="equality-constraints"> <h2 id="id1">
<span class="section-number">6.10.2.1. </span>Equality constraints</h2> <p>A type context can include equality constraints of the form <code>t1 ~ t2</code>, which denote that the types <code>t1</code> and <code>t2</code> need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</p> <pre data-language="haskell">sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) =&gt; c1 -&gt; c2 -&gt; c2
</pre> <p>where we require that the element type of <code>c1</code> and <code>c2</code> are the same. In general, the types <code>t1</code> and <code>t2</code> of an equality constraint may be arbitrary monotypes; i.e., they may not contain any quantifiers, independent of whether higher-rank types are otherwise enabled.</p> <p>Equality constraints can also appear in class and instance contexts. The former enable a simple translation of programs using functional dependencies into programs using family synonyms instead. The general idea is to rewrite a class declaration of the form</p> <pre data-language="haskell">class C a b | a -&gt; b
</pre> <p>to</p> <pre data-language="haskell">class (F a ~ b) =&gt; C a b where
  type F a
</pre> <p>That is, we represent every functional dependency (FD) <code>a1 .. an -&gt; b</code> by an FD type family <code>F a1 .. an</code> and a superclass context equality <code>F a1 .. an ~ b</code>, essentially giving a name to the functional dependency. In class instances, we define the type instances of FD families in accordance with the class head. Method signatures are not affected by that process.</p> </section> <section id="heterogeneous-equality"> <h2 id="index-0">
<span class="section-number">6.10.2.2. </span>Heterogeneous equality</h2> <p>GHC also supports <em>kind-heterogeneous</em> equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled <code>~~</code>. Here are the kinds of <code>~</code> and <code>~~</code> to better understand their difference:</p> <pre data-language="haskell">(~)  :: forall k. k -&gt; k -&gt; Constraint
(~~) :: forall k1 k2. k1 -&gt; k2 -&gt; Constraint
</pre> <p>Users will most likely want <code>~</code>, but <code>~~</code> is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that <code>(a :: k1) ~~ (b :: k2)</code> tells GHC both that <code>k1</code> and <code>k2</code> are the same and that <code>a</code> and <code>b</code> are the same.</p> <p>Because <code>~</code> is the more common equality relation, GHC prints out <code>~~</code> like <code>~</code> unless <a class="reference internal" href="../using.html#ghc-flag-fprint-equality-relations"><code>-fprint-equality-relations</code></a> is set.</p> </section> <section id="unlifted-heterogeneous-equality"> <h2>
<span class="section-number">6.10.2.3. </span>Unlifted heterogeneous equality</h2> <p>Internal to GHC is yet a third equality relation <code>(~#)</code>. It is heterogeneous (like <code>~~</code>) and is used only internally. It may appear in error messages and other output only when <a class="reference internal" href="../using.html#ghc-flag-fprint-equality-relations"><code>-fprint-equality-relations</code></a> is enabled.</p> </section> <section id="the-coercible-constraint"> <h2 id="coercible">
<span class="section-number">6.10.2.4. </span>The <code>Coercible</code> constraint</h2> <p>The constraint <code>Coercible t1 t2</code> is similar to <code>t1 ~ t2</code>, but denotes representational equality between <code>t1</code> and <code>t2</code> in the sense of Roles (<a class="reference internal" href="roles.html#roles"><span class="std std-ref">Roles</span></a>). It is exported by <a class="reference external" href="../../libraries/base-4.21.0.0-8e62/data-coerce.html">Data.Coerce</a>, which also contains the documentation. More details and discussion can be found in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf">“Safe Coercions”</a>.</p> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/equality_constraints.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/equality_constraints.html</a>
  </p>
</div>
