<h1 id="field-selectors-and-type-applications">6.5.3. Field selectors and TypeApplications</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="field-selectors-and-typeapplications">  <p>Field selectors can be used in conjunction with <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a>, as described in <a class="reference internal" href="type_applications.html#visible-type-application"><span class="std std-ref">Visible type application</span></a>. The type of a field selector is constructed by using the surrounding definition as context. This section provides a specification for how this construction works. We will explain it by considering three different forms of field selector, each of which is a minor variation of the same general theme.</p> <section id="field-selectors-for-haskell98-style-data-constructors"> <h2>
<span class="section-number">6.5.3.1. </span>Field selectors for Haskell98-style data constructors</h2> <p>Consider the following example:</p> <pre data-language="haskell">data T a b = MkT { unT :: forall e. Either e a }
</pre> <p>This data type uses a Haskell98-style declaration. The only part of this data type that is not Haskell98 code is <code>unT</code>, whose type uses higher-rank polymorphism (<a class="reference internal" href="rank_polymorphism.html#arbitrary-rank-polymorphism"><span class="std std-ref">Arbitrary-rank polymorphism</span></a>). To construct the type of the <code>unT</code> field selector, we will assemble the following:</p> <ol class="arabic simple"> <li>The type variables quantified by the data type head (<code>forall a b. &lt;...&gt;</code>).</li> <li>The return type of the data constructor (<code>&lt;...&gt; T a b -&gt; &lt;...&gt;</code>). By virtue of this being a Haskell98-style declaration, the order of type variables in the return type will always coincide with the order in which they are quantified.</li> <li>The type of the field (<code>&lt;...&gt; forall e. Either e a</code>).</li> </ol> <p>The final type of <code>unT</code> is therefore <code>forall a b. T a b -&gt; forall e. Either e a</code>. As a result, one way to use <code>unT</code> with <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a> is <code>unT @Int @Bool (MkT (Right 1)) @Char</code>.</p> </section> <section id="field-selectors-for-gadt-constructors"> <h2>
<span class="section-number">6.5.3.2. </span>Field selectors for GADT constructors</h2> <p>Field selectors for GADT constructors (<a class="reference internal" href="gadt_syntax.html#gadt-style"><span class="std std-ref">Declaring data types with explicit constructor signatures</span></a>) are slightly more involved. Consider the following example:</p> <pre data-language="haskell">data G a b where
  MkG :: forall x n a. (Eq a, Show n)
      =&gt; { unG1 :: forall e. Either e (a, x), unG2 :: n } -&gt; G a (Maybe x)
</pre> <p>The <code>MkG</code> GADT constructor has two records, <code>unG1</code> and <code>unG2</code>. However, only <code>unG1</code> can be used as a top-level field selector. <code>unG2</code> cannot because it is a “hidden” selector (see <a class="reference internal" href="existential_quantification.html#existential-records"><span class="std std-ref">Record Constructors</span></a>); its type mentions a free variable <code>n</code> that does not appear in the result type <code>G a (Maybe x)</code>. On the other hand, the only free type variables in the type of <code>unG1</code> are <code>a</code> and <code>x</code>, so <code>unG1</code> is fine to use as a top-level function.</p> <p>To construct the type of the <code>unG1</code> field selector, we will assemble the following:</p> <ol class="arabic"> <li>
<p>The subset of type variables quantified by the GADT constructor that are mentioned in the return type. Note that the order of these variables follows the same principles as in <a class="reference internal" href="type_applications.html#scopedsort"><span class="std std-ref">Ordering of specified variables</span></a>. If the constructor explicitly quantifies its type variables at the beginning of the type, then the field selector type will quantify them in the same order (modulo any variables that are dropped due to not being mentioned in the return type). If the constructor implicitly quantifies its type variables, then the field selector type will quantify them in the left-to-right order that they appear in the field itself.</p> <p>In this example, <code>MkG</code> explicitly quantifies <code>forall x n a.</code>, and of those type variables, <code>a</code> and <code>x</code> are mentioned in the return type. Therefore, the type of <code>unG1</code> starts as <code>forall x a. &lt;...&gt;</code>. If <code>MkG</code> had not used an explicit <code>forall</code>, then they would have instead been ordered as <code>forall a x. &lt;...&gt;</code>, since <code>a</code> appears to the left of <code>x</code> in the field type.</p> </li> <li>The GADT return type (<code>&lt;...&gt; G a (Maybe x) -&gt; ...</code>).</li> <li>The type of the field (<code>&lt;...&gt; -&gt; forall e. Either e (a, x)</code>).</li> </ol> <p>The final type of <code>unG1</code> is therefore <code>forall x a. G a (Maybe x) -&gt; forall e. Either e (a, x)</code>. As a result, one way to use <code>unG1</code> with <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a> is <code>unG1 @Int @Bool (MkG (Right (True, 42)) ()) @Char</code>.</p> </section> <section id="field-selectors-for-pattern-synonyms"> <h2>
<span class="section-number">6.5.3.3. </span>Field selectors for pattern synonyms</h2> <p>Certain record pattern synonyms (<a class="reference internal" href="pattern_synonyms.html#record-patsyn"><span class="std std-ref">Record Pattern Synonyms</span></a>) can give rise to top-level field selectors. Consider the following example:</p> <pre data-language="haskell">pattern P :: forall a. Read a
          =&gt; forall n. (Eq a, Show n)
          =&gt; (forall e. Either e (a, Bool)) -&gt; n -&gt; G a (Maybe Bool)
pattern P {unP1, unP2} = MkG unP1 unP2
</pre> <p>We can only make field selectors for pattern synonym records that do not mention any existential type variables whatsoever in their types, per <a class="reference internal" href="pattern_synonyms.html#record-patsyn"><span class="std std-ref">Record Pattern Synonyms</span></a>. (This is a stronger requirement than for GADT records, whose types can mention existential type variables provided that they are also mentioned in the return type.) We can see that <code>unP2</code> cannot be used as a top-level field selector since its type has a free type variable <code>n</code>, which is existential. <code>unP1</code> is fine, on the other hand, as its type only has one free variable, the universal type variable <code>a</code>.</p> <p>To construct the type of the <code>unP1</code> field selector, we will assemble the following:</p> <ol class="arabic simple"> <li>The universal type variables (<code>forall a. &lt;...&gt;</code>).</li> <li>The required constraints (<code>&lt;...&gt; Read a =&gt; &lt;...&gt;</code>).</li> <li>The pattern synonym return type (<code>&lt;...&gt; G a (Maybe Bool) -&gt; &lt;...&gt;</code>).</li> <li>The type of the field (<code>&lt;...&gt; -&gt; forall e. Either e (a, Bool)</code>).</li> </ol> <p>The final type of <code>unP1</code> is therefore <code>forall a. Read a =&gt; G a (Maybe Bool) -&gt; forall e. Either e (a, Bool)</code>. As a result, one way to use <code>unP1</code> with <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a> is <code>unP1 @Double (MkG (Right (4.5, True)) ()) @Char</code>.</p> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/field_selectors_and_type_applications.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/field_selectors_and_type_applications.html</a>
  </p>
</div>
