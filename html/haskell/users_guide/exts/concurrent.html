<h1 id="concurrent-and-parallel-haskell">6.15.1. Concurrent and Parallel Haskell</h1>
<div class="_sphinx"> <div itemprop="articleBody">    <h2 id="id1">6.15.1.1. Concurrent Haskell</h2> <p id="concurrent-haskell">Concurrent Haskell is the name given to GHC’s concurrency extension. It is enabled by default, so no special flags are required. The <a class="reference external" href="https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz">Concurrent Haskell paper</a> is still an excellent resource, as is <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/">Tackling the awkward squad</a>.</p> <p>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, <a class="reference external" href="../../libraries/base-4.17.0.0/control-concurrent.html">Control.Concurrent</a>. The functions exported by this library include:</p> <ul class="simple"> <li>Forking and killing threads.</li> <li>Sleeping.</li> <li>Synchronised mutable variables, called <code>MVars</code>
</li> <li>Support for bound threads; see the paper <a class="reference external" href="https://simonmar.github.io/bib/papers/conc-ffi.pdf">Extending the FFI with concurrency</a>.</li> </ul>   <h2 id="parallel-haskell">6.15.1.2. Parallel Haskell</h2> <p id="index-0">GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>, and run it with the RTS <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> option; see <a class="reference internal" href="../using-concurrent.html#using-smp"><span class="std std-ref">Using SMP parallelism</span></a>). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> RTS option.</p>   <h2 id="annotating-pure-code-for-parallelism">6.15.1.3. Annotating pure code for parallelism</h2> <p>Ordinary single-threaded Haskell programs will not benefit from enabling SMP parallelism alone: you must expose parallelism to the compiler. One way to do so is forking threads using Concurrent Haskell (<a class="reference internal" href="#concurrent-haskell"><span class="std std-ref">Concurrent Haskell</span></a>), but the simplest mechanism for extracting parallelism from pure code is to use the <code>par</code> combinator, which is closely related to (and often used with) <code>seq</code>. Both of these are available from the <a class="reference external" href="https://hackage.haskell.org/package/parallel">parallel library</a>:</p> <pre data-language="haskell">infixr 0 `par`
infixr 1 `pseq`

par  :: a -&gt; b -&gt; b
pseq :: a -&gt; b -&gt; b
</pre> <p>The expression <code>(x `par` y)</code> <em>sparks</em> the evaluation of <code>x</code> (to weak head normal form) and returns <code>y</code>. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</p> <p>For example, consider the following parallel version of our old nemesis, <code>nfib</code>:</p> <pre data-language="haskell">import Control.Parallel

nfib :: Int -&gt; Int
nfib n | n &lt;= 1 = 1
       | otherwise = par n1 (pseq n2 (n1 + n2))
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
</pre> <p>For values of <code>n</code> greater than 1, we use <code>par</code> to spark a thread to evaluate <code>nfib (n-1)</code>, and then we use <code>pseq</code> to force the parent thread to evaluate <code>nfib (n-2)</code> before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use <code>pseq</code> to ensure that the parent will evaluate <code>n2</code> <em>before</em> <code>n1</code> in the expression <code>(n1 + n2 + 1)</code>. It is not sufficient to reorder the expression as <code>(n2 + n1 + 1)</code>, because the compiler may not generate code to evaluate the addends from left to right.</p> <p>Note that we use <code>pseq</code> rather than <code>seq</code>. The two are almost equivalent, but differ in their runtime behaviour in a subtle way: <code>seq</code> can evaluate its arguments in either order, but <code>pseq</code> is required to evaluate its first argument before its second, which makes it more suitable for controlling the evaluation order in conjunction with <code>par</code>.</p> <p>When using <code>par</code>, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</p> <p>It is possible to glean a little information about how well <code>par</code> is working from the runtime statistics; see <a class="reference internal" href="../runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a>.</p> <p>More sophisticated combinators for expressing parallelism are available from the <code>Control.Parallel.Strategies</code> module in the <a class="reference external" href="https://hackage.haskell.org/package/parallel">parallel package</a>. This module builds functionality around <code>par</code>, expressing more elaborate patterns of parallel computation, such as parallel <code>map</code>.</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/concurrent.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/concurrent.html</a>
  </p>
</div>
