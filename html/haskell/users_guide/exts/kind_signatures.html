<h1 id="kinding">6.11.3. Explicitly-kinded quantification</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="explicitly-kinded-quantification"> <dt id="extension-KindSignatures">
<code>KindSignatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow explicit kind signatures on type variables.</p> </dd>
</dl> <p>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper “Restricted Data Types in Haskell” (Haskell Workshop 1999) John Hughes had to define the data type:</p> <pre data-language="haskell">data Set cxt a = Set [a]
               | Unused (cxt a -&gt; ())
</pre> <p>The only use for the <code>Unused</code> constructor was to force the correct kind for the type variable <code>cxt</code>.</p> <p>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>.</p> <p>This extension enables kind signatures in the following places:</p> <ul> <li>
<p class="first"><code>data</code> declarations:</p> <pre data-language="haskell">data Set (cxt :: Type -&gt; Type) a = Set [a]
</pre> </li> <li>
<p class="first"><code>type</code> declarations:</p> <pre data-language="haskell">type T (f :: Type -&gt; Type) = f Int
</pre> </li> <li>
<p class="first"><code>class</code> declarations:</p> <pre data-language="haskell">class (Eq a) =&gt; C (f :: Type -&gt; Type) a where ...
</pre> </li> <li>
<p class="first"><code>forall</code>’s in type signatures:</p> <pre data-language="haskell">f :: forall (cxt :: Type -&gt; Type). Set cxt Int
</pre> </li> </ul> <p>The parentheses are required.</p> <p>As part of the same extension, you can put kind annotations in types as well. Thus:</p> <pre data-language="haskell">f :: (Int :: Type) -&gt; Int
g :: forall a. a -&gt; (a :: Type)
</pre> <p>The syntax is</p> <pre data-language="none">atype ::= '(' ctype '::' kind ')
</pre> <p>The parentheses are required.</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/kind_signatures.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/kind_signatures.html</a>
  </p>
</div>
