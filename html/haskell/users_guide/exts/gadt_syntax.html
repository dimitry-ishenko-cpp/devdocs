<h1 id="gadt-style">6.4.7. Declaring data types with explicit constructor signatures</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="declaring-data-types-with-explicit-constructor-signatures">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-GADTSyntax">
<code>GADTSyntax</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Implied by<span class="colon">:</span>
</dt> <dd class="field-odd">
<p><a class="reference internal" href="gadt.html#extension-GADTs"><code>GADTs</code></a></p> </dd> <dt class="field-even">Since<span class="colon">:</span>
</dt> <dd class="field-even">
<p>7.2.1</p> </dd> <dt class="field-odd">Status<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>Included in <a class="reference internal" href="control.html#extension-GHC2024"><code>GHC2024</code></a>, <a class="reference internal" href="control.html#extension-GHC2021"><code>GHC2021</code></a></p> </dd> </dl> <p>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see <a class="reference internal" href="gadt.html#extension-GADTs"><code>GADTs</code></a>)</p> </dd>
</dl> <p>When the <code>GADTSyntax</code> extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</p> <pre data-language="haskell">data Maybe a where
    Nothing :: Maybe a
    Just    :: a -&gt; Maybe a

newtype Down a where
  Down :: a -&gt; Down a
</pre> <p>The form is called a “GADT-style declaration” because Generalised Algebraic Data Types, described in <a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>, can only be declared using this form.</p> <p>Notice that GADT-style syntax generalises existential types (<a class="reference internal" href="existential_quantification.html#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>). For example, these two declarations are equivalent:</p> <pre data-language="haskell">data Foo = forall a. MkFoo a (a -&gt; Bool)
data Foo' where { MKFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo' }
</pre> <p>Any datatype (or newtype) that can be declared in standard Haskell 98 syntax, can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</p> <pre data-language="haskell">data Set a where
  MkSet :: Eq a =&gt; [a] -&gt; Set a

makeSet :: Eq a =&gt; [a] -&gt; Set a
makeSet xs = MkSet (nub xs)

insert :: a -&gt; Set a -&gt; Set a
insert a (MkSet as) | a `elem` as = MkSet as
                    | otherwise   = MkSet (a:as)
</pre> <p>A use of <code>MkSet</code> as a constructor (e.g. in the definition of <code>makeSet</code>) gives rise to a <code>(Eq a)</code> constraint, as you would expect. The new feature is that pattern-matching on <code>MkSet</code> (as in the definition of <code>insert</code>) makes <em>available</em> an <code>(Eq a)</code> context. In implementation terms, the <code>MkSet</code> constructor has a hidden field that stores the <code>(Eq a)</code> dictionary that is passed to <code>MkSet</code>; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to <code>elem</code>, so that the type of <code>insert</code> itself has no <code>Eq</code> constraint.</p> <p>For example, one possible application is to reify dictionaries:</p> <pre data-language="haskell">data NumInst a where
  MkNumInst :: Num a =&gt; NumInst a

intInst :: NumInst Int
intInst = MkNumInst

plus :: NumInst a -&gt; a -&gt; a -&gt; a
plus MkNumInst p q = p + q
</pre> <p>Here, a value of type <code>NumInst a</code> is equivalent to an explicit <code>(Num a)</code> dictionary.</p> <p>All this applies to constructors declared using the syntax of <a class="reference internal" href="existential_quantification.html#existential-with-context"><span class="std std-ref">Existentials and type classes</span></a>. For example, the <code>NumInst</code> data type above could equivalently be declared like this:</p> <pre data-language="haskell">data NumInst a
   = Num a =&gt; MkNumInst (NumInst a)
</pre> <p>Notice that, unlike the situation when declaring an existential, there is no <code>forall</code>, because the <code>Num</code> constrains the data type’s universally quantified type variable <code>a</code>. A constructor may have both universal and existential type variables: for example, the following two declarations are equivalent:</p> <pre data-language="haskell">data T1 a
 = forall b. (Num a, Eq b) =&gt; MkT1 a b
data T2 a where
 MkT2 :: (Num a, Eq b) =&gt; a -&gt; b -&gt; T2 a
</pre> <p>All this behaviour contrasts with Haskell 98’s peculiar treatment of contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report). In Haskell 98 the definition</p> <pre data-language="haskell">data Eq a =&gt; Set' a = MkSet' [a]
</pre> <p>gives <code>MkSet'</code> the same type as <code>MkSet</code> above. But instead of <em>making available</em> an <code>(Eq a)</code> constraint, pattern-matching on <code>MkSet'</code> <em>requires</em> an <code>(Eq a)</code> constraint! GHC faithfully implements this behaviour, odd though it is. But for GADT-style declarations, GHC’s behaviour is much more useful, as well as much more intuitive.</p> <p>Note that the restrictions of <a class="reference internal" href="existential_quantification.html#existential-restrictions"><span class="std std-ref">Restrictions</span></a> are still in place; for example, a newtype declared with <code>GADTSyntax</code> cannot use existential quantification.</p> <section id="formal-syntax-for-gadts"> <h2 id="formal-gadt-syntax">
<span class="section-number">6.4.7.1. </span>Formal syntax for GADTs</h2> <p>To make more precise what is and what is not permitted inside of a GADT-style constructor, we provide a BNF-style grammar for GADT below. Note that this grammar is subject to change in the future.</p> <pre data-language="none">gadt_con ::= conids '::' opt_forall opt_ctxt gadt_body

conids ::= conid
        |  conid ',' conids

opt_forall ::= &lt;empty&gt;
            |  'forall' tv_bndrs '.'

tv_bndrs ::= &lt;empty&gt;
          |  tv_bndr tv_bndrs

tv_bndr ::= tyvar
         |  '(' tyvar '::' ctype ')'

opt_ctxt ::= &lt;empty&gt;
          |  btype '=&gt;'
          |  '(' ctxt ')' '=&gt;'

ctxt ::= ctype
      |  ctype ',' ctxt

gadt_body ::= prefix_gadt_body
           |  record_gadt_body

prefix_gadt_body ::= '(' prefix_gadt_body ')'
                  |  return_type
                  |  opt_unpack btype '-&gt;' prefix_gadt_body

record_gadt_body ::= '{' fieldtypes '}' '-&gt;' return_type

fieldtypes ::= &lt;empty&gt;
            |  fieldnames '::' opt_unpack ctype
            |  fieldnames '::' opt_unpack ctype ',' fieldtypes

fieldnames ::= fieldname
            |  fieldname ',' fieldnames

opt_unpack ::= opt_bang
            :  {-# UNPACK #-} opt_bang
            |  {-# NOUNPACK #-} opt_bang

opt_bang ::= &lt;empty&gt;
          |  '!'
          |  '~'
</pre> <p>Where:</p> <ul class="simple"> <li>
<code>btype</code> is a type that is not allowed to have an outermost <code>forall</code>/<code>=&gt;</code> unless it is surrounded by parentheses. For example, <code>forall a. a</code> and <code>Eq a =&gt; a</code> are not legal <code>btype</code>s, but <code>(forall a. a)</code> and <code>(Eq a =&gt; a)</code> are legal.</li> <li>
<code>ctype</code> is a <code>btype</code> that has no restrictions on an outermost <code>forall</code>/<code>=&gt;</code>, so <code>forall a. a</code> and <code>Eq a =&gt; a</code> are legal <code>ctype</code>s.</li> <li>
<code>return_type</code> is a type that is not allowed to have <code>forall</code>s, <code>=&gt;</code>s, or <code>-&gt;</code>s.</li> </ul> <p>This is a simplified grammar that does not fully delve into all of the implementation details of GHC’s parser (such as the placement of Haddock comments), but it is sufficient to attain an understanding of what is syntactically allowed. Some further various observations about this grammar:</p> <ul> <li>GADT constructor types are currently not permitted to have nested <code>forall</code>s or <code>=&gt;</code>s. (e.g., something like <code>MkT :: Int -&gt; forall a. a -&gt; T</code> would be rejected.) As a result, <code>gadt_sig</code> puts all of its quantification and constraints up front with <code>opt_forall</code> and <code>opt_context</code>. Note that higher-rank <code>forall</code>s and <code>=&gt;</code>s are only permitted if they do not appear directly to the right of a function arrow in a <code>prefix_gadt_body</code>. (e.g., something like <code>MkS :: Int -&gt; (forall a. a) -&gt; S</code> is allowed, since parentheses separate the <code>forall</code> from the <code>-&gt;</code>.)</li> <li>
<p>Furthermore, GADT constructors do not permit outermost parentheses that surround the <code>opt_forall</code> or <code>opt_ctxt</code>, if at least one of them are used. For example, <code>MkU :: (forall a. a -&gt; U)</code> would be rejected, since it would treat the <code>forall</code> as being nested.</p> <p>Note that it is acceptable to use parentheses in a <code>prefix_gadt_body</code>. For instance, <code>MkV1 :: forall a. (a) -&gt; (V1)</code> is acceptable, as is <code>MkV2 :: forall a. (a -&gt; V2)</code>.</p> </li> <li>The function arrows in a <code>prefix_gadt_body</code>, as well as the function arrow in a <code>record_gadt_body</code>, are required to be used infix. For example, <code>MkA :: (-&gt;) Int A</code> would be rejected.</li> <li>
<p>GHC uses the function arrows in a <code>prefix_gadt_body</code> and <code>prefix_gadt_body</code> to syntactically demarcate the function and result types. Note that GHC does not attempt to be clever about looking through type synonyms here. If you attempt to do this, for instance:</p> <pre data-language="haskell">type C = Int -&gt; B

data B where
  MkB :: C
</pre> <p>Then GHC will interpret the return type of <code>MkB</code> to be <code>C</code>, and since GHC requires that the return type must be headed by <code>B</code>, this will be rejected. On the other hand, it is acceptable to use type synonyms within the argument and result types themselves, so the following is permitted:</p> <pre data-language="haskell">type B1 = Int
type B2 = B

data B where
  MkB :: B1 -&gt; B2
</pre> </li> <li>GHC will accept any combination of <code>!</code>/<code>~</code> and <code>{-# UNPACK #-}</code>/<code>{-# NOUNPACK #-}</code>, although GHC will ignore some combinations. For example, GHC will produce a warning if you write <code>{-# UNPACK #-} ~Int</code> and proceed as if you had written <code>Int</code>.</li> </ul> </section> <section id="gadt-syntax-odds-and-ends"> <h2>
<span class="section-number">6.4.7.2. </span>GADT syntax odds and ends</h2> <p>The rest of this section gives further details about GADT-style data type declarations.</p> <ul> <li>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form <code>T a1 ... an</code>, where <code>a1 ... an</code> are distinct type variables, then the data type is <em>ordinary</em>; otherwise is a <em>generalised</em> data type (<a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>).</li> <li>
<p>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for <code>T1</code> and <code>T2</code>:</p> <pre data-language="haskell">data T a where
  T1,T2 :: a -&gt; T a
  T3 :: T a
</pre> </li> <li>
<p>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the “<code>data T a where</code>” header have no scope, and different constructors may have different universally-quantified type variables:</p> <pre data-language="haskell">data T a where        -- The 'a' has no scope
  T1,T2 :: b -&gt; T b   -- Means forall b. b -&gt; T b
  T3 :: T a           -- Means forall a. T a
</pre> </li> <li>
<p>A constructor signature may mention type class constraints, which can differ for different constructors. For example, this is fine:</p> <pre data-language="haskell">data T a where
  T1 :: Eq b =&gt; b -&gt; b -&gt; T b
  T2 :: (Show c, Ix c) =&gt; c -&gt; [c] -&gt; T c
</pre> <p>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</p> <pre data-language="haskell">f :: T a -&gt; String
f (T1 x y) | x==y      = "yes"
           | otherwise = "no"
f (T2 a b)             = show a
</pre> <p>Note that <code>f</code> is not overloaded; the <code>Eq</code> constraint arising from the use of <code>==</code> is discharged by the pattern match on <code>T1</code> and similarly the <code>Show</code> constraint arising from the use of <code>show</code>.</p> </li> <li>
<p>Unlike a Haskell-98-style data type declaration, the type variable(s) in the “<code>data Set a where</code>” header have no scope. Indeed, one can write a kind signature instead:</p> <pre data-language="haskell">data Set :: Type -&gt; Type where ...
</pre> <p>or even a mixture of the two:</p> <pre data-language="haskell">data Bar a :: (Type -&gt; Type) -&gt; Type where ...
</pre> <p>The type variables (if given) may be explicitly kinded, so we could also write the header for <code>Foo</code> like this:</p> <pre data-language="haskell">data Bar a (b :: Type -&gt; Type) where ...
</pre> </li> <li>
<p>You can use strictness annotations, in the obvious places in the constructor type:</p> <pre data-language="haskell">data Term a where
    Lit    :: !Int -&gt; Term Int
    If     :: Term Bool -&gt; !(Term a) -&gt; !(Term a) -&gt; Term a
    Pair   :: Term a -&gt; Term b -&gt; Term (a,b)
</pre> </li> <li>
<p>You can use a <code>deriving</code> clause on a GADT-style data type declaration. For example, these two declarations are equivalent</p> <pre data-language="haskell">data Maybe1 a where {
    Nothing1 :: Maybe1 a ;
    Just1    :: a -&gt; Maybe1 a
  } deriving( Eq, Ord )

data Maybe2 a = Nothing2 | Just2 a
     deriving( Eq, Ord )
</pre> </li> <li>
<p>The type signature may have quantified type variables that do not appear in the result type:</p> <pre data-language="haskell">data Foo where
   MkFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo
   Nil   :: Foo
</pre> <p>Here the type variable <code>a</code> does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called “existential”. Indeed, the above declaration declares precisely the same type as the <code>data Foo</code> in <a class="reference internal" href="existential_quantification.html#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>.</p> <p>The type may contain a class context too, of course:</p> <pre data-language="haskell">data Showable where
  MkShowable :: Show a =&gt; a -&gt; Showable
</pre> </li> <li>
<p>You can use record syntax on a GADT-style data type declaration:</p> <pre data-language="haskell">data Person where
    Adult :: { name :: String, children :: [Person] } -&gt; Person
    Child :: Show a =&gt; { name :: !String, funny :: a } -&gt; Person
</pre> <p>As usual, for every constructor that has a field <code>f</code>, the type of field <code>f</code> must be the same (modulo alpha conversion). The <code>Child</code> constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the “type” that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A “type” of this form can appear only in a constructor signature.)</p> </li> <li>Record updates are allowed with GADT-style declarations, only fields that have the following property: the type of the field mentions no existential type variables.</li> <li>
<p>As in the case of existentials declared using the Haskell-98-like record syntax (<a class="reference internal" href="existential_quantification.html#existential-records"><span class="std std-ref">Record Constructors</span></a>), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</p> <pre data-language="haskell">data Counter a where
    NewCounter :: { _this    :: self
                  , _inc     :: self -&gt; self
                  , _display :: self -&gt; IO ()
                  , tag      :: a
                  } -&gt; Counter a
</pre> <p>As before, only one selector function is generated here, that for <code>tag</code>. Nevertheless, you can still use all the field names in pattern matching and record construction.</p> </li> <li>
<p>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive <code>Show</code> for the type. (Data constructors declared infix are displayed infix by the derived <code>show</code>.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by <code>Show</code> iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</p> <pre data-language="haskell">infix 6 (:--:)
data T a where
  (:--:) :: Int -&gt; Bool -&gt; T Int
</pre> </li> </ul> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/gadt_syntax.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/gadt_syntax.html</a>
  </p>
</div>
