<h1>6.11.3. Named default declarations</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="named-default-declarations">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-NamedDefaults">
<code>NamedDefaults</code> </dt> 
</dl> <p>Haskell 2010 <a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4">language report</a> includes rarely used <code>default</code> declarations. Their primary purpose is to improve the ergonomics of numeric literals in simple programs:</p> <pre data-language="haskell">main = print (6 * 7)
</pre> <p>The type of the right-hand side of this equation is <code>(Num a, Show a) =&gt; IO
()</code>. There is nothing to tell the compiler which concrete type to instantiate for <code>a</code>. To resolve this ambiguity, the user can declare something like</p> <pre data-language="haskell">default (Integer, Int, Double)
</pre> <p>to specify that any ambiguous type variable (such as <code>a</code> in the above example) constrained to class <code>Num</code> should default to <code>Integer</code>. If that type doesn’t satisfy the remaining constraints required from the context (such as <code>Show a</code> above), the other specified types (e.g. <code>Int</code> and <code>Double</code>) are tried in turn.</p> <p>The language report applies the <code>default</code> declarations only to the ambiguities involving the <code>Num</code> class. The reason for this limitation is that the numeric literals are the only literals with ambiguous types in the language report. Since then, however, the <a class="reference internal" href="overloaded_strings.html#extension-OverloadedStrings"><code>OverloadedStrings</code></a> and <a class="reference internal" href="overloaded_lists.html#extension-OverloadedLists"><code>OverloadedLists</code></a> language extensions have made more syntactic constructs ambiguous. The former in particular is commonly used for more convenient coding of <code>Text</code> literals. Another potential source of ambiguity are the Prelude and the core libraries which are slowly evolving to be more generalized.</p> <section id="specifying-the-class"> <h2>
<span class="section-number">6.11.3.1. </span>Specifying the class</h2> <p>The Haskell 2010 language report specifies the following syntax for the default declaration:</p>  <p>where each type <em>qtycon</em><sub>i</sub> must be an instance of class <code>Num</code>.</p> <p>With the <a class="reference internal" href="#extension-NamedDefaults"><code>NamedDefaults</code></a> language extension, GHC generalizes these declarations so the user can specify the default types for any class rather than just <code>Num</code>:</p>  <p>where each type <em>qtycon</em><sub>i</sub> must be an instance of the specified class <em>qtycls</em>. The types may belong to any kind, but the class must have a single parameter. This declaration for example becomes legal:</p> <pre data-language="haskell">default Monoid ([Int])
</pre> <p>and in turn allows this program to compile:</p> <pre data-language="haskell">main = print mempty
</pre> <p>If no class is specified, the earlier default of <code>Num</code> is assumed. In other words, the Haskell ‘98 syntax of:</p> <pre data-language="haskell">default (Int, Float)
</pre> <p>would mean exactly the same as:</p> <pre data-language="haskell">default Num (Int, Float)
</pre> </section> <section id="exporting-the-defaults"> <h2>
<span class="section-number">6.11.3.2. </span>Exporting the defaults</h2> <p>A <code>default</code> declaration by itself applies only within the module it’s in. The <a class="reference internal" href="#extension-NamedDefaults"><code>NamedDefaults</code></a> extension also extends the syntax of module exports to permit a new form of export item:</p> <pre data-language="haskell">module MyModule (default Monoid)
</pre> <p>which exports the default that’s in effect in the module for the named class. This can mean either that it’s declared in the same module or that it’s imported from another module.</p> <p>When exporting a <code>default Num</code> declaration, the class <code>Num</code> has to be explicitly named like any other class.</p> <p>A module with no explicit export list (as in <code>module M where {...}</code>) exports all defaults declared in the module. Re-export of a whole imported module (as in <code>module M (module N) where{...}</code>) does <em>not</em> export any defaults.</p> <p>While default exports must be made explicit, their imports are automatic and implicit. To suppress or modify an imported default, a module can declare its own; a local <code>default</code> declaration will override all imported defaults for the same class.</p> </section> <section id="definition-of-subsumption"> <h2>
<span class="section-number">6.11.3.3. </span>Definition of subsumption</h2> <p>Given two <code>default</code> declarations for the same class</p>    <p>if <em>m</em> ≤ <em>n</em> and the first type sequence <em>Type</em><sub>1</sub><sup>a</sup> , … , <em>Type</em><sub>m</sub><sup>a</sup> is a sub-sequence of the second sequence <em>Type</em><sub>1</sub><sup>b</sup> , … , <em>Type</em><sub>n</sub><sup>b</sup> (<em>i.e.</em>, the former can be obtained by removing a number of <em>Type</em><sub>i</sub><sup>b</sup> items from the latter), we say that the second declaration <em>subsumes</em> the first one.</p> </section> <section id="rules-for-disambiguation-of-multiple-declarations"> <h2>
<span class="section-number">6.11.3.4. </span>Rules for disambiguation of multiple declarations</h2> <p>Only a single <code>default</code> declaration can be in effect in any single module for any particular class. If there is more than one <code>default</code> declaration in scope, the conflict is resolved using the following rules:</p> <ol class="arabic simple"> <li>Two declarations for two different classes are not considered to be in conflict; they can, however, clash at a particular use site as we’ll see in the following section.</li> <li>Two declarations for the same class explicitly declared in the same module are considered a static error.</li> <li>A <code>default</code> declaration in a module takes precedence over any imported <code>default</code> declarations for the same class. However the compiler may issue a warning (enabled by <a class="reference internal" href="../using-warnings.html#ghc-flag-Wtype-defaults"><code>-Wtype-defaults</code></a>) if an imported declaration is not subsumed by the local declaration.</li> <li>For any two imported <code>default</code> declarations for the same class where one subsumes the other, we ignore the subsumed declaration.</li> <li>If a class has neither a local <code>default</code> declaration nor an imported <code>default</code> declaration that subsumes all other imported <code>default</code> declarations for the class, the conflict between the imports is unresolvable. The effect is to ignore all <code>default</code> declarations for the class, so that no declaration is in effect in the module. The compiler may emit a warning in this case, if enabled by <a class="reference internal" href="../using-warnings.html#ghc-flag-Wtype-defaults"><code>-Wtype-defaults</code></a>, but no error would be triggered about the imports. Of course an error may be triggered in the body of the module if it contains an actual ambiguous type for the class with the conflicting imported defaults, as per the following subsection.</li> </ol> <p>As a result, in any module each class has either one default declaration in scope (a locally-declared one, or an imported one that subsumes all other imported ones), or none. This single default is used to resolve ambiguity, as described in the next subsection.</p> <p>Note that a <code>default</code> declaration that repeats a type name more than once is perfectly valid, and sometimes may be necessary to resolve coflicts. For example, a module that imports two conflicting defaults</p> <pre data-language="haskell">default C (Int, Bool)
</pre> <p>and</p> <pre data-language="haskell">default C (Bool, Int)
</pre> <p>may use a local declaration</p> <pre data-language="haskell">default C (Int, Bool, Int)
</pre> <p>to override the imports. Because this declaration subsumes both imported defaults it will not trigger any compiler warning. When used to resolve ambiguity (next section) it behaves exactly like <code>default C( Int, Bool)</code>; that is, the repeats can be discarded.</p> </section> <section id="rules-for-disambiguation-at-the-use-site"> <h2>
<span class="section-number">6.11.3.5. </span>Rules for disambiguation at the use site</h2> <p>The disambiguation rules are a conservative extension of the existing rules in Haskell 2010, which state that ambiguous type variable <em>v</em> is defaultable if:</p>  <ul class="simple"> <li>
<em>v</em> appears only in constraints of the form <em>C</em> <em>v</em>, where <em>C</em> is a class, and</li> <li>at least one of these classes is a numeric class, (that is, <code>Num</code> or a subclass of <code>Num</code>), and</li> <li>all of these classes are defined in the Prelude or a standard library.</li> </ul> <p>Each defaultable variable is replaced by the first type in the default list that is an instance of all the ambiguous variable’s classes. It is a static error if no such type is found.</p>  <p>The new rules instead require only that</p> <ul class="simple"> <li>
<em>v</em> appears in at least one constraint of the form <em>C</em> <em>v</em>, where <em>C</em> is a single-parameter class.</li> </ul> <p>Informally speaking, the type selected for defaulting is the first type from the <code>default</code> list for class <em>C</em> that satisfies all constraints on type variable <em>v</em>. If there are multiple <em>C</em><sub>i</sub> <em>v</em> constraints with competing <code>default</code> declarations, they have to resolve to the same type.</p> <p>To make the design more explicit, the following algorithm <em>can</em> be used for default resolution, but any other method that achieves the same effect can be substitued:</p> <p>Let <em>S</em> be the complete set of unsolved constraints, and initialize <em>S</em><sub>x</sub> to an empty set of constraints. For every <em>v</em> that is free in <em>S</em>:</p> <ol class="arabic simple"> <li>Define <em>C</em><sub>v</sub> = { <em>C</em><sub>i</sub> v | <em>C</em><sub>i</sub> v ∈ <em>S</em> }, the subset of <em>S</em> consisting of all constraints in <em>S</em> of form (<em>C</em><sub>i</sub> v), where <em>C</em><sub>i</sub> is a single-parameter type class.</li> <li>Define <em>D</em><sub>v</sub>, by extending <em>C</em><sub>v</sub> with the superclasses of every <em>C</em><sub>i</sub> in <em>C</em><sub>v</sub>
</li> <li>Define <em>E</em><sub>v</sub>, by filtering <em>D</em><sub>v</sub> to contain only classes with a default declaration.</li> <li>For each <em>C</em><sub>i</sub> in <em>E</em><sub>v</sub>, find the first type <em>T</em> in the default list for <em>C</em><sub>i</sub> for which, for every (<em>C</em><sub>i</sub> v) in <em>C</em><sub>v</sub>, the constraint (<em>C</em><sub>i</sub> <em>T</em>) is soluble.</li> <li>If there is precisely one type <em>T</em> in the resulting type set, resolve the ambiguity by adding a <code>v ~ T</code><sub>i</sub> constraint to a set <em>S</em><sub>x</sub>; otherwise report a static error.</li> </ol> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/named_defaults.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/named_defaults.html</a>
  </p>
</div>
