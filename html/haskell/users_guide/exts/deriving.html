<h1 id="deriving">6.6. Deriving mechanism</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="deriving-mechanism">  <p>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</p> <ul> <li>The derivation mechanism can be used separately from the data type declaration, using the <a class="reference internal" href="standalone_deriving.html#stand-alone-deriving"><span class="std std-ref">standalone deriving mechanism</span></a>.</li> <li>In Haskell 98, the only derivable classes are <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Ix</code>, <code>Bounded</code>, <code>Read</code>, and <code>Show</code>. <a class="reference internal" href="deriving_extra.html#deriving-extra"><span class="std std-ref">Various language extensions</span></a> extend this list.</li> <li>
<p>Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</p> <ul class="simple"> <li>
<a class="reference internal" href="newtype_deriving.html#newtype-deriving"><span class="std std-ref">Generalised newtype deriving</span></a> for newtypes and</li> <li>
<a class="reference internal" href="derive_any_class.html#derive-any-class"><span class="std std-ref">deriving any class</span></a> using an empty instance declaration.</li> </ul> <p>The user can optionally declare the desired <a class="reference internal" href="deriving_strategies.html#deriving-strategies"><span class="std std-ref">deriving strategy</span></a>, especially if the compiler chooses the wrong one <a class="reference internal" href="deriving_strategies.html#default-deriving-strategy"><span class="std std-ref">by default</span></a>.</p> </li> </ul>  <ul> <li class="toctree-l1"><a class="reference internal" href="empty_data_deriving.html">6.6.1. Deriving instances for empty data types</a></li> <li class="toctree-l1"><a class="reference internal" href="deriving_inferred.html">6.6.2. Inferred context for deriving clauses</a></li> <li class="toctree-l1"><a class="reference internal" href="standalone_deriving.html">6.6.3. Stand-alone deriving declarations</a></li> <li class="toctree-l1"><a class="reference internal" href="deriving_extra.html">6.6.4. Deriving instances of extra classes (<code>Data</code>, etc.)</a></li> <li class="toctree-l1"><a class="reference internal" href="newtype_deriving.html">6.6.5. Generalised derived instances for newtypes</a></li> <li class="toctree-l1"><a class="reference internal" href="derive_any_class.html">6.6.6. Deriving any other class</a></li> <li class="toctree-l1"><a class="reference internal" href="deriving_strategies.html">6.6.7. Deriving strategies</a></li> <li class="toctree-l1"><a class="reference internal" href="deriving_via.html">6.6.8. Deriving via</a></li> </ul>  </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/deriving.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/deriving.html</a>
  </p>
</div>
