<h1 id="id1">6.4.4. Type operators</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="type-operators"> <dt id="extension-TypeOperators">
<code>TypeOperators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="explicit_namespaces.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use and definition of types with operator names.</p> </dd>
</dl> <p>The language <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> allows you to use infix operators in types.</p> <ul> <li>Operator symbols are <em>constructors</em> rather than type <em>variables</em> (as they are in terms). </li> <li>
<p class="first">Operator symbols in types can be written infix, both in definitions and uses. For example:</p> <pre data-language="haskell">data a + b = Plus a b
type Foo = Int + Bool
</pre> </li> <li>
<p class="first">Alphanumeric type constructors can now be written infix, using backquote syntax:</p> <pre data-language="haskell">x :: Int `Either` Bool
x = Left 5
</pre> </li> <li>
<p class="first">There is now some potential ambiguity in import and export lists; for example if you write <code>import M( (+) )</code> do you mean the <em>function</em> <code>(+)</code> or the <em>type constructor</em> <code>(+)</code>? The default is the former, but with <a class="reference internal" href="explicit_namespaces.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> (which is implied by <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a>) GHC allows you to specify the latter by preceding it with the keyword <code>type</code>, thus:</p> <pre data-language="haskell">import M( type (+) )
</pre> <p>See <a class="reference internal" href="explicit_namespaces.html#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>.</p> </li> <li>The fixity of a type operator may be set using the usual fixity declarations but, as in <a class="reference internal" href="infix_tycons.html#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>, the function and type constructor share a single fixity. </li> <li>
<p class="first">There is now potential ambiguity in the traditional syntax for data constructor declarations. For example:</p> <pre data-language="haskell">type a :+: b = Either a b
data X = Int :+: Bool :+: Char
</pre> <p>This code wants to declare both a type-level <code>:+:</code> and a term-level <code>:+:</code> (which is, generally, allowed). But we cannot tell how to parenthesize the data constructor declaration in <code>X</code>: either way makes sense. We might imagine that a fixity declaration could help us, but it is awkward to apply the fixity declaration to the very definition of a new data constructor. Instead of declaring delicate rules around this issue, GHC simply rejects if the top level of a traditional-syntax data constructor declaration uses two operators without parenthesizing.</p> </li> </ul>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/type_operators.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/type_operators.html</a>
  </p>
</div>
