<h1 id="applicative-do">6.2.4. Applicative do-notation</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="applicative-do-notation"> <dt id="extension-ApplicativeDo">
<code>ApplicativeDo</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow use of <code>Applicative</code> <code>do</code> notation.</p> </dd>
</dl> <p>The language option <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> enables an alternative translation for the do-notation, which uses the operators <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code>, along with <code>join</code> as far as possible. There are two main reasons for wanting to do this:</p> <ul class="simple"> <li>We can use do-notation with types that are an instance of <code>Applicative</code> and <code>Functor</code>, but not <code>Monad</code>
</li> <li>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</li> </ul> <p>Applicative do-notation desugaring preserves the original semantics, provided that the <code>Applicative</code> instance satisfies <code>&lt;*&gt; = ap</code> and <code>pure = return</code> (these are true of all the common monadic types). Thus, you can normally turn on <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> without fear of breaking your program. There is one pitfall to watch out for; see <a class="reference internal" href="#applicative-do-pitfall"><span class="std std-ref">Things to watch out for</span></a>.</p> <p>There are no syntactic changes with <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a>. The only way it shows up at the source level is that you can have a <code>do</code> expression that doesn’t require a <code>Monad</code> constraint. For example, in GHCi:</p> <pre data-language="haskell">Prelude&gt; :set -XApplicativeDo
Prelude&gt; :t \m -&gt; do { x &lt;- m; return (not x) }
\m -&gt; do { x &lt;- m; return (not x) }
  :: Functor f =&gt; f Bool -&gt; f Bool
</pre> <p>This example only requires <code>Functor</code>, because it is translated into <code>(\x -&gt;
not x) &lt;$&gt; m</code>. A more complex example requires <code>Applicative</code>,</p> <pre data-language="haskell">Prelude&gt; :t \m -&gt; do { x &lt;- m 'a'; y &lt;- m 'b'; return (x || y) }
\m -&gt; do { x &lt;- m 'a'; y &lt;- m 'b'; return (x || y) }
  :: Applicative f =&gt; (Char -&gt; f Bool) -&gt; f Bool
</pre> <p>Here GHC has translated the expression into</p> <pre data-language="haskell">(\x y -&gt; x || y) &lt;$&gt; m 'a' &lt;*&gt; m 'b'
</pre> <p>It is possible to see the actual translation by using <a class="reference internal" href="../debugging.html#ghc-flag--ddump-ds"><code>-ddump-ds</code></a>, but be warned, the output is quite verbose.</p> <p>Note that if the expression can’t be translated into uses of <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> only, then it will incur a <code>Monad</code> constraint as usual. This happens when there is a dependency on a value produced by an earlier statement in the <code>do</code>-block:</p> <pre data-language="haskell">Prelude&gt; :t \m -&gt; do { x &lt;- m True; y &lt;- m x; return (x || y) }
\m -&gt; do { x &lt;- m True; y &lt;- m x; return (x || y) }
  :: Monad m =&gt; (Bool -&gt; m Bool) -&gt; m Bool
</pre> <p>Here, <code>m x</code> depends on the value of <code>x</code> produced by the first statement, so the expression cannot be translated using <code>&lt;*&gt;</code>.</p> <p>In general, the rule for when a <code>do</code> statement incurs a <code>Monad</code> constraint is as follows. If the do-expression has the following form:</p> <pre data-language="haskell">do p1 &lt;- E1; ...; pn &lt;- En; return E
</pre> <p>where none of the variables defined by <code>p1...pn</code> are mentioned in <code>E1...En</code>, and <code>p1...pn</code> are all variables or lazy patterns, then the expression will only require <code>Applicative</code>. Otherwise, the expression will require <code>Monad</code>. The block may return a pure expression <code>E</code> depending upon the results <code>p1...pn</code> with either <code>return</code> or <code>pure</code>.</p> <p>Note: the final statement must match one of these patterns exactly:</p> <ul class="simple"> <li><code>return E</code></li> <li><code>return $ E</code></li> <li><code>pure E</code></li> <li><code>pure $ E</code></li> </ul> <p>otherwise GHC cannot recognise it as a <code>return</code> statement, and the transformation to use <code>&lt;$&gt;</code> that we saw above does not apply. In particular, slight variations such as <code>return . Just $ x</code> or <code>let x
= e in return x</code> would not be recognised.</p> <p>If the final statement is not of one of these forms, GHC falls back to standard <code>do</code> desugaring, and the expression will require a <code>Monad</code> constraint.</p> <p>When the statements of a <code>do</code> expression have dependencies between them, and <code>ApplicativeDo</code> cannot infer an <code>Applicative</code> type, it uses a heuristic algorithm to try to use <code>&lt;*&gt;</code> as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</p> <dl class="ghc-flag"> <dt id="ghc-flag--foptimal-applicative-do">
<code>-foptimal-applicative-do</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enables an alternative algorithm for choosing where to use <code>&lt;*&gt;</code> in conjunction with the <code>ApplicativeDo</code> language extension. This algorithm always finds the optimal solution, but it is expensive: <code>O(n^3)</code>, so this option can lead to long compile times when there are very large <code>do</code> expressions (over 100 statements). The default <code>ApplicativeDo</code> algorithm is <code>O(n^2)</code>.</p> </dd>
</dl>  <h2 id="applicative-do-strict">6.2.4.1. Strict patterns</h2> <p id="strict-patterns">A strict pattern match in a bind statement prevents <code>ApplicativeDo</code> from transforming that statement to use <code>Applicative</code>. This is because the transformation would change the semantics by making the expression lazier.</p> <p>For example, this code will require a <code>Monad</code> constraint:</p> <pre data-language="haskell">&gt; :t \m -&gt; do { (x:xs) &lt;- m; return x }
\m -&gt; do { (x:xs) &lt;- m; return x } :: Monad m =&gt; m [b] -&gt; m b
</pre> <p>but making the pattern match lazy allows it to have a <code>Functor</code> constraint:</p> <pre data-language="haskell">&gt; :t \m -&gt; do { ~(x:xs) &lt;- m; return x }
\m -&gt; do { ~(x:xs) &lt;- m; return x } :: Functor f =&gt; f [b] -&gt; f b
</pre> <p>A “strict pattern match” is any pattern match that can fail. For example, <code>()</code>, <code>(x:xs)</code>, <code>!z</code>, and <code>C x</code> are strict patterns, but <code>x</code> and <code>~(1,2)</code> are not. For the purposes of <code>ApplicativeDo</code>, a pattern match against a <code>newtype</code> constructor is considered strict.</p> <p>When there’s a strict pattern match in a sequence of statements, <code>ApplicativeDo</code> places a <code>&gt;&gt;=</code> between that statement and the one that follows it. The sequence may be transformed to use <code>&lt;*&gt;</code> elsewhere, but the strict pattern match and the following statement will always be connected with <code>&gt;&gt;=</code>, to retain the same strictness semantics as the standard do-notation. If you don’t want this, simply put a <code>~</code> on the pattern match to make it lazy.</p>   <h2 id="applicative-do-pitfall">6.2.4.2. Things to watch out for</h2> <p id="things-to-watch-out-for">Your code should just work as before when <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> is enabled, provided you use conventional <code>Applicative</code> instances. However, if you define a <code>Functor</code> or <code>Applicative</code> instance using do-notation, then it will likely get turned into an infinite loop by GHC. For example, if you do this:</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = do x &lt;- m; return (f x)
</pre> <p>Then applicative desugaring will turn it into</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = fmap (\x -&gt; f x) m
</pre> <p>And the program will loop at runtime. Similarly, an <code>Applicative</code> instance like this</p> <pre data-language="haskell">instance Applicative MyType where
    pure = return
    x &lt;*&gt; y = do f &lt;- x; a &lt;- y; return (f a)
</pre> <p>will result in an infinite loop when <code>&lt;*&gt;</code> is called.</p> <p>Just as you wouldn’t define a <code>Monad</code> instance using the do-notation, you shouldn’t define <code>Functor</code> or <code>Applicative</code> instance using do-notation (when using <code>ApplicativeDo</code>) either. The correct way to define these instances in terms of <code>Monad</code> is to use the <code>Monad</code> operations directly, e.g.</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = m &gt;&gt;= return . f

instance Applicative MyType where
    pure = return
    (&lt;*&gt;) = ap
</pre>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/applicative_do.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/applicative_do.html</a>
  </p>
</div>
