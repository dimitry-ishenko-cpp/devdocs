<h1 id="id1">6.19.1. Rewrite rules</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="pragma" id="rewrite-rules"> <dt id="pragma-RULES">
<code>{-# RULES "⟨name⟩" forall ⟨binder⟩ ... . ⟨expr⟩ = ⟨expr⟩ ... #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Define a rewrite rule to be used to optimize a source program.</p> </dd>
</dl> <p>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</p> <pre data-language="haskell">{-# RULES
      "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  #-}
</pre> <p>Use the debug flag <a class="reference internal" href="../debugging.html#ghc-flag--ddump-simpl-stats"><code>-ddump-simpl-stats</code></a> to see what rules fired. If you need more information, then <a class="reference internal" href="../debugging.html#ghc-flag--ddump-rule-firings"><code>-ddump-rule-firings</code></a> shows you each individual rule firing and <a class="reference internal" href="../debugging.html#ghc-flag--ddump-rule-rewrites"><code>-ddump-rule-rewrites</code></a> also shows what the code looks like before and after the rewrite.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fenable-rewrite-rules">
<code>-fenable-rewrite-rules</code> </dt> <dd>
<p>Allow the compiler to apply rewrite rules to the source program.</p> </dd>
</dl>  <h2 id="syntax">6.19.1.1. Syntax</h2> <p>From a syntactic point of view:</p> <ul> <li>There may be zero or more rules in a <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> pragma, separated by semicolons (which may be generated by the layout rule). </li> <li>
<p class="first">The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single <code>RULES</code> pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</p> <pre data-language="haskell">{-# RULES
      "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
      "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
  #-}
</pre> <p>Furthermore, the closing <code>#-}</code> should start in a column to the right of the opening <code>{-#</code>.</p> </li> <li>Each rule has a name, enclosed in double quotes. The name itself has no significance at all. It is only used when reporting how many times the rule fired. </li> <li>
<p class="first">A rule may optionally have a phase-control number (see <a class="reference internal" href="pragmas.html#phase-control"><span class="std std-ref">Phase control</span></a>), immediately after the name of the rule. Thus:</p> <pre data-language="haskell">{-# RULES
      "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
  #-}
</pre> <p>The <code>[2]</code> means that the rule is active in Phase 2 and subsequent phases. The inverse notation <code>[~2]</code> is also accepted, meaning that the rule is active up to, but not including, Phase 2.</p> <p>Rules support the special phase-control notation <code>[~]</code>, which means the rule is never active. This feature supports plugins (see <a class="reference internal" href="../extending_ghc.html#compiler-plugins"><span class="std std-ref">Compiler Plugins</span></a>), by making it possible to define a RULE that is never run by GHC, but is nevertheless parsed, typechecked etc, so that it is available to the plugin.</p> </li> <li>Each (term) variable mentioned in a rule must either be in scope (e.g. <code>map</code>), or bound by the <code>forall</code> (e.g. <code>f</code>, <code>g</code>, <code>xs</code>). The variables bound by the <code>forall</code> are called the <em>pattern</em> variables. They are separated by spaces, just like in a type <code>forall</code>. </li> <li>
<p class="first">A pattern variable may optionally have a type signature. If the type of the pattern variable is polymorphic, it <em>must</em> have a type signature. For example, here is the <code>foldr/build</code> rule:</p> <pre data-language="haskell">"fold/build"  forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
              foldr k z (build g) = g k z
</pre> <p>Since <code>g</code> has a polymorphic type, it must have a type signature.</p> </li> <li>
<p class="first">If <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type/kind variables can also be explicitly bound. For example:</p> <pre data-language="haskell">{-# RULES "id" forall a. forall (x :: a). id @a x = x #-}
</pre> <p>When a type-level explicit <code>forall</code> is present, each type/kind variable mentioned must now also be either in scope or bound by the <code>forall</code>. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</p> <pre data-language="haskell">"this_is_bad" forall (c :: k). forall (x :: Proxy c) ...
"this_is_ok"  forall k (c :: k). forall (x :: Proxy c) ...
</pre> <p>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</p> <pre data-language="haskell">{-# RULES "map/id" forall a. forall. map (id @a) = id @[a] #-}
</pre> </li> <li>
<p class="first">The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is <em>not</em> OK:</p> <pre data-language="haskell">"wrong1"   forall e1 e2.  case True of { True -&gt; e1; False -&gt; e2 } = e1
"wrong2"   forall f.      f True = True
"wrong3"   forall x.      Just x = Nothing
</pre> <p>In <code>"wrong1"</code>, the LHS is not an application; in <code>"wrong2"</code>, the LHS has a pattern variable in the head. In <code>"wrong3"</code>, the LHS consists of a <em>constructor</em>, rather than a <em>variable</em>, applied to an argument.</p> </li> <li>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope. </li> <li>All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly. (That is, if A imports B, which imports C, then C’s rules are in force when compiling A.) The situation is very similar to that for instance declarations. </li> <li>Inside a <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> “<code>forall</code>” is treated as a keyword, regardless of any other flag settings. Furthermore, inside a <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a>, the language extension <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a> is automatically enabled; see <a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>. </li> <li>Like other pragmas, <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only <em>enabled</em> if the <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> flag is on (see <a class="reference internal" href="#rule-semantics"><span class="std std-ref">Semantics</span></a>). </li> </ul>   <h2 id="rule-semantics">6.19.1.2. Semantics</h2> <p id="semantics">From a semantic point of view:</p> <ul> <li>Rules are enabled (that is, used during optimisation) by the <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> flag. This flag is implied by <a class="reference internal" href="../using-optimisation.html#ghc-flag--O"><code>-O</code></a>, and may be switched off (as usual) by <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fno-enable-rewrite-rules</code></a>. (NB: enabling <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> without <a class="reference internal" href="../using-optimisation.html#ghc-flag--O"><code>-O</code></a> may not do what you expect, though, because without <a class="reference internal" href="../using-optimisation.html#ghc-flag--O"><code>-O</code></a> GHC ignores all optimisation information in interface files; see <a class="reference internal" href="../using-optimisation.html#ghc-flag--fignore-interface-pragmas"><code>-fignore-interface-pragmas</code></a>). Note that <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> is an <em>optimisation</em> flag, and has no effect on parsing or typechecking. </li> <li>Rules are regarded as left-to-right rewrite rules. When GHC finds an expression that is a substitution instance of the LHS of a rule, it replaces the expression by the (appropriately-substituted) RHS. By “a substitution instance” we mean that the LHS can be made equal to the expression by substituting for the pattern variables. </li> <li>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer’s! </li> <li>
<p class="first">GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</p> <pre data-language="haskell">"loop"        forall x y.  f x y = f y x
</pre> <p>This rule will cause the compiler to go into an infinite loop.</p> </li> <li>If more than one rule matches a call, GHC will choose one arbitrarily to apply. </li> <li>
<p class="first">GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that’s called higher-order matching).</p> <p>Matching is carried out on GHC’s intermediate language, which includes type abstractions and applications. So a rule only matches if the types match too. See <a class="reference internal" href="#rule-spec"><span class="std std-ref">Specialisation</span></a> below.</p> </li> <li>
<p class="first">GHC keeps trying to apply the rules as it optimises the program. For example, consider:</p> <pre data-language="haskell">let s = map f
    t = map g
in
s (t xs)
</pre> <p>The expression <code>s (t xs)</code> does not match the rule <code>"map/map"</code>, but GHC will substitute for <code>s</code> and <code>t</code>, giving an expression which does match. If <code>s</code> or <code>t</code> was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</p> </li> <li>
<p class="first">GHC will never match a forall’d variable in a template with an expression which contains locally bound variables. For example, it is permitted to write a rule which contains a case expression:</p> <pre data-language="haskell">{-# RULES
  "test/case-tup" forall (x :: (Int, Int)) (y :: Int) (z :: Int).
    test (case x of (l, r) -&gt; y) z = case x of (l, r) -&gt; test y z
  #-}
</pre> <p>But the rule will not match when <code>y</code> contains either of <code>l</code> or <code>r</code> because they are locally bound. Therefore the following application will fail to trigger the rule:</p> <pre data-language="haskell">prog :: (Int, Int) -&gt; (Int, Int)
prog x = test (case x of (p, q) -&gt; p) 0
</pre> <p>because <code>y</code> would have to match against <code>p</code> (which is locally bound) but it will fire for:</p> <pre data-language="haskell">prog :: (Int, Int) -&gt; (Int, Int)
prog x = test (case x of (p, q) -&gt; 0) 0
</pre> <p>because <code>y</code> can match against <code>0</code>.</p> </li> <li>
<p class="first">A rule that has a forall binder with a polymorphic type, is likely to fail to fire. E. g.,</p> <pre data-language="haskell">{-# RULES forall (x :: forall a. Num a =&gt; a -&gt; a).  f x = blah #-}
</pre> <p>Here <code>x</code> has a polymorphic type. This applies to a forall’d binder with a type class constraint, such as:</p> <pre data-language="haskell">{-# RULES forall @m (x :: KnownNat m =&gt; Proxy m).  g x = blah #-}
</pre> <p>See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/21093">#21093</a> for discussion.</p> </li> </ul>   <h2 id="rules-inline">6.19.1.3. How rules interact with <code>INLINE</code>/<code>NOINLINE</code> pragmas</h2> <p id="how-rules-interact-with-inline-noinline-pragmas">Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected results. Consider this (artificial) example</p> <pre data-language="haskell">f x = x
g y = f y
h z = g True

{-# RULES "f" f True = False #-}
</pre> <p>Since <code>f</code>’s right-hand side is small, it is inlined into <code>g</code>, to give</p> <pre data-language="haskell">g y = y
</pre> <p>Now <code>g</code> is inlined into <code>h</code>, but <code>f</code>’s RULE has no chance to fire. If instead GHC had first inlined <code>g</code> into <code>h</code> then there would have been a better chance that <code>f</code>’s <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> might fire.</p> <p>The way to get predictable behaviour is to use a <a class="reference internal" href="pragmas.html#pragma-NOINLINE"><code>NOINLINE</code></a> pragma, or an <code>INLINE[⟨phase⟩]</code> pragma, on <code>f</code>, to ensure that it is not inlined until its <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> have had a chance to fire. The warning flag <a class="reference internal" href="../using-warnings.html#ghc-flag--Winline-rule-shadowing"><code>-Winline-rule-shadowing</code></a> (see <a class="reference internal" href="../using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>) warns about this situation.</p>   <h2 id="conlike">6.19.1.4. How rules interact with <code>CONLIKE</code> pragmas</h2> <p id="how-rules-interact-with-conlike-pragmas">GHC is very cautious about duplicating work. For example, consider</p> <pre data-language="haskell">f k z xs = let xs = build g
           in ...(foldr k z xs)...sum xs...
{-# RULES "foldr/build" forall k z g. foldr k z (build g) = g k z #-}
</pre> <p>Since <code>xs</code> is used twice, GHC does not fire the foldr/build rule. Rightly so, because it might take a lot of work to compute <code>xs</code>, which would be duplicated if the rule fired.</p> <p>Sometimes, however, this approach is over-cautious, and we <em>do</em> want the rule to fire, even though doing so would duplicate redex. There is no way that GHC can work out when this is a good idea, so we provide the <code>CONLIKE</code> pragma to declare it, thus:</p> <pre data-language="haskell">{-# INLINE CONLIKE [1] f #-}
f x = blah
</pre> <p><code>CONLIKE</code> is a modifier to an <code>INLINE</code> or <code>NOINLINE</code> pragma. It specifies that an application of <code>f</code> to one argument (in general, the number of arguments to the left of the <code>=</code> sign) should be considered cheap enough to duplicate, if such a duplication would make rule fire. (The name “CONLIKE” is short for “constructor-like”, because constructors certainly have such a property.) The <a class="reference internal" href="pragmas.html#pragma-CONLIKE"><code>CONLIKE</code></a> pragma is a modifier to <a class="reference internal" href="pragmas.html#pragma-INLINE"><code>INLINE</code></a>/<a class="reference internal" href="pragmas.html#pragma-NOINLINE"><code>NOINLINE</code></a> because it really only makes sense to match <code>f</code> on the LHS of a rule if you are sure that <code>f</code> is not going to be inlined before the rule has a chance to fire.</p>   <h2 id="rules-class-methods">6.19.1.5. How rules interact with class methods</h2> <p id="how-rules-interact-with-class-methods">Giving a RULE for a class method is a bad idea:</p> <pre data-language="haskell">class C a where
  op :: a -&gt; a -&gt; a

instance C Bool where
  op x y = ...rhs for op at Bool...

{-# RULES "f" op True y = False #-}
</pre> <p>In this example, <code>op</code> is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of <code>op</code>-used-at-type-Bool to a specialised function, say <code>opBool</code>, where</p> <pre data-language="haskell">opBool :: Bool -&gt; Bool -&gt; Bool
opBool x y = ..rhs for op at Bool...
</pre> <p>So the RULE never has a chance to fire, for just the same reasons as in <a class="reference internal" href="#rules-inline"><span class="std std-ref">How rules interact with INLINE/NOINLINE pragmas</span></a>.</p> <p>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</p> <pre data-language="haskell">instance C Bool where
  op = opBool

opBool :: Bool -&gt; Bool -&gt; Bool
{-# NOINLINE [1] opBool #-}
opBool x y = ..rhs for op at Bool...

{-# RULES "f" opBool True y = False #-}
</pre> <p>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</p> <pre data-language="haskell">class C a where
  op_c :: a -&gt; a -&gt; a

op :: C a =&gt; a -&gt; a -&gt; a
{-# NOINLINE [1] op #-}
op = op_c

{-# RULES "reassociate" op (op x y) z = op x (op y z) #-}
</pre> <p>Now the inlining of <code>op</code> is delayed until the rule has a chance to fire. The down-side is that instance declarations must define <code>op_c</code>, but all other uses should go via <code>op</code>.</p>   <h2 id="list-fusion">6.19.1.6. List fusion</h2> <p>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a “good consumer” consumes an intermediate list constructed by a “good producer”, the intermediate list should be eliminated entirely.</p> <p>The following are good producers:</p> <ul class="simple"> <li>List comprehensions</li> <li>Enumerations of <code>Int</code>, <code>Integer</code> and <code>Char</code> (e.g. <code>['a'..'z']</code>).</li> <li>Explicit lists (e.g. <code>[True, False]</code>)</li> <li>The cons constructor (e.g <code>3:4:[]</code>)</li> <li><code>++</code></li> <li><code>map</code></li> <li>
<code>take</code>, <code>filter</code>
</li> <li>
<code>iterate</code>, <code>repeat</code>
</li> <li>
<code>zip</code>, <code>zipWith</code>
</li> </ul> <p>The following are good consumers:</p> <ul class="simple"> <li>List comprehensions</li> <li>
<code>array</code> (on its second argument)</li> <li>
<code>++</code> (on its first argument)</li> <li><code>foldr</code></li> <li><code>map</code></li> <li>
<code>take</code>, <code>filter</code>
</li> <li><code>concat</code></li> <li>
<code>unzip</code>, <code>unzip2</code>, <code>unzip3</code>, <code>unzip4</code>
</li> <li>
<code>zip</code>, <code>zipWith</code> (but on one argument only; if both are good producers, <code>zip</code> will fuse with one but not the other)</li> <li><code>partition</code></li> <li><code>head</code></li> <li>
<code>and</code>, <code>or</code>, <code>any</code>, <code>all</code>
</li> <li><code>sequence_</code></li> <li><code>msum</code></li> </ul> <p>So, for example, the following should generate no intermediate lists:</p> <pre data-language="haskell">array (1,10) [(i,i*i) | i &lt;- map (+ 1) [0..9]]
</pre> <p>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</p> <p>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</p>   <h2 id="rule-spec">6.19.1.7. Specialisation</h2> <p id="specialisation">Rewrite rules can be used to get the same effect as a feature present in earlier versions of GHC. For example, suppose that:</p> <pre data-language="haskell">genericLookup :: Ord a =&gt; Table a b   -&gt; a   -&gt; b
intLookup     ::          Table Int b -&gt; Int -&gt; b
</pre> <p>where <code>intLookup</code> is an implementation of <code>genericLookup</code> that works very fast for keys of type <code>Int</code>. You might wish to tell GHC to use <code>intLookup</code> instead of <code>genericLookup</code> whenever the latter was called with type <code>Table Int b -&gt; Int -&gt; b</code>. It used to be possible to write a <a class="reference internal" href="pragmas.html#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma with a right-hand-side:</p> <pre data-language="haskell">{-# SPECIALIZE genericLookup :: Table Int b -&gt; Int -&gt; b = intLookup #-}
</pre> <p>This feature is no longer in GHC, but rewrite rules let you do the same thing:</p> <pre data-language="haskell">{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</pre> <p>This slightly odd-looking rule instructs GHC to replace <code>genericLookup</code> by <code>intLookup</code> <em>whenever the types match</em>. What is more, this rule does not need to be in the same file as <code>genericLookup</code>, unlike the <code>SPECIALIZE</code> pragmas which currently do (so that they have an original definition available to specialise).</p> <p>It is <em>Your Responsibility</em> to make sure that <code>intLookup</code> really behaves as a specialised version of <code>genericLookup</code>!!!</p> <p>An example in which using <code>RULES</code> for specialisation will Win Big:</p> <pre data-language="haskell">toDouble :: Real a =&gt; a -&gt; Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</pre> <p>The <code>i2d</code> function is virtually one machine instruction; the default conversion—via an intermediate <code>Rational</code>-is obscenely expensive by comparison.</p>   <h2 id="controlling-rules">6.19.1.8. Controlling what’s going on in rewrite rules</h2> <ul id="controlling-what-s-going-on-in-rewrite-rules"> <li>Use <a class="reference internal" href="../debugging.html#ghc-flag--ddump-rules"><code>-ddump-rules</code></a> to see the rules that are defined <em>in this module</em>. This includes rules generated by the specialisation pass, but excludes rules imported from other modules. </li> <li>Use <a class="reference internal" href="../debugging.html#ghc-flag--ddump-simpl-stats"><code>-ddump-simpl-stats</code></a> to see what rules are being fired. If you add <a class="reference internal" href="../debugging.html#ghc-flag--dppr-debug"><code>-dppr-debug</code></a> you get a more detailed listing. </li> <li>Use <a class="reference internal" href="../debugging.html#ghc-flag--ddump-rule-firings"><code>-ddump-rule-firings</code></a> or <a class="reference internal" href="../debugging.html#ghc-flag--ddump-rule-rewrites"><code>-ddump-rule-rewrites</code></a> to see in great detail what rules are being fired. If you add <a class="reference internal" href="../debugging.html#ghc-flag--dppr-debug"><code>-dppr-debug</code></a> you get a still more detailed listing. </li> <li>
<p class="first">The definition of (say) <code>build</code> in <code>GHC/Base.hs</code> looks like this:</p> <pre data-language="haskell">build   :: forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
{-# INLINE build #-}
build g = g (:) []
</pre> <p>Notice the <a class="reference internal" href="pragmas.html#pragma-INLINE"><code>INLINE</code></a>! That prevents <code>(:)</code> from being inlined when compiling <code>PrelBase</code>, so that an importing module will “see” the <code>(:)</code>, and can match it on the LHS of a rule. <code>INLINE</code> prevents any inlining happening in the RHS of the <code>INLINE</code> thing. I regret the delicacy of this.</p> </li> <li>In <code>libraries/base/GHC/Base.hs</code> look at the rules for <code>map</code> to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn’t happen. More rules in <code>GHC/List.hs</code>. </li> </ul>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/rewrite_rules.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/rewrite_rules.html</a>
  </p>
</div>
