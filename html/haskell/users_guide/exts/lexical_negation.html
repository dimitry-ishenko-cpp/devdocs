<h1 id="id1">6.2.20. Lexical negation</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="lexical-negation"> <dt id="extension-LexicalNegation">
<code>LexicalNegation</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.0.1</td> </tr>  </table> <p>Detect if the minus sign stands for negation during lexical analysis by checking for the surrounding whitespace.</p> </dd>
</dl> <p>In Haskell 2010, the minus sign stands for negation when it has no left-hand side. Consider <code>x = - 5</code> and <code>y = 2 - 5</code>. In <code>x</code>, there’s no expression between the <code>=</code> and <code>-</code>, so the minus stands for negation, whereas in <code>y</code>, there’s <code>2</code> to the left of the minus, therefore it stands for subtraction.</p> <p>This leads to certain syntactic anomalies:</p> <ul class="simple"> <li>
<code>(% x)</code> is an operator section for any operator <code>(%)</code> except for <code>(-)</code>. <code>(- x)</code> is negated <code>x</code> rather than the right operator section of subtraction. Consequently, it is impossible to write such a section, and users are advised to write <code>(subtract x)</code> instead.</li> <li>Negative numbers must be parenthesized when they appear in function argument position. <code>f (-5)</code> is correct, whereas <code>f -5</code> is parsed as <code>(-) f 5</code>.</li> </ul> <p>The latter issue is partly mitigated by <a class="reference internal" href="negative_literals.html#extension-NegativeLiterals"><code>NegativeLiterals</code></a>. When it is enabled, <code>-5</code> is parsed as negative 5 regardless of context, so <code>f
-5</code> works as expected. However, it only applies to literals, so <code>f -x</code> or <code>f -(a*2)</code> are still parsed as subtraction.</p> <p>With <a class="reference internal" href="#extension-LexicalNegation"><code>LexicalNegation</code></a>, both anomalies are resolved:</p> <ul class="simple"> <li>
<code>(% x)</code> is an operator section for any operator <code>(%)</code>, no exceptions, as long as there’s whitespace between <code>%</code> and <code>x</code>.</li> <li>In <code>f -x</code>, the <code>-x</code> is parsed as the negation of <code>x</code> for any syntactically atomic expression <code>x</code> (variable, literal, or parenthesized expression).</li> <li>The prefix <code>-</code> binds tighter than any infix operator. <code>-a % b</code> is parsed as <code>(-a) % b</code> regardless of the fixity of <code>%</code>.</li> </ul> <p>This means that <code>(- x)</code> is the right operator section of subtraction, whereas <code>(-x)</code> is the negation of <code>x</code>. Note that these expressions will often have different types (<code>(- x)</code> might have type <code>Int -&gt; Int</code> while <code>(-x)</code> will have type <code>Int</code>), and so users mistaking one for the other will likely get a compile error.</p> <p>Under <a class="reference internal" href="#extension-LexicalNegation"><code>LexicalNegation</code></a>, negated literals are desugared without <code>negate</code>. That is, <code>-123</code> stands for <code>fromInteger (-123)</code> rather than <code>negate (fromInteger 123)</code>. This makes <a class="reference internal" href="#extension-LexicalNegation"><code>LexicalNegation</code></a> a valid replacement for <a class="reference internal" href="negative_literals.html#extension-NegativeLiterals"><code>NegativeLiterals</code></a>.</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/lexical_negation.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/lexical_negation.html</a>
  </p>
</div>
