<h1 id="recursive-do-notation">6.2.3. The recursive do-notation</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="the-recursive-do-notation">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-RecursiveDo">
<code>RecursiveDo</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>6.8.1</p> </dd> </dl> <p>Allow the use of recursive <code>do</code> notation.</p> </dd>
</dl> <p>The do-notation of Haskell 98 does not allow <em>recursive bindings</em>, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</p> <p>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the <code>mfix</code> method of the <code>MonadFix</code> class, defined in <code>Control.Monad.Fix</code> as follows:</p> <pre data-language="haskell">class Monad m =&gt; MonadFix m where
   mfix :: (a -&gt; m a) -&gt; m a
</pre> <p>Haskell’s <code>Maybe</code>, <code>[]</code> (list), <code>ST</code> (both strict and lazy versions), <code>IO</code>, and many other monads have <code>MonadFix</code> instances. On the negative side, the continuation monad, with the signature <code>(a -&gt; r) -&gt; r</code>, does not.</p> <p>For monads that do belong to the <code>MonadFix</code> class, GHC provides an extended version of the do-notation that allows recursive bindings. The <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a> (language pragma: <code>RecursiveDo</code>) provides the necessary syntactic support, introducing the keywords <code>mdo</code> and <code>rec</code> for higher and lower levels of the notation respectively. Unlike bindings in a <code>do</code> expression, those introduced by <code>mdo</code> and <code>rec</code> are recursively defined, much like in an ordinary let-expression. Due to the new keyword <code>mdo</code>, we also call this notation the <em>mdo-notation</em>.</p> <p>Here is a simple (albeit contrived) example:</p> <pre data-language="haskell">{-# LANGUAGE RecursiveDo #-}
justOnes = mdo { xs &lt;- Just (1:xs)
               ; return (map negate xs) }
</pre> <p>or equivalently</p> <pre data-language="haskell">{-# LANGUAGE RecursiveDo #-}
justOnes = do { rec { xs &lt;- Just (1:xs) }
              ; return (map negate xs) }
</pre> <p>As you can guess <code>justOnes</code> will evaluate to <code>Just [-1,-1,-1,...</code>.</p> <p>GHC’s implementation the mdo-notation closely follows the original translation as described in the paper <a class="reference external" href="https://leventerkok.github.io/papers/recdo.pdf">A recursive do for Haskell</a>, which in turn is based on the work <a class="reference external" href="https://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic Computations</a>. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the <code>rec</code> keyword, as we describe next.</p> <section id="recursive-binding-groups"> <h2>
<span class="section-number">6.2.3.1. </span>Recursive binding groups</h2> <p>The extension <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a> also introduces a new keyword <code>rec</code>, which wraps a mutually-recursive group of monadic statements inside a <code>do</code> expression, producing a single statement. Similar to a <code>let</code> statement inside a <code>do</code>, variables bound in the <code>rec</code> are visible throughout the <code>rec</code> group, and below it. For example, compare</p> <pre data-language="haskell">do { a &lt;- getChar            do { a &lt;- getChar
   ; let { r1 = f a r2          ; rec { r1 &lt;- f a r2
   ;     ; r2 = g r1 }          ;     ; r2 &lt;- g r1 }
   ; return (r1 ++ r2) }        ; return (r1 ++ r2) }
</pre> <p>In both cases, <code>r1</code> and <code>r2</code> are available both throughout the <code>let</code> or <code>rec</code> block, and in the statements that follow it. The difference is that <code>let</code> is non-monadic, while <code>rec</code> is monadic. (In Haskell <code>let</code> is really <code>letrec</code>, of course.)</p> <p>The semantics of <code>rec</code> is fairly straightforward. Whenever GHC finds a <code>rec</code> group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator <code>mfix</code>, belonging to the <code>MonadFix</code> class. Here is an example:</p> <pre data-language="haskell">rec { b &lt;- f a c     ===&gt;    (b,c) &lt;- mfix (\ ~(b,c) -&gt; do { b &lt;- f a c
    ; c &lt;- f b a }                                         ; c &lt;- f b a
                                                           ; return (b,c) })
</pre> <p>As usual, the meta-variables <code>b</code>, <code>c</code> etc., can be arbitrary patterns. In general, the statement <code>rec ss</code> is desugared to the statement</p> <pre data-language="haskell">vs &lt;- mfix (\ ~vs -&gt; do { ss; return vs })
</pre> <p>where <code>vs</code> is a tuple of the variables bound by <code>ss</code>.</p> <p>Note in particular that the translation for a <code>rec</code> block only involves wrapping a call to <code>mfix</code>: it performs no other analysis on the bindings. The latter is the task for the <code>mdo</code> notation, which is described next.</p> </section> <section id="the-mdo-notation"> <h2>
<span class="section-number">6.2.3.2. </span>The <code>mdo</code> notation</h2> <p>A <code>rec</code>-block tells the compiler where precisely the recursive knot should be tied. It turns out that the placement of the recursive knots can be rather delicate: in particular, we would like the knots to be wrapped around as minimal groups as possible. This process is known as <em>segmentation</em>, and is described in detail in Section 3.2 of <a class="reference external" href="https://leventerkok.github.io/papers/recdo.pdf">A recursive do for Haskell</a>. Segmentation improves polymorphism and reduces the size of the recursive knot. Most importantly, it avoids unnecessary interference caused by a fundamental issue with the so-called <em>right-shrinking</em> axiom for monadic recursion. In brief, most monads of interest (IO, strict state, etc.) do <em>not</em> have recursion operators that satisfy this axiom, and thus not performing segmentation can cause unnecessary interference, changing the termination behavior of the resulting translation. (Details can be found in Sections 3.1 and 7.2.2 of <a class="reference external" href="https://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic Computations</a>.)</p> <p>The <code>mdo</code> notation removes the burden of placing explicit <code>rec</code> blocks in the code. Unlike an ordinary <code>do</code> expression, in which variables bound by statements are only in scope for later statements, variables bound in an <code>mdo</code> expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a <code>rec</code> qualifier around them.</p> <p>The definition is syntactic:</p> <ul class="simple"> <li>
<p>A generator ⟨g⟩ <em>depends</em> on a textually following generator ⟨g’⟩, if</p> <ul> <li>⟨g’⟩ defines a variable that is used by ⟨g⟩, or</li> <li>⟨g’⟩ textually appears between ⟨g⟩ and ⟨g’’⟩, where ⟨g⟩ depends on ⟨g’’⟩.</li> </ul> </li> <li>A <em>segment</em> of a given <code>mdo</code>-expression is a minimal sequence of generators such that no generator of the sequence depends on an outside generator. As a special case, although it is not a generator, the final expression in an <code>mdo</code>-expression is considered to form a segment by itself.</li> </ul> <p>Segments in this sense are related to <em>strongly-connected components</em> analysis, with the exception that bindings in a segment cannot be reordered and must be contiguous.</p> <p>Here is an example <code>mdo</code>-expression, and its translation to <code>rec</code> blocks:</p> <pre data-language="haskell">mdo { a &lt;- getChar      ===&gt; do { a &lt;- getChar
    ; b &lt;- f a c                ; rec { b &lt;- f a c
    ; c &lt;- f b a                ;     ; c &lt;- f b a }
    ; z &lt;- h a b                ; z &lt;- h a b
    ; d &lt;- g d e                ; rec { d &lt;- g d e
    ; e &lt;- g a z                ;     ; e &lt;- g a z }
    ; putChar c }               ; putChar c }
</pre> <p>Note that a given <code>mdo</code> expression can cause the creation of multiple <code>rec</code> blocks. If there are no recursive dependencies, <code>mdo</code> will introduce no <code>rec</code> blocks. In this latter case an <code>mdo</code> expression is precisely the same as a <code>do</code> expression, as one would expect.</p> <p>In summary, given an <code>mdo</code> expression, GHC first performs segmentation, introducing <code>rec</code> blocks to wrap over minimal recursive groups. Then, each resulting <code>rec</code> is desugared, using a call to <code>Control.Monad.Fix.mfix</code> as described in the previous section. The original <code>mdo</code>-expression typechecks exactly when the desugared version would do so.</p> <p>Here are some other important points in using the recursive-do notation:</p> <ul class="simple"> <li>It is enabled with the extension <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a>, or the <code>LANGUAGE RecursiveDo</code> pragma. (The same extension enables both <code>mdo</code>-notation, and the use of <code>rec</code> blocks inside <code>do</code> expressions.)</li> <li>
<code>rec</code> blocks can also be used inside <code>mdo</code>-expressions, which will be treated as a single statement. However, it is good style to either use <code>mdo</code> or <code>rec</code> blocks in a single expression.</li> <li>If recursive bindings are required for a monad, then that monad must be declared an instance of the <code>MonadFix</code> class.</li> <li>The following instances of <code>MonadFix</code> are automatically provided: List, Maybe, IO. Furthermore, the <code>Control.Monad.ST</code> and <code>Control.Monad.ST.Lazy</code> modules provide the instances of the <code>MonadFix</code> class for Haskell’s internal state monad (strict and lazy, respectively).</li> <li>Like <code>let</code> and <code>where</code> bindings, name shadowing is not allowed within an <code>mdo</code>-expression or a <code>rec</code>-block; that is, all the names bound in a single <code>rec</code> must be distinct. (GHC will complain if this is not the case.)</li> </ul> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/recursive_do.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/recursive_do.html</a>
  </p>
</div>
