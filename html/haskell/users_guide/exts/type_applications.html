<h1 id="id1">6.4.16. Visible type application</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="visible-type-application">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-TypeApplications">
<code>TypeApplications</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>8.0.1</p> </dd> <dt class="field-even">Status<span class="colon">:</span>
</dt> <dd class="field-even">
<p>Included in <a class="reference internal" href="control.html#extension-GHC2024"><code>GHC2024</code></a>, <a class="reference internal" href="control.html#extension-GHC2021"><code>GHC2021</code></a></p> </dd> </dl> <p>Allow the use of type application syntax.</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a> extension allows you to use <em>visible type application</em> in expressions. Here is an example: <code>show (read @Int "5")</code>. The <code>@Int</code> is the visible type application; it specifies the value of the type variable in <code>read</code>’s type.</p> <p>A visible type application is preceded with an <code>@</code> sign. (To disambiguate the syntax, the <code>@</code> must be preceded with a non-identifier letter, usually a space. For example, <code>read@Int 5</code> would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</p> <p>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</p> <p>In addition to visible type application in terms and types, the type application syntax can be used in patterns matching a data constructor to bind type variables in that constructor’s type.</p> <section id="inferred-vs-specified-type-variables"> <h2 id="inferred-vs-specified">
<span class="section-number">6.4.16.1. </span>Inferred vs. specified type variables</h2> <p id="index-0">GHC tracks a distinction between what we call <em>inferred</em> and <em>specified</em> type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</p> <pre data-language="haskell">f :: (Eq b, Eq a) =&gt; a -&gt; b -&gt; Bool
f x y = (x == x) &amp;&amp; (y == y)

g x y = (x == x) &amp;&amp; (y == y)
</pre> <p>The functions <code>f</code> and <code>g</code> have the same body, but only <code>f</code> is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function’s type.</p> <p>If the user has supplied a type signature, as in <code>f</code>, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in <code>f</code> will be <code>b</code>, then <code>a</code>.</p> <p>In contrast, there is no reliable way to do this for <code>g</code>; we will not know whether <code>Eq a</code> or <code>Eq b</code> will be listed first in the constraint in <code>g</code>'s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with <code>g</code>.</p> <p>We say that the type variables in <code>f</code> are <em>specified</em>, while those in <code>g</code> are <em>inferred</em>. The general rule is this: if the user has written a type variable in the source program, it is <em>specified</em>; if not, it is <em>inferred</em>.</p> <p>This rule applies in datatype declarations, too. For example, if we have <code>data Proxy a = Proxy</code> (and <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code>PolyKinds</code></a> is enabled), then <code>a</code> will be assigned kind <code>k</code>, where <code>k</code> is a fresh kind variable. Because <code>k</code> was not written by the user, it will be unavailable for type application in the type of the constructor <code>Proxy</code>; only the <code>a</code> will be available.</p> <p>Inferred variables are printed in braces. Thus, the type of the data constructor <code>Proxy</code> from the previous example is <code>forall {k} (a :: k). Proxy a</code>. We can observe this behavior in a GHCi session:</p> <pre data-language="haskell">&gt; :set -XTypeApplications -fprint-explicit-foralls
&gt; let myLength1 :: Foldable f =&gt; f a -&gt; Int; myLength1 = length
&gt; :type myLength1
myLength1 :: forall (f :: * -&gt; *) a. Foldable f =&gt; f a -&gt; Int
&gt; let myLength2 = length
&gt; :type myLength2
myLength2 :: forall {t :: * -&gt; *} {a}. Foldable t =&gt; t a -&gt; Int
&gt; :type myLength2 @[]

&lt;interactive&gt;:1:1: error:
    • Cannot apply expression of type ‘t0 a0 -&gt; Int’
      to a visible type argument ‘[]’
    • In the expression: myLength2 @[]
</pre> <p>Notice that since <code>myLength1</code> was defined with an explicit type signature, <a class="reference internal" href="../ghci.html#ghci-cmd-type"><code>:type</code></a> reports that all of its type variables are available for type application. On the other hand, <code>myLength2</code> was not given a type signature. As a result, all of its type variables are surrounded with braces, and trying to use visible type application with <code>myLength2</code> fails.</p> </section> <section id="ordering-of-specified-variables"> <h2 id="index-1">
<span class="section-number">6.4.16.2. </span>Ordering of specified variables</h2> <p>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</p> <ul> <li>If an identifier’s type has a <code>forall</code>, then the order of type variables as written in the <code>forall</code> is retained.</li> <li>
<p>If any of the variables depend on other variables (that is, if some of the variables are <em>kind</em> variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</p> <pre data-language="haskell">h :: Proxy (a :: (j, k)) -&gt; Proxy (b :: Proxy a) -&gt; ()
  -- as if h :: forall j k a b. ...
</pre> <p>In this example, <code>a</code> depends on <code>j</code> and <code>k</code>, and <code>b</code> depends on <code>a</code>. Even though <code>a</code> appears lexically before <code>j</code> and <code>k</code>, <code>j</code> and <code>k</code> are quantified first, because <code>a</code> depends on <code>j</code> and <code>k</code>. Note further that <code>j</code> and <code>k</code> are not reordered with respect to each other, even though doing so would not violate dependency conditions.</p> <p>A “stable topological sort” here, we mean that we perform this algorithm (which we call <em>ScopedSort</em>):</p> <ul class="simple"> <li>Work left-to-right through the input list of type variables, with a cursor.</li> <li>If variable <code>v</code> at the cursor is depended on by any earlier variable <code>w</code>, move <code>v</code> immediately before the leftmost such <code>w</code>.</li> </ul> </li> <li>Class methods’ type arguments include the class type variables, followed by any variables an individual method is polymorphic in. So, <code>class Monad m where return :: a -&gt; m a</code> means that <code>return</code>’s type arguments are <code>m, a</code>.</li> <li>With the <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code>RankNTypes</code></a> extension (<a class="reference internal" href="scoped_type_variables.html#universal-quantification"><span class="std std-ref">Lexically scoped type variables</span></a>), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have <code>pair :: forall a. a -&gt; forall b. b -&gt; (a, b)</code> and then say <code>pair @Bool True @Char</code> which would have type <code>Char -&gt; (Bool, Char)</code>.</li> <li>Partial type signatures (<a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>) work nicely with visible type application. If you want to specify only the second type argument to <code>wurble</code>, then you can say <code>wurble @_ @Int</code>. The first argument is a wildcard, just like in a partial type signature. However, if used in a visible type application/visible kind application, it is <em>not</em> necessary to specify <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> and your code will not generate a warning informing you of the omitted type.</li> </ul> <p>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (<a class="reference internal" href="poly_kinds.html#inferring-variable-order"><span class="std std-ref">Inferring the order of variables in a type/class declaration</span></a>).</p> </section> <section id="manually-defining-inferred-variables"> <h2 id="id2">
<span class="section-number">6.4.16.3. </span>Manually defining inferred variables</h2> <p>Since the 9.0.1 release, GHC permits labelling the user-written type or kind variables as <em>inferred</em>, in contrast to the default of <em>specified</em>. By writing the type variable binder in braces as <code>{tyvar}</code> or <code>{tyvar :: kind}</code>, the new variable will be classified as inferred, not specified. Doing so gives the programmer control over which variables can be manually instantiated and which can’t. Note that the braces do not influence scoping: variables in braces are still brought into scope just the same. Consider for example:</p> <pre data-language="haskell">myConst :: forall {a} b. a -&gt; b -&gt; a
myConst x _ = x
</pre> <p>In this example, despite both variables appearing in a type signature, <code>a</code> is an inferred variable while <code>b</code> is specified. This means that the expression <code>myConst @Int</code> has type <code>forall {a}. a -&gt; Int -&gt; a</code>.</p> <p>The braces are allowed in the following places:</p> <ul> <li>In the type signatures of functions, variables, class methods, as well as type annotations on expressions. Consider the example above.</li> <li>
<p>In data constructor declarations, using the GADT syntax. Consider:</p> <pre data-language="haskell">data T a where MkT :: forall {k} (a :: k). Proxy a -&gt; T a
</pre> <p>The constructor <code>MkT</code> defined in this example is kind polymorphic, which is emphasized to the reader by explicitly abstracting over the <code>k</code> variable. As this variable is marked as inferred, it can not be manually instantiated.</p> </li> <li>
<p>In existential variable quantifications, e.g.:</p> <pre data-language="haskell">data HList = HNil
           | forall {a}. HCons a HList
</pre> </li> <li>
<p>In pattern synonym signatures. Consider for instance:</p> <pre data-language="haskell">data T a where MkT :: forall a b. a -&gt; b -&gt; T a

pattern Pat :: forall {c}. () =&gt; forall {d}. c -&gt; d -&gt; T c
pattern Pat x y = MkT x y
</pre> <p>Note that in this example, <code>a</code> is a universal variable in the data type <code>T</code>, where <code>b</code> is existential. When writing the pattern synonym, both types are allowed to be specified or inferred.</p> </li> <li>
<p>On the right-hand side of a type synonym, e.g.:</p> <pre data-language="haskell">type Foo = forall a {b}. Either a b
</pre> </li> <li>
<p>In type signatures on variables bound in RULES, e.g.:</p> <pre data-language="haskell">{-# RULES "parametricity" forall (f :: forall {a}. a -&gt; a). map f = id #-}
</pre> </li> </ul> <p>The braces are <em>not</em> allowed in the following places:</p> <ul> <li>
<p>In visible dependent quantifiers. Consider:</p> <pre data-language="haskell">data T :: forall {k} -&gt; k -&gt; Type
</pre> <p>This example is rejected, as a visible argument should by definition be explicitly applied. Making them inferred (and thus not appliable) would be conflicting.</p> </li> <li>
<p>In SPECIALISE pragmas or in instance declaration heads, e.g.:</p> <pre data-language="haskell">instance forall {a}. Eq (Maybe a) where ...
</pre> <p>The reason for this is, essentially, that none of these define a new construct. This means that no new type is being defined where specificity could play a role.</p> </li> <li>On the left-hand sides of type declarations, such as classes, data types, etc.</li> </ul> <p>Note that while specified and inferred type variables have different properties vis-à-vis visible type application, they do not otherwise affect GHC’s notion of equality over types. For example, given the following definitions:</p> <pre data-language="haskell">id1 :: forall a. a -&gt; a
id1 x = x

id2 :: forall {a}. a -&gt; a
id2 x = x

app1 :: (forall a. a -&gt; a) -&gt; b -&gt; b
app1 g x = g x

app2 :: (forall {a}. a -&gt; a) -&gt; b -&gt; b
app2 g x = g x
</pre> <p>GHC will deem all of <code>app1 id1</code>, <code>app1 id2</code>, <code>app2 id1</code>, and <code>app2 id2</code> to be well typed.</p> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/type_applications.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/type_applications.html</a>
  </p>
</div>
