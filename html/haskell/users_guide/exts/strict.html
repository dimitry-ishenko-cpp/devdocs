<h1 id="bang-patterns">6.14. Bang patterns and Strict Haskell</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <p id="bang-patterns-and-strict-haskell">In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</p> <ul class="simple"> <li>Bang patterns (<a class="reference internal" href="#extension-BangPatterns"><code>BangPatterns</code></a>) makes pattern matching and let bindings stricter.</li> <li>Strict data types (<a class="reference internal" href="#extension-StrictData"><code>StrictData</code></a>) makes constructor fields strict by default, on a per-module basis.</li> <li>Strict pattern (<a class="reference internal" href="#extension-Strict"><code>Strict</code></a>) makes all patterns and let bindings strict by default, on a per-module basis.</li> </ul> <p>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</p> <p>Bang patterns and strict matching do not affect the type system in any way.</p>  <h2 id="id1">6.14.1. Bang patterns</h2> <dl class="extension" id="bang-patterns-informal"> <dt id="extension-BangPatterns">
<code>BangPatterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of bang pattern syntax.</p> </dd>
</dl> <p>GHC supports an extension of pattern matching called <em>bang patterns</em>, written <code>!pat</code>. Bang patterns are available by default as a part of <a class="reference internal" href="control.html#extension-GHC2021"><code>GHC2021</code></a>.</p> <p>The main idea is to add a single new production to the syntax of patterns:</p> <pre data-language="haskell">pat ::= !pat
</pre> <p>Matching an expression <code>e</code> against a pattern <code>!p</code> is done by first evaluating <code>e</code> (to WHNF) and then matching the result against <code>p</code>. Example:</p> <pre data-language="haskell">f1 !x = True
</pre> <p>This definition makes <code>f1</code> is strict in <code>x</code>, whereas without the bang it would be lazy.</p> <p>Note the following points:</p> <ul> <li>
<p class="first">Bang patterns can be nested:</p> <pre data-language="haskell">f2 (!x, y) = [x,y]
</pre> <p>Here, <code>f2</code> is strict in <code>x</code> but not in <code>y</code>.</p> </li> <li>
<p class="first">Bang patterns can be used in <code>case</code> expressions too:</p> <pre data-language="haskell">g1 x = let y = f x in body
g2 x = case f x of { y -&gt; body }
g3 x = case f x of { !y -&gt; body }
</pre> <p>The functions <code>g1</code> and <code>g2</code> mean exactly the same thing. But <code>g3</code> evaluates <code>(f x)</code>, binds <code>y</code> to the result, and then evaluates <code>body</code>.</p> </li> <li>
<p class="first">Bang patterns do not have any effect with constructor patterns:</p> <pre data-language="haskell">f3 !(x,y) = [x,y]
f4 (x,y)  = [x,y]
</pre> <p>Here, <code>f3</code> and <code>f4</code> are identical; putting a bang before a pattern that forces evaluation anyway does nothing. However, see the caveat below.</p> </li> <li>
<p class="first">There is one problem with syntactic ambiguity. Consider:</p> <pre data-language="haskell">f !x = 3
</pre> <p>Is this a definition of the infix function “<code>(!)</code>”, or of the “<code>f</code>” with a bang pattern? GHC resolves this ambiguity by looking at the surrounding whitespace:</p> <pre data-language="haskell">a ! b = ...   -- infix operator
a !b = ...    -- bang pattern
</pre> <p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a> for the precise rules.</p> </li> </ul>  <h3 id="strict-bindings">6.14.1.1. Strict bindings</h3> <p>The <code>BangPatterns</code> extension furthermore enables syntax for strict <code>let</code> or <code>where</code> bindings with <code>!pat = expr</code>. For example,</p> <pre data-language="haskell">let !x = e in body
let !(p,q) = e in body
</pre> <p>In both cases <code>e</code> is evaluated before starting to evaluate <code>body</code>.</p> <p>Note the following points:</p> <ul> <li>This form is not the same as a bang pattern: The declarations <code>f3 (x,y) = ...</code> and <code>f4 !(x,y) = ....</code> are equivalent (because the constructor pattern <code>(x,y)</code> forces the argument), but the expressions <code>let (p,q) = e in body</code> and <code>let !(p,q) = e in body</code> are different. The former will not evaluate <code>e</code> unless <code>p</code> or <code>q</code> is forced in <code>body</code>. </li> <li>
<p class="first">Only a top-level bang (perhaps under parentheses) makes the binding strict; otherwise, it is considered a normal bang pattern. For example,</p> <pre data-language="haskell">let (!x,[y]) = e in b
</pre> <p>is equivalent to this:</p> <pre data-language="haskell">let { t = case e of (x,[y]) -&gt; x `seq` (x,y)
      x = fst t
      y = snd t }
in b
</pre> <p>The binding is lazy, but when either <code>x</code> or <code>y</code> is evaluated by <code>b</code> the entire pattern is matched, including forcing the evaluation of <code>x</code>.</p> </li> <li>
<p class="first">Because the <code>!</code> in a strict binding is not a bang pattern, it must be visible without looking through pattern synonyms</p> <pre data-language="haskell">pattern Bang x &lt;- !x
f1 = let Bang x = y in ...
f2 = let !x     = y in ...  -- not equivalent to f1
</pre> </li> <li>Strict bindings are not allowed at the top level of a module. </li> <li>See <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Semantics of let bindings with bang patterns</span></a> for the detailed semantics, and the <a class="reference external" href="https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns">Haskell prime feature description</a> for more discussion and examples. </li> </ul>    <h2 id="strict-data">6.14.2. Strict-by-default data types</h2> <dl class="extension" id="strict-by-default-data-types"> <dt id="extension-StrictData">
<code>StrictData</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Make fields of data types defined in the current module strict by default.</p> </dd>
</dl> <p>Informally the <code>StrictData</code> language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a <code>~</code> in front of the field.</p> <p>When the user writes</p> <pre data-language="haskell">data T = C a
data T' = C' ~a
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">data T = C !a
data T' = C' a
</pre> <p>The extension only affects definitions in this module.</p> <p>The <code>~</code> annotation must be written in prefix form:</p> <pre data-language="haskell">data T = MkT ~Int   -- valid
data T = MkT ~ Int  -- invalid
</pre> <p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a> for the precise rules.</p>   <h2 id="strict">6.14.3. Strict-by-default pattern bindings</h2> <dl class="extension" id="strict-by-default-pattern-bindings"> <dt id="extension-Strict">
<code>Strict</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-StrictData"><code>StrictData</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Make bindings in the current module strict by default.</p> </dd>
</dl> <p>Informally the <code>Strict</code> language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding <code>~</code> in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding <code>!</code> in front of a variable.</p> <p><code>Strict</code> implies <a class="reference internal" href="#strict-data"><span class="std std-ref">StrictData</span></a>.</p> <ul> <li>
<p class="first"><strong>Function definitions</strong></p> <p>When the user writes</p> <pre data-language="haskell">f x = ...
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">f !x = ...
</pre> <p>Adding <code>~</code> in front of <code>x</code> gives the regular lazy behavior.</p> <p>Turning patterns into irrefutable ones requires <code>~(~p)</code> when <code>Strict</code> is enabled.</p> </li> <li>
<p class="first"><strong>Let/where bindings</strong></p> <p>When the user writes</p> <pre data-language="haskell">let x = ...
let pat = ...
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">let !x = ...
let !pat = ...
</pre> <p>Adding <code>~</code> in front of <code>x</code> gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with <code>~</code>.</p> </li> <li>
<p class="first"><strong>Pattern matching in case expressions, lambdas, do-notation, etc</strong></p> <p>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with <code>~</code>. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</p> <pre data-language="haskell">case x of (a,b) -&gt; rhs
</pre> <p>is interpreted as</p> <pre data-language="haskell">case x of !(a,b) -&gt; rhs
</pre> <p>Since the semantics of pattern matching in case expressions is strict, this usually has no effect whatsoever. But it does make a difference in the degenerate case of variables and newtypes. So</p> <pre data-language="haskell">case x of y -&gt; rhs
</pre> <p>is lazy in Haskell, but with <code>Strict</code> is interpreted as</p> <pre data-language="haskell">case x of !y -&gt; rhs
</pre> <p>which evaluates <code>x</code>. Similarly, if <code>newtype Age = MkAge Int</code>, then</p> <pre data-language="haskell">case x of MkAge i -&gt; rhs
</pre> <p>is lazy in Haskell; but with <code>Strict</code> the added bang makes it strict.</p> <p>Similarly</p> <pre data-language="haskell">\ x -&gt; body
do { x &lt;- rhs; blah }
[ e | x &lt;- rhs; blah }
</pre> <p>all get implicit bangs on the <code>x</code> pattern.</p> </li> <li>
<p class="first"><strong>Nested patterns</strong></p> <p>Notice that we do <em>not</em> put bangs on nested patterns. For example</p> <pre data-language="haskell">let (p,q) = if flob then (undefined, undefined) else (True, False)
in ...
</pre> <p>will behave like</p> <pre data-language="haskell">let !(p,q) = if flob then (undefined, undefined) else (True,False)
in ...
</pre> <p>which will strictly evaluate the right hand side, and bind <code>p</code> and <code>q</code> to the components of the pair. But the pair itself is lazy (unless we also compile the <code>Prelude</code> with <code>Strict</code>; see <a class="reference internal" href="#strict-modularity"><span class="std std-ref">Modularity</span></a> below). So <code>p</code> and <code>q</code> may end up bound to undefined. See also <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Dynamic semantics of bang patterns</span></a> below.</p> </li> <li>
<p class="first"><strong>Top level bindings</strong></p> <p>are unaffected by <code>Strict</code>. For example:</p> <pre data-language="haskell">x = factorial 20
(y,z) = if x &gt; 10 then True else False
</pre> <p>Here <code>x</code> and the pattern binding <code>(y,z)</code> remain lazy. Reason: there is no good moment to force them, until first use.</p> </li> <li>
<p class="first"><strong>Newtypes</strong></p> <p>There is no effect on newtypes, which simply rename existing types. For example:</p> <pre data-language="haskell">newtype T = C a
f (C x)  = rhs1
g !(C x) = rhs2
</pre> <p>In ordinary Haskell, <code>f</code> is lazy in its argument and hence in <code>x</code>; and <code>g</code> is strict in its argument and hence also strict in <code>x</code>. With <code>Strict</code>, both become strict because <code>f</code>’s argument gets an implicit bang.</p> </li> </ul>   <h2 id="strict-modularity">6.14.4. Modularity</h2> <p id="modularity"><code>Strict</code> and <code>StrictData</code> only affects definitions in the module they are used in. Functions and data types imported from other modules are unaffected. For example, we won’t evaluate the argument to <code>Just</code> before applying the constructor. Similarly we won’t evaluate the first argument to <code>Data.Map.findWithDefault</code> before applying the function.</p> <p>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</p> <p>Tuples, lists, <code>Maybe</code>, and all the other types from <code>Prelude</code> continue to have their existing, lazy, semantics.</p>   <h2 id="bang-patterns-sem">6.14.5. Dynamic semantics of bang patterns</h2> <p id="dynamic-semantics-of-bang-patterns">The semantics of Haskell pattern matching is described in <a class="reference external" href="https://www.haskell.org/onlinereport/exps.html#sect3.17.2">Section 3.17.2</a> of the Haskell Report. To this description add one extra item 10, saying:</p> <ul class="simple"> <li>Matching the pattern <code>!pat</code> against a value <code>v</code> behaves as follows:<ul> <li>if <code>v</code> is bottom, the match diverges</li> <li>otherwise, <code>pat</code> is matched against <code>v</code>
</li> </ul> </li> </ul> <p>Similarly, in Figure 4 of <a class="reference external" href="https://www.haskell.org/onlinereport/exps.html#sect3.17.3">Section 3.17.3</a>, add a new case (t):</p> <pre data-language="haskell">case v of { !pat -&gt; e; _ -&gt; e' }
   = v `seq` case v of { pat -&gt; e; _ -&gt; e' }
</pre> <p>That leaves let expressions, whose translation is given in <a class="reference external" href="https://www.haskell.org/onlinereport/exps.html#sect3.12">Section 3.12</a> of the Haskell Report. Replace the “Translation” there with the following one. Given <code>let { bind1 ... bindn } in body</code>:</p> <div class="admonition-force admonition"> <p class="first admonition-title">FORCE</p> <p class="last">Replace any binding <code>!p = e</code> with <code>v = case e of p -&gt; (x1, ..., xn); (x1, ..., xn) = v</code> and replace <code>body</code> with <code>v seq body</code>, where <code>v</code> is fresh. This translation works fine if <code>p</code> is already a variable <code>x</code>, but can obviously be optimised by not introducing a fresh variable <code>v</code>.</p> </div> <div class="admonition-split admonition"> <p class="first admonition-title">SPLIT</p> <p class="last">Replace any binding <code>p = e</code>, where <code>p</code> is not a variable, with <code>v = e; x1 = case v of p -&gt; x1; ...; xn = case v of p -&gt; xn</code>, where <code>v</code> is fresh and <code>x1</code>.. <code>xn</code> are the bound variables of <code>p</code>. Again if <code>e</code> is a variable, this can be optimised by not introducing a fresh variable.</p> </div> <p>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using <code>fix</code>, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</p> <p>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</p> <p>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</p> <p>Here is a simple non-recursive case:</p> <pre data-language="haskell">let x :: Int     -- Non-recursive
    !x = factorial y
in body

===&gt; (FORCE)
    let x = factorial y in x `seq` body

===&gt; (inline seq)
    let x = factorial y in case x of x -&gt; body

===&gt; (inline x)
    case factorial y of x -&gt; body
</pre> <p>Same again, only with a pattern binding:</p> <pre data-language="haskell">let !(Just x, Left y) = e in body

===&gt; (FORCE)
    let v = case e of (Just x, Left y) -&gt; (x,y)
        (x,y) = v
    in v `seq` body

===&gt; (SPLIT)
    let v = case e of (Just x, Left y) -&gt; (x,y)
        x = case v of (x,y) -&gt; x
        y = case v of (x,y) -&gt; y
    in v `seq` body

===&gt; (inline seq, float x,y bindings inwards)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v -&gt; let x = case v of (x,y) -&gt; x
                          y = case v of (x,y) -&gt; y
                      in body

===&gt; (fluff up v's pattern; this is a standard Core optimisation)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v@(p,q) -&gt; let x = case v of (x,y) -&gt; x
                                y = case v of (x,y) -&gt; y
                            in body

===&gt; (case of known constructor)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v@(p,q) -&gt; let x = p
                                y = q
                            in body

===&gt; (inline x,y, v)
    case (case e of (Just x, Left y) -&gt; (x,y) of
        (p,q) -&gt; body[p/x, q/y]

===&gt; (case of case)
    case e of (Just x, Left y) -&gt; body[p/x, q/y]
</pre> <p>The final form is just what we want: a simple case expression.</p> <p>Here is a recursive case</p> <pre data-language="haskell">letrec xs :: [Int]  -- Recursive
        !xs = factorial y : xs
in body

===&gt; (FORCE)
    letrec xs = factorial y : xs in xs `seq` body

===&gt; (inline seq)
    letrec xs = factorial y : xs in case xs of xs -&gt; body

===&gt; (eliminate case of value)
    letrec xs = factorial y : xs in body
</pre> <p>and a polymorphic one:</p> <pre data-language="haskell">let f :: forall a. [a] -&gt; [a]    -- Polymorphic
    !f = fst (reverse, True)
in body

===&gt; (FORCE)
    let f = /\a. fst (reverse a, True) in f `seq` body
===&gt; (inline seq, inline f)
    case (/\a. fst (reverse a, True)) of f -&gt; body
</pre> <p>Notice that the <code>seq</code> is added only in the translation to Core If we did it in Haskell source, thus</p> <pre data-language="haskell">let f = ... in f `seq` body
</pre> <p>then <code>f</code>’s polymorphic type would get instantiated, so the Core translation would be</p> <pre data-language="haskell">let f = ... in f Any `seq` body
</pre> <p>When overloading is involved, the results might be slightly counter intuitive:</p> <pre data-language="haskell">let f :: forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool    -- Overloaded
    !f = fst (member, True)
in body

===&gt; (FORCE)
    let f = /\a \(d::Eq a). fst (member, True) in f `seq` body

===&gt; (inline seq, case of value)
    let f = /\a \(d::Eq a). fst (member, True) in body
</pre> <p>Note that the bang has no effect at all in this case</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/strict.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/strict.html</a>
  </p>
</div>
