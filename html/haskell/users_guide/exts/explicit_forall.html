<h1 id="explicit-foralls">6.11.1. Explicit universal quantification (forall)</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="explicit-universal-quantification-forall"> <dt id="extension-ExplicitForAll">
<code>ExplicitForAll</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Allow use of the <code>forall</code> keyword in places where universal quantification is implicit.</p> </dd>
</dl> <p>Haskell type signatures are implicitly quantified. When the language option <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is used, the keyword <code>forall</code> allows us to say exactly what this means. For example:</p> <pre data-language="haskell">g :: b -&gt; b
</pre> <p>means this:</p> <pre data-language="haskell">g :: forall b. (b -&gt; b)
</pre> <p>The two are treated identically, except that the latter may bring type variables into scope (see <a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>).</p> <p>This extension also enables explicit quantification of type and kind variables in <a class="reference internal" href="type_families.html#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, <a class="reference internal" href="type_families.html#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>, <a class="reference internal" href="type_families.html#closed-type-families"><span class="std std-ref">Closed type families</span></a>, <a class="reference internal" href="type_families.html#assoc-inst"><span class="std std-ref">Associated instances</span></a>, and <a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>.</p> <p>Notes:</p> <ul> <li>
<p class="first">As well as in type signatures, you can also use an explicit <code>forall</code> in an instance declaration:</p> <pre data-language="haskell">instance forall a. Eq a =&gt; Eq [a] where ...
</pre> <p>Note that the use of <code>forall</code>s in instance declarations is somewhat restricted in comparison to other types. For example, instance declarations are not allowed to contain nested <code>forall</code>s. See <a class="reference internal" href="instances.html#formal-instance-syntax"><span class="std std-ref">Formal syntax for instance declaration types</span></a> for more information.</p> </li> <li>
<p class="first">If the <a class="reference internal" href="../using-warnings.html#ghc-flag--Wunused-foralls"><code>-Wunused-foralls</code></a> flag is enabled, a warning will be emitted when you write a type variable in an explicit <code>forall</code> statement that is otherwise unused. For instance:</p> <pre data-language="haskell">g :: forall a b. (b -&gt; b)
</pre> <p>would warn about the unused type variable <code>a</code>.</p> </li> </ul>  <h2 id="forall-or-nothing">6.11.1.1. The <code>forall</code>-or-nothing rule</h2> <p id="the-forall-or-nothing-rule">In certain forms of types, type variables obey what is known as the “<code>forall</code>-or-nothing” rule: if a type has an outermost, explicit, invisible <code>forall</code>, then all of the type variables in the type must be explicitly quantified. These two examples illustrate how the rule works:</p> <pre data-language="haskell">f  :: forall a b. a -&gt; b -&gt; b         -- OK, `a` and `b` are explicitly bound
g  :: forall a. a -&gt; forall b. b -&gt; b -- OK, `a` and `b` are explicitly bound
h  :: forall a. a -&gt; b -&gt; b           -- Rejected, `b` is not in scope
</pre> <p>The type signatures for <code>f</code>, <code>g</code>, and <code>h</code> all begin with an outermost invisible <code>forall</code>, so every type variable in these signatures must be explicitly bound by a <code>forall</code>. Both <code>f</code> and <code>g</code> obey the <code>forall</code>-or-nothing rule, since they explicitly quantify <code>a</code> and <code>b</code>. On the other hand, <code>h</code> does not explicitly quantify <code>b</code>, so GHC will reject its type signature for being improperly scoped.</p> <p>In places where the <code>forall</code>-or-nothing rule takes effect, if a type does <em>not</em> have an outermost invisible <code>forall</code>, then any type variables that are not explicitly bound by a <code>forall</code> become implicitly quantified. For example:</p> <pre data-language="haskell">i :: a -&gt; b -&gt; b             -- `a` and `b` are implicitly quantified
j :: a -&gt; forall b. b -&gt; b   -- `a` is implicitly quantified
k :: (forall a. a -&gt; b -&gt; b) -- `b` is implicitly quantified
type L :: forall a -&gt; b -&gt; b -- `b` is implicitly quantified
</pre> <p>GHC will accept <code>i</code>, <code>j</code>, and <code>k</code>’s type signatures, as well as <code>L</code>’s kind signature. Note that:</p> <ul class="simple"> <li>
<code>j</code>’s signature is accepted despite its mixture of implicit and explicit quantification. As long as a <code>forall</code> is not an outermost one, it is fine to use it among implicitly bound type variables.</li> <li>
<code>k</code>’s signature is accepted because the outermost parentheses imply that the <code>forall</code> is not an outermost <code>forall</code>. The <code>forall</code>-or-nothing rule is one of the few places in GHC where the presence or absence of parentheses can be semantically significant!</li> <li>
<code>L</code>’s signature begins with an outermost <code>forall</code>, but it is a <em>visible</em> <code>forall</code>, not an invisible <code>forall</code>, and therefore does not trigger the <code>forall</code>-or-nothing rule.</li> </ul> <p>The <code>forall</code>-or-nothing rule takes effect in the following places:</p> <ul class="simple"> <li>Type signature declarations for functions, values, and class methods</li> <li>Expression type annotations</li> <li>Instance declarations</li> <li><a class="reference internal" href="default_signatures.html#class-default-signatures"><span class="std std-ref">Default method signatures</span></a></li> <li>Type signatures in a <a class="reference internal" href="pragmas.html#specialize-pragma"><span class="std std-ref">SPECIALIZE pragma</span></a> or <a class="reference internal" href="pragmas.html#specialize-instance-pragma"><span class="std std-ref">SPECIALIZE instance pragma</span></a>
</li> <li><a class="reference internal" href="poly_kinds.html#standalone-kind-signatures"><span class="std std-ref">Standalone kind signatures and polymorphic recursion</span></a></li> <li>Type signatures for <a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a> constructors</li> <li>Type signatures for <a class="reference internal" href="pattern_synonyms.html#pattern-synonyms"><span class="std std-ref">Pattern synonyms</span></a>
</li> <li>
<a class="reference internal" href="type_families.html#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, <a class="reference internal" href="type_families.html#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>, <a class="reference internal" href="type_families.html#closed-type-families"><span class="std std-ref">Closed type families</span></a>, and <a class="reference internal" href="type_families.html#assoc-inst"><span class="std std-ref">Associated instances</span></a>
</li> <li>
<a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a> in which the type variables are explicitly quantified</li> </ul> <p>Notes:</p> <ul> <li>
<p class="first"><a class="reference internal" href="scoped_type_variables.html#pattern-type-sigs"><span class="std std-ref">Pattern type signatures</span></a> are a notable example of a place where types do <em>not</em> obey the <code>forall</code>-or-nothing rule. For example, GHC will accept the following:</p> <pre data-language="haskell">f (g :: forall a. a -&gt; b) x = g x :: b
</pre> <p>Furthermore, <a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a> do not obey the <code>forall</code>-or-nothing rule when their type variables are not explicitly quantified:</p> <pre data-language="haskell">{-# RULES "f" forall (g :: forall a. a -&gt; b) x. f g x = g x :: b #-}
</pre> </li> <li>
<p class="first">GADT constructors are extra particular about their <code>forall</code>s. In addition to adhering to the <code>forall</code>-or-nothing rule, GADT constructors also forbid nested <code>forall</code>s. For example, GHC would reject the following GADT:</p> <pre data-language="haskell">data T where
  MkT :: (forall a. a -&gt; b -&gt; T)
</pre> <p>Because of the lack of an outermost <code>forall</code> in the type of <code>MkT</code>, the <code>b</code> would be implicitly quantified. In effect, it would be as if one had written <code>MkT :: forall b. (forall a. a -&gt; b -&gt; T)</code>, which contains nested <code>forall</code>s. See <a class="reference internal" href="gadt_syntax.html#formal-gadt-syntax"><span class="std std-ref">Formal syntax for GADTs</span></a>.</p> </li> </ul>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/explicit_forall.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/explicit_forall.html</a>
  </p>
</div>
