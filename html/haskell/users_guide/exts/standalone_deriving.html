<h1 id="stand-alone-deriving">6.6.3. Stand-alone deriving declarations</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="stand-alone-deriving-declarations">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-StandaloneDeriving">
<code>StandaloneDeriving</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>6.8.1</p> </dd> <dt class="field-even">Status<span class="colon">:</span>
</dt> <dd class="field-even">
<p>Included in <a class="reference internal" href="control.html#extension-GHC2024"><code>GHC2024</code></a>, <a class="reference internal" href="control.html#extension-GHC2021"><code>GHC2021</code></a></p> </dd> </dl> <p>Allow the use of stand-alone <code>deriving</code> declarations.</p> </dd>
</dl> <p>GHC allows stand-alone <code>deriving</code> declarations, enabled by <a class="reference internal" href="#extension-StandaloneDeriving"><code>StandaloneDeriving</code></a>:</p> <pre data-language="haskell">data Foo a = Bar a | Baz String

deriving instance Eq a =&gt; Eq (Foo a)
</pre> <p>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword <code>deriving</code>, and (b) the absence of the <code>where</code> part.</p> <p>However, standalone deriving differs from a <code>deriving</code> clause in a number of important ways:</p> <ul> <li>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (<a class="reference internal" href="../separate_compilation.html#orphan-modules"><span class="std std-ref">Orphan modules and instance declarations</span></a>).</li> <li>
<p>In most cases, you must supply an explicit context (in the example the context is <code>(Eq a)</code>), exactly as you would in an ordinary instance declaration. (In contrast, in a <code>deriving</code> clause attached to a data type declaration, the context is inferred.)</p> <p>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</p> <pre data-language="haskell">deriving instance _ =&gt; Eq (Foo a)
</pre> <p>This is essentially the same as if you had written <code>deriving Eq</code> after the declaration for <code>data Foo a</code>. Using this feature requires the use of <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> (<a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>).</p> </li> <li>
<p>Unlike a <code>deriving</code> declaration attached to a <code>data</code> declaration, the instance can be more specific than the data type (assuming you also use <a class="reference internal" href="instances.html#extension-FlexibleInstances"><code>FlexibleInstances</code></a>, <a class="reference internal" href="instances.html#instance-rules"><span class="std std-ref">Instance termination rules</span></a>). Consider for example</p> <pre data-language="haskell">data Foo a = Bar a | Baz String

deriving instance Eq a =&gt; Eq (Foo [a])
deriving instance Eq a =&gt; Eq (Foo (Maybe a))
</pre> <p>This will generate a derived instance for <code>(Foo [a])</code> and <code>(Foo (Maybe a))</code>, but other types such as <code>(Foo (Int,Bool))</code> will not be an instance of <code>Eq</code>.</p> </li> <li>
<p>Unlike a <code>deriving</code> declaration attached to a <code>data</code> declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</p> <p>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</p> <pre data-language="haskell">data T a where
   T1 :: T Int
   T2 :: T Bool

deriving instance Show (T a)
</pre> <p>In this example, you cannot say <code>... deriving( Show )</code> on the data type declaration for <code>T</code>, because <code>T</code> is a GADT, but you <em>can</em> generate the instance declaration using stand-alone deriving.</p> <p>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a <code>deriving</code> clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</p> </li> <li>
<p>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</p> <p>The one exception to this rule is <a class="reference internal" href="derive_any_class.html#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a>, since deriving an instance via <a class="reference internal" href="derive_any_class.html#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> simply generates an empty instance declaration, which does not require the use of any constructors. See the <a class="reference external" href="#derive-any-class">deriving any class</a> section for more details.</p> </li> </ul> <p>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</p> <ul> <li>A <code>deriving instance</code> declaration must obey the same rules concerning form and termination as ordinary instance declarations, controlled by the same flags; see <a class="reference internal" href="instances.html#instance-decls"><span class="std std-ref">Instance declarations and resolution</span></a>.</li> <li>
<p>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary <code>deriving</code> clauses are generalised (<a class="reference internal" href="newtype_deriving.html#newtype-deriving"><span class="std std-ref">Generalised derived instances for newtypes</span></a>). For example:</p> <pre data-language="haskell">newtype Foo a = MkFoo (State Int a)

deriving instance MonadState Int Foo
</pre> <p>GHC always treats the <em>last</em> parameter of the instance (<code>Foo</code> in this example) as the type whose instance is being derived.</p> </li> </ul> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/standalone_deriving.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/standalone_deriving.html</a>
  </p>
</div>
