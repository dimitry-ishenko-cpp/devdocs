<h1 id="id1">6.4.20. Impredicative polymorphism</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="impredicative-polymorphism">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-ImpredicativeTypes">
<code>ImpredicativeTypes</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Implies<span class="colon">:</span>
</dt> <dd class="field-odd">
<p><a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code>RankNTypes</code></a></p> </dd> <dt class="field-even">Since<span class="colon">:</span>
</dt> <dd class="field-even">
<p>9.2.1 (unreliable in 6.10 - 9.0)</p> </dd> </dl> <p>Allow impredicative polymorphic types.</p> </dd>
</dl> <p>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</p> <pre data-language="haskell">runST :: (forall s. ST s a) -&gt; a
id :: forall b. b -&gt; b

foo = id runST   -- Rejected
</pre> <p>The definition of <code>foo</code> is rejected because one would have to instantiate <code>id</code>'s type with <code>b := (forall s. ST s a) -&gt; a</code>, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called <em>impredicative polymorphism</em>.</p> <p>GHC has robust support for <em>impredicative polymorphism</em>, enabled with <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a>, using the so-called Quick Look inference algorithm. It is described in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/a-quick-look-at-impredicativity/">A quick look at impredicativity</a> (Serrano et al, ICFP 2020).</p> <p>Switching on <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a></p> <ul class="simple"> <li>Switches on <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code>RankNTypes</code></a>
</li> <li>Allows user-written types to have foralls under type constructors, not just under arrows. For example <code>f :: Maybe (forall a. [a] -&gt; [a])</code> is a legal type signature.</li> <li>Allows polymorphic types in Visible Type Application (when <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a> is enabled). For example, you can write <code>reverse @(forall b. b-&gt;b) xs</code>. Using VTA with a polymorphic type argument is useful in cases when Quick Look cannot infer the correct instantiation.</li> <li>Switches on the Quick Look type inference algorithm, as described in the paper. This allows the compiler to infer impredicative instantiations of polymorphic functions in many cases. For example, <code>reverse xs</code> will typecheck even if <code>xs :: [forall a. a-&gt;a]</code>, by instantiating <code>reverse</code> at type <code>forall a. a-&gt;a</code>.</li> </ul> <p>Note that the treatment of type-class constraints and implicit parameters remains entirely monomorphic, even with ImpredicativeTypes. Specifically:</p> <ul class="simple"> <li>You cannot apply a type class to a polymorphic type. This is illegal: <code>f :: C (forall a. a-&gt;a) =&gt; [a] -&gt; [a]</code>
</li> <li>You cannot give an instance declaration with a polymorphic argument. This is illegal: <code>instance C (forall a. a-&gt;a)</code>
</li> <li>An implicit parameter cannot have a polymorphic type: <code>g :: (?x :: forall a. a-&gt;a) =&gt; [a] -&gt; [a]</code>
</li> </ul> <p>For many years GHC has a special case for the function <code>($)</code>, that allows it to typecheck an application like <code>runST $ (do { ... })</code>, even though that instantiation may be impredicative. This special case remains: even without <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a> GHC switches on Quick Look for applications of <code>($)</code>.</p> <p>This flag was available in earlier versions of GHC (6.10.1 - 9.0), but the behavior was unpredictable and not officially supported.</p> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/impredicative_types.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/impredicative_types.html</a>
  </p>
</div>
