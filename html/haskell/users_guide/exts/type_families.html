<h1 id="id1">6.4.9. Type families</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="type-families">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-TypeFamilies">
<code>TypeFamilies</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Implies<span class="colon">:</span>
</dt> <dd class="field-odd">
<p><a class="reference internal" href="let_generalisation.html#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>, <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a>, <a class="reference internal" href="explicit_namespaces.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></p> </dd> <dt class="field-even">Implied by<span class="colon">:</span>
</dt> <dd class="field-even">
<p><a class="reference internal" href="#extension-TypeFamilyDependencies"><code>TypeFamilyDependencies</code></a></p> </dd> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>6.8.1</p> </dd> </dl> <p>Allow use and definition of indexed type and data families.</p> </dd>
</dl> <p>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types <a class="reference internal" href="#assocdatatypes2005" id="id2"><span>[AssocDataTypes2005]</span></a> and associated type synonyms <a class="reference internal" href="#assoctypesyn2005" id="id3"><span>[AssocTypeSyn2005]</span></a> Type families themselves are described in Schrijvers 2008 <a class="reference internal" href="#typefamilies2008" id="id4"><span>[TypeFamilies2008]</span></a>. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</p> <p>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</p> <p>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</p> <p>Type families are enabled by the language extension <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a>. Additional information on the use of type families in GHC is available on <a class="reference external" href="https://www.haskell.org/haskellwiki/GHC/Indexed_types">the Haskell wiki page on type families</a>.</p> <div role="list" class="citation-list"> <div class="citation" id="assocdatatypes2005" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">AssocDataTypes2005</a><span class="fn-bracket">]</span></span> <p>“<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/assoc.pdf">Associated Types with Class</a>”, M. Chakravarty, G. Keller, S. Peyton Jones, and S. Marlow. In Proceedings of “The 32nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’05)”, pages 1-13, ACM Press, 2005.</p> </div> <div class="citation" id="assoctypesyn2005" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">AssocTypeSyn2005</a><span class="fn-bracket">]</span></span> <p>“<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/at-syns.pdf">Associated Type Synonyms</a>”, M. Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of “The Tenth ACM SIGPLAN International Conference on Functional Programming”, ACM Press, pages 241-253, 2005.</p> </div> <div class="citation" id="typefamilies2008" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">TypeFamilies2008</a><span class="fn-bracket">]</span></span> <p>“<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2008/01/icfp2008.pdf">Type Checking with Open Type Functions</a>”, T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in Proceedings of “ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming”, ACM Press, pages 51-62, 2008.</p> </div> </div> <section id="data-families"> <h2 id="id5">
<span class="section-number">6.4.9.1. </span>Data families</h2> <p>Data families appear in two flavours: (1) they can be defined on the toplevel or (2) they can appear inside type classes (in which case they are known as associated types). The former is the more general variant, as it lacks the requirement for the type-indexes to coincide with the class parameters. However, the latter can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel form first and then cover the additional constraints placed on associated types.</p> <section id="data-family-declarations"> <h3 id="id6">
<span class="section-number">6.4.9.1.1. </span>Data family declarations</h3> <p>Indexed data families are introduced by a signature, such as</p> <pre data-language="haskell">data family GMap k :: Type -&gt; Type
</pre> <p>The special <code>family</code> distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to <code>Type</code> if omitted. An example is</p> <pre data-language="haskell">data family Array e
</pre> <p>Named arguments can also be given explicit kind signatures if needed. Just as with <a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">GADT declarations</span></a> named arguments are entirely optional, so that we can declare <code>Array</code> alternatively with</p> <pre data-language="haskell">data family Array :: Type -&gt; Type
</pre> <p>Unlike with ordinary data definitions, the result kind of a data family does not need to be <code>Type</code>. It can alternatively be:</p> <ul> <li>
<p>Of the form <code>TYPE r</code> for some <code>r</code> (see <a class="reference internal" href="representation_polymorphism.html#runtime-rep"><span class="std std-ref">Representation polymorphism</span></a>). For example:</p> <pre data-language="haskell">data family DF1 :: TYPE IntRep
data family DF2 (r :: RuntimeRep)  :: TYPE r
data family DF3 :: Type -&gt; TYPE WordRep
</pre> </li> <li>
<p>A bare kind variable (with <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code>PolyKinds</code></a> enabled). For example:</p> <pre data-language="haskell">data family DF4 :: k
data family DF5 (a :: k) :: k
data family DF6 :: (k -&gt; Type) -&gt; k
</pre> </li> </ul> <p>Data instances’ kinds must end in <code>Type</code>, however. This restriction is slightly relaxed when the <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> extension is enabled, as it permits a <code>newtype instance</code>’s kind to end in <code>TYPE r</code> for some <code>r</code>.</p> </section> <section id="data-instance-declarations"> <h3 id="id7">
<span class="section-number">6.4.9.1.2. </span>Data instance declarations</h3> <p>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword <code>data</code> or <code>newtype</code> is followed by <code>instance</code> and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the <code>Either</code> instance for <code>GMap</code> is</p> <pre data-language="haskell">data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
</pre> <p>In this example, the declaration has only one variant. In general, it can be any number.</p> <p>When <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</p> <pre data-language="haskell">data instance forall a (b :: Proxy a). F (Proxy b) = FProxy Bool
</pre> <p>When an explicit <code>forall</code> is present, <em>all</em> type and kind variables mentioned which are not already in scope must be bound by the <code>forall</code>:</p> <pre data-language="haskell">data instance forall   (a :: k). F a = FOtherwise  -- rejected: k not in scope
data instance forall k (a :: k). F a = FOtherwise  -- accepted
</pre> <p>When the flag <a class="reference internal" href="../using-warnings.html#ghc-flag-Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (<code>_x</code>) are otherwise treated as ordinary type variables.</p> <p>This resembles the wildcards that can be used in <a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> have any effect.</p> <p>A type or kind variable explicitly bound using <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> but not used on the left hand side will generate an error, not a warning.</p> <p>Data and newtype instance declarations are only permitted when an appropriate family declaration is in scope - just as a class instance declaration requires the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration. This implies that the number of parameters of an instance declaration matches the arity determined by the kind of the family.</p> <p>A data family instance declaration can use the full expressiveness of ordinary <code>data</code> or <code>newtype</code> declarations:</p> <ul> <li>
<p>Although, a data family is <em>introduced</em> with the keyword “<code>data</code>”, a data family <em>instance</em> can use either <code>data</code> or <code>newtype</code>. For example:</p> <pre data-language="haskell">data family T a
data    instance T Int  = T1 Int | T2 Bool
newtype instance T Char = TC Bool
</pre> </li> <li>
<p>A <code>data instance</code> can use GADT syntax for the data constructors, and indeed can define a GADT. For example:</p> <pre data-language="haskell">data family G a b
data instance G [a] b where
   G1 :: c -&gt; G [Int] b
   G2 :: G [a] Bool
</pre> </li> <li>You can use a <code>deriving</code> clause on a <code>data instance</code> or <code>newtype instance</code> declaration.</li> </ul> <p>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</p> <pre data-language="haskell">data family T a
data instance T Int  = A
data instance T Char = B
foo :: T a -&gt; Int
foo A = 1
foo B = 2
</pre> <p>Instead, you would have to write <code>foo</code> as a class operation, thus:</p> <pre data-language="haskell">class Foo a where
  foo :: T a -&gt; Int
instance Foo Int where
  foo A = 1
instance Foo Char where
  foo B = 2
</pre> <p>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are <em>open;</em> i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</p> </section> <section id="overlap-of-data-instances"> <h3 id="data-family-overlap">
<span class="section-number">6.4.9.1.3. </span>Overlap of data instances</h3> <p>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</p> </section> </section> <section id="synonym-families"> <h2 id="id8">
<span class="section-number">6.4.9.2. </span>Synonym families</h2> <p>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</p> <section id="type-family-declarations"> <h3 id="id9">
<span class="section-number">6.4.9.2.1. </span>Type family declarations</h3> <p>Open indexed type families are introduced by a signature, such as</p> <pre data-language="haskell">type family Elem c :: Type
</pre> <p>The special <code>family</code> distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to <code>Type</code> if omitted. An example is</p> <pre data-language="haskell">type family Elem c
</pre> <p>Parameters can also be given explicit kind signatures if needed. We call the number of parameters in a type family declaration, the family’s arity, and all applications of a type family must be fully saturated with respect to that arity. This requirement is unlike ordinary type synonyms and it implies that the kind of a type family is not sufficient to determine a family’s arity, and hence in general, also insufficient to determine whether a type family application is well formed. As an example, consider the following declaration:</p> <pre data-language="haskell">type family F a b :: Type -&gt; Type
  -- F's arity is 2,
  -- although its overall kind is Type -&gt; Type -&gt; Type -&gt; Type
</pre> <p>Given this declaration the following are examples of well-formed and malformed types:</p> <pre data-language="haskell">F Char [Int]       -- OK!  Kind: Type -&gt; Type
F Char [Int] Bool  -- OK!  Kind: Type
F IO Bool          -- WRONG: kind mismatch in the first argument
F Bool             -- WRONG: unsaturated application
</pre> <p>The result kind annotation is optional and defaults to <code>Type</code> (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</p> <pre data-language="haskell">type family F a :: k
</pre> <p>In this case the kind parameter <code>k</code> is actually an implicit parameter of the type family.</p> <p>At definition site, the arity determines what inputs can be matched on:</p> <pre data-language="haskell">data PT (a :: Type)

type family F1 :: k -&gt; Type
type instance F1 = PT
  -- OK, 'k' can be matched on.

type family F0 :: forall k. k -&gt; Type
type instance F0 = PT
  -- Error:
  --   • Expected kind ‘forall k. k -&gt; Type’,
  --       but ‘PT’ has kind ‘Type -&gt; Type’
  --   • In the type ‘PT’
  --     In the type instance declaration for ‘F0’
</pre> <p>Both <code>F1</code> and <code>F0</code> have kind <code>forall k. k -&gt; Type</code>, but their arity differs.</p> <p>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</p> <pre data-language="haskell">type HRK (f :: forall k. k -&gt; Type) = (f Int, f Maybe, f True)

type H1 = HRK F0  -- OK
type H2 = HRK F1
  -- Error:
  --   • Expected kind ‘forall k. k -&gt; Type’,
  --       but ‘F1’ has kind ‘k0 -&gt; Type’
  --   • In the first argument of ‘HRK’, namely ‘F1’
  --     In the type ‘HRK F1’
  --     In the type declaration for ‘H2’
</pre> <p>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</p> </section> <section id="type-instance-declarations"> <h3 id="id10">
<span class="section-number">6.4.9.2.2. </span>Type instance declarations</h3> <p>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword <code>type</code> is followed by <code>instance</code> and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the <code>[e]</code> instance for <code>Elem</code> is</p> <pre data-language="haskell">type instance Elem [e] = e
</pre> <p>Type arguments can be replaced with underscores (<code>_</code>) if the names of the arguments don’t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the <a class="reference internal" href="../using-warnings.html#ghc-flag-Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> flag is enabled. The same rules apply as for <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>.</p> <p>Also in the same way as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, when <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type and kind variables can be explicitly bound in a type instance declaration.</p> <p>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</p> </section> <section id="closed-type-families"> <h3 id="id11">
<span class="section-number">6.4.9.2.3. </span>Closed type families</h3> <p>A type family can also be declared with a <code>where</code> clause, defining the full set of equations for that family. For example:</p> <pre data-language="haskell">type family F a where
  F Int  = Double
  F Bool = Char
  F a    = String
</pre> <p>A closed type family’s equations are tried in order, from top to bottom, when simplifying a type family application. In this example, we declare an instance for <code>F</code> such that <code>F Int</code> simplifies to <code>Double</code>, <code>F Bool</code> simplifies to <code>Char</code>, and for any other type <code>a</code> that is known not to be <code>Int</code> or <code>Bool</code>, <code>F a</code> simplifies to <code>String</code>. Note that GHC must be sure that <code>a</code> cannot unify with <code>Int</code> or <code>Bool</code> in that last case; if a programmer specifies just <code>F a</code> in their code, GHC will not be able to simplify the type. After all, <code>a</code> might later be instantiated with <code>Int</code>.</p> <p>A closed type family’s equations have the same restrictions and extensions as the equations for open type family instances. For instance, when <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type or kind variables used on the left hand side of an equation can be explicitly bound, such as in:</p> <pre data-language="haskell">type family R a where
  forall t a. R (t a) = [a]
  forall a.   R a     = a
</pre> <p>A closed type family may be declared with no equations. Such closed type families are opaque type-level definitions that will never reduce, are not necessarily injective (unlike empty data types), and cannot be given any instances.</p> <p>In an <code>hs-boot</code> file, closed type families must either have the same equations as those in the source file, or you can use the following syntax to omit the equations (note the literal <code>..</code>)</p> <pre data-language="haskell">type family R a where ..
</pre> <p>In this case, the closed type family <code>R</code> matching this “boot” declaration may have any number of equations given in the source <code>hs</code> file (including zero). For more information on mutual recursive modules with <code>hs-boot</code> modules (including type families) see <a class="reference internal" href="../separate_compilation.html#mutual-recursion"><span class="std std-ref">Mutually recursive modules and hs-boot files</span></a>.</p> </section> <section id="type-family-examples"> <h3 id="id12">
<span class="section-number">6.4.9.2.4. </span>Type family examples</h3> <p>Here are some examples of admissible and illegal type instances:</p> <pre data-language="haskell">type family F a :: Type
type instance F [Int]   = Int   -- OK!
type instance F String  = Char  -- OK!
type instance F (F a)   = a     -- WRONG: type parameter mentions a type family
type instance
  F (forall a. (a, b))  = b     -- WRONG: a forall type appears in a type parameter
type instance
  F Float = forall a.a          -- WRONG: right-hand side may not be a forall type
type family H a where          -- OK!
  H Int  = Int
  H Bool = Bool
  H a    = String
type instance H Char = Char    -- WRONG: cannot have instances of closed family
type family K a where          -- OK!

type family G a b :: Type -&gt; Type
type instance G Int            = (,)     -- WRONG: must be two type parameters
type instance G Int Char Float = Double  -- WRONG: must be two type parameters
</pre> </section> <section id="compatibility-and-apartness-of-type-family-equations"> <h3 id="type-family-overlap">
<span class="section-number">6.4.9.2.5. </span>Compatibility and apartness of type family equations</h3> <p>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</p> <ol class="arabic simple"> <li>all corresponding types and implicit kinds in the patterns are apart, or</li> <li>the two patterns unify producing a substitution, and the right-hand sides are equal under that substitution.</li> </ol> <p>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</p> <p>The first clause of “compatible” is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</p> <pre data-language="haskell">type instance F Int = Bool
type instance F Int = Char
</pre> <p>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</p> <pre data-language="haskell">type instance F (a, Int) = [a]
type instance F (Int, b) = [b]   -- overlap permitted

type instance G (a, Int)  = [a]
type instance G (Char, a) = [a]  -- ILLEGAL overlap, as [Char] /= [Int]
</pre> <p>Note that this compatibility condition is independent of whether the type family is associated or not, and it is not only a matter of consistency, but one of type safety.</p> <p>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</p> <pre data-language="haskell">type family J a :: k
type instance J Int = Bool
type instance J Int = Maybe
</pre> <p>These instances are compatible because they differ in their implicit kind parameter; the first uses <code>Type</code> while the second uses <code>Type -&gt; Type</code>.</p> <p>The definition for “compatible” uses a notion of “apart”, whose definition in turn relies on type family reduction. This condition of “apartness”, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</p> <pre data-language="haskell">type instance H x   x = Int
type instance H [x] x = Bool
</pre> <p>The type patterns in this pair equal if <code>x</code> is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</p> <p>Compatibility also affects closed type families. When simplifying an application of a closed type family, GHC will select an equation only when it is sure that no incompatible previous equation will ever apply. Here are some examples:</p> <pre data-language="haskell">type family F a where
  F Int = Bool
  F a   = Char

type family G a where
  G Int = Int
  G a   = a
</pre> <p>In the definition for <code>F</code>, the two equations are incompatible – their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type <code>F a</code> does not simplify; only a type such as <code>F Double</code> will simplify to <code>Char</code>. In <code>G</code>, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, <code>G a</code> will simplify to <code>a</code>.</p> <p>Incompatibilities between closed type family equations can be displayed in <a class="reference internal" href="../ghci.html#ghci-cmd-info"><code>:info</code></a> when <a class="reference internal" href="../using.html#ghc-flag-fprint-axiom-incomps"><code>-fprint-axiom-incomps</code></a> is enabled.</p> <p>However see <a class="reference internal" href="../ghci.html#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a> for the overlap rules in GHCi.</p> </section> <section id="decidability-of-type-synonym-instances"> <h3 id="type-family-decidability">
<span class="section-number">6.4.9.2.6. </span>Decidability of type synonym instances</h3> <p>In order to guarantee that type inference in the presence of type families is decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of “<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2008/01/icfp2008.pdf">Type Checking with Open Type Functions</a>”). Instance declarations have the general form</p> <pre data-language="haskell">type instance F t1 .. tn = t
</pre> <p>where we require that for every type family application <code>(G s1 .. sm)</code> in <code>t</code>,</p> <ol class="arabic simple"> <li>
<code>s1 .. sm</code> do not contain any type family constructors,</li> <li>the total number of symbols (data type constructors and type variables) in <code>s1 .. sm</code> is strictly smaller than in <code>t1 .. tn</code>, and</li> <li>for every type variable <code>a</code>, <code>a</code> occurs in <code>s1 .. sm</code> at most as often as in <code>t1 .. tn</code>.</li> </ol> <p>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, ‘’loopy equalities’’, such as <code>a ~ [F a]</code>, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</p> <p>If the option <a class="reference internal" href="instances.html#extension-UndecidableInstances"><code>UndecidableInstances</code></a> is passed to the compiler (see <a class="reference internal" href="instances.html#undecidable-instances"><span class="std std-ref">Undecidable instances and loopy superclasses</span></a>), the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</p> </section> <section id="reducing-type-family-applications"> <h3>
<span class="section-number">6.4.9.2.7. </span>Reducing type family applications</h3> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ffamily-application-cache">
<code>-ffamily-application-cache</code> </dt> <dd>
<p>The flag <a class="reference internal" href="#ghc-flag-ffamily-application-cache"><code>-ffamily-application-cache</code></a> (on by default) instructs GHC to use a cache when reducing type family applications. In most cases, this will speed up compilation. The use of this flag will not affect runtime behaviour.</p> </dd>
</dl> <p>When GHC encounters a type family application (like <code>F Int a</code>) in a program, it must often reduce it in order to complete type checking. Here is a simple example:</p> <pre data-language="haskell">type family F a where
  F Int            = Bool
  F (Maybe Double) = Char

g :: F Int -&gt; Bool
g = not
</pre> <p>Despite the fact that <code>g</code>'s type mentions <code>F Int</code>, GHC must recognize that <code>g</code>'s argument really has type <code>Bool</code>. This is done by <em>reducing</em> <code>F Int</code> to become <code>Bool</code>. Sometimes, there is not enough information to reduce a type family application; we say such an application is <em>stuck</em>. Continuing this example, an occurrence of <code>F (Maybe a)</code> (for some type variable <code>a</code>) would be stuck, as no equation applies.</p> <p>During type checking, GHC uses heuristics to determine which type family application to reduce next; there is no predictable ordering among different type family applications. The non-determinism rarely matters in practice. In most programs, type family reduction terminates, and so these choices are immaterial. However, if a type family application does not terminate, it is possible that type-checking may unpredictably diverge. (GHC will always take the same path for a given source program, but small changes in that source program may induce GHC to take a different path. Compiling a given, unchanged source program is still deterministic.)</p> <p>In order to speed up type family reduction, GHC normally uses a cache, remembering what type family applications it has previously reduced. This feature can be disabled with <a class="reference internal" href="#ghc-flag--ffamily-application-cache"><code>-fno-family-application-cache</code></a>.</p> </section> </section> <section id="wildcards-on-the-lhs-of-data-and-type-family-instances"> <h2 id="type-wildcards-lhs">
<span class="section-number">6.4.9.3. </span>Wildcards on the LHS of data and type family instances</h2> <p>When the name of a type argument of a data or type instance declaration doesn’t matter, it can be replaced with an underscore (<code>_</code>). This is the same as writing a type variable with a unique name.</p> <pre data-language="haskell">data family F a b :: Type
data instance F Int _ = Int
-- Equivalent to  data instance F Int b = Int

type family T a :: Type
type instance T (a,_) = a
-- Equivalent to  type instance T (a,b) = a
</pre> <p>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see <a class="reference internal" href="partial_type_signatures.html#type-wildcards"><span class="std std-ref">Type Wildcards</span></a>).</p> <p>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</p> <pre data-language="haskell">data instance F Bool _a = _a -&gt; Int
-- Equivalent to  data instance F Bool a = a -&gt; Int
</pre> <p>Contrast this with the special treatment of named wildcards in type signatures (<a class="reference internal" href="partial_type_signatures.html#named-wildcards"><span class="std std-ref">Named Wildcards</span></a>).</p> </section> <section id="associated-data-and-type-families"> <h2 id="assoc-decl">
<span class="section-number">6.4.9.4. </span>Associated data and type families</h2> <p>A data or type synonym family can be declared as part of a type class, thus:</p> <pre data-language="haskell">class GMapKey k where
  data GMap k :: Type -&gt; Type
  ...

class Collects ce where
  type Elem ce :: Type
  ...
</pre> <p>When doing so, we (optionally) may drop the “<code>family</code>” keyword.</p> <p>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</p> <pre data-language="haskell">class C a b c where
  type T c a x :: Type
</pre> <p>Here <code>c</code> and <code>a</code> are class parameters, but the type is also indexed on a third parameter <code>x</code>.</p> <section id="associated-instances"> <h3 id="assoc-inst">
<span class="section-number">6.4.9.4.1. </span>Associated instances</h3> <p>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the <code>instance</code> keyword in the family instance:</p> <pre data-language="haskell">instance (GMapKey a, GMapKey b) =&gt; GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...

instance Eq (Elem [e]) =&gt; Collects [e] where
  type Elem [e] = e
  ...
</pre> <p>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must be precisely the same as types given in the instance head. For example:</p> <pre data-language="haskell">class Collects ce where
  type Elem ce :: Type

instance Eq (Elem [e]) =&gt; Collects [e] where
  -- Choose one of the following alternatives:
  type Elem [e] = e       -- OK
  type Elem [x] = x       -- BAD; '[x]' is different to '[e]' from head
  type Elem x   = x       -- BAD; 'x' is different to '[e]'
  type Elem [Maybe x] = x -- BAD: '[Maybe x]' is different to '[e]'
</pre> <p>Note the following points:</p> <ul> <li>An instance for an associated family can only appear as part of an instance declarations of the class in which the family was declared, just as with the equations of the methods of a class.</li> <li>
<p>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for <em>kind</em> variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</p> <pre data-language="haskell">data family Nat :: k -&gt; k -&gt; Type
-- k is implicitly bound by an invisible kind pattern
newtype instance Nat :: (k -&gt; Type) -&gt; (k -&gt; Type) -&gt; Type where
  Nat :: (forall xx. f xx -&gt; g xx) -&gt; Nat f g

class Funct f where
  type Codomain f :: Type
instance Funct ('KProxy :: KProxy o) where
  -- o is implicitly bound by the kind signature
  -- of the LHS type pattern ('KProxy)
  type Codomain 'KProxy = NatTr (Proxy :: o -&gt; Type)
</pre> </li> <li>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see <a class="reference internal" href="#assoc-decl-defs"><span class="std std-ref">Associated type synonym defaults</span></a>), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as <code>undefined</code>, can assume the type.</li> <li>
<p>Although it is unusual, there (currently) can be <em>multiple</em> instances for an associated family in a single instance declaration. For example, this is legitimate:</p> <pre data-language="haskell">instance GMapKey Flob where
  data GMap Flob [v] = G1 v
  data GMap Flob Int = G2 Int
  ...
</pre> <p>Here we give two data instance declarations, one in which the last parameter is <code>[v]</code>, and one for which it is <code>Int</code>. Since you cannot give any <em>subsequent</em> instances for <code>(GMap Flob ...)</code>, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike <code>Type</code>).</p> </li> <li>
<p>When <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type and kind variables can be explicitly bound in associated data or type family instances in the same way (and with the same restrictions) as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a> or <a class="reference internal" href="#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>. For example, adapting the above, the following is accepted:</p> <pre data-language="haskell">instance Eq (Elem [e]) =&gt; Collects [e] where
  type forall e. Elem [e] = e
</pre> </li> </ul> </section> <section id="associated-type-synonym-defaults"> <h3 id="assoc-decl-defs">
<span class="section-number">6.4.9.4.2. </span>Associated type synonym defaults</h3> <p>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</p> <pre data-language="haskell">class IsBoolMap v where
  type Key v
  type instance Key v = Int

  lookupKey :: Key v -&gt; v -&gt; Maybe Bool

instance IsBoolMap [(Int, Bool)] where
  lookupKey = lookup
</pre> <p>In an <code>instance</code> declaration for the class, if no explicit <code>type instance</code> declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</p> <p>Note the following points:</p> <ul> <li>The <code>instance</code> keyword is optional.</li> <li>There can be at most one default declaration for an associated type synonym.</li> <li>A default declaration is not permitted for an associated <em>data</em> type.</li> <li>
<p>The default declaration must mention only type <em>variables</em> on the left hand side, and type variables may not be repeated on the left-hand side. The right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for <em>kind</em> variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</p> <p>Like with <a class="reference internal" href="#assoc-inst"><span class="std std-ref">Associated instances</span></a>, it is possible to explicitly bind type and kind variables in default declarations with a <code>forall</code> by using the <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> language extension.</p> </li> <li>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</li> </ul> <p>Here are some examples:</p> <pre data-language="haskell">class C (a :: Type) where
  type F1 a :: Type
  type instance F1 a = [a]     -- OK
  type instance F1 a = a-&gt;a    -- BAD; only one default instance is allowed

  type F2 b a                  -- OK; note the family has more type
                               --     variables than the class
  type instance F2 c d = c-&gt;d  -- OK; you don't have to use 'a' in the type instance

  type F3 a
  type F3 [b] = b              -- BAD; only type variables allowed on the
                               --      LHS, and the argument to F3 is
                               --      instantiated to [b], which is not
                               --      a bare type variable

  type F4 x y
  type F4 x x = x              -- BAD; the type variable x is repeated on
                               --      the LHS

  type F5 a
  type F5 b = a                -- BAD; 'a' is not in scope  in the RHS

  type F6 a :: [k]
  type F6 a = ('[] :: [x])     -- OK; the kind variable x is implicitly
                               --     bound by an invisible kind pattern
                               --     on the LHS

  type F7 a
  type F7 a =
    Proxy ('[] :: [x])         -- BAD; the kind variable x is not bound,
                               --      even by an invisible kind pattern

  type F8 (x :: a) :: [a]
  type F8 x = ('[] :: [a])     -- OK; the kind variable a is implicitly
                               --     bound by the kind signature of the
                               --     LHS type pattern

  type F9 (a :: k)
  type F9 a = Maybe a          -- BAD; the kind variable k is
                               --      instantiated to Type, which is not
                               --      a bare kind variable

  type F10 (a :: j) (b :: k)
  type F10 (a :: z) (b :: z)
    = Proxy a                  -- BAD; the kind variable z is repeated,
                               --      as both j and k are instantiated to z

  type F11 a b
  type forall a b. F11 a b = a -- OK; LHS type variables can be
                               --     explicitly bound with 'forall'

  type F12 (a :: k)
  type F12 @k a = Proxy a      -- OK; visible kind application syntax is
                               --     permitted in default declarations
</pre> </section> <section id="scoping-of-class-parameters"> <h3 id="scoping-class-params">
<span class="section-number">6.4.9.4.3. </span>Scoping of class parameters</h3> <p>The visibility of class parameters in the right-hand side of associated family instances depends <em>solely</em> on the parameters of the family. As an example, consider the simple class declaration</p> <pre data-language="haskell">class C a b where
  data T a
</pre> <p>Only one of the two class parameters is a parameter to the data family. Hence, the following instance declaration is invalid:</p> <pre data-language="haskell">instance C [c] d where
  data T [c] = MkT (c, d)    -- WRONG!!  'd' is not in scope
</pre> <p>Here, the right-hand side of the data instance mentions the type variable <code>d</code> that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</p> <p>Bear in mind that it is also possible for the <em>right</em>-hand side of an associated family instance to contain <em>kind</em> parameters (by using the <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code>PolyKinds</code></a> extension). For instance, this class and instance are perfectly admissible:</p> <pre data-language="haskell">class C k where
  type T :: k

instance C (Maybe a) where
  type T = (Nothing :: Maybe a)
</pre> <p>Here, although the right-hand side <code>(Nothing :: Maybe a)</code> mentions a kind variable <code>a</code> which does not occur on the left-hand side, this is acceptable, because <code>a</code> is <em>implicitly</em> bound by <code>T</code>’s kind pattern.</p> <p>A kind variable can also be bound implicitly in a LHS type pattern, as in this example:</p> <pre data-language="haskell">class C a where
  type T (x :: a) :: [a]

instance C (Maybe a) where
  type T x = ('[] :: [Maybe a])
</pre> <p>In <code>('[] :: [Maybe a])</code>, the kind variable <code>a</code> is implicitly bound by the kind signature of the LHS type pattern <code>x</code>.</p> </section> <section id="instance-contexts-and-associated-type-and-data-instances"> <h3>
<span class="section-number">6.4.9.4.4. </span>Instance contexts and associated type and data instances</h3> <p>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a <code>deriving</code> clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a <a class="reference internal" href="standalone_deriving.html#extension-StandaloneDeriving"><code>standalone deriving</code></a> clause (at the top level).</p> </section> </section> <section id="import-and-export"> <h2 id="data-family-import-export">
<span class="section-number">6.4.9.5. </span>Import and export</h2> <p>The rules for export lists (Haskell Report <a class="reference external" href="https://www.haskell.org/onlinereport/modules.html#sect5.2">Section 5.2</a>) need adjustment for type families:</p> <ul class="simple"> <li>The form <code>T(..)</code>, where <code>T</code> is a data family, names the family <code>T</code> and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of <code>T</code>.</li> <li>The form <code>T(.., ci, .., fj, ..)</code>, where <code>T</code> is a data family, names <code>T</code> and the specified constructors <code>ci</code> and fields <code>fj</code> as usual. The constructors and field names must belong to some data instance of <code>T</code>, but are not required to belong to the <em>same</em> instance.</li> <li>The form <code>C(..)</code>, where <code>C</code> is a class, names the class <code>C</code> and all its methods <em>and associated types</em>.</li> <li>The form <code>C(.., mi, .., type Tj, ..)</code>, where <code>C</code> is a class, names the class <code>C</code>, and the specified methods <code>mi</code> and associated types <code>Tj</code>. The types need a keyword “<code>type</code>” to distinguish them from data constructors.</li> <li>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</li> </ul> <section id="examples"> <h3 id="data-family-impexp-examples">
<span class="section-number">6.4.9.5.1. </span>Examples</h3> <p>Recall our running <code>GMapKey</code> class example:</p> <pre data-language="haskell">class GMapKey k where
  data GMap k :: Type -&gt; Type
  insert :: GMap k v -&gt; k -&gt; v -&gt; GMap k v
  lookup :: GMap k v -&gt; k -&gt; Maybe v
  empty  :: GMap k v

instance (GMapKey a, GMapKey b) =&gt; GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...method declarations...
</pre> <p>Here are some export lists and their meaning:</p> <ul> <li>
<pre data-language="haskell">module GMap( GMapKey )
</pre> <p>Exports just the class name.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey(..) )
</pre> <p>Exports the class, the associated type <code>GMap</code> and the member functions <code>empty</code>, <code>lookup</code>, and <code>insert</code>. The data constructors of <code>GMap</code> (in this case <code>GMapEither</code>) are not exported.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey( type GMap, empty, lookup, insert ) )
</pre> <p>Same as the previous item. Note the “<code>type</code>” keyword.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey(..), GMap(..) )
</pre> <p>Same as previous item, but also exports all the data constructors for <code>GMap</code>, namely <code>GMapEither</code>.</p> </li> <li>
<pre data-language="haskell">module GMap ( GMapKey( empty, lookup, insert), GMap(..) )
</pre> <p>Same as previous item.</p> </li> <li>
<pre data-language="haskell">module GMap ( GMapKey, empty, lookup, insert, GMap(..) )
</pre> <p>Same as previous item.</p> </li> </ul> <p>Two things to watch out for:</p> <ul> <li>You cannot write <code>GMapKey(type GMap(..))</code> — i.e., sub-component specifications cannot be nested. To specify <code>GMap</code>‘s data constructors, you have to list it separately.</li> <li>
<p>Consider this example:</p> <pre data-language="haskell">module X where
  data family D

module Y where
  import X
  data instance D Int = D1 | D2
</pre> <p>Module <code>Y</code> exports all the entities defined in <code>Y</code>, namely the data constructors <code>D1</code> and <code>D2</code>, and <em>implicitly</em> the data family <code>D</code>, even though it’s defined in <code>X</code>. This means you can write <code>import Y( D(D1,D2) )</code> <em>without</em> giving an explicit export list like this:</p> <pre data-language="haskell">     module Y( D(..) ) where ...
or   module Y( module Y, D ) where ...
</pre> </li> </ul> </section> <section id="instances"> <h3 id="data-family-impexp-instances">
<span class="section-number">6.4.9.5.2. </span>Instances</h3> <p>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</p> </section> </section> <section id="type-families-and-instance-declarations"> <h2 id="ty-fams-in-instances">
<span class="section-number">6.4.9.6. </span>Type families and instance declarations</h2> <p>Type families require us to extend the rules for the form of instance heads, which are given in <a class="reference internal" href="instances.html#flexible-instance-head"><span class="std std-ref">Relaxed rules for the instance head</span></a>. Specifically:</p> <ul class="simple"> <li>Data type families may appear in an instance head</li> <li>Type synonym families may not appear (at all) in an instance head</li> </ul> <p>The reason for the latter restriction is that there is no way to check for instance matching. Consider</p> <pre data-language="haskell">type family F a
type instance F Bool = Int

class C a

instance C Int
instance C (F a)
</pre> <p>Now a constraint <code>(C (F Bool))</code> would match both instances. The situation is especially bad because the type instance for <code>F Bool</code> might be in another module, or even in a module that is not yet written.</p> <p>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</p> <pre data-language="haskell">data instance T Int = T1 Int | T2 Bool
instance Eq (T Int) where
  (T1 i) == (T1 j) = i==j
  (T2 i) == (T2 j) = i==j
  _      == _      = False
</pre> <p>Note that class instances are always for particular <em>instances</em> of a data family and never for an entire family as a whole. This is for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of <em>different</em> instances of a single type family. It would require a form of extensible case construct.</p> <p>Data instance declarations can also have <code>deriving</code> clauses. For example, we can write</p> <pre data-language="haskell">data GMap () v = GMapUnit (Maybe v)
               deriving Show
</pre> <p>which implicitly defines an instance of the form</p> <pre data-language="haskell">instance Show v =&gt; Show (GMap () v) where ...
</pre> </section> <section id="injective-type-families"> <h2 id="injective-ty-fams">
<span class="section-number">6.4.9.7. </span>Injective type families</h2> <dl class="std extension"> <dt class="sig sig-object std" id="extension-TypeFamilyDependencies">
<code>TypeFamilyDependencies</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Implies<span class="colon">:</span>
</dt> <dd class="field-odd">
<p><a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a></p> </dd> <dt class="field-even">Since<span class="colon">:</span>
</dt> <dd class="field-even">
<p>8.0.1</p> </dd> </dl> <p>Allow functional dependency annotations on type families. This allows one to define injective type families.</p> </dd>
</dl> <p>Starting with GHC 8.0 type families can be annotated with injectivity information. This information is then used by GHC during type checking to resolve type ambiguities in situations where a type variable appears only under type family applications. Consider this contrived example:</p> <pre data-language="haskell">type family Id a
type instance Id Int = Int
type instance Id Bool = Bool

id :: Id t -&gt; Id t
id x = x
</pre> <p>Here the definition of <code>id</code> will be rejected because type variable <code>t</code> appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that <code>Id</code> is injective, which means it will be possible to infer <code>t</code> at call sites from the type of the argument:</p> <pre data-language="haskell">type family Id a = r | r -&gt; a
</pre> <p>Injective type families are enabled with <code>-XTypeFamilyDependencies</code> language extension. This extension implies <code>-XTypeFamilies</code>.</p> <p>For full details on injective type families refer to the Haskell Symposium 2015 paper <a class="reference external" href="https://richarde.dev/papers/2015/injective/injective-type-families.pdf">Injective type families for Haskell</a>.</p> <section id="syntax-of-injectivity-annotation"> <h3 id="injective-ty-fams-syntax">
<span class="section-number">6.4.9.7.1. </span>Syntax of injectivity annotation</h3> <p>The injectivity annotation is added after the type family head and consists of two parts:</p> <ul class="simple"> <li>a type variable that names the result of a type family. Syntax: <code>= tyvar</code> or <code>= (tyvar :: kind)</code>. The type variable must be fresh.</li> <li>an injectivity annotation of the form <code>| A -&gt; B</code>, where <code>A</code> is the result type variable (see previous bullet) and <code>B</code> is a list of argument type and kind variables in which type family is injective. It is possible to omit some variables if the type family is not injective in them.</li> </ul> <p>Examples:</p> <pre data-language="haskell">type family Id a = result | result -&gt; a where
type family F a b c = d | d -&gt; a c b
type family G (a :: k) b c = foo | foo -&gt; k b where
</pre> <p>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</p> </section> <section id="verifying-the-injectivity-annotation-against-type-family-equations"> <h3 id="injective-ty-fams-typecheck">
<span class="section-number">6.4.9.7.2. </span>Verifying the injectivity annotation against type family equations</h3> <p>Once the user declares type family to be injective GHC must verify that this declaration is correct, i.e., that type family equations don’t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way the user claims and an error is reported. In the bullets below <em>RHS</em> refers to the right-hand side of the type family equation being checked for injectivity. <em>LHS</em> refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</p> <ol class="arabic"> <li>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</li> <li>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</li> <li>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires <a class="reference internal" href="instances.html#extension-UndecidableInstances"><code>UndecidableInstances</code></a>; GHC suggests enabling the flag when it is necessary.</li> <li>
<p><em>Open type families</em> Open type families are typechecked incrementally. This means that when a module is imported type family instances contained in that module are checked against instances present in already imported modules.</p> <p>A pair of an open type family equations is checked by attempting to unify their RHSs. If the RHSs don’t unify this pair does not violate injectivity annotation. If unification succeeds with a substitution then LHSs of unified equations must be identical under that substitution. If they are not identical then GHC reports that the type family is not injective.</p> </li> <li>
<p>In a <em>closed type family</em> all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</p> <p>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don’t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</p> </li> </ol> <p>Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.</p> </section> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/type_families.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/type_families.html</a>
  </p>
</div>
