<h1 id="magic-hash">6.2.2. The magic hash</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="the-magic-hash">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-MagicHash">
<code>MagicHash</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>6.8.1</p> </dd> </dl> <p>Enables the use of the hash character (<code>#</code>) as an identifier suffix.</p> </dd>
</dl> <p>The language extension <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> allows <code>#</code> as a postfix modifier to identifiers. Thus, <code>x#</code> is a valid variable, and <code>T#</code> is a valid type constructor or data constructor.</p> <p>The hash sign does not change semantics at all. We tend to use variable names ending in “#” for unboxed values or types (e.g. <code>Int#</code>), but there is no requirement to do so; they are just plain ordinary variables. Nor does the <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension bring anything into scope. For example, to bring <code>Int#</code> into scope you must import <code>GHC.Exts</code> (see <a class="reference internal" href="primitives.html#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>); the <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension then allows you to <em>refer</em> to the <code>Int#</code> that is now in scope. Note that with this option, the meaning of <code>x#y = 0</code> is changed: it defines a function <code>x#</code> taking a single argument <code>y</code>; to define the operator <code>#</code>, put a space: <code>x # y = 0</code>.</p> <p>The <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> also enables some new forms of literals (see <a class="reference internal" href="primitives.html#glasgow-unboxed"><span class="std std-ref">Unboxed types</span></a>):</p> <ul class="simple"> <li>
<code>'x'#</code> has type <code>Char#</code>
</li> <li>
<code>"foo"#</code> has type <code>Addr#</code> (see <a class="reference internal" href="primitives.html#primitive-string-literals"><span class="std std-ref">Primitive string literals</span></a>).</li> <li>
<code>3#</code> has type <code>Int#</code>. In general, any Haskell integer lexeme followed by a <code>#</code> is an <code>Int#</code> literal, e.g. <code>-0x3A#</code> as well as <code>32#</code>.</li> <li>
<code>3##</code> has type <code>Word#</code>. In general, any non-negative Haskell integer lexeme followed by <code>##</code> is a <code>Word#</code>.</li> <li>
<code>3.2#</code> has type <code>Float#</code>.</li> <li>
<code>3.2##</code> has type <code>Double#</code>
</li> </ul> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/magic_hash.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/magic_hash.html</a>
  </p>
</div>
