<h1 id="id1">6.20. Pragmas</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="pragmas">  <p id="index-0">GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don’t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</p> <p>Pragmas all take the form <code>{-# word ... #-}</code> where ⟨word⟩ indicates the type of pragma, and is followed optionally by information specific to that type of pragma. Case is ignored in ⟨word⟩. The various values for ⟨word⟩ that GHC understands are described in the following sections; any pragma encountered with an unrecognised ⟨word⟩ is ignored.</p> <p>Certain pragmas are <em>file-header pragmas</em>:</p> <ul class="simple"> <li>A file-header pragma must precede the <code>module</code> keyword in the file.</li> <li>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</li> <li>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</li> <li>The file-header pragmas are: <code>{-# LANGUAGE #-}</code>, <code>{-# OPTIONS_GHC #-}</code>, and <code>{-# INCLUDE #-}</code>.</li> </ul> <section id="language-pragma"> <h2 id="id2">
<span class="section-number">6.20.1. </span><code>LANGUAGE</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-LANGUAGE">
<code>{-# LANGUAGE ⟨ext⟩, ⟨ext⟩, ... #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>file header</p> </dd> </dl> <p>Enable or disable a set of language extensions.</p> </dd>
</dl> <p>The <code>LANGUAGE</code> pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the <code>LANGUAGE</code> pragma with the same syntax, although not all extensions are supported by all compilers, of course. The <code>LANGUAGE</code> pragma should be used instead of <code>OPTIONS_GHC</code>, if possible.</p> <p>For example, to enable the FFI and preprocessing with CPP:</p> <pre data-language="haskell">{-# LANGUAGE ForeignFunctionInterface, CPP #-}
</pre> <p><code>LANGUAGE</code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p> <p>Every language extension can also be turned into a command-line flag by prefixing it with “<code>-X</code>”; for example <code>-XForeignFunctionInterface</code>. (Similarly, all “<code>-X</code>” flags can be written as <code>LANGUAGE</code> pragmas.)</p> <p>A list of all supported language extensions can be obtained by invoking <code>ghc --supported-extensions</code> (see <a class="reference internal" href="../using.html#ghc-flag-supported-extensions"><code>--supported-extensions</code></a>).</p> <p>Any extension from the <code>Extension</code> type defined in <a class="reference external" href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/Cabal-3.14.1.0-be50/Language-Haskell-Extension.html">Language.Haskell.Extension</a> may be used. GHC will report an error if any of the requested extensions are not supported.</p> </section> <section id="options-ghc-pragma"> <h2 id="options-pragma">
<span class="section-number">6.20.2. </span><code>OPTIONS_GHC</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-OPTIONS_GHC">
<code>{-# OPTIONS_GHC ⟨flags⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>file header</p> </dd> </dl> </dd>
</dl> <p>The <code>OPTIONS_GHC</code> pragma is used to specify additional options that are given to the compiler when compiling this source file. See <a class="reference internal" href="../using.html#source-file-options"><span class="std std-ref">Command line options in source files</span></a> for details.</p> <p>Previous versions of GHC accepted <code>OPTIONS</code> rather than <code>OPTIONS_GHC</code>, but that is now deprecated.</p> <p><code>OPTIONS_GHC</code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p> </section> <section id="include-pragma"> <h2 id="id3">
<span class="section-number">6.20.3. </span><code>INCLUDE</code> pragma</h2> <p>The <code>INCLUDE</code> used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</p> </section> <section id="warning-and-deprecated-pragmas"> <h2 id="warning-deprecated-pragma">
<span class="section-number">6.20.4. </span><code>WARNING</code> and <code>DEPRECATED</code> pragmas</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-WARNING">
<code>{-# WARNING #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>declaration or module name</p> </dd> </dl> <p>The <code>WARNING</code> pragma allows you to attach an arbitrary warning to a particular function, class, type, export field or module.</p> </dd>
</dl> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-DEPRECATED">
<code>{-# DEPRECATED #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>declaration or module name</p> </dd> </dl> <p>A <code>DEPRECATED</code> pragma lets you specify that a particular function, class, type, export or module is deprecated.</p> </dd>
</dl> <p>There are three ways of using these pragmas.</p> <ul> <li>
<p>You can work on an entire module thus:</p> <pre data-language="haskell">module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
  ...
</pre> <p>Or:</p> <pre data-language="haskell">module Wibble {-# WARNING "This is an unstable interface." #-} where
  ...
</pre> <p>When you compile any module that import <code>Wibble</code>, GHC will print the specified message.</p> </li> <li>
<p>You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations:</p> <pre data-language="haskell">{-# DEPRECATED f, C, T "Don't use these" #-}
{-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</pre> <p>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</p> <p>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as <code>T</code> refers to <em>either</em> the type constructor <code>T</code> <em>or</em> the data constructor <code>T</code>, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities <a class="reference internal" href="infix_tycons.html#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>).</p> </li> <li>
<p>You can add a warning to an instance (including derived instances):</p> <pre data-language="haskell">instance {-# DEPRECATED "Don't use" #-} Show T1 where { .. }
instance {-# WARNING "Don't use either" #-} Show G1 where { .. }

deriving instance {-# DEPRECATED "to be removed" #-} Eq T2
deriving instance {-# WARNING "to be removed as well" #-} Eq G2
</pre> <p>Doing so will cause warnings to be emitted whenever such instances are used to solve a constraint. For example:</p> <pre data-language="haskell">foo = show (MkT1 :: T1) -- warning: uses "instance Show T1"

bar :: forall a. Eq a =&gt; a -&gt; Bool
bar x = x == x
baz :: T2 -&gt; Bool
baz = bar -- warning: uses "instance Eq T2"
quux :: Eq T2 =&gt; T2 -&gt; Bool
quux = bar -- no warning: does not use "instance Eq T2"
</pre> <p>As with other deprecation mechanisms, note that warnings will not be emitted for the usages of those instances in the module in which they are defined.</p> </li> <li>
<p>Finally, you can attach a warning to an export field, be it a regular export:</p> <pre data-language="haskell">module Wibble (
    {-# DEPRECATED "Do not use this type" #-} T,
    {-# WARNING "This is a hacky function" #-} f
  ) where
  ...
</pre> <p>Or a re-export of import from another module:</p> <pre data-language="haskell">module Wibble (
    {-# DEPRECATED "Import this function from A instead" #-} g
  ) where
import A
</pre> <p>Or a re-export of an entire module:</p> <pre data-language="haskell">module Wibble (
    {-# DEPRECATED "This declaration has been moved to B instead" #-}
      module B
  ) where
import B
</pre> <p>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</p> <p>An entity will only be warned about if all of its exports are deprecated:</p> <pre data-language="haskell">module Wibble (
    {-# WARNING "This would not be warned about" #-} g,
    module A
  )
import A (g)
</pre> <p>If the :ghc-flag: <code>-Wincomplete-export-warnings</code> is on, such occurrences are warned about.</p> <p>Moreover, all warning declarations of a specific name have to be warned with the same pragma and message:</p> <pre data-language="haskell">module Wibble (
    {-# WARNING "This would throw an error" #-} T(T1),
    {-# WARNING "Because the warning messages differ for T" #-} T,
)
...
</pre> </li> </ul> <p>Also note that the argument to <code>DEPRECATED</code> and <code>WARNING</code> can also be a list of strings, in which case the strings will be presented on separate lines in the resulting warning message,</p> <pre data-language="haskell">{-# DEPRECATED foo, bar ["Don't use these", "Use gar instead"] #-}
</pre> <p>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, (c) unqualified uses of an entity imported through different modules when not all of them are warned about, and (d) uses in an export list (except for export warnings). The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</p> <p>A <code>WARNING</code> pragma (but not a <code>DEPRECATED</code> pragma) may optionally specify a <em>warning category</em> as a string literal following the <code>in</code> keyword. This affects the flag used to suppress the warning. The examples above do not specify a category, so the default category <code>deprecations</code> applies, and they can be suppressed with the flag <a class="reference internal" href="../using-warnings.html#ghc-flag-Wdeprecations"><code>-Wno-deprecations</code></a> (and its synonym <a class="reference internal" href="../using-warnings.html#ghc-flag-Wwarnings-deprecations"><code>-Wno-warnings-deprecations</code></a>).</p> <p>If a category is specified, the warning can instead be suppressed with the flag <code>-Wno-x-⟨category⟩</code>, for example warnings from the following pragma can be suppressed with <code>-Wno-x-partial</code>:</p> <pre data-language="haskell">{-# WARNING in "x-partial" head "This function is partial..." #-}
</pre> <p>Alternatively, warnings from all <code>WARNING</code> and <code>DEPRECATED</code> pragmas regardless of category can be suppressed with <a class="reference internal" href="../using-warnings.html#ghc-flag-Wextended-warnings"><code>-Wno-extended-warnings</code></a>.</p> <p>When a deprecated name appears in both value and type namespaces (i.e. punning occurs) <code>WARNING</code> and <code>DEPRECATED</code> pragmas will affect both:</p> <pre data-language="haskell">{-# LANGUAGE PatternSynonyms #-}

data D = MkD
pattern D = MkD
{-# DEPRECATED D "This will deprecate both the type D and the pattern synonym D" #-}
</pre> <p>It is possible to specify the namespace of the name to be warned about or deprecated using <code>type</code> and <code>data</code> specifiers, but this feature requires enabling <a class="reference internal" href="explicit_namespaces.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a>:</p> <pre data-language="haskell">{-# LANGUAGE PatternSynonyms #-}

data D = MkD
pattern D = MkD
{-# DEPRECATED data D "This will deprecate only the pattern synonym D" #-}
{-# DEPRECATED type D "This will deprecate only the type D" #-}
</pre> </section> <section id="minimal-pragma"> <h2 id="id4">
<span class="section-number">6.20.5. </span><code>MINIMAL</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-MINIMAL">
<code>{-# MINIMAL ⟨name⟩ | ⟨name⟩ , ... #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>in class body</p> </dd> </dl> <p>Define the methods needed for a minimal complete instance of a class.</p> </dd>
</dl> <p>The <code>MINIMAL</code> pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</p> <pre data-language="haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
    {-# MINIMAL (==) | (/=) #-}
</pre> <p>Without the <code>MINIMAL</code> pragma no warning would be generated for an instance that implements neither method.</p> <p>The syntax for minimal complete definition is:</p> <pre data-language="haskell">mindef ::= name
        |  '(' mindef ')'
        |  mindef '|' mindef
        |  mindef ',' mindef
</pre> <p>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</p> <p>If no <code>MINIMAL</code> pragma is given in the class declaration, it is just as if a pragma <code>{-# MINIMAL op1, op2, ..., opn #-}</code> was given, where the <code>opi</code> are the methods that lack a default method in the class declaration (c.f. <a class="reference internal" href="../using-warnings.html#ghc-flag-Wmissing-methods"><code>-Wmissing-methods</code></a>, <a class="reference internal" href="../using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p> <p>This warning can be turned off with the flag <a class="reference internal" href="../using-warnings.html#ghc-flag-Wmissing-methods"><code>-Wno-missing-methods</code></a>.</p> </section> <section id="inline-and-noinline-pragmas"> <h2 id="inline-noinline-pragma">
<span class="section-number">6.20.6. </span><code>INLINE</code> and <code>NOINLINE</code> pragmas</h2> <p>These pragmas control the inlining of function definitions.</p> <section id="inline-pragma"> <h3 id="id5">
<span class="section-number">6.20.6.1. </span><code>INLINE</code> pragma</h3> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-INLINE">
<code>{-# INLINE ⟨name⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>any function definition</p> </dd> </dl> <p>Force GHC to inline a value.</p> </dd>
</dl> <p>GHC (with <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a>, as always) tries to inline (or “unfold”) functions/values that are “small enough,” thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won’t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see <a class="reference internal" href="../using-optimisation.html#options-f"><span class="std std-ref">-f*: platform-independent flags</span></a>.</p> <p>Normally GHC will do a reasonable job of deciding by itself when it is a good idea to inline a function. However, sometimes you might want to override the default behaviour. For example, if you have a key function that is important to inline because it leads to further optimisations, but GHC judges it to be too big to inline.</p> <p>The sledgehammer you can bring to bear is the <code>INLINE</code> pragma, used thusly:</p> <pre data-language="haskell">key_function :: Int -&gt; String -&gt; (Bool, Double)
{-# INLINE key_function #-}
</pre> <p>The major effect of an <code>INLINE</code> pragma is to declare a function’s “cost” to be very low. The normal unfolding machinery will then be very keen to inline it. However, an <code>INLINE</code> pragma for a function “<code>f</code>” has a number of other effects:</p> <ul> <li>
<p>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</p> <pre data-language="haskell">map key_function xs
</pre> <p>there really isn’t any point in inlining <code>key_function</code> to get</p> <pre data-language="haskell">map (\x -&gt; body) xs
</pre> <p>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</p> </li> <li>
<p>Moreover, GHC will only inline the function if it is <em>fully applied</em>, where “fully applied” means applied to as many arguments as appear (syntactically) on the LHS of the function definition. For example:</p> <pre data-language="haskell">comp1 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp1 #-}
comp1 f g = \x -&gt; f (g x)

comp2 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp2 #-}
comp2 f g x = f (g x)
</pre> <p>The two functions <code>comp1</code> and <code>comp2</code> have the same semantics, but <code>comp1</code> will be inlined when applied to <em>two</em> arguments, while <code>comp2</code> requires <em>three</em>. This might make a big difference if you say</p> <pre data-language="haskell">map (not `comp1` not) xs
</pre> <p>which will optimise better than the corresponding use of <code>comp2</code>.</p> </li> <li>
<p>It is useful for GHC to optimise the definition of an INLINE function <code>f</code> just like any other non-<code>INLINE</code> function, in case the non-inlined version of <code>f</code> is ultimately called. But we don’t want to inline the <em>optimised</em> version of <code>f</code>; a major reason for <code>INLINE</code> pragmas is to expose functions in <code>f</code>'s RHS that have rewrite rules, and it’s no good if those functions have been optimised away.</p> <p>So <em>GHC guarantees to inline precisely the code that you wrote</em>, no more and no less. It does this by capturing a copy of the definition of the function to use for inlining (we call this the “inline-RHS”), which it leaves untouched, while optimising the ordinarily RHS as usual. For externally-visible functions the inline-RHS (not the optimised RHS) is recorded in the interface file.</p> </li> <li>An <code>INLINE</code> function is not worker/wrappered by strictness analysis. It’s going to be inlined wholesale instead.</li> </ul> <p>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more <em>loop breakers</em> that is never inlined (see <a class="reference external" href="https://simonmar.github.io/bib/papers/inline.pdf">Secrets of the GHC inliner, JFP 12(4) July 2002</a>). GHC tries not to select a function with an <code>INLINE</code> pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the <code>INLINE</code> pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an <code>INLINE</code> pragma is always ignored.</p> <p><code>INLINE</code> pragmas are a particularly good idea for the <code>then</code>/<code>return</code> (or <code>bind</code>/<code>unit</code>) functions in a monad. For example, in GHC’s own <code>UniqueSupply</code> monad code, we have:</p> <pre data-language="haskell">{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
</pre> <p>See also the <code>NOINLINE</code> (<a class="reference internal" href="#noinline-pragma"><span class="std std-ref">NOINLINE pragma</span></a>) and <code>INLINABLE</code> (<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) pragmas.</p> <section id="inline-pragma-effects-on-various-locations"> <h4>
<span class="section-number">6.20.6.1.1. </span><code>INLINE</code> pragma effects on various locations</h4> <p>Syntactically, an <code>INLINE</code> pragma for a function can be put anywhere its type signature could be put. This means a <code>INLINE</code> pragma can really be put on any definition site for a binding. This includes top-level, <code>let</code> and <code>where</code> bindings as well as default class methods and instance declarations.</p> <p>The pragma itself will only have an effect when the RHS of the binding it’s applied to is used. For regular bindings this is straight forward but for class methods and instance definitions this can have surprising ramifications.</p> <p>If we consider a class definition with two instances like this:</p> <pre data-language="haskell">class C a where
    op1 :: a -&gt; a

    op2 :: [a] -&gt; [a]
    op2 xs = reverse (xs ++ xs)
    {-# INLINE op2 #-}

instance C T1 where
    op1 x = ...blah...

instance C T2 where
    {-# INLINE op1 #-}
    op1 x = ...blah...
    op2 xs = ...blah...
</pre> <p>Then <code>op2</code> for the T1 instance will get an implicit <code>INLINE</code> pragma. This is because the RHS of the default method is used for <code>op2</code> which retains it’s <code>INLINE</code> pragma.</p> <p>In the T2 instance <code>op1</code> gets an <code>INLINE</code> pragma and behaves accordingly. However <code>op2</code> for T2 is <strong>not</strong> implemented by the default method. This means the pragma in the class definition doesn’t apply to this instance. With no pragma being explicitly applied GHC will then decide on a proper inlining behaviour for <code>T2</code>s <code>op2</code> method on it’s own.</p> </section> </section> <section id="inlinable-pragma"> <h3 id="id6">
<span class="section-number">6.20.6.2. </span><code>INLINABLE</code> pragma</h3> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-INLINABLE">
<code>{-# INLINABLE ⟨name⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>any function definition</p> </dd> </dl> <p>Suggest that the compiler always consider inlining <code>name</code>.</p> </dd>
</dl> <p>An <code>{-# INLINABLE f #-}</code> pragma on a function <code>f</code> has the following behaviour:</p> <ul class="simple"> <li>While <code>INLINE</code> says “please inline me”, the <code>INLINABLE</code> says “feel free to inline me; use your discretion”. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike <code>INLINE</code>, that decision is made at the <em>call site</em>, and will therefore be affected by the inlining threshold, optimisation level etc.</li> <li>Like <code>INLINE</code>, the <code>INLINABLE</code> pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.</li> <li>One way to use <code>INLINABLE</code> is in conjunction with the special function <code>inline</code> (<a class="reference internal" href="special_builtin.html#special-ids"><span class="std std-ref">Special built-in functions</span></a>). The call <code>inline f</code> tries very hard to inline <code>f</code>. To make sure that <code>f</code> can be inlined, it is a good idea to mark the definition of <code>f</code> as <code>INLINABLE</code>, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating <code>f</code> as <code>INLINABLE</code>, you ensure that <code>f</code>'s original RHS is inlined, rather than whatever random optimised version of <code>f</code> GHC’s optimiser has produced.</li> <li>The <code>INLINABLE</code> pragma also works with <code>SPECIALISE</code>: if you mark function <code>f</code> as <code>INLINABLE</code>, then you can subsequently <code>SPECIALISE</code> in another module (see <a class="reference internal" href="#specialize-pragma"><span class="std std-ref">SPECIALIZE pragma</span></a>).</li> <li>Unlike <code>INLINE</code>, it is OK to use an <code>INLINABLE</code> pragma on a recursive function. The principal reason do to so to allow later use of <code>SPECIALISE</code>
</li> </ul> <p>The alternative spelling <code>INLINEABLE</code> is also accepted by GHC.</p> </section> <section id="noinline-pragma"> <h3 id="id7">
<span class="section-number">6.20.6.3. </span><code>NOINLINE</code> pragma</h3> <dl class="std pragma" id="index-1"> <dt class="sig sig-object std" id="pragma-NOINLINE">
<code>{-# NOINLINE ⟨name⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>any function definition</p> </dd> </dl> <p>Instructs the compiler not to inline a value.</p> </dd>
</dl> <p>The <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma does exactly what you’d expect: it stops the named function from being inlined by the compiler. You shouldn’t ever need to do this, unless you’re very cautious about code size.</p> <p><code>NOTINLINE</code> is a synonym for <code>NOINLINE</code> (<code>NOINLINE</code> is specified by Haskell 98 as the standard way to disable inlining, so it should be used if you want your code to be portable).</p> </section> <section id="conlike-modifier"> <h3 id="conlike-pragma">
<span class="section-number">6.20.6.4. </span><code>CONLIKE</code> modifier</h3> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-CONLIKE">
<code>{-# CONLIKE #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>modifies <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma</p> </dd> </dl> <p>Instructs GHC to consider a value to be especially cheap to inline.</p> </dd>
</dl> <p>An <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma may have a <a class="reference internal" href="#pragma-CONLIKE"><code>CONLIKE</code></a> modifier, which affects matching in <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code>RULE</code></a>s (only). See <a class="reference internal" href="rewrite_rules.html#conlike"><span class="std std-ref">How rules interact with CONLIKE pragmas</span></a>.</p> </section> <section id="phase-control"> <h3 id="id8">
<span class="section-number">6.20.6.5. </span>Phase control</h3> <p>Sometimes you want to control exactly when in GHC’s pipeline the <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma is switched on. Inlining happens only during runs of the <em>simplifier</em>. Each run of the simplifier has a different <em>phase number</em>; the phase number decreases towards zero. If you use <a class="reference internal" href="../debugging.html#ghc-flag-dverbose-core2core"><code>-dverbose-core2core</code></a> you will see the sequence of phase numbers for successive runs of the simplifier. In an <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma you can optionally specify a phase number, thus:</p> <ul class="simple"> <li>“<code>INLINE[k] f</code>” means: do not inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards be very keen to inline it.</li> <li>“<code>INLINE[~k] f</code>” means: be very keen to inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards do not inline it.</li> <li>“<code>NOINLINE[k] f</code>” means: do not inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards be willing to inline it (as if there was no pragma).</li> <li>“<code>NOINLINE[~k] f</code>” means: be willing to inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards do not inline it.</li> </ul> <p>The same information is summarised here:</p> <pre data-language="none">                         -- Before phase 2     Phase 2 and later
{-# INLINE   [2]  f #-}  --      No                 Yes
{-# INLINE   [~2] f #-}  --      Yes                No
{-# NOINLINE [2]  f #-}  --      No                 Maybe
{-# NOINLINE [~2] f #-}  --      Maybe              No

{-# INLINE   f #-}       --      Yes                Yes
{-# NOINLINE f #-}       --      No                 No
</pre> <p>By “Maybe” we mean that the usual heuristic inlining rules apply (if the function body is small, or it is applied to interesting-looking arguments etc). Another way to understand the semantics is this:</p> <ul class="simple"> <li>For both <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> and <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a>, the phase number says when inlining is allowed at all.</li> <li>The <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma has the additional effect of making the function body look small, so that when inlining is allowed it is very likely to happen.</li> </ul> <p>The same phase-numbering control is available for <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code>RULE</code></a>s (<a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>).</p> </section> </section> <section id="opaque-pragma"> <h2 id="id9">
<span class="section-number">6.20.7. </span><code>OPAQUE</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-OPAQUE">
<code>{-# OPAQUE ⟨name⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>top-level</p> </dd> </dl> <p>Instructs the compiler to ensure that every call of <code>name</code> remains a call of <code>name</code>, and not some name-mangled variant.</p> </dd>
</dl> <p>The <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> pragma is an even stronger variant of the <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma. Like the <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a>, named functions annotated with a <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> pragma are not inlined, nor will they be be specialized. Unlike the <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a>, named functions annotated with a <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> pragma are left untouched by the Worker/Wrapper transformation. Unlike <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a>, <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> has no phase control.</p> <p>In effect, every call of a named function annotated with an <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> pragma remains a call of that named function, not some name-mangled variant. You shouldn’t ever need to use the <a class="reference internal" href="#pragma-OPAQUE"><code>OPAQUE</code></a> pragma, unless you have a reason to care about name-mangling.</p> </section> <section id="line-pragma"> <h2 id="id10">
<span class="section-number">6.20.8. </span><code>LINE</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-LINE">
<code>{-# LINE ⟨lineno⟩ "⟨file⟩" #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>anywhere</p> </dd> </dl> <p>Generated by preprocessors to convey source line numbers of the original source.</p> </dd>
</dl> <p>This pragma is similar to C’s <code>#line</code> pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</p> <pre data-language="haskell">{-# LINE 42 "Foo.vhs" #-}
</pre> <p>if you’d generated the current file from something called <code>Foo.vhs</code> and this line corresponds to line 42 in the original. GHC will adjust its error messages to refer to the line/file named in the <code>LINE</code> pragma.</p> <p><code>LINE</code> pragmas generated from Template Haskell set the file and line position for the duration of the splice and are limited to the splice. Note that because Template Haskell splices abstract syntax, the file positions are not automatically advanced.</p> </section> <section id="column-pragma"> <h2 id="id11">
<span class="section-number">6.20.9. </span><code>COLUMN</code> pragma</h2> <p id="index-2">This is the analogue of the <code>LINE</code> pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</p> <pre data-language="haskell">foo = do
  {-# COLUMN 42 #-}pure ()
  pure ()
</pre> <p>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</p> </section> <section id="rules-pragma"> <h2 id="rules">
<span class="section-number">6.20.10. </span><code>RULES</code> pragma</h2> <p>The <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code>RULES</code></a> pragma lets you specify rewrite rules. It is described in <a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>.</p> </section> <section id="specialize-pragma"> <h2 id="id12">
<span class="section-number">6.20.11. </span><code>SPECIALIZE</code> pragma</h2> <dl class="std pragma" id="index-3"> <dt class="sig sig-object std" id="pragma-SPECIALIZE">
<code>{-# SPECIALIZE ⟨name⟩ :: ⟨type⟩ #-}</code> </dt> <dd>
<p>Ask that GHC specialize a polymorphic value to a particular type.</p> </dd>
</dl> <p>(UK spelling also accepted.) For key overloaded functions, you can create extra versions (NB: at the cost of larger code) specialised to particular types. Thus, if you have an overloaded function:</p> <pre data-language="haskell">hammeredLookup :: Ord key =&gt; [(key, value)] -&gt; key -&gt; value
</pre> <p>If it is heavily used on lists with <code>Widget</code> keys, you could specialise it as follows:</p> <pre data-language="haskell">{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre> <ul> <li>A <code>SPECIALIZE</code> pragma for a function can be put anywhere its type signature could be put. Moreover, you can also <code>SPECIALIZE</code> an <em>imported</em> function provided it was given an <code>INLINABLE</code> pragma at its definition site (<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>).</li> <li>A <code>SPECIALIZE</code> has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see <a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) that rewrites a call to the un-specialised function into a call to the specialised one. Moreover, given a <code>SPECIALIZE</code> pragma for a function <code>f</code>, GHC will automatically create specialisations for any type-class-overloaded functions called by <code>f</code>, if they are in the same module as the <code>SPECIALIZE</code> pragma, or if they are <code>INLINABLE</code>; and so on, transitively.</li> <li>
<p>You can add phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to the RULE generated by a <code>SPECIALIZE</code> pragma, just as you can if you write a <code>RULE</code> directly. For example:</p> <pre data-language="haskell">{-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre> <p>generates a specialisation rule that only fires in Phase 0 (the final phase). If you do not specify any phase control in the <code>SPECIALIZE</code> pragma, the phase control is inherited from the inline pragma (if any) of the function. For example:</p> <pre data-language="haskell">foo :: Num a =&gt; a -&gt; a
foo = ...blah...
{-# NOINLINE [0] foo #-}
{-# SPECIALIZE foo :: Int -&gt; Int #-}
</pre> <p>The <code>NOINLINE</code> pragma tells GHC not to inline <code>foo</code> until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</p> <p>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only <em>then</em> specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</p> </li> <li>
<p>The type in a <code>SPECIALIZE</code> pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is <code>f</code> then the pragma</p> <pre data-language="haskell">{-# SPECIALIZE f :: &lt;type&gt; #-}
</pre> <p>is valid if and only if the definition</p> <pre data-language="haskell">f_spec :: &lt;type&gt;
f_spec = f
</pre> <p>is valid. Here are some examples (where we only give the type signature for the original function, not its code):</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; b -&gt; b
{-# SPECIALISE f :: Int -&gt; b -&gt; b #-}

g :: (Eq a, Ix b) =&gt; a -&gt; b -&gt; b
{-# SPECIALISE g :: (Eq a) =&gt; a -&gt; Int -&gt; Int #-}

h :: Eq a =&gt; a -&gt; a -&gt; a
{-# SPECIALISE h :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a] #-}
</pre> <p>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</p> </li> </ul> <section id="specialize-inline"> <h3 id="id13">
<span class="section-number">6.20.11.1. </span><code>SPECIALIZE INLINE</code>
</h3> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-SPECIALIZE-INLINE">
<code>{-# SPECIALIZE INLINE ⟨name⟩ :: ⟨type⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>top-level</p> </dd> </dl> </dd>
</dl> <p>A <code>SPECIALIZE</code> pragma can optionally be followed with a <code>INLINE</code> or <code>NOINLINE</code> pragma, optionally followed by a phase, as described in <a class="reference internal" href="#inline-noinline-pragma"><span class="std std-ref">INLINE and NOINLINE pragmas</span></a>. The <code>INLINE</code> pragma affects the specialised version of the function (only), and applies even if the function is recursive. The motivating example is this:</p> <pre data-language="haskell">-- A GADT for arrays with type-indexed representation
data Arr e where
  ArrInt :: !Int -&gt; ByteArray# -&gt; Arr Int
  ArrPair :: !Int -&gt; Arr e1 -&gt; Arr e2 -&gt; Arr (e1, e2)

(!:) :: Arr e -&gt; Int -&gt; e
{-# SPECIALISE INLINE (!:) :: Arr Int -&gt; Int -&gt; Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -&gt; Int -&gt; (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</pre> <p>Here, <code>(!:)</code> is a recursive function that indexes arrays of type <code>Arr e</code>. Consider a call to <code>(!:)</code> at type <code>(Int,Int)</code>. The second specialisation will fire, and the specialised function will be inlined. It has two calls to <code>(!:)</code>, both at type <code>Int</code>. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</p> <p>You can add explicit phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to <code>SPECIALISE INLINE</code> pragma, just like on an <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma; if you do so, the same phase is used for the rewrite rule and the INLINE control of the specialised function.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>You can make GHC diverge by using <code>SPECIALISE INLINE</code> on an ordinarily-recursive function.</p> </div> </section> <section id="specialize-for-imported-functions"> <h3>
<span class="section-number">6.20.11.2. </span><code>SPECIALIZE</code> for imported functions</h3> <p>Generally, you can only give a <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma for a function defined in the same module. However if a function <code>f</code> is given an <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a> pragma at its definition site, then it can subsequently be specialised by importing modules (see <a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>). For example</p> <pre data-language="haskell">module Map( lookup, blah blah ) where
  lookup :: Ord key =&gt; [(key,a)] -&gt; key -&gt; Maybe a
  lookup = ...
  {-# INLINABLE lookup #-}

module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )
  {-# SPECIALISE lookup :: [(T,a)] -&gt; T -&gt; Maybe a
</pre> <p>Here, <code>lookup</code> is declared <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a>, but it cannot be specialised for type <code>T</code> at its definition site, because that type does not exist yet. Instead a client module can define <code>T</code> and then specialise <code>lookup</code> at that type.</p> <p>Moreover, every module that imports <code>Client</code> (or imports a module that imports <code>Client</code>, transitively) will “see”, and make use of, the specialised version of <code>lookup</code>. You don’t need to put a <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma in every module.</p> <p>Moreover you often don’t even need the <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma in the first place. When compiling a module <code>M</code>, GHC’s optimiser (when given the <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a> flag) automatically considers each top-level overloaded function declared in <code>M</code>, and specialises it for the different types at which it is called in <code>M</code>. The optimiser <em>also</em> considers each <em>imported</em> <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a> overloaded function, and specialises it for the different types at which it is called in <code>M</code>. So in our example, it would be enough for <code>lookup</code> to be called at type <code>T</code>:</p> <pre data-language="haskell">module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )

  findT1 :: [(T,a)] -&gt; Maybe a
  findT1 m = lookup m T1   -- A call of lookup at type T
</pre> <p>However, sometimes there are no such calls, in which case the pragma can be useful.</p> </section> </section> <section id="specialize-instance-pragma"> <h2 id="id14">
<span class="section-number">6.20.12. </span><code>SPECIALIZE</code> instance pragma</h2> <dl class="std pragma" id="index-4"> <dt class="sig sig-object std" id="pragma-SPECIALIZE-instance">
<code>{-# SPECIALIZE instance ⟨instance head⟩ #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>instance body</p> </dd> </dl> </dd>
</dl> <p>Same idea, except for instance declarations. For example:</p> <pre data-language="haskell">instance (Eq a) =&gt; Eq (Foo a) where {
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... usual stuff ...
 }
</pre> <p>The pragma must occur inside the <code>where</code> part of the instance declaration.</p> </section> <section id="unpack-pragma"> <h2 id="id15">
<span class="section-number">6.20.13. </span><code>UNPACK</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-UNPACK">
<code>{-# UNPACK #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>data constructor field</p> </dd> </dl> <p>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</p> </dd>
</dl> <p>The <code>UNPACK</code> indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</pre> <p>will create a constructor <code>T</code> containing two unboxed floats. This may not always be an optimisation: if the <code>T</code> constructor is scrutinised and the floats passed to a non-strict function for example, they will have to be reboxed (this is done automatically by the compiler).</p> <p>Unpacking constructor fields should only be used in conjunction with <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a> <a class="footnote-reference brackets" href="#id17" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</p> <pre data-language="haskell">f :: T -&gt; Float
f (T f1 f2) = f1 + f2
</pre> <p>The compiler will avoid reboxing <code>f1</code> and <code>f2</code> by inlining <code>+</code> on floats, but only when <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a> is on.</p> <p>Any single-constructor data is eligible for unpacking; for example</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !(Int,Int)
</pre> <p>will store the two <code>Int</code>s directly in the <code>T</code> constructor, by flattening the pair. Multi-level unpacking is also supported:</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</pre> <p>will store two unboxed <code>Int#</code>s directly in the <code>T</code> constructor. The unpacker can see through newtypes, too.</p> <p>Since 9.6.1, data types with multiple constructors can also be unpacked, effectively transforming the field into an unboxed sum of the unpackings of each constructor (see <a class="reference internal" href="primitives.html#extension-UnboxedSums"><code>UnboxedSums</code></a>).</p> <p>See also the <a class="reference internal" href="../using-optimisation.html#ghc-flag-funbox-strict-fields"><code>-funbox-strict-fields</code></a> flag, which essentially has the effect of adding <code>{-# UNPACK #-}</code> to every strict constructor field which is of a single-constructor data type. Sum types won’t be unpacked automatically by this though, only with the explicit pragma.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id17" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">1</a><span class="fn-bracket">]</span></span> <p>In fact, <a class="reference internal" href="#pragma-UNPACK"><code>UNPACK</code></a> has no effect without <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a>, for technical reasons (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5252">#5252</a>).</p> </aside> </aside> </section> <section id="nounpack-pragma"> <h2 id="id18">
<span class="section-number">6.20.14. </span><code>NOUNPACK</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-NOUNPACK">
<code>{-# NOUNPACK #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>top-level</p> </dd> </dl> <p>Instructs the compiler not to unpack a constructor field.</p> </dd>
</dl> <p>The <code>NOUNPACK</code> pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</p> <pre data-language="haskell">data T = T {-# NOUNPACK #-} !(Int,Int)
</pre> <p>Even with the flags <a class="reference internal" href="../using-optimisation.html#ghc-flag-funbox-strict-fields"><code>-funbox-strict-fields</code></a> and <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code>-O</code></a>, the field of the constructor <code>T</code> is not unpacked.</p> </section> <section id="source-pragma"> <h2 id="id19">
<span class="section-number">6.20.15. </span><code>SOURCE</code> pragma</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-SOURCE">
<code>{-# SOURCE #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>after <code>import</code> statement</p> </dd> </dl> <p>Import a module by <code>hs-boot</code> file to break a module loop.</p> </dd>
</dl> <p>The <code>{-# SOURCE #-}</code> pragma is used only in <code>import</code> declarations, to break a module loop. It is described in detail in <a class="reference internal" href="../separate_compilation.html#mutual-recursion"><span class="std std-ref">Mutually recursive modules and hs-boot files</span></a>.</p> </section> <section id="complete-pragmas"> <h2 id="complete-pragma">
<span class="section-number">6.20.16. </span><code>COMPLETE</code> pragmas</h2> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-COMPLETE">
<code>{-# COMPLETE #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>at top level</p> </dd> </dl> <p>Specify the set of constructors or pattern synonyms which constitute a total match.</p> </dd>
</dl> <p>The <code>COMPLETE</code> pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</p> <p>The most common usage of <code>COMPLETE</code> pragmas is with <a class="reference internal" href="pattern_synonyms.html#pattern-synonyms"><span class="std std-ref">Pattern synonyms</span></a>. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</p> <p>For example, the data types <code>2 * A</code> and <code>A + A</code> are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a <code>COMPLETE</code> pragma in order to inform the pattern match checker that a function which matches on both <code>LeftChoice</code> and <code>RightChoice</code> is total.</p> <pre data-language="haskell">data Choice a = Choice Bool a

pattern LeftChoice :: a -&gt; Choice a
pattern LeftChoice a = Choice False a

pattern RightChoice :: a -&gt; Choice a
pattern RightChoice a = Choice True a

{-# COMPLETE LeftChoice, RightChoice #-}

foo :: Choice Int -&gt; Int
foo (LeftChoice n) = n * 2
foo (RightChoice n) = n - 2
</pre> <p><code>COMPLETE</code> pragmas are only used by the pattern match checker. If a function definition matches on all the constructors specified in the pragma then the compiler will produce no warning.</p> <p><code>COMPLETE</code> pragmas can contain any data constructors or pattern synonyms which are in scope, but must mention at least one data constructor or pattern synonym defined in the same module. <code>COMPLETE</code> pragmas may only appear at the top level of a module. Once defined, they are automatically imported and exported from modules. <code>COMPLETE</code> pragmas should be thought of as asserting a universal truth about a set of patterns and as a result, should not be used to silence context specific incomplete match warnings.</p> <p>It is also possible to restrict the types to which a <code>COMPLETE</code> pragma applies by putting a double colon <code>::</code> after the list of constructors, followed by a result type constructor, which will be used to restrict the cases in which the pragma applies. GHC will compare the annotated result type constructor with the type constructor in the head of the scrutinee type in a pattern match to see if the <code>COMPLETE</code> pragma is meant to apply to it.</p> <p>This is especially useful in cases that the constructors specified are polymorphic, e.g.:</p> <pre data-language="haskell">data Proxy a = Proxy

class IsEmpty a where
  isEmpty :: a -&gt; Bool

class IsCons a where
  type Elt a
  isCons :: a -&gt; Maybe (Elt a, a)

pattern Empty :: IsEmpty a =&gt; a
pattern Empty &lt;- (isEmpty -&gt; True)

pattern Cons :: IsCons a =&gt; Elt a -&gt; a -&gt; a
pattern Cons x xs &lt;- (isCons -&gt; Just (x,xs))

instance IsEmpty (Proxy a) where
  isEmpty Proxy = True

instance IsEmpty [a] where
  isEmpty = null

instance IsCons [a] where
  type Elt [a] = a
  isCons [] = Nothing
  isCons (x:xs) = Just (x,xs)

{-# COMPLETE Empty :: Proxy #-}
{-# COMPLETE Empty, Cons :: [] #-}

foo :: Proxy a -&gt; Int
foo Empty = 0

bar :: [a] -&gt; Int
bar Empty = 0
bar (Cons _ _) = 1

baz :: [a] -&gt; Int
baz Empty = 0
</pre> <p>In this example, <code>foo</code> and <code>bar</code> will not be warned about, as their pattern matches are covered by the two <code>COMPLETE</code> pragmas above, but <code>baz</code> will be warned about as incomplete.</p> </section> <section id="overlapping-overlappable-overlaps-and-incoherent-pragmas"> <h2 id="overlap-pragma">
<span class="section-number">6.20.17. </span><code>OVERLAPPING</code>, <code>OVERLAPPABLE</code>, <code>OVERLAPS</code>, and <code>INCOHERENT</code> pragmas</h2> <dl class="std pragma" id="index-5"> <dt class="sig sig-object std" id="pragma-OVERLAPPING">
<code>{-# OVERLAPPING #-}</code> </dt> 
</dl> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-OVERLAPPABLE">
<code>{-# OVERLAPPABLE #-}</code> </dt> 
</dl> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-OVERLAPS">
<code>{-# OVERLAPS #-}</code> </dt> 
</dl> <dl class="std pragma"> <dt class="sig sig-object std" id="pragma-INCOHERENT">
<code>{-# INCOHERENT #-}</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Where<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>on instance head</p> </dd> </dl> </dd>
</dl> <p>The pragmas <code>OVERLAPPING</code>, <code>OVERLAPPABLE</code>, <code>OVERLAPS</code>, <code>INCOHERENT</code> are used to specify the overlap behavior for individual instances, as described in Section <a class="reference internal" href="instances.html#instance-overlap"><span class="std std-ref">Overlapping instances</span></a>. The pragmas are written immediately after the <code>instance</code> keyword, like this:</p> <pre data-language="haskell">instance {-# OVERLAPPING #-} C t where ...
</pre> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/pragmas.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/pragmas.html</a>
  </p>
</div>
