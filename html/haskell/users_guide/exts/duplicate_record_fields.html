<h1 id="id1">6.5.4. Duplicate record fields</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="duplicate-record-fields"> <dt id="extension-DuplicateRecordFields">
<code>DuplicateRecordFields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="disambiguate_record_fields.html#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow definition of record types with identically-named fields.</p> </dd>
</dl> <p>Going beyond <a class="reference internal" href="disambiguate_record_fields.html#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a> (see <a class="reference internal" href="disambiguate_record_fields.html#disambiguate-fields"><span class="std std-ref">Record field disambiguation</span></a>), the <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</p> <pre data-language="haskell">module M where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with <a class="reference internal" href="disambiguate_record_fields.html#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>):</p> <pre data-language="haskell">s = MkS { x = 3 }

f (MkT { x = b }) = b
</pre> <p>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</p> <p>While <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> permits multiple fields with the same name in a single module, it does not permit a field and a normal value binding to have the same name. For that, use <a class="reference internal" href="field_selectors.html#extension-FieldSelectors"><code>NoFieldSelectors</code></a>.</p>  <h2 id="selector-functions">6.5.4.1. Selector functions</h2> <p>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both <code>S(x)</code> and <code>T(x)</code> are in scope:</p> <pre data-language="haskell">bad r = x r
</pre> <p><strong>Warning</strong>: the type-based disambiguation rules described in the remainder of this section are being removed (see the proposal <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0366-no-ambiguous-field-access.rst">DuplicateRecordFields without ambiguous field access</a>). The <a class="reference internal" href="../using-warnings.html#ghc-flag--Wambiguous-fields"><code>-Wambiguous-fields</code></a> option will warn about code that relies on these rules. In a future GHC release, such code will produce ambiguity errors.</p> <p>An ambiguous selector may be disambiguated by the type being “pushed down” to the occurrence of the selector (see <a class="reference internal" href="rank_polymorphism.html#higher-rank-type-inference"><span class="std std-ref">Type inference</span></a> for more details on what “pushed down” means). For example, the following are permitted:</p> <pre data-language="haskell">ok1 = x :: S -&gt; Int

ok2 :: S -&gt; Int
ok2 = x

ok3 = k x -- assuming we already have k :: (S -&gt; Int) -&gt; _
</pre> <p>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</p> <pre data-language="haskell">ok4 s = x (s :: S)
</pre> <p>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</p> <pre data-language="haskell">bad :: S -&gt; Int
bad s = x s
</pre> <p>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import <code>S(x)</code> but not <code>T(x)</code>, and then use <code>x</code> unambiguously.</p>   <h2 id="record-updates">6.5.4.2. Record updates</h2> <p>In a record update such as <code>e { x = 1 }</code>, if there are multiple <code>x</code> fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</p> <pre data-language="haskell">data S = MkS { foo :: Int }
data T = MkT { foo :: Int, bar :: Int }
data U = MkU { bar :: Int, baz :: Int }
</pre> <p>Without <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a>, an update mentioning <code>foo</code> will always be ambiguous if all these definitions were in scope. When the extension is enabled, and there is exactly one type that has all the fields being updated, that type will be used. For example:</p> <pre data-language="haskell">f x = x { foo = 3, bar = 2 }
</pre> <p>Here <code>f</code> must be updating <code>T</code> because neither <code>S</code> nor <code>U</code> have both fields.</p> <p>If there are multiple types with all the fields, type information may be used to disambiguate which record type is meant. <strong>Warning</strong>: the following rules are being removed (see the proposal <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0366-no-ambiguous-field-access.rst">DuplicateRecordFields without ambiguous field access</a>). The <a class="reference internal" href="../using-warnings.html#ghc-flag--Wambiguous-fields"><code>-Wambiguous-fields</code></a> option will warn about code that relies on these rules. In a future GHC release, such code will produce ambiguity errors.</p> <ul> <li>
<p class="first">Use the type being pushed in to the record update, as in the following:</p> <pre data-language="haskell">g1 :: T -&gt; T
g1 x = x { foo = 3 }

g2 x = x { foo = 3 } :: T

g3 = k (x { foo = 3 }) -- assuming we already have k :: T -&gt; _
</pre> </li> <li>
<p class="first">Use an explicit type signature on the record expression, as in:</p> <pre data-language="haskell">h x = (x :: T) { foo = 3 }
</pre> </li> </ul> <p>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</p> <pre data-language="haskell">let x :: T
    x = blah
in x { foo = 3 }

\x -&gt; [x { foo = 3 },  blah :: T ]

\ (x :: T) -&gt; x { foo = 3 }
</pre>   <h2 id="import-and-export-of-record-fields">6.5.4.3. Import and export of record fields</h2> <p>When <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</p> <pre data-language="haskell">module M (S(x), T(..)) where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>However, this would not be permitted, because <code>x</code> is ambiguous:</p> <pre data-language="haskell">module M (x) where ...
</pre> <p>Similar restrictions apply on import.</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/duplicate_record_fields.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/duplicate_record_fields.html</a>
  </p>
</div>
