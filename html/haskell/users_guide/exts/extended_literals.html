<h1 id="extended-literals">6.9.5. Sized primitive literal syntax</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="sized-primitive-literal-syntax">  <dl class="std extension"> <dt class="sig sig-object std" id="extension-ExtendedLiterals">
<code>ExtendedLiterals</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>9.8.1</p> </dd> </dl> <p>Allows defining unboxed numeric primitive values through <code>#Type</code> suffixes on numeric literals e.g. <code>0xFF#Word8 :: Word8#</code>.</p> </dd>
</dl> <p>The <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code>MagicHash</code></a> extension enables some new literals, including <code>3#
:: Int#</code>, <code>3## :: Word#</code>. This does not extend to all unboxed values. For example, there is no literal syntax for <code>Word8#</code>: you must write something such as <code>wordToWord8 (3## :: Word#) :: Word8#</code>.</p> <p><a class="reference internal" href="#extension-ExtendedLiterals"><code>ExtendedLiterals</code></a> enables further syntax for defining primitive numeric literals. Suffix any Haskell integer lexeme with a hash sign <code>#</code> followed by a primitive numeric type (without its hash suffix) to obtain a value of that type. For example, <code>0xFF#Word8 :: Word8#</code>. There must be no spaces between the parts of the literal.</p> <p>The primitive numeric types allowed are:</p> <ul class="simple"> <li><code>Int8#</code></li> <li><code>Int16#</code></li> <li><code>Int32#</code></li> <li><code>Int64#</code></li> <li><code>Int#</code></li> <li><code>Word8#</code></li> <li><code>Word16#</code></li> <li><code>Word32#</code></li> <li><code>Word64#</code></li> <li><code>Word#</code></li> </ul> <p>All types permit any positive and negative Haskell integer lexeme. Defining a literal with a value that canâ€™t fit in its requested type will emit an overflow warning by default, the same as boxed numeric literals (see <a class="reference internal" href="../using-warnings.html#ghc-flag-Woverflowed-literals"><code>-Woverflowed-literals</code></a>).</p> <p>As with <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code>MagicHash</code></a>, this extension does not bring anything into scope, nor change any semantics. The syntax only applies to numeric literals. You may want to import <code>GHC.Exts</code> (see <a class="reference internal" href="primitives.html#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>) to refer to the types of the literals you define.</p> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/extended_literals.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/exts/extended_literals.html</a>
  </p>
</div>
