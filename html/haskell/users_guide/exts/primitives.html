<h1 id="primitives">6.16. Unboxed types and primitive operations</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <p id="unboxed-types-and-primitive-operations">GHC is built on a raft of primitive data types and operations; “primitive” in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn’t, we’d like to know about it.</p> <p>All these primitive data types and operations are exported by the library <a class="reference external" href="../../libraries/base-4.17.0.0/ghc-exts.html">GHC.Exts</a>.</p> <p>If you want to mention any of the primitive data types or operations in your program, you must first import <code>GHC.Exts</code> to bring them into scope. Many of them have names ending in <code>#</code>, and to mention such names you need the <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code>MagicHash</code></a> extension.</p> <p>The primops make extensive use of <a class="reference external" href="#glasgow-unboxed">unboxed types</a> and <a class="reference external" href="#unboxed-tuples">unboxed tuples</a>, which we briefly summarise here.</p>  <h2 id="glasgow-unboxed">6.16.1. Unboxed types</h2> <p id="unboxed-types">Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell <code>Int</code>, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved.</p> <p>Unboxed types correspond to the “raw machine” types you would use in C: <code>Int#</code> (long int), <code>Double#</code> (double), <code>Addr#</code> (void *), etc. The <em>primitive operations</em> (PrimOps) on these types are what you might expect; e.g., <code>(+#)</code> is addition on <code>Int#</code>s, and is the machine-addition that we all know and love—usually one instruction.</p> <p>Primitive (unboxed) types cannot be defined in Haskell, and are therefore built into the language and compiler. Primitive types are always unlifted; that is, a value of a primitive type cannot be bottom. (Note: a “boxed” type means that a value is represented by a pointer to a heap object; a “lifted” type means that terms of that type may be bottom. See the next paragraph for an example.) We use the convention (but it is only a convention) that primitive types, values, and operations have a <code>#</code> suffix (see <a class="reference internal" href="magic_hash.html#magic-hash"><span class="std std-ref">The magic hash</span></a>). For some primitive types we have special syntax for literals, also described in the <a class="reference external" href="#magic-hash">same section</a>.</p> <p>Primitive values are often represented by a simple bit-pattern, such as <code>Int#</code>, <code>Float#</code>, <code>Double#</code>. But this is not necessarily the case: a primitive value might be represented by a pointer to a heap-allocated object. Examples include <code>Array#</code>, the type of primitive arrays. Thus, <code>Array#</code> is an unlifted, boxed type. A primitive array is heap-allocated because it is too big a value to fit in a register, and would be too expensive to copy around; in a sense, it is accidental that it is represented by a pointer. If a pointer represents a primitive value, then it really does point to that value: no unevaluated thunks, no indirections. Nothing can be at the other end of the pointer than the primitive value. A numerically-intensive program using unboxed types can go a <em>lot</em> faster than its “standard” counterpart—we saw a threefold speedup on one example.</p>   <h2 id="unboxed-type-kinds">6.16.2. Unboxed type kinds</h2> <p>Because unboxed types are represented without the use of pointers, we cannot store them in a polymorphic data type. For example, the <code>Just</code> node of <code>Just 42#</code> would have to be different from the <code>Just</code> node of <code>Just 42</code>; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of <code>Just</code> nodes (nor for any other data type). Accordingly, the <em>kind</em> of an unboxed type is different from the kind of a boxed type.</p> <p>The Haskell Report describes that <code>*</code> (spelled <code>Type</code> and imported from <code>Data.Kind</code> in the GHC dialect of Haskell) is the kind of ordinary data types, such as <code>Int</code>. Furthermore, type constructors can have kinds with arrows; for example, <code>Maybe</code> has kind <code>Type -&gt; Type</code>. Unboxed types have a kind that specifies their runtime representation. For example, the type <code>Int#</code> has kind <code>TYPE IntRep</code> and <code>Double#</code> has kind <code>TYPE DoubleRep</code>. These kinds say that the runtime representation of an <code>Int#</code> is a machine integer, and the runtime representation of a <code>Double#</code> is a machine double-precision floating point. In contrast, the kind <code>Type</code> is actually just a synonym for <code>TYPE
LiftedRep</code>. More details of the <code>TYPE</code> mechanisms appear in the <a class="reference external" href="#runtime-rep">section on runtime representation polymorphism</a>.</p> <p>Given that <code>Int#</code>’s kind is not <code>Type</code>, then it follows that <code>Maybe
Int#</code> is disallowed. Similarly, because type variables tend to be of kind <code>Type</code> (for example, in <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>, all the type variables have kind <code>Type</code>), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</p> <p>There are some restrictions on the use of primitive types:</p> <ul> <li>
<p class="first">You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:</p> <pre data-language="haskell">newtype A = MkA Int#
</pre> <p>However, this restriction can be relaxed by enabling <a class="reference internal" href="#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a>. The <a class="reference external" href="#unlifted-newtypes">section on unlifted newtypes</a> details the behavior of such types.</p> </li> <li>You cannot bind a variable with an unboxed type in a <em>top-level</em> binding. </li> <li>You cannot bind a variable with an unboxed type in a <em>recursive</em> binding. </li> <li>
<p class="first">You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning <a class="reference internal" href="../using-warnings.html#ghc-flag--Wunbanged-strict-patterns"><code>-Wunbanged-strict-patterns</code></a>.) For example, rather than:</p> <pre data-language="haskell">data Foo = Foo Int Int#

f x = let (Foo a b, w) = ..rhs.. in ..body..
</pre> <p>you must write:</p> <pre data-language="haskell">data Foo = Foo Int Int#

f x = let !(Foo a b, w) = ..rhs.. in ..body..
</pre> <p>since <code>b</code> has type <code>Int#</code>.</p> </li> </ul>   <h2 id="id1">6.16.3. Unboxed tuples</h2> <dl class="extension" id="unboxed-tuples"> <dt id="extension-UnboxedTuples">
<code>UnboxedTuples</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-UnboxedSums"><code>UnboxedSums</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> </dd>
</dl> <p>Unboxed tuples aren’t really exported by <code>GHC.Exts</code>; they are a syntactic extension (<a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a>). An unboxed tuple looks like this:</p> <pre data-language="haskell">(# e_1, ..., e_n #)
</pre> <p>where <code>e_1..e_n</code> are expressions of any type (primitive or non-primitive). The type of an unboxed tuple looks the same.</p> <p>Note that when unboxed tuples are enabled, <code>(#</code> is a single lexeme, so for example when using operators like <code>#</code> and <code>#-</code> you need to write <code>( # )</code> and <code>( #- )</code> rather than <code>(#)</code> and <code>(#-)</code>.</p> <p>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in <code>primops.txt.pp</code> return unboxed tuples. In particular, the <code>IO</code> and <code>ST</code> monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</p> <p>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a <code>case</code> expression, thus:</p> <pre data-language="haskell">f x y = (# x+1, y-1 #)
g x = case f x x of { (# a, b #) -&gt; a + b }
</pre> <p>You can have an unboxed tuple in a pattern binding, thus</p> <pre data-language="haskell">f x = let (# p,q #) = h x in ..body..
</pre> <p>If the types of <code>p</code> and <code>q</code> are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</p> <pre data-language="haskell">f x = let t = case h x of { (# p,q #) -&gt; (p,q) }
          p = fst t
          q = snd t
      in ..body..
</pre> <p>Indeed, the bindings can even be recursive.</p> <p>To refer to the unboxed tuple type constructors themselves, e.g. if you want to attach instances to them, use <code>(# #)</code>, <code>(#,#)</code>, <code>(#,,#)</code>, etc. This mirrors the syntax for boxed tuples <code>()</code>, <code>(,)</code>, <code>(,,)</code>, etc.</p>   <h2 id="id2">6.16.4. Unboxed sums</h2> <dl class="extension" id="unboxed-sums"> <dt id="extension-UnboxedSums">
<code>UnboxedSums</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.1</td> </tr>  </table> <p>Enable the use of unboxed sum syntax. Implied by <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a>.</p> </dd>
</dl> <p><code>-XUnboxedSums</code> enables new syntax for anonymous, unboxed sum types. The syntax for an unboxed sum type with N alternatives is</p> <pre data-language="haskell">(# t_1 | t_2 | ... | t_N #)
</pre> <p>where <code>t_1</code> … <code>t_N</code> are types (which can be unlifted, including unboxed tuples and sums).</p> <p>Unboxed tuples can be used for multi-arity alternatives. For example:</p> <pre data-language="haskell">(# (# Int, String #) | Bool #)
</pre> <p>The term level syntax is similar. Leading and preceding bars (<code>|</code>) indicate which alternative it is. Here are two terms of the type shown above:</p> <pre data-language="haskell">(# (# 1, "foo" #) | #) -- first alternative

(# | True #) -- second alternative
</pre> <p>The pattern syntax reflects the term syntax:</p> <pre data-language="haskell">case x of
  (# (# i, str #) | #) -&gt; ...
  (# | bool #) -&gt; ...
</pre> <p>Note that spaces are always required around bars. For example, <code>(# | 1# | | #)</code> is valid, but <code>(# | 1# || #)</code> and <code>(#| 1# | | #)</code> are both invalid.</p> <p>The type constructors themselves can be written in prefix form as <code>(# | #)</code>, <code>(# | | #)</code>, <code>(# | | | #)</code>, etc. Partial applications must also use prefix form, i.e. <code>(# | #) Int#</code>. Saturated applications can be written either way, so that <code>(# | #) Int# Float#</code> is equivalent to <code>(# Int# | Float# #)</code>.</p> <p>Unboxed sums are “unboxed” in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These “components” depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</p> <p>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</p> <ul> <li>All types are classified as one of these classes: 32bit word, 64bit word, 32bit float, 64bit float, pointer. </li> <li>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has <code>Int</code>, <code>Float#</code> and <code>String</code> fields, the layout will have an 32bit word, 32bit float and pointer fields. </li> <li>
<p class="first">Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</p> <pre data-language="haskell">(# (# Word32#, String, Float# #)
|  (# Float#, Float#, Maybe Int #) #)
</pre> <p>The final layout will be something like</p> <pre data-language="haskell">Int32, Float32, Float32, Word32, Pointer
</pre> <p>The first <code>Int32</code> is for the tag. There are two <code>Float32</code> fields because floating point types can’t overlap with other types, because of limitations of the code generator that we’re hoping to overcome in the future. The second alternative needs two <code>Float32</code> fields: The <code>Word32</code> field is for the <code>Word32#</code> in the first alternative. The <code>Pointer</code> field is shared between <code>String</code> and <code>Maybe Int</code> values of the alternatives.</p> <p>As another example, this is the layout for the unboxed version of <code>Maybe a</code> type, <code>(# (# #) | a #)</code>:</p> <pre data-language="haskell">Int32, Pointer
</pre> <p>The <code>Pointer</code> field is not used when tag says that it’s <code>Nothing</code>. Otherwise <code>Pointer</code> points to the value in <code>Just</code>. As mentioned above, this type is lazy in its lifted field. Therefore, the type</p> <pre data-language="haskell">data Maybe' a = Maybe' (# (# #) | a #)
</pre> <p>is <em>precisely</em> isomorphic to the type <code>Maybe a</code>, although its memory representation is different.</p> <p>In the degenerate case where all the alternatives have zero width, such as the <code>Bool</code>-like <code>(# (# #) | (# #) #)</code>, the unboxed sum layout only has an <code>Int32</code> tag field (i.e., the whole thing is represented by an integer).</p> </li> </ul>   <h2 id="id3">6.16.5. Unlifted Newtypes</h2> <dl class="extension" id="unlifted-newtypes"> <dt id="extension-UnliftedNewtypes">
<code>UnliftedNewtypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10.1</td> </tr>  </table> <p>Enable the use of newtypes over types with non-lifted runtime representations.</p> </dd>
</dl> <p>GHC implements an <a class="reference internal" href="#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> extension as specified in <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0098-unlifted-newtypes.rst">the GHC proposal #98</a>. <a class="reference internal" href="#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> relaxes the restrictions around what types can appear inside of a <code>newtype</code>. For example, the type</p> <pre data-language="haskell">newtype A = MkA Int#
</pre> <p>is accepted when this extension is enabled. This creates a type <code>A :: TYPE IntRep</code> and a data constructor <code>MkA :: Int# -&gt; A</code>. Although the kind of <code>A</code> is inferred by GHC, there is nothing visually distinctive about this type that indicated that is it not of kind <code>Type</code> like newtypes typically are. <a class="reference external" href="#gadt-style">GADTSyntax</a> can be used to provide a kind signature for additional clarity</p> <pre data-language="haskell">newtype A :: TYPE IntRep where
  MkA :: Int# -&gt; A
</pre> <p>The <code>Coercible</code> machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of <code>A</code> given above, users would additionally have access to a coercion between <code>A</code> and <code>Int#</code>.</p> <p>As a consequence of the <a class="reference external" href="#representation-polymorphism-restrictions">representation-polymorphic binder restriction</a>, representation-polymorphic fields are disallowed in data constructors of data types declared using <code>data</code>. However, since <code>newtype</code> data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a <code>newtype</code> data constructor. Thus, the type checker accepts</p> <pre data-language="haskell">newtype Identity# :: forall (r :: RuntimeRep). TYPE r -&gt; TYPE r where
  MkIdentity# :: forall (r :: RuntimeRep) (a :: TYPE r). a -&gt; Identity# a
</pre> <p>And with <a class="reference external" href="#unboxed-sums">UnboxedSums</a> enabled</p> <pre data-language="haskell">newtype Maybe# :: forall (r :: RuntimeRep). TYPE r -&gt; TYPE (SumRep '[r, TupleRep '[]]) where
  MkMaybe# :: forall (r :: RuntimeRep) (a :: TYPE r). (# a | (# #) #) -&gt; Maybe# a
</pre> <p>This extension also relaxes some of the restrictions around data family instances. In particular, <a class="reference internal" href="#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> permits a <code>newtype instance</code> to be given a return kind of <code>TYPE r</code>, not just <code>Type</code>. For example, the following <code>newtype instance</code> declarations would be permitted:</p> <pre data-language="haskell">class Foo a where
  data FooKey a :: TYPE IntRep
class Bar (r :: RuntimeRep) where
  data BarType r :: TYPE r

instance Foo Bool where
  newtype FooKey Bool = FooKeyBoolC Int#
instance Bar WordRep where
  newtype BarType WordRep = BarTypeWordRepC Word#
</pre> <p>It is worth noting that <a class="reference internal" href="#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> is <em>not</em> required to give the data families themselves return kinds involving <code>TYPE</code>, such as the <code>FooKey</code> and <code>BarType</code> examples above. The extension is only required for <code>newtype instance</code> declarations, such as <code>FooKeyBoolC</code> and <code>BarTypeWorkRepC</code> above.</p> <p>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified <a class="reference external" href="#complete-kind-signatures">the section on CUSKs</a>.</p>   <h2 id="unlifted-datatypes">6.16.6. Unlifted Datatypes</h2> <dl class="extension"> <dt id="extension-UnliftedDatatypes">
<code>UnliftedDatatypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="data_kinds.html#extension-DataKinds"><code>DataKinds</code></a>, <a class="reference internal" href="poly_kinds.html#extension-StandaloneKindSignatures"><code>StandaloneKindSignatures</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2.1</td> </tr>  </table> <p>Enable the declaration of data types with unlifted or levity-polymorphic result kind.</p> </dd>
</dl> <p>GHC implements the <a class="reference internal" href="#extension-UnliftedDatatypes"><code>UnliftedDatatypes</code></a> extension as specified in <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0265-unlifted-datatypes.rst">the GHC proposal #265</a>. <a class="reference internal" href="#extension-UnliftedDatatypes"><code>UnliftedDatatypes</code></a> relaxes the restrictions around what result kinds are allowed in data declarations. For example, the type</p> <pre data-language="haskell">data UList a :: UnliftedType where
  UCons :: a -&gt; UList a -&gt; UList a
  UNil :: UList a
</pre> <p>defines a list type that lives in kind <code>UnliftedType</code> (e.g., <code>TYPE (BoxedRep Unlifted)</code>). As such, each occurrence of a term of that type is assumed to be evaluated (and the compiler makes sure that is indeed the case). In other words: Unlifted data types behave like data types in strict languages such as OCaml or Idris. However unlike <a class="reference internal" href="strict.html#extension-StrictData"><code>StrictData</code></a>, this extension will not change whether the fields of a (perhaps unlifted) data type are strict or lazy. For example, <code>UCons</code> is lazy in its first argument as its field has kind <code>Type</code>.</p> <p>The fact that unlifted types are always evaluated allows GHC to elide evaluatedness checks at runtime. See the Motivation section of the proposal for how this can improve performance for some programs.</p> <p>The above data declaration in GADT syntax correctly suggests that unlifted data types are compatible with the full GADT feature set. Somewhat conversely, you can also declare unlifted data types in Haskell98 syntax, which requires you to specify the result kind via <a class="reference internal" href="poly_kinds.html#extension-StandaloneKindSignatures"><code>StandaloneKindSignatures</code></a>:</p> <pre data-language="haskell">type UList :: Type -&gt; UnliftedType
data UList a = UCons a (UList a) | UNil
</pre> <p>You may even declare levity-polymorphic data types:</p> <pre data-language="haskell">type PEither :: Type -&gt; Type -&gt; TYPE (BoxedRep l)
data PEither l r = PLeft l | PRight r

f :: PEither @Unlifted Int Bool -&gt; Bool
f (PRight b) = b
f _          = False
</pre> <p>While <code>f</code> above could reasonably be levity-polymorphic (as it evaluates its argument either way), GHC currently disallows the more general type <code>PEither @l Int Bool -&gt; Bool</code>. This is a consequence of the <a class="reference external" href="#representation-polymorphism-restrictions">representation-polymorphic binder restriction</a>,</p> <p>Due to <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/19487">#19487</a>, it’s currently not possible to declare levity-polymorphic data types with nullary data constructors. There’s a workaround, though:</p> <pre data-language="haskell">type T :: TYPE (BoxedRep l)
data T where
  MkT :: forall l. (() :: Constraint) =&gt; T @l
</pre> <p>The use of <code>=&gt;</code> makes the type of <code>MkT</code> lifted. If you want a zero-runtime-cost alternative, use <code>MkT :: Proxy# () -&gt; T @l</code> instead and bear with the additional <code>proxy#</code> argument at construction sites.</p> <p>This extension also relaxes some of the restrictions around data family instances. In particular, <a class="reference internal" href="#extension-UnliftedDatatypes"><code>UnliftedDatatypes</code></a> permits a <code>data instance</code> to be given a return kind that unifies with <code>TYPE (BoxedRep l)</code>, not just <code>Type</code>. For example, the following <code>data
instance</code> declarations would be permitted:</p> <pre data-language="haskell">data family F a :: UnliftedType
data instance F Int = FInt

data family G a :: TYPE (BoxedRep l)
data instance G Int = GInt Int -- defaults to Type
data instance G Bool :: UnliftedType where
  GBool :: Bool -&gt; G Bool
data instance G Char :: Type where
  GChar :: Char -&gt; G Char
data instance G Double :: forall l. TYPE (BoxedRep l) where
  GDouble :: Int -&gt; G @l Double
</pre> <p>It is worth noting that <a class="reference internal" href="#extension-UnliftedDatatypes"><code>UnliftedDatatypes</code></a> is <em>not</em> required to give the data families themselves return kinds involving <code>TYPE</code>, such as the <code>G</code> example above. The extension is only required for <code>data instance</code> declarations, such as <code>FInt</code> and <code>GBool</code> above.</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/primitives.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/primitives.html</a>
  </p>
</div>
