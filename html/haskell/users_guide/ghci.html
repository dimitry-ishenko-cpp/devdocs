<h1 id="ghci">3. Using GHCi</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="using-ghci">  <p id="index-0">GHCi <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> is GHC’s interactive environment that includes an interactive debugger (see <a class="reference internal" href="#ghci-debugger"><span class="std std-ref">The GHCi Debugger</span></a>).</p> <p>GHCi can</p> <ul class="simple"> <li>interactively evaluate Haskell expressions</li> <li>interpret Haskell programs</li> <li>load GHC-compiled modules.</li> </ul> <p>At the moment GHCi supports most of GHC’s language extensions.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id2" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>The “i” stands for “Interactive”</p> </aside> </aside> <section id="introduction-to-ghci"> <h2 id="ghci-introduction">
<span class="section-number">3.1. </span>Introduction to GHCi</h2> <p>Let’s start with an example GHCi session. You can fire up GHCi with the command <code>ghci</code>:</p> <pre data-language="none">$ ghci
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
ghci&gt;
</pre> <p>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type <a class="reference internal" href="#ghci-cmd-2"><code>:?</code></a> to see the list of commands available, and a half line description of each of them. We’ll explain most of these commands as we go along, and there is complete documentation for all the commands in <a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>.</p> <p>Haskell expressions can be typed at the prompt:</p> <pre data-language="none">ghci&gt; 1+2
3
ghci&gt; let x = 42 in x / 9
4.666666666666667
ghci&gt;
</pre> <p>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</p> <p>In Haskell, a <code>let</code> expression is followed by <code>in</code>. However, in GHCi, since the expression can also be interpreted in the <code>IO</code> monad, a <code>let</code> binding with no accompanying <code>in</code> statement can be signalled by an empty line, as in the above example.</p> <p>Since GHC 8.0.1, you can bind values and functions to names without <code>let</code> statement:</p> <pre data-language="none">ghci&gt; x = 42
ghci&gt; x
42
ghci&gt;
</pre> </section> <section id="loading-source-files"> <h2 id="id3">
<span class="section-number">3.2. </span>Loading source files</h2> <p>Suppose we have the following Haskell source code, which we place in a file <code>Main.hs</code>:</p> <pre data-language="haskell">main = print (fac 20)

fac 0 = 1
fac n = n * fac (n-1)
</pre> <p>You can save <code>Main.hs</code> anywhere you like, but if you save it somewhere other than the current directory <a class="footnote-reference brackets" href="#id5" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> then we will need to change to the right directory in GHCi:</p> <pre data-language="none">ghci&gt; :cd dir
</pre> <p>where ⟨dir⟩ is the directory (or folder) in which you saved <code>Main.hs</code>.</p> <p>To load a Haskell source file into GHCi, use the <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> command:</p> <pre data-language="none">ghci&gt; :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt;
</pre> <p>GHCi has loaded the <code>Main</code> module, and the prompt has changed to <code>*ghci&gt;</code> to indicate that the current context for expressions typed at the prompt is the <code>Main</code> module we just loaded (we’ll explain what the <code>*</code> means later in <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). So we can now type expressions involving the functions from <code>Main.hs</code>:</p> <pre data-language="none">*ghci&gt; fac 17
355687428096000
</pre> <p>Loading a multi-module program is just as straightforward; just give the name of the “topmost” module to the <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> command (hint: <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> can be abbreviated to <code>:l</code>). The topmost module will normally be <code>Main</code>, but it doesn’t have to be. GHCi will discover which modules are required, directly or indirectly, by the topmost module, and load them all in dependency order.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id5" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span> <p>If you started up GHCi from the command line then GHCi’s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the “Start” menu in Windows, then the current directory is probably something like <code>C:\Documents and Settings\user name</code>.</p> </aside> </aside> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fshow-loaded-modules">
<code>-fshow-loaded-modules</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>off</p> </dd> <dt class="field-even">Since<span class="colon">:</span>
</dt> <dd class="field-even">
<p>8.2.2</p> </dd> </dl> <p>Typically GHCi will show only the number of modules that it loaded after a <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> command. With this flag, GHC will also list the loaded modules’ names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</p> </dd>
</dl> <section id="modules-vs-filenames"> <h3 id="ghci-modules-filenames">
<span class="section-number">3.2.1. </span>Modules vs. filenames</h3> <p id="index-3">Question: How does GHC find the filename which contains module ⟨M⟩? Answer: it looks for the file <code>M.hs</code>, or <code>M.lhs</code>. This means that for most modules, the module name must match the filename. If it doesn’t, GHCi won’t be able to find it.</p> <p>There is one exception to this general rule: when you load a program with <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, or specify it when you invoke <code>ghci</code>, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several <code>Main</code> modules in the same directory and you can’t call them all <code>Main.hs</code>.</p> <p>The search path for finding source files is specified with the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> option on the GHCi command line, like so:</p> <pre data-language="none">ghci -idir1:...:dirn
</pre> <p>or it can be set using the <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> command from within GHCi (see <a class="reference internal" href="#ghci-cmd-line-options"><span class="std std-ref">Setting GHC command-line options in GHCi</span></a>) <a class="footnote-reference brackets" href="#id7" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p> <p>One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the <code>Prelude</code> and standard libraries such as <code>IO</code> and <code>Complex</code>. If you attempt to load a module for which GHCi can’t find a source file, even if there are object and interface files for the module, you’ll get an error message.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id7" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span> <p>Note that in GHCi, and <a class="reference internal" href="using.html#ghc-flag-make"><code>--make</code></a> mode, the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> option is used to specify the search path for <em>source</em> files, whereas in standard batch-compilation mode the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> option is used to specify the search path for interface files, see <a class="reference internal" href="separate_compilation.html#search-path"><span class="std std-ref">The search path</span></a>.</p> </aside> </aside> </section> <section id="making-changes-and-recompilation"> <h3>
<span class="section-number">3.2.2. </span>Making changes and recompilation</h3> <p id="index-4">If you make some changes to the source code and want GHCi to recompile the program, give the <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a> command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven’t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see <a class="reference internal" href="separate_compilation.html#recomp"><span class="std std-ref">The recompilation checker</span></a>).</p> </section> </section> <section id="loading-compiled-code"> <h2 id="ghci-compiled">
<span class="section-number">3.3. </span>Loading compiled code</h2> <p id="index-5">When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the <code>base</code> package, which contains the <code>Prelude</code>.</p> <p>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren’t changing very often, and use the interpreter for the code being actively developed.</p> <p>When loading up source modules with <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. Modules <code>B</code> and <code>C</code> both import <code>D</code> only, and <code>A</code> imports both <code>B</code> and <code>C</code>:</p> <pre data-language="none">  A
 / \
B   C
 \ /
  D
</pre> <p>We can compile <code>D</code>, then load the whole program, like this:</p> <pre data-language="none">ghci&gt; :! ghc -c -dynamic D.hs
ghci&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D (D.o).
*ghci&gt;
</pre> <p>In the messages from the compiler, we see that there is no line for <code>D</code>. This is because it isn’t necessary to compile <code>D</code>, because the source and everything it depends on is unchanged since the last compilation.</p> <p>Note the <a class="reference internal" href="phases.html#ghc-flag-dynamic"><code>-dynamic</code></a> flag to GHC: GHCi uses dynamically-linked object code (if you are on a platform that supports it), and so in order to use compiled code with GHCi it must be compiled for dynamic linking.</p> <p>At any time you can use the command <a class="reference internal" href="#ghci-cmd-show-modules"><code>:show modules</code></a> to get a list of the modules currently loaded into GHCi:</p> <pre data-language="none">*ghci&gt; :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*ghci&gt;
</pre> <p>If we now modify the source of <code>D</code> (or pretend to: using the Unix command <code>touch</code> on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</p> <pre data-language="none">*ghci&gt; :! touch D.hs
*ghci&gt; :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*ghci&gt;
</pre> <p>Note that module <code>D</code> was compiled, but in this instance because its source hadn’t really changed, its interface remained the same, and the recompilation checker determined that <code>A</code>, <code>B</code> and <code>C</code> didn’t need to be recompiled.</p> <p>So let’s try compiling one of the other modules:</p> <pre data-language="none">*ghci&gt; :! ghc -c C.hs
*ghci&gt; :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</pre> <p>We didn’t get the compiled version of <code>C</code>! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case <code>C</code> depends on <code>D</code>, which doesn’t have an object file, so GHCi also rejected <code>C</code>'s object file. Ok, so let’s also compile <code>D</code>:</p> <pre data-language="none">*ghci&gt; :! ghc -c D.hs
*ghci&gt; :reload
Ok, modules loaded: A, B, C, D.
</pre> <p>Nothing happened! Here’s another lesson: newly compiled modules aren’t picked up by <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, only <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>:</p> <pre data-language="none">*ghci&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C (C.o), D (D.o).
</pre> <p>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a <code>*</code> to the module name or filename when using <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, for example</p> <pre data-language="none">ghci&gt; :load *A
Compiling A                ( A.hs, interpreted )
*ghci&gt;
</pre> <p>When the <code>*</code> is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use <code>:add *M</code> to specify that you want <code>M</code> to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</p> <p>To always compile everything to object code and never use the interpreter, use the <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code>-fobject-code</code></a> option (see <a class="reference internal" href="#ghci-obj"><span class="std std-ref">Compiling to object code inside GHCi</span></a>).</p> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>Since GHCi will only use a compiled object file if it can be sure that the compiled version is up-to-date, a good technique when working on a large program is to occasionally run <code>ghc --make</code> to compile the whole project (say before you go for lunch :-), then continue working in the interpreter. As you modify code, the changed modules will be interpreted, but the rest of the project will remain compiled.</p> </div> </section> <section id="interactive-evaluation-at-the-prompt"> <h2 id="interactive-evaluation">
<span class="section-number">3.4. </span>Interactive evaluation at the prompt</h2> <p>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</p> <pre data-language="none">ghci&gt; reverse "hello"
"olleh"
ghci&gt; 5+5
10
</pre> <section id="i-o-actions-at-the-prompt"> <h3 id="actions-at-prompt">
<span class="section-number">3.4.1. </span>I/O actions at the prompt</h3> <p>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type <code>IO a</code> for some <code>a</code>, then GHCi <em>executes</em> it as an IO-computation.</p> <pre data-language="none">ghci&gt; "hello"
"hello"
ghci&gt; putStrLn "hello"
hello
</pre> <p>This works even if the type of the expression is more general, provided it can be <em>instantiated</em> to <code>IO a</code>. For example</p> <pre data-language="none">ghci&gt; return True
True
</pre> <p>Furthermore, GHCi will print the result of the I/O action if (and only if):</p> <ul class="simple"> <li>The result type is an instance of <code>Show</code>.</li> <li>The result type is not <code>()</code>.</li> </ul> <p>For example, remembering that <code>putStrLn :: String -&gt; IO ()</code>:</p> <pre data-language="none">ghci&gt; putStrLn "hello"
hello
ghci&gt; do { putStrLn "hello"; return "yes" }
hello
"yes"
</pre> </section> <section id="using-do-notation-at-the-prompt"> <h3 id="ghci-stmts">
<span class="section-number">3.4.2. </span>Using <code>do</code> notation at the prompt</h3> <p id="index-6">GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</p> <p>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell <code>do</code> expression. However, there’s no monad overloading here: statements typed at the prompt must be in the <code>IO</code> monad.</p> <pre data-language="none">ghci&gt; x &lt;- return 42
ghci&gt; print x
42
ghci&gt;
</pre> <p>The statement <code>x &lt;- return 42</code> means “execute <code>return 42</code> in the <code>IO</code> monad, and bind the result to <code>x</code>”. We can then use <code>x</code> in future statements, for example to print it as we did above.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-bind-result">
<code>-fprint-bind-result</code> </dt> <dd>
<p>If <a class="reference internal" href="#ghc-flag-fprint-bind-result"><code>-fprint-bind-result</code></a> is set then GHCi will print the result of a statement if and only if:</p> <ul class="simple"> <li>The statement is not a binding, or it is a monadic binding (<code>p &lt;- e</code>) that binds exactly one variable.</li> <li>The variable’s type is not polymorphic, is not <code>()</code>, and is an instance of <code>Show</code>.</li> </ul> </dd>
</dl> <p>Of course, you can also bind normal non-IO expressions using the <code>let</code>-statement:</p> <pre data-language="none">ghci&gt; let x = 42
ghci&gt; x
42
ghci&gt;
</pre> <p>Another important difference between the two types of binding is that the monadic bind (<code>p &lt;- e</code>) is <em>strict</em> (it evaluates <code>e</code>), whereas with the <code>let</code> form, the expression isn’t evaluated immediately:</p> <pre data-language="none">ghci&gt; let x = error "help!"
ghci&gt; print x
*** Exception: help!
ghci&gt;
</pre> <p>Note that <code>let</code> bindings do not automatically print the value bound, unlike monadic bindings.</p> <p>You can also define functions at the prompt:</p> <pre data-language="none">ghci&gt; add a b = a + b
ghci&gt; add 1 2
3
ghci&gt;
</pre> <p>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</p> <pre data-language="none">ghci&gt; f op n [] = n ; f op n (h:t) = h `op` f op n t
ghci&gt; f (+) 0 [1..3]
6
ghci&gt;
</pre> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-0">
<code>:{</code> </dt> <dt class="sig sig-object std" id="ghci-cmd-1">
<code>:}</code> </dt> <dd>
<p>Begin or end a multi-line GHCi command block.</p> </dd>
</dl> <p>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in <code>:{</code> and <code>:}</code> (each on a single line of its own):</p> <pre data-language="none">ghci&gt; :{
ghci| g op n [] = n
ghci| g op n (h:t) = h `op` g op n t
ghci| :}
ghci&gt; g (*) 1 [1..3]
6
</pre> <p>Such multiline commands can be used with any GHCi command, and note that the layout rule is in effect. The main purpose of multiline commands is not to replace module loading but to make definitions in .ghci-files (see <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>) more readable and maintainable.</p> <p>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module <a class="reference external" href="../libraries/base-4.21.0.0-8e62/control-exception.html">Control.Exception</a> in the libraries documentation.)</p> <p>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Temporary bindings introduced at the prompt only last until the next <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> or <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a> command, at which time they will be simply lost. However, they do survive a change of context with <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a>: the temporary bindings just move to the new location.</p> </div> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>To get a list of the bindings currently in scope, use the <a class="reference internal" href="#ghci-cmd-show-bindings"><code>:show bindings</code></a> command:</p> <pre data-language="none">ghci&gt; :show bindings
x :: Int
ghci&gt;
</pre> </div> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>If you turn on the <code>+t</code> option, GHCi will show the type of each variable bound by a statement. For example:</p> <pre data-language="none">ghci&gt; :set +t
ghci&gt; let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</pre> </div> </section> <section id="multiline-input"> <h3 id="index-7">
<span class="section-number">3.4.3. </span>Multiline input</h3> <p>Apart from the <code>:{ ... :}</code> syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by <code>:set +m</code>, <code>:set +m</code> in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</p> <pre data-language="none">ghci&gt; :set +m
ghci&gt; let x = 42
ghci|
</pre> <p>Further bindings can be added to this <code>let</code> statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this <code>let</code> we have to line them up:</p> <pre data-language="none">ghci&gt; :set +m
ghci&gt; let x = 42
ghci|     y = 3
ghci|
ghci&gt;
</pre> <p>Explicit braces and semicolons can be used instead of layout:</p> <pre data-language="none">ghci&gt; do {
ghci| putStrLn "hello"
ghci| ;putStrLn "world"
ghci| }
hello
world
ghci&gt;
</pre> <p>Note that after the closing brace, GHCi knows that the current statement is finished, so no empty line is required.</p> <p>Multiline mode is useful when entering monadic <code>do</code> statements:</p> <pre data-language="none">ghci&gt; flip evalStateT 0 $ do
ghci| i &lt;- get
ghci| lift $ do
ghci|   putStrLn "Hello World!"
ghci|   print i
ghci|
"Hello World!"
0
ghci&gt;
</pre> <p>During a multiline interaction, the user can interrupt and return to the top-level prompt.</p> <pre data-language="none">ghci&gt; do
ghci| putStrLn "Hello, World!"
ghci| ^C
ghci&gt;
</pre> </section> <section id="type-class-and-other-declarations"> <h3 id="ghci-decls">
<span class="section-number">3.4.4. </span>Type, class and other declarations</h3> <p>At the GHCi prompt you can also enter any top-level Haskell declaration, including <code>data</code>, <code>type</code>, <code>newtype</code>, <code>class</code>, <code>instance</code>, <code>deriving</code>, and <code>foreign</code> declarations. For example:</p> <pre data-language="none">ghci&gt; data T = A | B | C deriving (Eq, Ord, Show, Enum)
ghci&gt; [A ..]
[A,B,C]
ghci&gt; :i T
data T = A | B | C      -- Defined at &lt;interactive&gt;:2:6
instance Enum T -- Defined at &lt;interactive&gt;:2:45
instance Eq T -- Defined at &lt;interactive&gt;:2:30
instance Ord T -- Defined at &lt;interactive&gt;:2:34
instance Show T -- Defined at &lt;interactive&gt;:2:39
</pre> <p>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there’s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</p> <pre data-language="none">ghci&gt; data T = A | B
ghci&gt; let f A = True; f B = False
ghci&gt; data T = A | B | C
ghci&gt; f A

&lt;interactive&gt;:2:3:
    Couldn't match expected type `main::Interactive.T'
                with actual type `T'
    In the first argument of `f', namely `A'
    In the expression: f A
    In an equation for `it': it = f A
ghci&gt;
</pre> <p>The old, shadowed, version of <code>T</code> is displayed as <code>main::Interactive.T</code> by GHCi in an attempt to distinguish it from the new <code>T</code>, which is displayed as simply <code>T</code>.</p> <p>Class and type-family instance declarations are simply added to the list of available instances, with one exception. Since you might want to re-define one, a class instance <em>replaces</em> any earlier instance with an identical head. You aren’t allowed to re-define a type family instance, since it might not be type safe to do so. Instead, re-define the whole type-family. (See <a class="reference internal" href="exts/type_families.html#type-families"><span class="std std-ref">Type families</span></a>.) For example:</p> <pre data-language="none">ghci&gt; type family T a b
ghci&gt; type instance T a b = a
ghci&gt; let uc :: a -&gt; T a b; uc = id

ghci&gt; type instance T a b = b

&lt;interactive&gt;:3:15: error:
    Conflicting family instance declarations:
      T a b = a -- Defined at &lt;interactive&gt;:3:15
      T a b = b -- Defined at &lt;interactive&gt;:5:15

-- Darn! We have to re-declare T.

ghci&gt; type family T a b
-- This is a brand-new T, unrelated to the old one
ghci&gt; type instance T a b = b
ghci&gt; uc 'a' :: Int

&lt;interactive&gt;:8:1: error:
    • Couldn't match type ‘Char’ with ‘Int’
      Expected type: Int
        Actual type: Ghci1.T Char b0
    • In the expression: uc 'a' :: Int
      In an equation for ‘it’: it = uc 'a' :: Int
</pre> </section> <section id="what-s-really-in-scope-at-the-prompt"> <h3 id="ghci-scope">
<span class="section-number">3.4.5. </span>What’s really in scope at the prompt?</h3> <p>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</p> <ul class="simple"> <li>The <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a> commands (<a class="reference internal" href="#ghci-load-scope"><span class="std std-ref">The effect of :load on what is in scope</span></a>).</li> <li>The <code>import</code> declaration (<a class="reference internal" href="#ghci-import-decl"><span class="std std-ref">Controlling what is in scope with import</span></a>).</li> <li>The <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> command (<a class="reference internal" href="#ghci-module-cmd"><span class="std std-ref">Controlling what is in scope with the :module command</span></a>).</li> </ul> <p>The command <a class="reference internal" href="#ghci-cmd-show-imports"><code>:show imports</code></a> will show a summary of which modules contribute to the top-level scope.</p> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type <code>J&lt;tab&gt;</code> then GHCi will expand it to <code>Just</code>.</p> </div> <section id="the-effect-of-load-on-what-is-in-scope"> <h4 id="ghci-load-scope">
<span class="section-number">3.4.5.1. </span>The effect of <code>:load</code> on what is in scope</h4> <p>The <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a> commands (<a class="reference internal" href="#loading-source-files"><span class="std std-ref">Loading source files</span></a> and <a class="reference internal" href="#ghci-compiled"><span class="std std-ref">Loading compiled code</span></a>) affect the top-level scope. Let’s start with the simple cases; when you start GHCi the prompt looks like this:</p> <pre data-language="none">ghci&gt;
</pre> <p>By default, this means that everything from the module <code>Prelude</code> is currently in scope. Should the prompt be set to <code>%s&gt;</code> in the <code>.ghci</code> configuration file, we would be seeing <code>Prelude&gt;</code> displayed. However, it is not the default mechanism due to the large space the prompt can take if more imports are done.</p> <p>The syntax in the prompt <code>*module</code> indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the <code>*</code>, just the exports of the module are visible.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For technical reasons, GHCi can only support the <code>*</code>-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the <code>*</code> when loading the module, e.g. <code>:load *M</code>.</p> </div> <p>In general, after a <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> command, an automatic import is added to the scope for the most recently loaded “target” module, in a <code>*</code>-form if possible. For example, if you say <code>:load foo.hs bar.hs</code> and <code>bar.hs</code> contains module <code>Bar</code>, then the scope will be set to <code>*Bar</code> if <code>Bar</code> is interpreted, or if <code>Bar</code> is compiled it will be set to <code>Prelude</code> and <code>Bar</code> (GHCi automatically adds <code>Prelude</code> if it isn’t present and there aren’t any <code>*</code>-form modules). These automatically-added imports can be seen with <a class="reference internal" href="#ghci-cmd-show-imports"><code>:show imports</code></a>:</p> <pre data-language="none">ghci&gt; :load hello.hs
[1 of 1] Compiling Main             ( hello.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt; :show imports
:module +*Main -- added automatically
*ghci&gt;
</pre> <p>and the automatically-added import is replaced the next time you use <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> or <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a>. It can also be removed by <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> as with normal imports.</p> </section> <section id="controlling-what-is-in-scope-with-import"> <h4 id="ghci-import-decl">
<span class="section-number">3.4.5.2. </span>Controlling what is in scope with <code>import</code>
</h4> <p>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of <code>*</code> and non-<code>*</code> forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</p> <p>To add modules to the scope, use ordinary Haskell <code>import</code> syntax:</p> <pre data-language="none">ghci&gt; import System.IO
ghci&gt; hPutStrLn stdout "hello\n"
hello
</pre> <p>The full Haskell import syntax is supported, including <code>hiding</code> and <code>as</code> clauses. The prompt shows the modules that are currently imported, but it omits details about <code>hiding</code>, <code>as</code>, and so on. To see the full story, use <a class="reference internal" href="#ghci-cmd-show-imports"><code>:show imports</code></a>:</p> <pre data-language="none">ghci&gt; import System.IO
ghci&gt; import Data.Map as Map
ghci Map&gt; :show imports
import Prelude -- implicit
import System.IO
import Data.Map as Map
</pre> <p>Note that the <code>Prelude</code> import is marked as implicit. It can be overridden with an explicit <code>Prelude</code> import, just like in a Haskell module.</p> <p>With multiple modules in scope, especially multiple <code>*</code>-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</p> </section> <section id="controlling-what-is-in-scope-with-the-module-command"> <h4 id="ghci-module-cmd">
<span class="section-number">3.4.5.3. </span>Controlling what is in scope with the <code>:module</code> command</h4> <p>Another way to manipulate the scope is to use the <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> command, whose syntax is this:</p> <pre data-language="none">:module +|- *mod1 ... *modn
</pre> <p>Using the <code>+</code> form of the <code>module</code> commands adds modules to the current scope, and <code>-</code> removes them. Without either <code>+</code> or <code>-</code>, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out <code>Prelude</code>, an implicit <code>Prelude</code> import will be added automatically.</p> <p>The <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> command provides a way to do two things that cannot be done with ordinary <code>import</code> declarations:</p> <ul class="simple"> <li>
<a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> supports the <code>*</code> modifier on modules, which opens the full top-level scope of a module, rather than just its exports.</li> <li>Imports can be <em>removed</em> from the context, using the syntax <code>:module -M</code>. The <code>import</code> syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</li> </ul> </section> <section id="qualified-names"> <h4 id="ghci-import-qualified">
<span class="section-number">3.4.5.4. </span>Qualified names</h4> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fimplicit-import-qualified">
<code>-fimplicit-import-qualified</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>on</p> </dd> </dl> </dd>
</dl> <p>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit <code>import qualified</code> declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the <code>-fno-implicit-import-qualified</code> flag.</p> </section> <section id="module-and-load"> <h4>
<span class="section-number">3.4.5.5. </span><code>:module</code> and <code>:load</code>
</h4> <p>It might seem that <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a>/<code>import</code> and <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>/<a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a>/<a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a> do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</p> <ul class="simple"> <li>The set of modules that are currently <em>loaded</em>. This set is modified by <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a>, and can be shown with <a class="reference internal" href="#ghci-cmd-show-modules"><code>:show modules</code></a>.</li> <li>The set of modules that are currently <em>in scope</em> at the prompt. This set is modified by <code>import</code> and <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a>, and it is also modified automatically after <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a>, as described above. The set of modules in scope can be shown with <a class="reference internal" href="#ghci-cmd-show-imports"><code>:show imports</code></a>.</li> </ul> <p>You can add a module to the scope (via <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> or <code>import</code>) only if either (a) it is loaded, or (b) it is a module from a package that GHCi knows about. Using <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> or <code>import</code> to try bring into scope a non-loaded module may result in the message <code>module M is not loaded</code>.</p> </section> <section id="shadowing-and-the-ghci1-module-name"> <h4>
<span class="section-number">3.4.5.6. </span>Shadowing and the <code>Ghci1</code> module name</h4> <p>Bindings on the prompt can shadow earlier bindings:</p> <pre data-language="none">ghci&gt; let foo = True
ghci&gt; let foo = False
ghci&gt; :show bindings
foo :: Bool = False
</pre> <p>But the shadowed thing still exists, and may show up again later, for example in a type signature:</p> <pre data-language="none">ghci&gt; data T = A | B deriving Eq
ghci&gt; let a = A
ghci&gt; data T = ANewType
ghci&gt; :t a
a :: Ghci1.T
</pre> <p>Now the type of <code>a</code> is printed using the fully qualified name of <code>T</code>, using the module name <code>Ghci1</code> (and <code>Ghci2</code> for the next set of bindings, and so on). You can use these qualified names as well:</p> <pre data-language="none">ghci&gt; a == Ghci1.A
True
ghci&gt; let a = False -- shadowing a
ghci&gt; Ghci2.a == Ghci1.A
True
</pre> <p>The command <code>:show bindings</code> only shows bindings that are not shadowed. Bindings that define multiple names, such as a type constructor and its data constructors, are shown if <em>any</em> defined name is still available without the need for qualification.</p> </section> </section> <section id="the-it-variable"> <h3>
<span class="section-number">3.4.6. </span>The <code>it</code> variable</h3> <p id="index-8">Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable <code>it</code>. For example:</p> <pre data-language="none">ghci&gt; 1+2
3
ghci&gt; it * 2
6
</pre> <p>What actually happens is that GHCi typechecks the expression, and if it doesn’t have an <code>IO</code> type, then it transforms it as follows: an expression <code>e</code> turns into</p> <pre data-language="none">let it = e;
print it
</pre> <p>which is then run as an IO-action.</p> <p>Hence, the original expression must have a type which is an instance of the <code>Show</code> class, or GHCi will complain:</p> <pre data-language="none">ghci&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print' at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a 'do' expression: print it
</pre> <p>The error message contains some clues as to the transformation happening internally.</p> <p>If the expression was instead of type <code>IO a</code> for some <code>a</code>, then <code>it</code> will be bound to the result of the <code>IO</code> computation, which is of type <code>a</code>. eg.:</p> <pre data-language="none">ghci&gt; Data.Time.getZonedTime
2017-04-10 12:34:56.93213581 UTC
ghci&gt; print it
2017-04-10 12:34:56.93213581 UTC
</pre> <p>The corresponding translation for an IO-typed <code>e</code> is</p> <pre data-language="none">it &lt;- e
</pre> <p>Note that <code>it</code> is shadowed by the new value each time you evaluate a new expression, and the old value of <code>it</code> is lost.</p> <p>In order to stop the value <code>it</code> being bound on each command, the flag <a class="reference internal" href="#ghc-flag-fno-it"><code>-fno-it</code></a> can be set. The <code>it</code> variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see <a class="reference internal" href="#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a>).</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fno-it">
<code>-fno-it</code> </dt> <dd>
<p>When this flag is set, the variable <code>it</code> will no longer be set to the result of the previously evaluated expression.</p> </dd>
</dl> </section> <section id="type-defaulting-in-ghci"> <h3 id="extended-default-rules">
<span class="section-number">3.4.7. </span>Type defaulting in GHCi</h3> <dl class="std extension" id="index-9"> <dt class="sig sig-object std" id="extension-ExtendedDefaultRules">
<code>ExtendedDefaultRules</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>6.8.1</p> </dd> </dl> <p>Allow defaulting to take place for more than just numeric classes.</p> </dd>
</dl> <p>Consider this GHCi session:</p> <pre data-language="none">ghci&gt; reverse []
</pre> <p>What should GHCi do? Strictly speaking, the program is ambiguous. <code>show (reverse [])</code> (which is what GHCi computes here) has type <code>Show a =&gt; String</code> and how that displays depends on the type <code>a</code>. For example:</p> <pre data-language="none">ghci&gt; reverse ([] :: String)
""
ghci&gt; reverse ([] :: [Int])
[]
</pre> <p>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell’s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints <code>(C1 a, C2 a, ..., Cn a)</code> for each type variable <code>a</code>, and defaults the type variable if</p> <ol class="arabic simple"> <li>The type variable <code>a</code> appears in no other constraints</li> <li>All the classes <code>Ci</code> are standard.</li> <li>At least one of the classes <code>Ci</code> is numeric.</li> </ol> <p>At the GHCi prompt, or with GHC if the <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a> flag is given, the types are instead resolved with the following method:</p> <p>Find all the unsolved constraints. Then:</p> <ul class="simple"> <li>Find those that are of form <code>(C a)</code> where <code>a</code> is a type variable, and partition those constraints into groups that share a common type variable <code>a</code>.</li> <li>Keep only the groups in which at least one of the classes is an <strong>interactive class</strong> (defined below).</li> <li>Now, for each remaining group G, try each type <code>ty</code> from the default-type list in turn; if setting <code>a = ty</code> would allow the constraints in G to be completely solved. If so, default <code>a</code> to <code>ty</code>.</li> <li>The unit type <code>()</code> and the list type <code>[]</code> are added to the start of the standard list of types which are tried when doing type defaulting.</li> </ul> <p>Note that any multi-parameter constraints <code>(D a b)</code> or <code>(D [a] Int)</code> do not participate in the process (either to help or to hinder); but they must of course be soluble once the defaulting process is complete.</p> <p>The last point means that, for example, this program:</p> <pre data-language="haskell">main :: IO ()
main = print def

instance Num ()

def :: (Num a, Enum a) =&gt; a
def = toEnum 0
</pre> <p>prints <code>()</code> rather than <code>0</code> as the type is defaulted to <code>()</code> rather than <code>Integer</code>.</p> <p>The motivation for the change is that it means <code>IO a</code> actions default to <code>IO ()</code>, which in turn means that ghci won’t try to print a result when running them. This is particularly important for <code>printf</code>, which has an instance that returns <code>IO a</code>. However, it is only able to return <code>undefined</code> (the reason for the instance having this type is so that printf doesn’t require extensions to the class system), so if the type defaults to <code>Integer</code> then ghci gives an error when running a printf.</p> <p>See also <a class="reference internal" href="#actions-at-prompt"><span class="std std-ref">I/O actions at the prompt</span></a> for how the monad of a computational expression defaults to <code>IO</code> if possible.</p> <section id="interactive-classes"> <h4>
<span class="section-number">3.4.7.1. </span>Interactive classes</h4> <p id="index-10">The interactive classes (only relevant when <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a> is in effect) are: any numeric class, <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Foldable</code> or <code>Traversable</code>.</p> <p>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</p> </section> <section id="extended-rules-around-default-declarations"> <h4>
<span class="section-number">3.4.7.2. </span>Extended rules around <code>default</code> declarations</h4> <p id="index-11">Since the rules for defaulting are relaxed under <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a>, the rules for <code>default</code> declarations are also relaxed. According to Section 4.3.4 of the Haskell 2010 Report, a <code>default</code> declaration looks like <code>default (t1, ..., tn)</code> where, for each <code>ti</code>, <code>Num ti</code> must hold. This is relaxed to say that for each <code>ti</code>, there must exist an interactive class <code>C</code> such that <code>C ti</code> holds. This means that type <em>constructors</em> can be allowed in these lists. For example, the following works if you wish your <code>Foldable</code> constraints to default to <code>Maybe</code> but your <code>Num</code> constraints to still default to <code>Integer</code> or <code>Double</code>:</p> <pre data-language="haskell">default (Maybe, Integer, Double)
</pre> </section> </section> <section id="using-a-custom-interactive-printing-function"> <h3 id="ghci-interactive-print">
<span class="section-number">3.4.8. </span>Using a custom interactive printing function</h3> <p id="index-12">Since GHC 7.6.1, GHCi prints the result of expressions typed at the prompt using the function <code>System.IO.print</code>. Its type signature is <code>Show a =&gt; a -&gt;
IO ()</code>, and it works by converting the value to <code>String</code> using <code>show</code>.</p> <p>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</p> <p>The <a class="reference internal" href="#ghc-flag-interactive-print-name"><code>-interactive-print ⟨name⟩</code></a> flag allows to specify any function of type <code>C a =&gt; a -&gt; IO ()</code>, for some constraint <code>C</code>, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a <a class="reference internal" href="#ghci-cmd-cd"><code>:cd</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a>, <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a>, <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a> or, <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-interactive-print-name">
<code>-interactive-print ⟨name⟩</code> </dt> <dd>
<p>Set the function used by GHCi to print evaluation results. Given name must be of type <code>C a =&gt; a -&gt; IO ()</code>.</p> </dd>
</dl> <p>As an example, suppose we have following special printing module:</p> <pre data-language="haskell">module SpecPrinter where
import System.IO

sprint a = putStrLn $ show a ++ "!"
</pre> <p>The <code>sprint</code> function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</p> <pre data-language="none">ghci -interactive-print=SpecPrinter.sprint SpecPrinter
</pre> <p>will start an interactive session where values with be printed using <code>sprint</code>:</p> <pre data-language="none">*SpecPrinter&gt; [1,2,3]
[1,2,3]!
*SpecPrinter&gt; 42
42!
</pre> <p>A custom pretty printing function can be used, for example, to format tree-like and nested structures in a more readable way.</p> <p>The <a class="reference internal" href="#ghc-flag-interactive-print-name"><code>-interactive-print ⟨name⟩</code></a> flag can also be used when running GHC in <code>-e mode</code>:</p> <pre data-language="none">% ghc -e "[1,2,3]" -interactive-print=SpecPrinter.sprint SpecPrinter
[1,2,3]!
</pre> </section> <section id="stack-traces-in-ghci"> <h3 id="ghci-stack-traces">
<span class="section-number">3.4.9. </span>Stack Traces in GHCi</h3> <p id="index-13">[ This is an experimental feature enabled by the new <code>-fexternal-interpreter</code> flag that was introduced in GHC 8.0.1. It is currently not supported on Windows.]</p> <p>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</p> <pre data-language="none">ghci -fexternal-interpreter -prof
</pre> <p>This runs the interpreted code in a separate process (see <a class="reference internal" href="#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>) and runs it in profiling mode to collect call stack information. Note that because we’re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The <code>-prof</code> flag to GHCi only works in conjunction with <code>-fexternal-interpreter</code>.</p> <p>There are three ways to get access to the current call stack.</p> <ul class="simple"> <li>
<code>error</code> and <code>undefined</code> automatically attach the current stack to the error message. This often complements the <code>HasCallStack</code> stack (see <a class="reference internal" href="exts/callstack.html#hascallstack"><span class="std std-ref">HasCallStack</span></a>), so both call stacks are shown.</li> <li>
<code>Debug.Trace.traceStack</code> is a version of <code>Debug.Trace.trace</code> that also prints the current call stack.</li> <li>Functions in the module <code>GHC.Stack</code> can be used to get the current stack and render it.</li> </ul> <p>You don’t need to use <code>-fprof-auto</code> for interpreted modules, annotations are automatically added at a granularity fine enough to distinguish individual call sites. However, you won’t see any call stack information for compiled code unless it was compiled with <code>-fprof-auto</code> or has explicit <code>SCC</code> annotations (see <a class="reference internal" href="profiling.html#scc-pragma"><span class="std std-ref">Inserting cost centres by hand</span></a>).</p> </section> </section> <section id="the-ghci-debugger"> <h2 id="ghci-debugger">
<span class="section-number">3.5. </span>The GHCi Debugger</h2> <p id="index-14">GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger <a class="footnote-reference brackets" href="#id15" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p> <p>The debugger provides the following:</p> <ul class="simple"> <li>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</li> <li>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</li> <li>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn’t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</li> <li>Exceptions (e.g. pattern matching failure and <code>error</code>) can be treated as breakpoints, to help locate the source of an exception in the program.</li> </ul> <p>There is currently no support for obtaining a “stack trace”, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see <a class="reference internal" href="#ghci-debugger-exceptions"><span class="std std-ref">Debugging exceptions</span></a>).</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fbreak-points">
<code>-fbreak-points</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>enabled for GHCi</p> </dd> </dl> <p>This flag’s purpose is to allow disabling breakpoint insertion with the reverse form.</p> </dd>
</dl> <section id="breakpoints-and-inspecting-variables"> <h3 id="breakpoints">
<span class="section-number">3.5.1. </span>Breakpoints and inspecting variables</h3> <p>Let’s use quicksort as a running example. Here’s the code:</p> <pre data-language="haskell">qsort [] = []
qsort (a:as) = qsort left ++ [a] ++ qsort right
  where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
</pre> <p>First, load the module into GHCi:</p> <pre data-language="none">ghci&gt; :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt;
</pre> <p>Now, let’s set a breakpoint on the right-hand-side of the second equation of qsort:</p> <pre data-language="none">*ghci&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:15-46
*ghci&gt;
</pre> <p>The command <code>:break 2</code> sets a breakpoint on line 2 of the most recently-loaded module, in this case <code>qsort.hs</code>. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression <code>(qsort left ++ [a] ++ qsort right)</code>.</p> <p>Now, we run the program:</p> <pre data-language="none">*ghci&gt; main
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *ghci&gt;
</pre> <p>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: <code>[qsort.hs:2:15-46]</code>. To further clarify the location, we can use the <a class="reference internal" href="#ghci-cmd-list"><code>:list</code></a> command:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :list
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</pre> <p>The <a class="reference internal" href="#ghci-cmd-list"><code>:list</code></a> command lists the source code around the current breakpoint. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> <p>GHCi has provided bindings for the free variables <a class="footnote-reference brackets" href="#id16" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> of the expression on which the breakpoint was placed (<code>a</code>, <code>left</code>, <code>right</code>), and additionally a binding for the result of the expression (<code>_result</code>). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with <a class="reference internal" href="#ghci-cmd-type"><code>:type</code></a>, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of <code>left</code>:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; left

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Show a' arising from a use of `print' at &lt;interactive&gt;:1:0-3
    Cannot resolve unknown runtime types: a
    Use :print or :force to determine these types
</pre> <p>This is because <code>qsort</code> is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display <code>left</code> at the prompt, GHCi can’t figure out which instance of <code>Show</code> to use, so it emits the type error above.</p> <p>Fortunately, the debugger includes a generic printing command, <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on <code>left</code>:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :set -fprint-evld-with-show
[qsort.hs:2:15-46] *ghci&gt; :print left
left = (_t1::[a])
</pre> <p>This isn’t particularly enlightening. What happened is that <code>left</code> is bound to an unevaluated computation (a suspension, or thunk), and <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> does not force any evaluation. The idea is that <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> can be used to inspect values at a breakpoint without any unfortunate side effects. It won’t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won’t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see <a class="reference internal" href="#nested-breakpoints"><span class="std std-ref">Nested breakpoints</span></a>). Rather than forcing thunks, <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> binds each thunk to a fresh variable beginning with an underscore, in this case <code>_t1</code>.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-evld-with-show">
<code>-fprint-evld-with-show</code> </dt> <dd>
<p>The flag <a class="reference internal" href="#ghc-flag-fprint-evld-with-show"><code>-fprint-evld-with-show</code></a> instructs <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> to reuse available <code>Show</code> instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</p> </dd>
</dl> <p>If we aren’t concerned about preserving the evaluatedness of a variable, we can use <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a> instead of <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>. The <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a> command behaves exactly like <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>, except that it forces the evaluation of any thunks it encounters:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :force left
left = [4,0,3,1]
</pre> <p>Now, since <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a> has inspected the runtime value of <code>left</code>, it has reconstructed its type. We can see the results of this type reconstruction:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :show bindings
_result :: [Integer]
a :: Integer
left :: [Integer]
right :: [Integer]
_t1 :: [Integer]
</pre> <p>Not only do we now know the type of <code>left</code>, but all the other partial types have also been resolved. So we can ask for the value of <code>a</code>, for example:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; a
8
</pre> <p>You might find it useful to use Haskell’s <code>seq</code> function to evaluate individual thunks rather than evaluating the whole expression with <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a>. For example:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :print right
right = (_t1::[Integer])
[qsort.hs:2:15-46] *ghci&gt; seq _t1 ()
()
[qsort.hs:2:15-46] *ghci&gt; :print right
right = 23 : (_t2::[Integer])
</pre> <p>We evaluated only the <code>_t1</code> thunk, revealing the head of the list, and the tail is another thunk now bound to <code>_t2</code>. The <code>seq</code> function is a little inconvenient to use here, so you might want to use <a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a> to make a nicer interface (left as an exercise for the reader!).</p> <p>Finally, we can continue the current execution:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :continue
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *ghci&gt;
</pre> <p>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</p> <section id="setting-breakpoints"> <h4 id="id10">
<span class="section-number">3.5.1.1. </span>Setting breakpoints</h4> <p>Breakpoints can be set in various ways. Perhaps the easiest way to set a breakpoint is to name a top-level function:</p> <pre data-language="none">:break identifier
</pre> <p>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied. If the function has several patterns, then a breakpoint will be set on each of them.</p> <p>By using qualified names, one can set breakpoints on all functions (top-level and nested) in every loaded and interpreted module:</p> <pre data-language="none">:break [ModQual.]topLevelIdent[.nestedIdent]...[.nestedIdent]
</pre> <p>⟨ModQual⟩ is optional and is either the effective name of a module or the local alias of a qualified import statement.</p> <p>⟨topLevelIdent⟩ is the name of a top level function in the module referenced by ⟨ModQual⟩.</p> <p>⟨nestedIdent⟩ is optional and the name of a function nested in a let or where clause inside the previously mentioned function ⟨nestedIdent⟩ or ⟨topLevelIdent⟩.</p> <p>If ⟨ModQual⟩ is a module name, then ⟨topLevelIdent⟩ can be any top level identifier in this module. If ⟨ModQual⟩ is missing or a local alias of a qualified import, then ⟨topLevelIdent⟩ must be in scope.</p> <p>Breakpoints can be set on arbitrarily deeply nested functions, but the whole chain of nested function names must be specified.</p> <p>Consider the function <code>foo</code> in a module <code>Main</code>:</p> <pre data-language="none">foo s = 'a' : add s
    where add = (++"z")
</pre> <p>The breakpoint on the function <code>add</code> can be set with one of the following commands:</p> <pre data-language="none">:break Main.foo.add
:break foo.add
</pre> <p>Breakpoints can also be set by line (and optionally column) number:</p> <pre data-language="none">:break line
:break line column
:break module line
:break module line column
</pre> <p>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</p> <p>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn’t match others. The best advice is to avoid tab characters in your source code altogether (see <a class="reference internal" href="using-warnings.html#ghc-flag-Wtabs"><code>-Wtabs</code></a> in <a class="reference internal" href="using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p> <p>If the module is omitted, then the most recently-loaded module is used.</p> <p>Not all subexpressions are potential breakpoint locations. Single variables are typically not considered to be breakpoint locations (unless the variable is the right-hand-side of a function definition, lambda, or case alternative). The rule of thumb is that all redexes are breakpoint locations, together with the bodies of functions, lambdas, case alternatives and binding statements. There is normally no breakpoint on a let expression, but there will always be a breakpoint on its body, because we are usually interested in inspecting the values of the variables bound by the let.</p> </section> <section id="managing-breakpoints"> <h4>
<span class="section-number">3.5.1.2. </span>Managing breakpoints</h4> <p>The list of breakpoints currently defined can be displayed using <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a>:</p> <pre data-language="none">*ghci&gt; :show breaks
[0] Main qsort.hs:1:11-12 enabled
[1] Main qsort.hs:2:15-46 enabled
</pre> <p>To disable one or several defined breakpoint, use the <a class="reference internal" href="#ghci-cmd-disable"><code>:disable</code></a> command with one or several blank separated numbers given in the output from <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a>:. To disable all breakpoints at once, use <code>:disable *</code>.</p> <pre data-language="none">*ghci&gt; :disable 0
*ghci&gt; :show breaks
[0] Main qsort.hs:1:11-12 disabled
[1] Main qsort.hs:2:15-46 enabled
</pre> <p>Disabled breakpoints can be (re-)enabled with the <a class="reference internal" href="#ghci-cmd-enable"><code>:enable</code></a> command. The parameters of the <a class="reference internal" href="#ghci-cmd-disable"><code>:disable</code></a> and <a class="reference internal" href="#ghci-cmd-enable"><code>:enable</code></a> commands are identical.</p> <p>To delete a breakpoint, use the <a class="reference internal" href="#ghci-cmd-delete"><code>:delete</code></a> command with the number given in the output from <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a>:</p> <pre data-language="none">*ghci&gt; :delete 0
*ghci&gt; :show breaks
[1] Main qsort.hs:2:15-46 disabled
</pre> <p>To delete all breakpoints at once, use <code>:delete *</code>.</p> </section> </section> <section id="single-stepping"> <h3 id="id11">
<span class="section-number">3.5.2. </span>Single-stepping</h3> <p>Single-stepping is a great way to visualise the execution of your program, and it is also a useful tool for identifying the source of a bug. GHCi offers two variants of stepping. Use <a class="reference internal" href="#ghci-cmd-step"><code>:step</code></a> to enable all the breakpoints in the program, and execute until the next breakpoint is reached. Use <a class="reference internal" href="#ghci-cmd-steplocal"><code>:steplocal</code></a> to limit the set of enabled breakpoints to those in the current top level function. Similarly, use <a class="reference internal" href="#ghci-cmd-stepmodule"><code>:stepmodule</code></a> to single step only on breakpoints contained in the current module. For example:</p> <pre data-language="none">*ghci&gt; :step main
Stopped at qsort.hs:5:7-47
_result :: IO ()
</pre> <p>The command <a class="reference internal" href="#ghci-cmd-step"><code>:step expr</code></a> begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. <a class="reference internal" href="#ghci-cmd-steplocal"><code>:steplocal</code></a> and <a class="reference internal" href="#ghci-cmd-stepmodule"><code>:stepmodule</code></a> commands work similarly.</p> <p>The <a class="reference internal" href="#ghci-cmd-list"><code>:list</code></a> command is particularly useful when single-stepping, to see where you currently are:</p> <pre data-language="none">[qsort.hs:5:7-47] *ghci&gt; :list
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:7-47] *ghci&gt;
</pre> <p>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do <a class="reference internal" href="#ghci-cmd-list"><code>:list</code></a>:</p> <pre data-language="none">[qsort.hs:5:7-47] *ghci&gt; :set stop :list
[qsort.hs:5:7-47] *ghci&gt; :step
Stopped at qsort.hs:5:14-46
_result :: [Integer]
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:14-46] *ghci&gt;
</pre> </section> <section id="nested-breakpoints"> <h3 id="id12">
<span class="section-number">3.5.3. </span>Nested breakpoints</h3> <p>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the “current” one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</p> <pre data-language="none">[qsort.hs:2:15-46] *ghci&gt; :st qsort [1,3]
Stopped at qsort.hs:(1,0)-(3,55)
_result :: [a]
... [qsort.hs:(1,0)-(3,55)] *ghci&gt;
</pre> <p>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with <code>:step qsort [1,3]</code>. This new evaluation stopped after one step (at the definition of <code>qsort</code>). The prompt has changed, now prefixed with <code>...</code>, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use <a class="reference internal" href="#ghci-cmd-show-context"><code>:show context</code></a>:</p> <pre data-language="none">... [qsort.hs:(1,0)-(3,55)] *ghci&gt; :show context
--&gt; main
  Stopped at qsort.hs:2:15-46
--&gt; qsort [1,3]
  Stopped at qsort.hs:(1,0)-(3,55)
... [qsort.hs:(1,0)-(3,55)] *ghci&gt;
</pre> <p>To abandon the current evaluation, use <a class="reference internal" href="#ghci-cmd-abandon"><code>:abandon</code></a>:</p> <pre data-language="none">... [qsort.hs:(1,0)-(3,55)] *ghci&gt; :abandon
[qsort.hs:2:15-46] *ghci&gt; :abandon
*ghci&gt;
</pre> </section> <section id="the-result-variable"> <h3 id="ghci-debugger-result">
<span class="section-number">3.5.4. </span>The <code>_result</code> variable</h3> <p>When stopped at a breakpoint or single-step, GHCi binds the variable <code>_result</code> to the value of the currently active expression. The value of <code>_result</code> is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering <code>_result</code> at the prompt will show it. However, there’s one caveat to doing this: evaluating <code>_result</code> will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to <a class="reference internal" href="#ghci-cmd-step"><code>:step</code></a>). So it will probably be necessary to issue a <a class="reference internal" href="#ghci-cmd-continue"><code>:continue</code></a> immediately when evaluating <code>_result</code>. Alternatively, you can use <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a> which ignores breakpoints.</p> </section> <section id="tracing-and-history"> <h3 id="tracing">
<span class="section-number">3.5.5. </span>Tracing and history</h3> <p>A question that we often want to ask when debugging a program is “how did I get here?”. Traditional imperative debuggers usually provide some kind of stack-tracing feature that lets you see the stack of active function calls (sometimes called the “lexical call stack”), describing a path through the code to the current location. Unfortunately this is hard to provide in Haskell, because execution proceeds on a demand-driven basis, rather than a depth-first basis as in strict languages. The “stack“ in GHC’s execution engine bears little resemblance to the lexical call stack. Ideally GHCi would maintain a separate lexical call stack in addition to the dynamic call stack, and in fact this is exactly what our profiling system does (<a class="reference internal" href="profiling.html#profiling"><span class="std std-ref">Profiling</span></a>), and what some other Haskell debuggers do. For the time being, however, GHCi doesn’t maintain a lexical call stack (there are some technical challenges to be overcome). Instead, we provide a way to backtrack from a breakpoint to previous evaluation steps: essentially this is like single-stepping backwards, and should in many cases provide enough information to answer the “how did I get here?” question.</p> <p>To use tracing, evaluate an expression with the <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a> command. For example, if we set a breakpoint on the base case of <code>qsort</code>:</p> <pre data-language="none">*ghci&gt; :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
4
*ghci&gt; :b 1
Breakpoint 1 activated at qsort.hs:1:11-12
*ghci&gt;
</pre> <p>and then run a small <code>qsort</code> with tracing:</p> <pre data-language="none">*ghci&gt; :trace qsort [3,2,1]
Stopped at qsort.hs:1:11-12
_result :: [a]
[qsort.hs:1:11-12] *ghci&gt;
</pre> <p>We can now inspect the history of evaluation steps:</p> <pre data-language="none">[qsort.hs:1:11-12] *ghci&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:3:24-38
-7  : qsort.hs:3:23-55
-8  : qsort.hs:(1,0)-(3,55)
-9  : qsort.hs:2:15-24
-10 : qsort.hs:2:15-46
-11 : qsort.hs:3:24-38
-12 : qsort.hs:3:23-55
-13 : qsort.hs:(1,0)-(3,55)
-14 : qsort.hs:2:15-24
-15 : qsort.hs:2:15-46
-16 : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
</pre> <p>To examine one of the steps in the history, use <a class="reference internal" href="#ghci-cmd-back"><code>:back</code></a>:</p> <pre data-language="none">[qsort.hs:1:11-12] *ghci&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *ghci&gt;
</pre> <p>Note that the local variables at each step in the history have been preserved, and can be examined as usual. Also note that the prompt has changed to indicate that we’re currently examining the first step in the history: <code>-1</code>. The command <a class="reference internal" href="#ghci-cmd-forward"><code>:forward</code></a> can be used to traverse forward in the history.</p> <p>The <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a> command can be used with or without an expression. When used without an expression, tracing begins from the current breakpoint, just like <a class="reference internal" href="#ghci-cmd-step"><code>:step</code></a>.</p> <p>The history is only available when using <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a>; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fghci-hist-size-n">
<code>-fghci-hist-size=⟨n⟩</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>50</p> </dd> </dl> <p>Modify the depth of the evaluation history tracked by GHCi.</p> </dd>
</dl> </section> <section id="debugging-exceptions"> <h3 id="ghci-debugger-exceptions">
<span class="section-number">3.5.6. </span>Debugging exceptions</h3> <p>Another common question that comes up when debugging is “where did this exception come from?”. Exceptions such as those raised by <code>error</code> or <code>head []</code> have no context information attached to them. Finding which particular call to <code>head</code> in your program resulted in the error can be a painstaking process, usually involving <code>Debug.Trace.trace</code>, or compiling with profiling and using <code>Debug.Trace.traceStack</code> or <code>+RTS -xc</code> (see <a class="reference internal" href="runtime_control.html#rts-flag-xc"><code>-xc</code></a>).</p> <p>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a> and <a class="reference internal" href="#ghci-cmd-history"><code>:history</code></a> to establish the context. However, <code>head</code> is in a library and we can’t set a breakpoint on it directly. For this reason, GHCi provides the flags <a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code>-fbreak-on-exception</code></a> which causes the evaluator to stop when an exception is thrown, and <a class="reference internal" href="#ghc-flag-fbreak-on-error"><code>-fbreak-on-error</code></a>, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a>, in order to log the steps leading up to the exception. For example:</p> <pre data-language="none">*ghci&gt; :set -fbreak-on-exception
*ghci&gt; :trace qsort ("abc" ++ undefined)
“Stopped at &lt;exception thrown&gt;
_exception :: e
[&lt;exception thrown&gt;] *ghci&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
[&lt;exception thrown&gt;] *ghci&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *ghci&gt; :force as
*** Exception: Prelude.undefined
[-1: qsort.hs:3:24-38] *ghci&gt; :print as
as = 'b' : 'c' : (_t1::[Char])
</pre> <p>The exception itself is bound to a new variable, <code>_exception</code>.</p> <p>Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fbreak-on-exception">
<code>-fbreak-on-exception</code> </dt> <dd>
<p>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. <a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code>-fbreak-on-exception</code></a> breaks on all exceptions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fbreak-on-error">
<code>-fbreak-on-error</code> </dt> <dd>
<p>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. <a class="reference internal" href="#ghc-flag-fbreak-on-error"><code>-fbreak-on-error</code></a> breaks on only those exceptions which would otherwise be uncaught.</p> </dd>
</dl> </section> <section id="example-inspecting-functions"> <h3>
<span class="section-number">3.5.7. </span>Example: inspecting functions</h3> <p>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</p> <p>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known <code>map</code> function:</p> <pre data-language="haskell">import Prelude hiding (map)

map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
</pre> <p>We set a breakpoint on <code>map</code>, and call it.</p> <pre data-language="none">*ghci&gt; :break 5
Breakpoint 0 activated at  map.hs:5:15-28
*ghci&gt; map Just [1..5]
Stopped at map.hs:(4,0)-(5,12)
_result :: [b]
x :: a
f :: a -&gt; b
xs :: [a]
</pre> <p>GHCi tells us that, among other bindings, <code>f</code> is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of <code>x</code>, and its result type is shared with <code>_result</code>.</p> <p>As we demonstrated earlier (<a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a>), the debugger has some intelligence built-in to update the type of <code>f</code> whenever the types of <code>x</code> or <code>_result</code> are discovered. So what we do in this scenario is force <code>x</code> a bit, in order to recover both its type and the argument part of <code>f</code>.</p> <pre data-language="none">*ghci&gt; seq x ()
*ghci&gt; :print x
x = 1
</pre> <p>We can check now that as expected, the type of <code>x</code> has been reconstructed, and with it the type of <code>f</code> has been too:</p> <pre data-language="none">*ghci&gt; :t x
x :: Integer
*ghci&gt; :t f
f :: Integer -&gt; b
</pre> <p>From here, we can apply f to any argument of type Integer and observe the results.</p> <pre data-language="none">*ghci&gt; let b = f 10
*ghci&gt; :t b
b :: b
*ghci&gt; b
&lt;interactive&gt;:1:0:
    Ambiguous type variable `b' in the constraint:
      `Show b' arising from a use of `print' at &lt;interactive&gt;:1:0
*ghci&gt; :p b
b = (_t2::a)
*ghci&gt; seq b ()
()
*ghci&gt; :t b
b :: a
*ghci&gt; :p b
b = Just 10
*ghci&gt; :t b
b :: Maybe Integer
*ghci&gt; :t f
f :: Integer -&gt; Maybe Integer
*ghci&gt; f 20
Just 20
*ghci&gt; map f [1..5]
[Just 1, Just 2, Just 3, Just 4, Just 5]
</pre> <p>In the first application of <code>f</code>, we had to do some more type reconstruction in order to recover the result type of <code>f</code>. But after that, we are free to use <code>f</code> normally.</p> </section> <section id="limitations"> <h3>
<span class="section-number">3.5.8. </span>Limitations</h3> <ul> <li>
<p>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn’t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</p> <p>The most common way this can happen is when you’re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</p> </li> <li>Implicit parameters (see <a class="reference internal" href="exts/implicit_parameters.html#implicit-parameters"><span class="std std-ref">Implicit parameters</span></a>) are only available at the scope of a breakpoint if there is an explicit type signature.</li> </ul> </section> </section> <section id="invoking-ghci"> <h2 id="ghci-invocation">
<span class="section-number">3.6. </span>Invoking GHCi</h2> <p id="index-15">GHCi is invoked with the command <code>ghci</code> or <code>ghc --interactive</code>. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said <code>:load modules</code> at the GHCi prompt (see <a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>). For example, to start GHCi and load the program whose topmost module is in the file <code>Main.hs</code>, we could say:</p> <pre data-language="none">$ ghci Main.hs
</pre> <p>Most of the command-line options accepted by GHC (see <a class="reference internal" href="using.html#using-ghc"><span class="std std-ref">Using GHC</span></a>) also make sense in interactive mode. The ones that don’t make sense are mostly obvious.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-flocal-ghci-history">
<code>-flocal-ghci-history</code> </dt> <dd>
<p>By default, GHCi keeps global history in <code>$XDG_DATA_HOME/ghc/ghci_history</code> or <code>%APPDATA%/&lt;app&gt;/ghci_history</code>, but you can use current directory, e.g.:</p> <pre data-language="none">$ ghci -flocal-ghci-history
</pre> <p>It will create <code>.ghci-history</code> in current folder where GHCi is launched.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fghci-leak-check">
<code>-fghci-leak-check</code> </dt> <dd>
<p>(Debugging only) When loading new modules with <code>:load</code>, check that any previously loaded modules have been correctly garbage collected. Emits messages if a leak is detected.</p> </dd>
</dl> <section id="packages"> <h3>
<span class="section-number">3.6.1. </span>Packages</h3> <p id="index-16">Most packages (see <a class="reference internal" href="packages.html#using-packages"><span class="std std-ref">Using Packages</span></a>) are available without needing to specify any extra flags at all: they will be automatically loaded the first time they are needed.</p> <p>For hidden packages, however, you need to request the package be loaded by using the <a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code>-package ⟨pkg⟩</code></a> flag:</p> <pre data-language="none">$ ghci -package readline
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
ghci&gt;
</pre> <p>The following command works to load new packages into a running GHCi:</p> <pre data-language="none">ghci&gt; :set -package name
</pre> <p>But note that doing this will cause all currently loaded modules to be unloaded, and you’ll be dumped back into the <code>Prelude</code>.</p> </section> <section id="extra-libraries"> <h3>
<span class="section-number">3.6.2. </span>Extra libraries</h3> <p id="index-17">Extra libraries may be specified on the command line using the normal <code>-llib</code> option. (The term <em>library</em> here refers to libraries of foreign object code; for using libraries of Haskell source code, see <a class="reference internal" href="#ghci-modules-filenames"><span class="std std-ref">Modules vs. filenames</span></a>.) For example, to load the “m” library:</p> <pre data-language="none">$ ghci -lm
</pre> <p>On systems with <code>.so</code>-style shared libraries, the actual library loaded will the <code>liblib.so</code>. GHCi searches the following places for libraries, in this order:</p> <ul class="simple"> <li>Paths specified using the <a class="reference internal" href="phases.html#ghc-flag-L-dir"><code>-L ⟨dir⟩</code></a> command-line option,</li> <li>The standard library search path for your system loader, which on some systems may be overridden by setting the <code id="index-18">LD_LIBRARY_PATH</code> environment variable.</li> <li>The linker standard library search can also be overridden on some systems using the <code id="index-19">LIBRARY_PATH</code> environment variable. Because of some implementation detail on Windows, setting <code>LIBRARY_PATH</code> will also extend the system loader path for any library it finds. So often setting <code id="index-20">LIBRARY_PATH</code> is enough.</li> </ul> <p>On systems with <code>.dll</code>-style shared libraries, the actual library loaded will be <code>lib.dll</code>, <code>liblib.dll</code>. GHCi also has full support for import libraries, either Microsoft style <code>.lib</code>, or GNU GCC style <code>.a</code> and <code>.dll.a</code> libraries. If you have an import library it is advisable to always specify the import library instead of the <code>.dll</code>. e.g. use <code>-lgcc` instead of
``-llibgcc_s_seh-1</code>. Again, GHCi will signal an error if it can’t find the library.</p> <p>GHCi can also load plain object files (<code>.o</code> or <code>.obj</code> depending on your platform) or static archives (<code>.a</code>) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the <code>big-obj</code> format.</p> <p>Ordering of <code>-l</code> options matters: a library should be mentioned <em>before</em> the libraries it depends on (see <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p> </section> </section> <section id="ghci-commands"> <h2 id="id13">
<span class="section-number">3.7. </span>GHCi commands</h2> <p>GHCi commands all begin with “<code>:</code>” and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</p> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-abandon">
<code>:abandon</code> </dt> <dd>
<p>Abandons the current evaluation (only available when stopped at a breakpoint).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-add">
<code>:add [*]⟨module⟩</code> </dt> <dd>
<p>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the <code>*</code> prefix forces the module to be loaded as byte-code.</p> <p>⟨module⟩ may be a file path. A “<code>~</code>” symbol at the beginning of ⟨module⟩ will be replaced by the contents of the environment variable <code id="index-21">HOME</code>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-all-types">
<code>:all-types</code> </dt> <dd>
<p>List all types collected for expressions and (local) bindings currently loaded (while <a class="reference internal" href="#ghci-cmd-set-c"><code>:set +c</code></a> was active) with their respective source-code span, e.g.</p> <pre data-language="haskell">GhciTypes&gt; :all-types
GhciTypes.hs:(38,13)-(38,24): Maybe Id
GhciTypes.hs:(45,10)-(45,29): Outputable SpanInfo
GhciTypes.hs:(45,10)-(45,29): (Rational -&gt; SpanInfo -&gt; SDoc) -&gt; Outputable SpanInfo
</pre> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-back">
<code>:back ⟨n⟩</code> </dt> <dd>
<p>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also: <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a>, <a class="reference internal" href="#ghci-cmd-history"><code>:history</code></a>, <a class="reference internal" href="#ghci-cmd-forward"><code>:forward</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-break">
<code>:break [⟨identifier⟩ | [⟨module⟩] ⟨line⟩ [⟨column⟩]]</code> </dt> <dd>
<p>Set a breakpoint on the specified function or line and column. See <a class="reference internal" href="#setting-breakpoints"><span class="std std-ref">Setting breakpoints</span></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-browse">
<code>:browse[!] [[*] ⟨module⟩]</code> </dt> <dd>
<p>Displays the identifiers exported by the module ⟨module⟩, which must be either loaded into GHCi or be a member of a package. If ⟨module⟩ is omitted, the most recently-loaded module is used.</p> <p>Like all other GHCi commands, the output is always displayed in the current GHCi scope (<a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>).</p> <p>There are two variants of the browse command:</p> <ul> <li>
<p>If the <code>*</code> symbol is placed before the module name, then <em>all</em> the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</p> <p>The <code>*</code>-form is only available for modules which are interpreted; for compiled modules (including modules from packages) only the non-<code>*</code> form of <a class="reference internal" href="#ghci-cmd-browse"><code>:browse</code></a> is available.</p> </li> <li>
<p>Data constructors and class methods are usually displayed in the context of their data type or class declaration. However, if the <code>!</code> symbol is appended to the command, thus <code>:browse!</code>, they are listed individually. The <code>!</code>-form also annotates the listing with comments giving possible imports for each group of entries. Here is an example:</p> <pre data-language="haskell">ghci&gt; :browse! Data.Maybe
-- not currently imported
Data.Maybe.catMaybes :: [Maybe a] -&gt; [a]
Data.Maybe.fromJust :: Maybe a -&gt; a
Data.Maybe.fromMaybe :: a -&gt; Maybe a -&gt; a
Data.Maybe.isJust :: Maybe a -&gt; Bool
Data.Maybe.isNothing :: Maybe a -&gt; Bool
Data.Maybe.listToMaybe :: [a] -&gt; Maybe a
Data.Maybe.mapMaybe :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
Data.Maybe.maybeToList :: Maybe a -&gt; [a]
-- imported via Prelude
Just :: a -&gt; Maybe a
data Maybe a = Nothing | Just a
Nothing :: Maybe a
maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</pre> <p>This output shows that, in the context of the current session (ie in the scope of <code>Prelude</code>), the first group of items from <code>Data.Maybe</code> are not in scope (although they are available in fully qualified form in the GHCi session - see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>), whereas the second group of items are in scope (via <code>Prelude</code>) and are therefore available either unqualified, or with a <code>Prelude.</code> qualifier.</p> </li> </ul> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-cd">
<code>:cd ⟨dir⟩</code> </dt> <dd>
<p>Changes the current working directory to ⟨dir⟩. A “<code>~</code>” symbol at the beginning of ⟨dir⟩ will be replaced by the contents of the environment variable <code id="index-22">HOME</code>. See also the <a class="reference internal" href="#ghci-cmd-show-paths"><code>:show paths</code></a> command for showing the current working directory.</p> <p>Note: changing directories causes all currently loaded modules to be unloaded. This is because the search path is usually expressed using relative directories, and changing the search path in the middle of a session is not supported.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-cmd">
<code>:cmd ⟨expr⟩</code> </dt> <dd>
<p>Executes ⟨expr⟩ as a computation of type <code>IO String</code>, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The <a class="reference internal" href="#ghci-cmd-cmd"><code>:cmd</code></a> command is useful with <a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a> and <a class="reference internal" href="#ghci-cmd-set-stop"><code>:set stop</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-complete">
<code>:complete ⟨type⟩ [⟨n⟩-][⟨m⟩] ⟨string-literal⟩</code> </dt> <dd>
<p>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi’s completion with text editors and IDEs.</p> <p>When called, <a class="reference internal" href="#ghci-cmd-complete"><code>:complete</code></a> prints the ⟨n⟩<sup>th</sup> to ⟨m⟩<sup>th</sup> completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the <code>repl</code> domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</p> <p>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</p> <p>The output of <a class="reference internal" href="#ghci-cmd-complete"><code>:complete</code></a> begins with a header line containing three space-delimited fields:</p> <ul class="simple"> <li>An integer denoting the number <code>l</code> of printed completions,</li> <li>an integer denoting the total number of completions available, and finally</li> <li>a string literal denoting a common prefix to be added to the returned completion candidates.</li> </ul> <p>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</p> <pre data-language="none">ghci&gt; :complete repl 0 ""
0 470 ""
ghci&gt; :complete repl 5 "import For"
5 21 "import "
"Foreign"
"Foreign.C"
"Foreign.C.Error"
"Foreign.C.String"
"Foreign.C.Types"
ghci&gt; :complete repl 5-10 "import For"
6 21 "import "
"Foreign.C.Types"
"Foreign.Concurrent"
"Foreign.ForeignPtr"
"Foreign.ForeignPtr.Safe"
"Foreign.ForeignPtr.Unsafe"
"Foreign.Marshal"
ghci&gt; :complete repl 20- "import For"
2 21 "import "
"Foreign.StablePtr"
"Foreign.Storable"
ghci&gt; :complete repl "map"
3 3 ""
"map"
"mapM"
"mapM_"
ghci&gt; :complete repl 5-10 "map"
0 3 ""
</pre> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-continue">
<code>:continue [⟨ignoreCount⟩]</code> </dt> <dd>
<p>Continue the current evaluation, when stopped at a breakpoint.</p> <p>If an <code>⟨ignoreCount⟩</code> is specified, the program will ignore the current breakpoint for the next <code>⟨ignoreCount⟩</code> iterations. See command <a class="reference internal" href="#ghci-cmd-ignore"><code>:ignore</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-def">
<code>:def[!] ⟨name⟩ ⟨expr⟩</code> </dt> <dd>
<p><a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a> is used to define new commands, or macros, in GHCi. The command <code>:def ⟨name⟩ ⟨expr⟩</code> defines a new GHCi command <code>:name</code>, implemented by the Haskell expression ⟨expr⟩, which must have type <code>String -&gt; IO String</code>. When <code>:name args</code> is typed at the prompt, GHCi will run the expression <code>(name args)</code>, take the resulting <code>String</code>, and feed it back into GHCi as a new sequence of commands. Separate commands in the result must be separated by “<code>\n</code>”.</p> <p>That’s all a little confusing, so here’s a few examples. To start with, here’s a new GHCi command which doesn’t take any arguments or produce any results, it just outputs the current date and time:</p> <pre data-language="none">ghci&gt; let date _ = Data.Time.getZonedTime &gt;&gt;= print &gt;&gt; return ""
ghci&gt; :def date date
ghci&gt; :date
2017-04-10 12:34:56.93213581 UTC
</pre> <p>Here’s an example of a command that takes an argument. It’s a re-implementation of <a class="reference internal" href="#ghci-cmd-cd"><code>:cd</code></a>:</p> <pre data-language="none">ghci&gt; let mycd d = System.Directory.setCurrentDirectory d &gt;&gt; return ""
ghci&gt; :def mycd mycd
ghci&gt; :mycd ..
</pre> <p>Or I could define a simple way to invoke “<code>ghc --make Main</code>” in the current directory:</p> <pre data-language="none">ghci&gt; :def make (\_ -&gt; return ":! ghc --make Main")
</pre> <p>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</p> <pre data-language="none">ghci&gt; :def . readFile
ghci&gt; :. cmds.ghci
</pre> <p>Notice that we named the command <code>:.</code>, by analogy with the “<code>.</code>” Unix shell command that does the same thing.</p> <p>Typing <code>:def</code> on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the <code>:def!</code> form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceding the command name with a double colon (eg <code>::load</code>). It’s not possible to redefine the commands <code>:{</code>, <code>:}</code> and <code>:!</code>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-delete">
<code>:delete * | ⟨num⟩ ...</code> </dt> <dd>
<p>Delete one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a> to see the number of each breakpoint). The <code>*</code> form deletes all the breakpoints.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-disable">
<code>:disable * | ⟨num⟩ ...</code> </dt> <dd>
<p>Disable one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a> to see the number and state of each breakpoint). The <code>*</code> form disables all the breakpoints.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-doc">
<code>:doc ⟨name⟩</code> </dt> <dd>
<p>(Experimental: This command will likely change significantly in GHC 8.8.)</p> <p>Displays the documentation for the given name. Currently the command is restricted to displaying the documentation directly on the declaration in question, ignoring documentation for arguments, constructors etc.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-edit">
<code>:edit ⟨file⟩</code> </dt> <dd>
<p>Opens an editor to edit the file ⟨file⟩, or the most recently loaded module if ⟨file⟩ is omitted. If there were errors during the last loading, the cursor will be positioned at the line of the first error. The editor to invoke is taken from the <a class="reference internal" href="#envvar-VISUAL" id="index-23"><code>VISUAL</code></a> or <code id="index-24">EDITOR</code> environment variables, or a default editor on your system if neither is not set. You can change the editor using <a class="reference internal" href="#ghci-cmd-set-editor"><code>:set
editor</code></a>.</p> </dd>
</dl> <dl class="std envvar"> <dt class="sig sig-object std" id="envvar-VISUAL">
<code>VISUAL</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Hidden<span class="colon">:</span>
</dt>  </dl> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-enable">
<code>:enable * | ⟨num⟩ ...</code> </dt> <dd>
<p>Enable one or more disabled breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code>:show breaks</code></a> to see the number and state of each breakpoint). The <code>*</code> form enables all the disabled breakpoints. Enabling a break point will reset its <code>ignore count</code> to 0. (See <a class="reference internal" href="#ghci-cmd-ignore"><code>:ignore</code></a>)</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-force">
<code>:force ⟨identifier⟩ ...</code> </dt> <dd>
<p>Prints the value of ⟨identifier⟩ in the same way as <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>. Unlike <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>, <a class="reference internal" href="#ghci-cmd-force"><code>:force</code></a> evaluates each thunk that it encounters while traversing the value. This may cause exceptions or infinite loops, or further breakpoints (which are ignored, but displayed).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-forward">
<code>:forward ⟨n⟩</code> </dt> <dd>
<p>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also: <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a>, <a class="reference internal" href="#ghci-cmd-history"><code>:history</code></a>, <a class="reference internal" href="#ghci-cmd-back"><code>:back</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-help">
<code>:help</code> </dt> <dt class="sig sig-object std" id="ghci-cmd-2">
<code>:?</code> </dt> <dd>
<p>Displays a list of the available commands.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-3">
<code>:</code> </dt> <dd>
<p id="index-25">Repeat the previous command.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-history">
<code>:history [num]</code> </dt> <dd>
<p>Display the history of evaluation steps. With a number, displays that many steps (default: 20). For use with <a class="reference internal" href="#ghci-cmd-trace"><code>:trace</code></a>; see <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>. To set the number of history entries stored by GHCi, use the <a class="reference internal" href="#ghc-flag-fghci-hist-size-n"><code>-fghci-hist-size=⟨n⟩</code></a> flag.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-info">
<code>:info[!] ⟨name⟩</code> </dt> <dd>
<p>Displays information about the given name(s). For example, if ⟨name⟩ is a class, then the class methods and their types will be printed; if ⟨name⟩ is a type constructor, then its definition will be printed; if ⟨name⟩ is a function, then its type will be printed. If ⟨name⟩ has been loaded from a source file, then GHCi will also display the location of its definition in the source.</p> <p>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> or <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> commands.</p> <p>The command <code>:info!</code> works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-instances">
<code>:instances ⟨type⟩</code> </dt> <dd>
<p>Displays all the class instances available to the argument ⟨type⟩. The command will match ⟨type⟩ with the first parameter of every instance and then check that all constraints are satisfiable.</p> <p>When combined with <a class="reference internal" href="exts/partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a>, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</p> <p>The output is a listing of all matching instances, simplified and instantiated as much as possible.</p> <p>For example:</p> <pre data-language="none">&gt; :instances Maybe (Maybe Int)
instance Eq (Maybe (Maybe Int)) -- Defined in ‘GHC.Maybe’
instance Ord (Maybe (Maybe Int)) -- Defined in ‘GHC.Maybe’
instance Show (Maybe (Maybe Int)) -- Defined in ‘GHC.Show’
instance Read (Maybe (Maybe Int)) -- Defined in ‘GHC.Read’

&gt; :set -XPartialTypeSignatures -fno-warn-partial-type-signatures

&gt; :instances Maybe _
instance Eq _ =&gt; Eq (Maybe _) -- Defined in ‘GHC.Maybe’
instance Semigroup _ =&gt; Monoid (Maybe _) -- Defined in ‘GHC.Base’
instance Ord _ =&gt; Ord (Maybe _) -- Defined in ‘GHC.Maybe’
instance Semigroup _ =&gt; Semigroup (Maybe _) -- Defined in ‘GHC.Base’
instance Show _ =&gt; Show (Maybe _) -- Defined in ‘GHC.Show’
instance Read _ =&gt; Read (Maybe _) -- Defined in ‘GHC.Read’
</pre> <p>Only instances which could potentially be used will be displayed in the results. Instances which require unsatisfiable constraints such as <code>TypeError</code> will not be included. In the following example, the instance for <code>A</code> is not shown because it cannot be used.</p> <pre data-language="none">ghci&gt;:set -XDataKinds -XUndecidableInstances
ghci&gt;import GHC.TypeLits
ghci&gt;class A a
ghci&gt;instance (TypeError (Text "Not possible")) =&gt; A Bool
ghci&gt;:instances Bool
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Show Bool -- Defined in ‘GHC.Show’
instance Read Bool -- Defined in ‘GHC.Read’
instance Bounded Bool -- Defined in ‘GHC.Enum’
</pre> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-issafe">
<code>:issafe [⟨module⟩]</code> </dt> <dd>
<p>Displays Safe Haskell information about the given module (or the current module if omitted). This includes the trust type of the module and its containing package.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-ignore">
<code>:ignore ⟨break⟩ ⟨ignoreCount⟩</code> </dt> <dd>
<p>Set the ignore count of the breakpoint with number <code>⟨break⟩</code> to <code>⟨ignoreCount⟩</code>.</p> <p>The next <code>⟨ignoreCount⟩</code> times the program hits the breakpoint <code>⟨break⟩</code>, this breakpoint is ignored and the program doesn’t stop. Every time the breakpoint is ignored, the <code>ignore count</code> is decremented by 1. When the <code>ignore count</code> is zero, the program again stops at the break point.</p> <p>You can also specify an <code>⟨ignoreCount⟩</code> on a <a class="reference internal" href="#ghci-cmd-continue"><code>:continue</code></a> command when you resume execution of your program.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-kind">
<code>:kind[!] ⟨type⟩</code> </dt> <dd>
<p>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as <code>Either Int</code>. In fact, <a class="reference internal" href="#ghci-cmd-kind"><code>:kind</code></a> even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</p> <pre data-language="none">ghci&gt; type T a b = (a,b,a)
ghci&gt; :k T Int Bool
T Int Bool :: *
ghci&gt; :k T
T :: * -&gt; * -&gt; *
ghci&gt; :k T Int
T Int :: * -&gt; *
</pre> <p>Free type variables are also implicitly quantified, same as if you wrote <code>:k forall a. [a]</code> so this also works:</p> <pre data-language="none">ghci&gt; :k [a]
[a] :: *
</pre> <p>If you specify the optional “<code>!</code>”, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-list">
<code>:list ⟨identifier⟩</code> </dt> <dd>
<p>Lists the source code around the definition of ⟨identifier⟩ or the current breakpoint if not given. This requires that the identifier be defined in an interpreted module. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-list-module">
<code>:list [⟨module⟩] ⟨line⟩</code> </dt> <dd>
<p>Lists the source code around the given line number of ⟨module⟩. This requires that the module be interpreted. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-load">
<code>:load[!] [*]⟨module⟩</code> </dt> <dd>
<p>Recursively loads the specified ⟨module⟩s, and all the modules they depend on. Here, each ⟨module⟩ must be a module name or filename, but may not be the name of a module in a package.</p> <p>All previously loaded modules, except package modules, are forgotten. The new set of modules is known as the target set. Note that <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> can be used without any arguments to unload all the currently loaded modules and bindings.</p> <p>Normally pre-compiled code for a module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the <code>*</code> prefix forces a module to be loaded as byte-code.</p> <p>Adding the optional “<code>!</code>” turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the <a class="reference internal" href="exts/defer_type_errors.html#ghc-flag-fdefer-type-errors"><code>-fdefer-type-errors</code></a> flag is set before loading and unset after loading if the flag has not already been set before. See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p> <p>After a <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> command, the current context is set to:</p> <ul class="simple"> <li>⟨module⟩, if it was loaded successfully, or</li> <li>the most recently successfully loaded module, if any other modules were loaded as a result of the current <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, or</li> <li>
<code>Prelude</code> otherwise.</li> </ul> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-loc-at">
<code>:loc-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Tries to find the definition site of the name at the given source-code span, e.g.:</p> <pre data-language="none">X&gt; :loc-at X.hs 6 14 6 16 mu
X.hs:(8,7)-(8,9)
</pre> <p>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</p> <p>The <code>:loc-at</code> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-main">
<code>:main ⟨arg1⟩ ... ⟨argn⟩</code> </dt> <dd>
<p>When a program is compiled and executed, it can use the <code>getArgs</code> IO action to access the command-line arguments. However, we cannot simply pass the arguments to <code>main</code> while we are testing in ghci, as <code>main</code> doesn’t take its arguments directly.</p> <p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-main"><code>:main</code></a> command. This runs whatever <code>main</code> is in scope, with any arguments being treated the same as command-line arguments, e.g.:</p> <pre data-language="none">ghci&gt; main = System.Environment.getArgs &gt;&gt;= print
ghci&gt; :main foo bar
["foo","bar"]
</pre> <p>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</p> <pre data-language="none">ghci&gt; :main foo "bar baz"
["foo","bar baz"]
ghci&gt; :main ["foo", "bar baz"]
["foo","bar baz"]
</pre> <p>Finally, other IO actions can be called, either with the <code>-main-is</code> flag or the <a class="reference internal" href="#ghci-cmd-run"><code>:run</code></a> command:</p> <pre data-language="none">ghci&gt; foo = putStrLn "foo" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; bar = putStrLn "bar" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; :set -main-is foo
ghci&gt; :main foo "bar baz"
foo
["foo","bar baz"]
ghci&gt; :run bar ["foo", "bar baz"]
bar
["foo","bar baz"]
</pre> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-module">
<code>:module +|- [*]⟨mod1⟩ ...</code> </dt> 
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-import">
<code>import ⟨mod⟩</code> </dt> <dd>
<p>Sets or modifies the current context for statements typed at the prompt. The form <code>import mod</code> is equivalent to <code>:module +mod</code>. See <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for more details.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-print">
<code>:print ⟨names⟩</code> </dt> <dd>
<p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> may be used on values whose types are unknown or partially known, which might be the case for local variables with polymorphic types at a breakpoint. While inspecting the runtime value, <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> attempts to reconstruct the type of the value, and will elaborate the type in GHCi’s environment if possible. If any unevaluated components (thunks) are encountered, then <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> binds a fresh variable with a name beginning with <code>_t</code> to each thunk. See <a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a> for more information. See also the <a class="reference internal" href="#ghci-cmd-sprint"><code>:sprint</code></a> command, which works like <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a> but does not bind new variables.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-quit">
<code>:quit</code> </dt> <dd>
<p>Quits GHCi. You can also quit by typing <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">D</kbd></kbd> at the prompt.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-reload">
<code>:reload[!]</code> </dt> <dd>
<p>Attempts to reload the current target set (see <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</p> <p>Adding the optional “<code>!</code>” turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the <a class="reference internal" href="exts/defer_type_errors.html#ghc-flag-fdefer-type-errors"><code>-fdefer-type-errors</code></a> flag is set before loading and unset after loading if the flag has not already been set before. See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-run">
<code>:run</code> </dt> <dd>
<p>See <a class="reference internal" href="#ghci-cmd-main"><code>:main</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-script">
<code>:script [⟨n⟩] ⟨filename⟩</code> </dt> <dd>
<p>Executes the lines of a file as a series of GHCi commands. The syntax for file-name arguments respects shell quoting rules, i.e., file names containing spaces can be enclosed in double quotes or with spaces escaped with a backslash. This command is compatible with multiline statements as set by <a class="reference internal" href="#ghci-cmd-set-m"><code>:set +m</code></a></p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set">
<code>:set [⟨option⟩ ...]</code> </dt> <dd>
<p>Sets various options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available options and <a class="reference internal" href="flags.html#interactive-mode-options"><span class="std std-ref">Interactive-mode options</span></a> for a list of GHCi-specific flags. The <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> command by itself shows which options are currently set. It also lists the current dynamic flag settings, with GHCi-specific flags listed separately.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-args">
<code>:set args ⟨arg⟩</code> </dt> <dd>
<p id="index-26">Sets the list of arguments which are returned when the program calls <code>System.Environment.getArgs</code>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-editor">
<code>:set editor ⟨cmd⟩</code> </dt> <dd>
<p>Sets the command used by <a class="reference internal" href="#ghci-cmd-edit"><code>:edit</code></a> to ⟨cmd⟩.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-local-config">
<code>:set local-config ⟨source|ignore⟩</code> </dt> <dd>
<p>If <code>ignore</code>, <code>./.ghci</code> files will be ignored (sourcing untrusted local scripts is a security risk). The default is <code>source</code>. Set this directive in your user <code>.ghci</code> script, i.e. before the local script would be sourced.</p> <p>Even when set to <code>ignore</code>, a local script will still be processed if given by <a class="reference internal" href="#ghc-flag-ghci-script"><code>-ghci-script</code></a> on the command line, or sourced via <a class="reference internal" href="#ghci-cmd-script"><code>:script</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-prog">
<code>:set prog ⟨prog⟩</code> </dt> <dd>
<p id="index-27">Sets the string to be returned when the program calls <code>System.Environment.getProgName</code>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-prompt">
<code>:set prompt ⟨prompt⟩</code> </dt> <dd>
<p id="index-28">Sets the string to be used as the prompt in GHCi. Inside ⟨prompt⟩, the next sequences are replaced:</p> <ul class="simple"> <li>
<code>%s</code> by the names of the modules currently in scope.</li> <li>
<code>%l</code> by the line number (as referenced in compiler messages) of the current prompt.</li> <li>
<code>%d</code> by the date in “Weekday Month Date” format (e.g., “Tue May 26”) .</li> <li>
<code>%t</code> by the current time in 24-hour HH:MM:SS format.</li> <li>
<code>%T</code> by the current time in 12-hour HH:MM:SS format.</li> <li>
<code>%@</code> by the current time in 12-hour am/pm format.</li> <li>
<code>%A</code> by the current time in 24-hour HH:MM format.</li> <li>
<code>%u</code> by the username of the current user.</li> <li>
<code>%w</code> by the current working directory.</li> <li>
<code>%o</code> by the operating system.</li> <li>
<code>%a</code> by the machine architecture.</li> <li>
<code>%N</code> by the compiler name.</li> <li>
<code>%V</code> by the compiler version.</li> <li>
<code>%call(cmd [args])</code> by the result of calling <code>cmd args</code>.</li> <li>
<code>%%</code> by <code>%</code>.</li> </ul> <p>If ⟨prompt⟩ starts with <code>"</code> then it is parsed as a Haskell String; otherwise it is treated as a literal string.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-prompt-cont">
<code>:set prompt-cont ⟨prompt⟩</code> </dt> <dd>
<p>Sets the string to be used as the continuation prompt (used when using the <a class="reference internal" href="#ghci-cmd-0"><code>:{</code></a> command) in GHCi.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-prompt-function">
<code>:set prompt-function ⟨prompt-function⟩</code> </dt> <dd>
<p id="index-29">Sets the function to be used for the prompt displaying in GHCi. The function should be of the type <code>[String] -&gt; Int -&gt; IO String</code>. This function is called each time the prompt is being made. The first argument stands for the names of the modules currently in scope (the name of the “topmost” module will begin with a <code>*</code>; see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for more information). The second arguments is the line number (as referenced in compiler messages) of the current prompt.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-prompt-cont-function">
<code>:set prompt-cont-function ⟨prompt-function⟩</code> </dt> <dd>
<p>Sets the function to be used for the continuation prompt (used when using the <a class="reference internal" href="#ghci-cmd-0"><code>:{</code></a> command) displaying in GHCi.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-stop">
<code>:set stop ⟨num⟩ ⟨cmd⟩</code> </dt> <dd>
<p>Set a command to be executed when a breakpoint is hit, or a new item in the history is selected. The most common use of <a class="reference internal" href="#ghci-cmd-set-stop"><code>:set stop</code></a> is to display the source code at the current location, e.g. <code>:set stop :list</code>.</p> <p>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, <code>:set stop 1 :continue</code> effectively disables breakpoint 1, by running <a class="reference internal" href="#ghci-cmd-continue"><code>:continue</code></a> whenever it is hit In this case GHCi will still emit a message to say the breakpoint was hit. If you don’t want such a message, you can use the <a class="reference internal" href="#ghci-cmd-disable"><code>:disable</code></a> command. What’s more, with cunning use of <a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a> and <a class="reference internal" href="#ghci-cmd-cmd"><code>:cmd</code></a> you can use <a class="reference internal" href="#ghci-cmd-set-stop"><code>:set stop</code></a> to implement conditional breakpoints:</p> <pre data-language="none">*ghci&gt; :def cond \expr -&gt; return (":cmd if (" ++ expr ++ ") then return \"\" else return \":continue\"")
*ghci&gt; :set stop 0 :cond (x &lt; 3)
</pre> <p>To ignore breakpoints for a specified number of iterations use the <a class="reference internal" href="#ghci-cmd-ignore"><code>:ignore</code></a> or the <code>⟨ignoreCount⟩</code> parameter of the <a class="reference internal" href="#ghci-cmd-continue"><code>:continue</code></a> command.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-seti">
<code>:seti [⟨option⟩ ...]</code> </dt> <dd>
<p>Like <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>, but options set with <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a> affect only expressions and commands typed at the prompt, and not modules loaded with <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> (in contrast, options set with <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> apply everywhere). See <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>.</p> <p>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-bindings">
<code>:show bindings</code> </dt> <dd>
<p>Show the bindings made at the prompt and their types.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-breaks">
<code>:show breaks</code> </dt> <dd>
<p>List the active breakpoints.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-context">
<code>:show context</code> </dt> <dd>
<p>List the active evaluations that are stopped at breakpoints.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-imports">
<code>:show imports</code> </dt> <dd>
<p>Show the imports that are currently in force, as created by <code>import</code> and <a class="reference internal" href="#ghci-cmd-module"><code>:module</code></a> commands.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-modules">
<code>:show modules</code> </dt> <dd>
<p>Show the list of modules currently loaded.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-packages">
<code>:show packages</code> </dt> <dd>
<p>Show the currently active package flags, as well as the list of packages currently loaded.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-paths">
<code>:show paths</code> </dt> <dd>
<p>Show the current working directory (as set via <a class="reference internal" href="#ghci-cmd-cd"><code>:cd</code></a> command), as well as the list of directories searched for source files (as set by the <code>-i</code> option).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-language">
<code>:show language</code> </dt> <dd>
<p>Show the currently active language flags for source files.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-showi-language">
<code>:showi language</code> </dt> <dd>
<p>Show the currently active language flags for expressions typed at the prompt (see also <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a>).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show-targets">
<code>:show targets</code> </dt> <dd>
<p>Show list of currently loaded modules. This set of loaded modules can be modified by <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a>, <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-unadd"><code>:unadd</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-show">
<code>:show [args|prog|prompt|editor|stop]</code> </dt> <dd>
<p>Displays the specified setting (see <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-sprint">
<code>:sprint ⟨expr⟩</code> </dt> <dd>
<p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-sprint"><code>:sprint</code></a> is similar to <a class="reference internal" href="#ghci-cmd-print"><code>:print</code></a>, with the difference that unevaluated subterms are not bound to new variables, they are simply denoted by <code>_</code>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-step">
<code>:step [⟨expr⟩]</code> </dt> <dd>
<p>Enable all breakpoints and begin evaluating an expression in single-stepping mode. In this mode evaluation will be stopped after every reduction, allowing local variables to be inspected. If ⟨expr⟩ is not given, evaluation will resume at the last breakpoint. See <a class="reference internal" href="#single-stepping"><span class="std std-ref">Single-stepping</span></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-steplocal">
<code>:steplocal</code> </dt> <dd>
<p>Enable only breakpoints in the current top-level binding and resume evaluation at the last breakpoint. Continuation with <a class="reference internal" href="#ghci-cmd-steplocal"><code>:steplocal</code></a> is not possible if this last breakpoint was hit by an error (<a class="reference internal" href="#ghc-flag-fbreak-on-error"><code>-fbreak-on-error</code></a>) or an exception (<a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code>-fbreak-on-exception</code></a>).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-stepmodule">
<code>:stepmodule</code> </dt> <dd>
<p>Enable only breakpoints in the current module and resume evaluation at the last breakpoint.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-trace">
<code>:trace ⟨expr⟩</code> </dt> <dd>
<p>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using <a class="reference internal" href="#ghci-cmd-history"><code>:history</code></a>. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-type">
<code>:type ⟨expression⟩</code> </dt> <dd>
<p>Infers and prints the type of ⟨expression⟩, solving constraints and reducing type families as much as possible. For polymorphic types, it does not instantiate any forall quantified variables.</p> <pre data-language="none">*X&gt; :type length
length :: Foldable t =&gt; t a -&gt; Int
</pre> <p>Type family reduction is skipped if the function is not fully instantiated, as this has been observed to give more intuitive results. You may want to use <a class="reference internal" href="#ghci-cmd-info"><code>:info</code></a> if you are not applying any arguments, as that will return the original type of the function.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-type-d">
<code>:type +d ⟨expression⟩</code> </dt> <dd>
<p>Infers and prints the type of ⟨expression⟩, instantiating <em>all</em> the forall quantifiers, solving constraints, defaulting, and generalising. In this mode, if the inferred type is constrained by any interactive class (<code>Num</code>, <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Foldable</code>, or <code>Traversable</code>), the constrained type variable(s) are defaulted according to the rules described under <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a>. This mode is quite useful when the inferred type is quite general (such as for <code>foldr</code>) and it may be helpful to see a more concrete instantiation.</p> <pre data-language="none">*X&gt; :type +d length
length :: [a] -&gt; Int
</pre> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-type-at">
<code>:type-at ⟨path⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Reports the inferred type at the given span/position in the module, e.g.:</p> <pre data-language="none">*X&gt; :type-at X.hs 6 6 6 7 f
Int -&gt; Int
</pre> <p>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</p> <p>The first parameter (path) must be a file path and not a module name. The type of this path is dependent on how the module was loaded into GHCi: If the module was loaded by name, then the path name calculated by GHCi as described in <a class="reference internal" href="#ghci-modules-filenames"><span class="std std-ref">Modules vs. filenames</span></a> must be used. If the module was loaded with an absolute or a relative path, then the same path must be specified.</p> <p>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case <a class="reference internal" href="#ghci-cmd-type-at"><code>:type-at</code></a> falls back to a general <a class="reference internal" href="#ghci-cmd-type"><code>:type</code></a> like lookup.</p> <p>The <a class="reference internal" href="#ghci-cmd-type-at"><code>:type-at</code></a> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-unadd">
<code>:unadd ⟨module⟩</code> </dt> <dd>
<p>Removes ⟨module⟩(s) from the current target set, and perform a reload (see <a class="reference internal" href="#ghci-cmd-add"><code>:add</code></a> above).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-undef">
<code>:undef ⟨name⟩</code> </dt> <dd>
<p>Undefines the user-defined command ⟨name⟩ (see <a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a> above).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-unset">
<code>:unset ⟨option⟩</code> </dt> <dd>
<p>Unsets certain options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available options.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-uses">
<code>:uses ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Reports all module-local uses of the thing at the given position in the module, e.g.:</p> <pre data-language="none">:uses GhciFind.hs 53 66 53 70 name
GhciFind.hs:(46,25)-(46,29)
GhciFind.hs:(47,37)-(47,41)
GhciFind.hs:(53,66)-(53,70)
GhciFind.hs:(57,62)-(57,66)
</pre> <p>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</p> <p>The <a class="reference internal" href="#ghci-cmd-uses"><code>:uses</code></a> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-builtin-command">
<code>:: ⟨builtin-command⟩</code> </dt> <dd>
<p>Executes the GHCi built-in command (e.g. <code>::type 3</code>). That is, look up on the list of builtin commands, excluding defined macros. See also: <a class="reference internal" href="#ghci-cmd-def"><code>:def</code></a>.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-command">
<code>:! ⟨command⟩</code> </dt> <dd>
<p id="index-30">Executes the shell command ⟨command⟩.</p> </dd>
</dl> </section> <section id="the-set-and-seti-commands"> <h2 id="ghci-set">
<span class="section-number">3.8. </span>The <code>:set</code> and <code>:seti</code> commands</h2> <p id="index-31">The <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> command sets two types of options: GHCi options, which begin with “<code>+</code>”, and “command-line” options, which begin with “<code>-</code>“.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>At the moment, the <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> command doesn’t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, <code>:set -DFOO='BAR BAZ'</code> will not do what you expect.</p> </div> <section id="ghci-options"> <h3>
<span class="section-number">3.8.1. </span>GHCi options</h3> <p id="index-32">GHCi options may be set using <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> and unset using <a class="reference internal" href="#ghci-cmd-unset"><code>:unset</code></a>.</p> <p>The available GHCi options are:</p> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-c">
<code>:set +c</code> </dt> <dd>
<p>Collect type and location information after loading modules. The commands <a class="reference internal" href="#ghci-cmd-all-types"><code>:all-types</code></a>, <a class="reference internal" href="#ghci-cmd-loc-at"><code>:loc-at</code></a>, <a class="reference internal" href="#ghci-cmd-type-at"><code>:type-at</code></a>, and <a class="reference internal" href="#ghci-cmd-uses"><code>:uses</code></a> require <code>+c</code> to be active.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-m">
<code>:set +m</code> </dt> <dd>
<p id="index-33">Enable parsing of multiline commands. A multiline command is prompted for when the current input line contains open layout contexts (see <a class="reference internal" href="#ghci-multiline"><span class="std std-ref">Multiline input</span></a>).</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-r">
<code>:set +r</code> </dt> <dd>
<p id="index-34">Normally, any evaluation of top-level expressions (otherwise known as CAFs or Constant Applicative Forms) in loaded modules is retained between evaluations. Turning on <code>+r</code> causes all evaluation of top-level expressions to be discarded after each evaluation (they are still retained <em>during</em> a single evaluation).</p> <p>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-s">
<code>:set +s</code> </dt> <dd>
<p>Display some stats after evaluating each expression, including the elapsed time and number of bytes allocated. NOTE: the allocation figure is only accurate to the size of the storage manager’s allocation area, because it is calculated at every GC. Hence, you might see values of zero if no GC has occurred.</p> </dd>
</dl> <dl class="std ghci-cmd"> <dt class="sig sig-object std" id="ghci-cmd-set-t">
<code>:set +t</code> </dt> <dd>
<p id="index-35">Display the type of each variable bound after a statement is entered at the prompt. If the statement is a single expression, then the only variable binding will be for the variable <code>it</code>.</p> </dd>
</dl> </section> <section id="setting-ghc-command-line-options-in-ghci"> <h3 id="ghci-cmd-line-options">
<span class="section-number">3.8.2. </span>Setting GHC command-line options in GHCi</h3> <p>Normal GHC command-line options may also be set using <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>. For example, to turn on <a class="reference internal" href="using-warnings.html#ghc-flag-Wmissing-signatures"><code>-Wmissing-signatures</code></a>, you would say:</p> <pre data-language="none">ghci&gt; :set -Wmissing-signatures
</pre> <p>GHCi will also accept any file-header pragmas it finds, such as <code>{-# OPTIONS_GHC ... #-}</code> and <code>{-# LANGUAGE ... #-}</code> (see <a class="reference internal" href="exts/pragmas.html#pragmas"><span class="std std-ref">Pragmas</span></a>). For example, instead of using <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> to enable <a class="reference internal" href="using-warnings.html#ghc-flag-Wmissing-signatures"><code>-Wmissing-signatures</code></a>, you could instead write:</p> <pre data-language="none">ghci&gt; {-# OPTIONS_GHC -Wmissing-signatures #-}
</pre> <p>Any GHC command-line option that is designated as dynamic (see the table in <a class="reference internal" href="flags.html#flag-reference"><span class="std std-ref">Flag reference</span></a>), may be set using <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>. To unset an option, you can set the reverse option:</p> <pre data-language="none">ghci&gt; :set -Wno-incomplete-patterns -XNoMultiParamTypeClasses
</pre> <p><a class="reference internal" href="flags.html#flag-reference"><span class="std std-ref">Flag reference</span></a> lists the reverse for each option where applicable.</p> <p>Certain static options (<a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code>-package ⟨pkg⟩</code></a>, <a class="reference internal" href="phases.html#ghc-flag-Idir"><code>-I⟨dir⟩</code></a>, <a class="reference internal" href="separate_compilation.html#ghc-flag-idir-dir"><code>-i⟨dir⟩[:⟨dir⟩]*</code></a>, and <a class="reference internal" href="phases.html#ghc-flag-l-lib"><code>-l ⟨lib⟩</code></a> in particular) will also work, but some may not take effect until the next reload.</p> </section> <section id="setting-options-for-interactive-evaluation-only"> <h3 id="index-37">
<span class="section-number">3.8.3. </span>Setting options for interactive evaluation only</h3> <p>GHCi actually maintains <em>two</em> sets of options:</p> <ul class="simple"> <li>The <em>loading options</em> apply when loading modules</li> <li>The <em>interactive options</em> apply when evaluating expressions and commands typed at the GHCi prompt.</li> </ul> <p>The <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> command modifies both, but there is also a <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a> command (for “set interactive”) that affects only the interactive options set.</p> <p>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</p> <pre data-language="none">:seti -XMonoLocalBinds
</pre> <p>It would be undesirable if <a class="reference internal" href="exts/let_generalisation.html#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</p> <p>If you are setting language options in your <code>.ghci</code> file, it is good practice to use <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a> rather than <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a>, unless you really do want them to apply to all modules you load in GHCi.</p> <p>The two sets of options can be inspected using the <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> and <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a> commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</p> <pre data-language="none">ghci&gt; :seti
base language is: GHC2021
with the following modifiers:
  -XExtendedDefaultRules
  -XNoMonomorphismRestriction
GHCi-specific dynamic flag settings:
other dynamic, non-language, flag settings:
  -fexternal-dynamic-refs
  -fignore-optim-changes
  -fignore-hpc-changes
  -fimplicit-import-qualified
warning settings:
</pre> <p>The two sets of options are initialised as follows. First, both sets of options are initialised as described in <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>. Then the interactive options are modified as follows:</p> <ul class="simple"> <li>The option <code>-XExtendedDefaultRules</code> is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see <a class="reference internal" href="#extended-default-rules"><span class="std std-ref">Type defaulting in GHCi</span></a>).</li> <li>The Monomorphism Restriction is disabled (see <a class="reference internal" href="exts/monomorphism.html#monomorphism"><span class="std std-ref">Switching off the Monomorphism Restriction</span></a>).</li> </ul> </section> </section> <section id="the-ghci-and-haskeline-files"> <h2 id="ghci-dot-files">
<span class="section-number">3.9. </span>The <code>.ghci</code> and <code>.haskeline</code> files</h2> <section id="the-ghci-files"> <h3 id="dot-ghci-files">
<span class="section-number">3.9.1. </span>The <code>.ghci</code> files</h3> <p id="index-38">When it starts, unless the <a class="reference internal" href="#ghc-flag-ignore-dot-ghci"><code>-ignore-dot-ghci</code></a> flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</p> <ol class="arabic simple"> <li>
<code><em>ghcappdata</em>/ghci.conf</code>, where ⟨ghcappdata⟩ depends on your system, but is usually something like <code>$HOME/.ghc</code> or <code>$XDG_CONFIG_HOME/ghc</code> on Unix or <code>C:\Users{username}\AppData\Roaming\ghc</code> on Windows.</li> <li><code>./.ghci</code></li> </ol> <p>The <code>ghci.conf</code> file is most useful for turning on favourite options (e.g. <code>:set +s</code>), and defining useful macros.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When setting language options in this file it is usually desirable to use <a class="reference internal" href="#ghci-cmd-seti"><code>:seti</code></a> rather than <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> (see <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>).</p> </div> <p>Placing a <code>.ghci</code> file in a directory with a Haskell project is a useful way to set certain project-wide options so you don’t have to type them every time you start GHCi: eg. if your project uses multi-parameter type classes, scoped type variables, and CPP, and has source files in three subdirectories A, B and C, you might put the following lines in <code>.ghci</code>:</p> <pre data-language="none">:set -XMultiParamTypeClasses -XScopedTypeVariables -cpp
:set -iA:B:C
</pre> <p>(Note that strictly speaking the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> flag is a static one, but in fact it works to set it using <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> like this. The changes won’t take effect until the next <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a>, though.)</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Sourcing untrusted <code>./.ghci</code> files is a security risk. They can contain arbitrary commands that will be executed as the user. Use <a class="reference internal" href="#ghci-cmd-set-local-config"><code>:set local-config</code></a> to inhibit the processing of <code>./.ghci</code> files.</p> </div> <p>Once you have a library of GHCi macros, you may want to source them from separate files, or you may want to source your <code>.ghci</code> file into your running GHCi session while debugging it</p> <pre data-language="none">:def source readFile
</pre> <p>With this macro defined in your <code>.ghci</code> file, you can use <code>:source file</code> to read GHCi commands from <code>file</code>. You can find (and contribute!-) other suggestions for <code>.ghci</code> files on this Haskell wiki page: <a class="reference external" href="https://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</a></p> <p>Additionally, any files specified with <a class="reference internal" href="#ghc-flag-ghci-script"><code>-ghci-script</code></a> flags will be read after the standard files, allowing the use of custom .ghci files.</p> <p>Two command-line options control whether the startup files files are read:</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ignore-dot-ghci">
<code>-ignore-dot-ghci</code> </dt> <dd>
<p>Don’t read either <code>./.ghci</code> or the other startup files when starting up.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ghci-script">
<code>-ghci-script</code> </dt> <dd>
<p>Read a specific file after the usual startup files. May be specified repeatedly for multiple inputs. <a class="reference internal" href="#ghc-flag-ignore-dot-ghci"><code>-ignore-dot-ghci</code></a> does not apply to these files.</p> </dd>
</dl> <p>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</p> <p>For example, consider if you had a macro named <code>:time</code> and in the shell, typed <code>:t 3</code> — what should happen? The current algorithm we use for completing commands is:</p> <ol class="arabic simple"> <li>First, look up an exact match on the name from the defined macros.</li> <li>Look for the exact match on the name in the built-in command list.</li> <li>Do a prefix lookup on the list of built-in commands - if a built-in command matches, but a macro is defined with the same name as the built-in defined, pick the macro.</li> <li>Do a prefix lookup on the list of built-in commands.</li> <li>Do a prefix lookup on the list of defined macros.</li> </ol> <p>Here are some examples:</p> <ol class="arabic"> <li>
<p>You have a macro <code>:time</code> and enter <code>:t 3</code></p> <p>You get <code>:type 3</code></p> </li> <li>
<p>You have a macro <code>:type</code> and enter <code>:t 3</code></p> <p>You get <code>:type 3</code> with your defined macro, not the builtin.</p> </li> <li>
<p>You have a macro <code>:time</code> and a macro <code>:type</code>, and enter <code>:t 3</code></p> <p>You get <code>:type 3</code> with your defined macro.</p> </li> </ol> <p>When giving priority to built-in commands, you can use <a class="reference internal" href="#ghci-cmd-builtin-command"><code>:: ⟨builtin-command⟩</code></a>, like <code>::type 3</code>.</p> </section> <section id="the-haskeline-file"> <h3 id="dot-haskeline-file">
<span class="section-number">3.9.2. </span>The <code>.haskeline</code> file</h3> <p id="index-39">GHCi uses <a class="reference external" href="https://hackage.haskell.org/package/haskeline">Haskeline</a> under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: <a class="reference external" href="https://github.com/judah/haskeline/wiki/UserPreferences">Haskeline user preferences</a>.</p> </section> </section> <section id="compiling-to-object-code-inside-ghci"> <h2 id="ghci-obj">
<span class="section-number">3.10. </span>Compiling to object code inside GHCi</h2> <p>By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system. GHCi can also compile Haskell code to object code: to turn on this feature, use the <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code>-fobject-code</code></a> flag either on the command line or with <a class="reference internal" href="#ghci-cmd-set"><code>:set</code></a> (the option <a class="reference internal" href="phases.html#ghc-flag-fbyte-code"><code>-fbyte-code</code></a> restores byte-code compilation again). Compiling to object code takes longer, but typically the code will execute 10-20 times faster than byte-code.</p> <p>Compiling to object code inside GHCi is particularly useful if you are developing a compiled application, because the <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a> command typically runs much faster than restarting GHC with <a class="reference internal" href="using.html#ghc-flag-make"><code>--make</code></a> from the command-line, because all the interface files are already cached in memory.</p> <p>There are disadvantages to compiling to object-code: you can’t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</p> </section> <section id="running-the-interpreter-in-a-separate-process"> <h2 id="external-interpreter">
<span class="section-number">3.11. </span>Running the interpreter in a separate process</h2> <p>Normally GHCi runs the interpreted code in the same process as GHC itself, on top of the same RTS and sharing the same heap. However, if the flag <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code>-fexternal-interpreter</code></a> is given, then GHC will spawn a separate process for running interpreted code, and communicate with it using messages over a pipe.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fexternal-interpreter">
<code>-fexternal-interpreter</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>8.0.1</p> </dd> </dl> <p>Run interpreted code (for GHCi, Template Haskell, Quasi-quoting, or Annotations) in a separate process. The interpreter will run in profiling mode if <a class="reference internal" href="profiling.html#ghc-flag-prof"><code>-prof</code></a> is in effect, and in dynamically-linked mode if <a class="reference internal" href="phases.html#ghc-flag-dynamic"><code>-dynamic</code></a> is in effect.</p> <p>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don’t work with <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code>-fexternal-interpreter</code></a>.</p> <p>See also the <a class="reference internal" href="phases.html#ghc-flag-pgmi-cmd"><code>-pgmi ⟨cmd⟩</code></a> (<a class="reference internal" href="phases.html#replacing-phases"><span class="std std-ref">Replacing the program for one or more phases</span></a>) and <a class="reference internal" href="phases.html#ghc-flag-opti-option"><code>-opti ⟨option⟩</code></a> (<a class="reference internal" href="phases.html#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>) flags.</p> </dd>
</dl> <p>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</p> <ul class="simple"> <li>We can use the profiler to collect stack traces when using GHCi (see <a class="reference internal" href="#ghci-stack-traces"><span class="std std-ref">Stack Traces in GHCi</span></a>).</li> <li>When compiling Template Haskell code with <a class="reference internal" href="profiling.html#ghc-flag-prof"><code>-prof</code></a> we don’t need to compile the modules without <a class="reference internal" href="profiling.html#ghc-flag-prof"><code>-prof</code></a> first (see <a class="reference internal" href="exts/template_haskell.html#th-profiling"><span class="std std-ref">Using Template Haskell with Profiling</span></a>) because we can run the profiled object code in the interpreter.</li> </ul> <p>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</p> <section id="building-an-external-interpreter"> <h3>
<span class="section-number">3.11.1. </span>Building an external interpreter</h3> <p>The source code for the external interpreter program is in <code>utils/iserv</code>. It is very simple because most of the heavy lifting code is from the <code>ghci</code> library.</p> <p>It is sometimes desirable to customize the external interpreter program. For example, it is possible to add symbols to the RTS linker used by the external interpreter. This is done simply at link time by linking an additional <code>.o</code> that defines a <code>rtsExtraSyms</code> function returning the extra symbols. Doing it this way avoids the need to recompile the RTS with symbols added to its built-in list. A typical C file would look like this:</p> <pre data-language="C">#include &lt;RtsSymbols.h&gt;

#define CODE_SYM(vvv) { MAYBE_LEADING_UNDERSCORE_STR(#vvv), \
                      (void*)(&amp;(vvv)), STRENGTH_NORMAL, SYM_TYPE_CODE },
#define DATA_SYM(vvv) { MAYBE_LEADING_UNDERSCORE_STR(#vvv), \
                      (void*)(&amp;(vvv)), STRENGTH_NORMAL, SYM_TYPE_DATA },

RtsSymbolVal my_iserv_syms[] = {
    CODE_SYM(malloc)
    CODE_SYM(getauxval)
    CODE_SYM(posix_spawn_file_actions_init)
    ...
    { 0, 0, STRENGTH_NORMAL, SYM_TYPE_CODE } /* sentinel */
};

RtsSymbolVal* rtsExtraSyms() {
    return my_iserv_syms;
}
</pre> <p>For more information, read the Note [Extra RTS symbols] in the RTS.</p> </section> <section id="running-the-interpreter-on-a-different-host"> <h3 id="external-interpreter-proxy">
<span class="section-number">3.11.2. </span>Running the interpreter on a different host</h3> <p>When using the flag <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code>-fexternal-interpreter</code></a> GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the <code>utils</code> directory.</p> <ul class="simple"> <li>
<code>remote-iserv</code> needs to be built with the cross compiler to be executed on the remote host. Or in the case of using it on the same host the stage2 compiler will do as well.</li> <li>
<code>iserv-proxy</code> needs to be built on the build machine by the build compiler.</li> </ul> <p>After starting <code>remote-iserv ⟨tmp_dir⟩ ⟨port⟩</code> on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</p> <p>Providing <a class="reference internal" href="phases.html#ghc-flag-pgmi-cmd"><code>-pgmi ⟨/path/to/iserv-proxy⟩</code></a> and <a class="reference internal" href="phases.html#ghc-flag-opti-option"><code>-opti ⟨slave-ip⟩ -opti ⟨slave-port⟩ [-opti -v]</code></a> in addition to <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code>-fexternal-interpreter</code></a> will then make ghc go through the proxy instead.</p> <p>There are some limitations when using this. File and process IO will be executed on the target. As such packages like <code>git-embed</code>, <code>file-embed</code> and others might not behave as expected if the target and host do not share the same filesystem.</p> </section> </section> <section id="building-ghci-libraries"> <h2 id="id14">
<span class="section-number">3.12. </span>Building GHCi libraries</h2> <p>When invoked in the static way, GHCi will use the GHC RTS’s static runtime linker to load object files for imported modules when available. However, when these modules are built with <a class="reference internal" href="phases.html#ghc-flag-split-sections"><code>-split-sections</code></a> this linking can be quite expensive. To reduce this cost, package managers and build systems may opt to produce a pre-linked <em>GHCi object</em> using the <a class="reference internal" href="using.html#ghc-flag-merge-objs"><code>--merge-objs</code></a> mode. This merges the per-module objects into a single object, collapsing function sections into a single text section which can be efficiently loaded by the runtime linker.</p> </section> <section id="faq-and-things-to-watch-out-for"> <h2 id="ghci-faq">
<span class="section-number">3.13. </span>FAQ and Things To Watch Out For</h2> <dl class="simple"> <dt>The interpreter can’t load modules with foreign export declarations!</dt>
<dd>
<p>Unfortunately not. We haven’t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</p> </dd> </dl> <p><a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code>-O</code></a> is ineffective in GHCi!</p>  <p id="index-40">Before GHC 9.8, optimizations were considered too unstable to be used with the bytecode interpreter. This restriction has been lifted, but is still regarded as experimental and guarded by <a class="reference internal" href="debugging.html#ghc-flag-funoptimized-core-for-interpreter"><code>-funoptimized-core-for-interpreter</code></a>, which is enabled by default. In order to use optimizations, run:</p> <pre data-language="haskell">ghci -fno-unoptimized-core-for-interpreter -O
</pre>  <dl> <dt>Concurrent threads don’t carry on running when GHCi is waiting for input.</dt>
<dd>
<p>This should work, as long as your GHCi was built with the <a class="reference internal" href="phases.html#ghc-flag--single-threaded"><code>-threaded</code></a> switch, which is the default. Consult whoever supplied your GHCi installation.</p> </dd> <dt>
<code>After using getContents, I can’t use stdin, until I do :load or :reload</code> </dt>
<dd>
<p>This is the defined behaviour of <code>getContents</code>: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next <a class="reference internal" href="#ghci-cmd-load"><code>:load</code></a> or <a class="reference internal" href="#ghci-cmd-reload"><code>:reload</code></a> command.</p> <p>You can make <code>stdin</code> reset itself after every evaluation by giving GHCi the command <code>:set +r</code>. This works because <code>stdin</code> is just a top-level expression that can be reverted to its unevaluated state in the same way as any other top-level expression (CAF).</p> </dd> <dt>I can’t use <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> to interrupt computations in GHCi on Windows.</dt>
<dd>
<p>See <a class="reference internal" href="win32-dlls.html#ghci-windows"><span class="std std-ref">Running GHCi on Windows</span></a>.</p> </dd> <dt>The default buffering mode is different in GHCi to GHC.</dt>
<dd>
<p>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</p> <p>If you want line-buffered behaviour, as in GHC, you can start your program thus:</p> <pre data-language="haskell">main = do { hSetBuffering stdout LineBuffering; ... }
</pre> </dd> </dl> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id15" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">5</a><span class="fn-bracket">]</span></span> <p>Note that packages only contain compiled code, so debugging a package requires finding its source and loading that directly.</p> </aside> <aside class="footnote brackets" id="id16" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span> <p>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</p> </aside> </aside> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/ghci.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/ghci.html</a>
  </p>
</div>
