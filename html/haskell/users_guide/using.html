<h1 id="id1">5.1. Using GHC</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="using-ghc">  <section id="getting-started-compiling-programs"> <h2 id="index-0">
<span class="section-number">5.1.1. </span>Getting started: compiling programs</h2> <p>In this chapter you’ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It’s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</p> <p>Let’s create a Hello World program, and compile and run it. First, create a file <code>hello.hs</code> containing the Haskell code:</p> <pre data-language="haskell">main = putStrLn "Hello, World!"
</pre> <p>To compile the program, use GHC like this:</p> <pre data-language="sh">$ ghc hello.hs
</pre> <p>(where <code>$</code> represents the prompt: don’t type it). GHC will compile the source file <code>hello.hs</code>, producing an object file <code>hello.o</code> and an interface file <code>hello.hi</code>, and then it will link the object file to the libraries that come with GHC to produce an executable called <code>hello</code> on Unix/Linux/Mac, or <code>hello.exe</code> on Windows.</p> <p>By default GHC will be very quiet about what it is doing, only printing error messages. If you want to see in more detail what’s going on behind the scenes, add <a class="reference internal" href="#ghc-flag-v"><code>-v</code></a> to the command line.</p> <p>Then we can run the program like this:</p> <pre data-language="sh">$ ./hello
Hello World!
</pre> <p>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the <code>Main</code> module, and GHC will examine the <code>import</code> declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the <code>Main</code> module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module <code>Data.Person</code> would be in the file <code>Data/Person.hs</code> on Unix/Linux/Mac, or <code>Data\Person.hs</code> on Windows.</p> </section> <section id="options-overview"> <h2>
<span class="section-number">5.1.2. </span>Options overview</h2> <p>GHC’s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</p> <section id="command-line-arguments"> <h3>
<span class="section-number">5.1.2.1. </span>Command-line arguments</h3> <p id="index-1">An invocation of GHC takes the following form:</p> <pre data-language="none">ghc [argument...]
</pre> <p>Command-line arguments are either options or file names.</p> <p>Command-line options begin with <code>-</code>. They may <em>not</em> be grouped: <code>-vO</code> is different from <code>-v -O</code>. Options need not precede filenames: e.g., <code>ghc *.o -o foo</code>. All options are processed and then applied to all files; you cannot, for example, invoke <code>ghc -c -O1 Foo.hs -O2 Bar.hs</code> to apply different optimisation levels to the files <code>Foo.hs</code> and <code>Bar.hs</code>.</p> <p>In addition to passing arguments via the command-line, arguments can be passed via GNU-style response files. For instance,</p> <pre data-language="bash">$ cat response-file
-O1
Hello.hs
-o Hello
$ ghc @response-file
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p id="index-2">Note that command-line options are <em>order-dependent</em>, with arguments being evaluated from left-to-right. This can have seemingly strange effects in the presence of flag implication. For instance, consider <a class="reference internal" href="using-optimisation.html#ghc-flag-fspecialise"><code>-fno-specialise</code></a> and <a class="reference internal" href="using-optimisation.html#ghc-flag-O1"><code>-O1</code></a> (which implies <a class="reference internal" href="using-optimisation.html#ghc-flag-fspecialise"><code>-fspecialise</code></a>). These two command lines mean very different things:</p> <p><code>-fno-specialise -O1</code></p>  <p><code>-fspecialise</code> will be enabled as the <code>-fno-specialise</code> is overridden by the <code>-O1</code>.</p>  <p><code>-O1 -fno-specialise</code></p>  <p><code>-fspecialise</code> will not be enabled, since the <code>-fno-specialise</code> overrides the <code>-fspecialise</code> implied by <code>-O1</code>.</p>  </div> </section> <section id="command-line-options-in-source-files"> <h3 id="source-file-options">
<span class="section-number">5.1.2.2. </span>Command line options in source files</h3> <p id="index-3">Sometimes it is useful to make the connection between a source file and the command-line options it requires quite tight. For instance, if a Haskell source file deliberately uses name shadowing, it should be compiled with the <code>-Wno-name-shadowing</code> option. Rather than maintaining the list of per-file options in a <code>Makefile</code>, it is possible to do this directly in the source file using the <code>OPTIONS_GHC</code> <a class="reference internal" href="exts/pragmas.html#options-pragma"><span class="std std-ref">pragma</span></a></p> <pre data-language="haskell">{-# OPTIONS_GHC -Wno-name-shadowing #-}
module X where
...
</pre> <p><code>OPTIONS_GHC</code> is a <em>file-header pragma</em> (see <a class="reference internal" href="exts/pragmas.html#options-pragma"><span class="std std-ref">OPTIONS_GHC pragma</span></a>).</p> <p>Only <em>dynamic</em> flags can be used in an <code>OPTIONS_GHC</code> pragma (see <a class="reference internal" href="#mode-dynamic-flags"><span class="std std-ref">Dynamic and Mode options</span></a>).</p> <p>Note that your command shell does not get to the source file options, they are just included literally in the array of command-line arguments the compiler maintains internally, so you’ll be desperately disappointed if you try to glob etc. inside <code>OPTIONS_GHC</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The contents of <code>OPTIONS_GHC</code> are appended to the command-line options, so options given in the source file override those given on the command-line.</p> </div> <p>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the <code>OPTIONS_GHC</code> pragma is the Right Thing. (If you use <a class="reference internal" href="separate_compilation.html#ghc-flag-keep-hc-file"><code>-keep-hc-file</code></a> and have <code>OPTION</code> flags in your module, the <code>OPTIONS_GHC</code> will get put into the generated <code>.hc</code> file).</p> </section> <section id="setting-options-in-ghci"> <h3>
<span class="section-number">5.1.2.3. </span>Setting options in GHCi</h3> <p>Options may also be modified from within GHCi, using the <a class="reference internal" href="ghci.html#ghci-cmd-set"><code>:set</code></a> command.</p> </section> </section> <section id="dynamic-and-mode-options"> <h2 id="mode-dynamic-flags">
<span class="section-number">5.1.3. </span>Dynamic and Mode options</h2> <p id="index-4">Each of GHC’s command line options is classified as dynamic or mode:</p>  <p>Mode: A mode may be used on the command line only. You can pass only one mode flag. For example, <a class="reference internal" href="#ghc-flag-make"><code>--make</code></a> or <a class="reference internal" href="#ghc-flag-E"><code>-E</code></a>. The available modes are listed in <a class="reference internal" href="#modes"><span class="std std-ref">Modes of operation</span></a>.</p> <p>Dynamic: A dynamic flag may be used on the command line, in a <code>OPTIONS_GHC</code> pragma in a source file, or set using <a class="reference internal" href="ghci.html#ghci-cmd-set"><code>:set</code></a> in GHCi.</p>  <p>The flag reference tables (<a class="reference internal" href="flags.html#flag-reference"><span class="std std-ref">Flag reference</span></a>) lists the status of each flag.</p> </section> <section id="meaningful-file-suffixes"> <h2 id="file-suffixes">
<span class="section-number">5.1.4. </span>Meaningful file suffixes</h2> <p id="index-5">File names with “meaningful” suffixes (e.g., <code>.lhs</code> or <code>.o</code>) cause the “right thing” to happen to those files.</p> <dl> <dt>
<code>.hs</code> </dt>
<dd>
<p>A Haskell module.</p> </dd> <dt>
<code>.lhs</code> </dt>
<dd>
<p id="index-6">A “literate Haskell” module.</p> </dd> <dt>
<code>.hspp</code> </dt>
<dd>
<p>A file created by the preprocessor.</p> </dd> <dt>
<code>.hi</code> </dt>
<dd>
<p>A Haskell interface file, probably compiler-generated.</p> </dd> <dt>
<code>.hie</code> </dt>
<dd>
<p>An extended Haskell interface file, produced by the Haskell compiler.</p> </dd> <dt>
<code>.hc</code> </dt>
<dd>
<p>Intermediate C file produced by the Haskell compiler.</p> </dd> <dt>
<code>.c</code> </dt>
<dd>
<p>A C file not produced by the Haskell compiler.</p> </dd> <dt>
<code>.ll</code> </dt>
<dd>
<p>An llvm-intermediate-language source file, usually produced by the compiler.</p> </dd> <dt>
<code>.bc</code> </dt>
<dd>
<p>An llvm-intermediate-language bitcode file, usually produced by the compiler.</p> </dd> <dt>
<code>.s</code> </dt>
<dd>
<p>An assembly-language source file, usually produced by the compiler.</p> </dd> <dt>
<code>.o</code> </dt>
<dd>
<p>An object file, produced by an assembler.</p> </dd> </dl> <p>Files with other suffixes (or without suffixes) are passed straight to the linker.</p> </section> <section id="modes-of-operation"> <h2 id="modes">
<span class="section-number">5.1.5. </span>Modes of operation</h2> <p id="index-7">GHC’s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</p> <pre data-language="none">$ ghc Main.hs --make -o my-application
</pre> <p>If no mode flag is present, then GHC will enter <a class="reference internal" href="#ghc-flag-make"><code>--make</code></a> mode (<a class="reference internal" href="#make-mode"><span class="std std-ref">Using ghc --make</span></a>) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</p> <p>The available mode flags are:</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-interactive">
<code>--interactive</code> </dt> <dd>
<p id="index-8">Interactive mode, which is also available as <strong class="program">ghci</strong>. Interactive mode is described in more detail in <a class="reference internal" href="ghci.html#ghci"><span class="std std-ref">Using GHCi</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-run-file">
<code>--run ⟨file⟩</code> </dt> <dd>
<p id="index-9">Run a script’s <code>main</code> entry-point. Similar to <code>runghc</code>/<code>runhaskell</code> this will by default use the bytecode interpreter. If the command-line contains a <code>--</code> argument then all arguments that follow will be passed to the script. All arguments that precede <code>--</code> are interpreted as GHC arguments.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-make">
<code>--make</code> </dt> <dd>
<p id="index-10">In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using <strong class="command">make</strong>. Make mode is described in <a class="reference internal" href="#make-mode"><span class="std std-ref">Using ghc --make</span></a>.</p> <p>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the <a class="reference internal" href="#ghc-flag-make"><code>--make</code></a> option can be omitted.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-e-expr">
<code>-e ⟨expr⟩</code> </dt> <dd>
<p id="index-11">Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. This flag may be given multiple times, in which case each expression is evaluated sequentially. See <a class="reference internal" href="#eval-mode"><span class="std std-ref">Expression evaluation mode</span></a> for more details.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-E">
<code>-E</code> </dt> <dd>
<p>Stop after preprocessing (<code>.hspp</code> file)</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-C">
<code>-C</code> </dt> <dd>
<p>Stop after generating C (<code>.hc</code> file)</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-S">
<code>-S</code> </dt> <dd>
<p>Stop after generating assembly (<code>.s</code> file)</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-c">
<code>-c</code> </dt> <dd>
<p>Stop after generating object (<code>.o</code>) file</p> <p>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See <a class="reference internal" href="#options-order"><span class="std std-ref">Batch compiler mode</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-merge-objs">
<code>--merge-objs</code> </dt> <dd>
<p>Merge a set of static object files into a library optimised for loading in GHCi. See <a class="reference internal" href="ghci.html#building-ghci-libraries"><span class="std std-ref">Building GHCi libraries</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-M">
<code>-M</code> </dt> <dd>
<p id="index-12">Dependency-generation mode. In this mode, GHC can be used to generate dependency information suitable for use in a <code>Makefile</code>. See <a class="reference internal" href="separate_compilation.html#makefile-dependencies"><span class="std std-ref">Dependency generation</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-frontend-module">
<code>--frontend ⟨module⟩</code> </dt> <dd>
<p id="index-13">Run GHC using the given frontend plugin. See <a class="reference internal" href="extending_ghc.html#frontend-plugins"><span class="std std-ref">Frontend plugins</span></a> for details.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-shared">
<code>-shared</code> </dt> <dd>
<p id="index-14">Create a shared object (or, on Windows, DLL). See <a class="reference internal" href="win32-dlls.html#win32-dlls-create"><span class="std std-ref">Creating a DLL</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-help">
<code>--help</code> </dt> <dt class="sig sig-object std" id="ghc-flag-0">
<code>-?</code> </dt> <dd>
<p>Cause GHC to spew a long usage message to standard output and then exit.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-show-iface-file">
<code>--show-iface ⟨file⟩</code> </dt> <dd>
<p>Read the interface in ⟨file⟩ and dump it as text to <code>stdout</code>. For example <code>ghc --show-iface M.hi</code>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-supported-extensions">
<code>--supported-extensions</code> </dt> <dt class="sig sig-object std" id="ghc-flag-supported-languages">
<code>--supported-languages</code> </dt> <dd>
<p>Print the supported language extensions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-show-options">
<code>--show-options</code> </dt> <dd>
<p>Print the supported command line options. This flag can be used for autocompletion in a shell.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-info">
<code>--info</code> </dt> <dd>
<p>Print information about the compiler.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-version">
<code>--version</code> </dt> <dt class="sig sig-object std" id="ghc-flag-V">
<code>-V</code> </dt> <dd>
<p>Print a one-line string including GHC’s version number.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-numeric-version">
<code>--numeric-version</code> </dt> <dd>
<p>Print GHC’s numeric version number only.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-booter-version">
<code>--print-booter-version</code> </dt> <dd>
<p>Print the numeric version of the GHC binary used to bootstrap the build of this compiler.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-build-platform">
<code>--print-build-platform</code> </dt> <dd>
<p>Print the target string of the build platform, on which GHC was built, as generated by GNU Autotools. The format is <code>cpu-manufacturer-operating_system-(kernel)</code>, e.g., <code>x86_64-unknown-linux</code>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-c-compiler-flags">
<code>--print-c-compiler-flags</code> </dt> <dd>
<p>List the flags passed to the C compiler during GHC build.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-c-compiler-link-flags">
<code>--print-c-compiler-link-flags</code> </dt> <dd>
<p>List the flags passed to the C compiler for the linking step during GHC build.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-debug-on">
<code>--print-debug-on</code> </dt> <dd>
<p>Print <code>True</code> if GHC was built with <code>-DDebug</code> flag. This enables assertions and extra debug code. The flag can be set in <code>GhcStage1HcOpts</code> and/or <code>GhcStage2HcOpts</code> and is automatically set for <code>devel1</code> and <code>devel2</code> build flavors.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-global-package-db">
<code>--print-global-package-db</code> </dt> <dd>
<p>Print the path to GHC’s global package database directory. A package database stores details about installed packages as a directory containing a file for each package. This flag prints the path to the global database shipped with GHC, and looks something like <code>/usr/lib/ghc/package.conf.d</code> on Unix. There may be other package databases, e.g., the user package databse. For more details see <a class="reference internal" href="packages.html#package-databases"><span class="std std-ref">Package Databases</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-have-interpreter">
<code>--print-have-interpreter</code> </dt> <dd>
<p>Print <code>YES</code> if GHC was compiled to include the interpreter, <code>NO</code> otherwise. If this GHC does not have the interpreter included, running it in interactive mode (see <a class="reference internal" href="#ghc-flag-interactive"><code>--interactive</code></a>) will throw an error. This only pertains the use of GHC interactively, not any separate GHCi binaries (see <a class="reference internal" href="ghci.html#ghci"><span class="std std-ref">Using GHCi</span></a>).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-have-native-code-generator">
<code>--print-have-native-code-generator</code> </dt> <dd>
<p>Print <code>YES</code> if native code generator supports the target platform, <code>NO</code> otherwise. (See <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">Native Code Generator (-fasm)</span></a>)</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-host-platform">
<code>--print-host-platform</code> </dt> <dd>
<p>Print the target string of the host platform, i.e., the one on which GHC is supposed to run, as generated by GNU Autotools. The format is <code>cpu-manufacturer-operating_system-(kernel)</code>, e.g., <code>x86_64-unknown-linux</code>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-leading-underscore">
<code>--print-leading-underscore</code> </dt> <dd>
<p>Print <code>YES</code> if GHC was compiled to use symbols with leading underscores in object files, <code>NO</code> otherwise. This is usually atarget platform dependent.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-libdir">
<code>--print-libdir</code> </dt> <dd>
<p id="index-15">Print the path to GHC’s library directory. This is the top of the directory tree containing GHC’s libraries, interfaces, and include files (usually something like <code>/usr/local/lib/ghc-5.04</code> on Unix). This is the value of <code>$libdir</code> in the package configuration file (see <a class="reference internal" href="packages.html#packages"><span class="std std-ref">Packages</span></a>).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-ld-flags">
<code>--print-ld-flags</code> </dt> <dd>
<p>Print linke flags used to compile GHC.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-object-splitting-supported">
<code>--print-object-splitting-supported</code> </dt> <dd>
<p>Prints <code>NO</code> as object splitting is no longer supported. See <a class="reference internal" href="phases.html#ghc-flag-split-sections"><code>-split-sections</code></a> for a more portable and reliable alternative.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-project-git-commit-id">
<code>--print-project-git-commit-id</code> </dt> <dd>
<p>Print the Git commit id from which this GHC was built. This can be used to trace the current binary back to a specific revision, which is especially useful during development on GHC itself. It is set by the configure script.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-project-version">
<code>--print-project-version</code> </dt> <dd>
<p>Print the version set in the configure script during build. This is simply the GHC version.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-rts-ways">
<code>--print-rts-ways</code> </dt> <dd>
<p>Packages, like the Runtime System, can be built in a number of ways: - profiling - with profiling support - dynamic - with dynamic linking - logging - RTS event logging - threaded - mulithreaded RTS - debug - RTS with debug information</p> <p>Various combinations of these flavours are possible.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-stage">
<code>--print-stage</code> </dt> <dd>
<p>GHC is built using GHC itself and this build happens in stages, which are numbered.</p> <ul class="simple"> <li>Stage 0 is the GHC you have installed. The “GHC you have installed” is also called “the bootstrap compiler”.</li> <li>Stage 1 is the first GHC we build, using stage 0. Stage 1 is then used to build the packages.</li> <li>Stage 2 is the second GHC we build, using stage 1. This is the one we normally install when you say make install.</li> <li>Stage 3 is optional, but is sometimes built to test stage 2.</li> </ul> <p>Stage 1 does not support interactive execution (GHCi) and Template Haskell.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-support-smp">
<code>--print-support-smp</code> </dt> <dd>
<p>Print <code>YES</code> if GHC was built with multiporcessor support, <code>NO</code> otherwise.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-tables-next-to-code">
<code>--print-tables-next-to-code</code> </dt> <dd>
<p>Print <code>YES</code> if GHC was built with the flag <code>--enable-tables-next-to-code</code>, <code>NO</code> otherwise. This option is on by default, as it generates a more efficient code layout.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-target-platform">
<code>--print-target-platform</code> </dt> <dd>
<p>Print the target string of the target platform, i.e., the one on which generated binaries will run, as generated by GNU Autotools. The format is <code>cpu-manufacturer-operating_system-(kernel)</code>, e.g., <code>x86_64-unknown-linux</code>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-print-unregisterised">
<code>--print-unregisterised</code> </dt> <dd>
<p>Print <code>YES</code> if this GHC was built in unregisterised mode, <code>NO</code> otherwise. “Unregisterised” means that GHC will disable most platform-specific tricks and optimisations. Only the LLVM and C code generators will be available. See <a class="reference internal" href="codegens.html#unreg"><span class="std std-ref">Unregisterised compilation</span></a> for more details.</p> </dd>
</dl> <section id="using-ghc-make"> <h3 id="make-mode">
<span class="section-number">5.1.5.1. </span>Using <code>ghc</code> <code>--make</code>
</h3> <p id="index-16">In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just <code>Main</code>). For example, if your <code>Main</code> module is in a file called <code>Main.hs</code>, you could compile and link the program like this:</p> <pre data-language="none">ghc --make Main.hs
</pre> <p>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</p> <pre data-language="none">ghc Main.hs
</pre> <p>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a <code>Main</code> module, the program will also be linked into an executable.</p> <p>The main advantages to using <code>ghc --make</code> over traditional <code>Makefile</code>s are:</p> <ul> <li>GHC doesn’t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with <code>ghc --make</code> can be up to twice as fast as running <code>ghc</code> individually on each source file.</li> <li>You don’t have to write a <code>Makefile</code>. </li> <li id="index-17">GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</li> <li>Using the <a class="reference internal" href="#ghc-flag-j-n"><code>-j[⟨n⟩]</code></a> flag, you can compile modules in parallel. Specify <code>-j ⟨n⟩</code> to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</li> </ul> <p>Any of the command-line options described in the rest of this chapter can be used with <code>--make</code>, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you’ll need to use an <code>OPTIONS_GHC</code> pragma (see <a class="reference internal" href="#source-file-options"><span class="std std-ref">Command line options in source files</span></a>).</p> <p>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</p> <p>For backward compatibility with existing make scripts, when used in combination with <a class="reference internal" href="#ghc-flag-c"><code>-c</code></a>, the linking phase is omitted (same as <code>--make -no-link</code>).</p> <p>Note that GHC can only follow dependencies if it has the source file available, so if your program includes a module for which there is no source file, even if you have an object and an interface file for the module, then GHC will complain. The exception to this rule is for package modules, which may or may not have source files.</p> <p>The source files for the program don’t all need to be in the same directory; the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> option can be used to add directories to the search path (see <a class="reference internal" href="separate_compilation.html#search-path"><span class="std std-ref">The search path</span></a>).</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-j-n">
<code>-j[⟨n⟩]</code> </dt> <dd>
<p>Perform compilation in parallel when possible. GHC will use up to ⟨N⟩ threads during compilation. If N is omitted, then it defaults to the number of processors. Note that compilation of a module may not begin until its dependencies have been built.</p> </dd>
</dl> </section> <section id="ghc-jobserver-protocol"> <h3>
<span class="section-number">5.1.5.2. </span>GHC Jobserver Protocol</h3> <p>The GHC Jobserver Protocol was specified in <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0540-jsem.rst">GHC proposal #540</a>.</p> <p>This protocol allows a server to dynamically invoke many instances of a client process, while restricting all of those instances to use no more than &lt;n&gt; capabilities. This is achieved by coordination over a system semaphore (either a POSIX semaphore in the case of Linux and Darwin, or a Win32 semaphore in the case of Windows platforms).</p> <p>There are two kinds of participants in the GHC Jobserver protocol:</p> <ul> <li>
<p>The <em>jobserver</em> creates a system semaphore with a certain number of available tokens.</p> <p>Each time the jobserver wants to spawn a new jobclient subprocess, it <strong>must</strong> first acquire a single token from the semaphore, before spawning the subprocess. This token <strong>must</strong> be released once the subprocess terminates.</p> <p>Once work is finished, the jobserver <strong>must</strong> destroy the semaphore it created.</p> </li> <li>
<p>A <em>jobclient</em> is a subprocess spawned by the jobserver or another jobclient.</p> <p>Each jobclient starts with one available token (its <em>implicit token</em>, which was acquired by the parent which spawned it), and can request more tokens through the Jobserver Protocol by waiting on the semaphore.</p> <p>Each time a jobclient wants to spawn a new jobclient subprocess, it <strong>must</strong> pass on a single token to the child jobclient. This token can either be the jobclient’s implicit token, or another token which the jobclient acquired from the semaphore.</p> <p>Each jobclient <strong>must</strong> release exactly as many tokens as it has acquired from the semaphore (this does not include the implicit tokens).</p> <p>GHC itself acts as a jobclient which can be enabled by using the flag <code>-jsem</code>.</p> </li> </ul> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-jsem">
<code>-jsem</code> </dt> <dd>
<p>Perform compilation in parallel when possible, coordinating with other processes through the semaphore ⟨sem⟩ (specified as a string). Error if the semaphore doesn’t exist.</p> <p>Use of <code>-jsem</code> will override use of <a class="reference internal" href="#ghc-flag-j-n"><code>-j[⟨n⟩]</code></a>, and vice-versa.</p> </dd>
</dl> </section> <section id="multiple-home-units"> <h3 id="multi-home-units">
<span class="section-number">5.1.5.3. </span>Multiple Home Units</h3> <p>The compiler also has support for building multiple units in a single compiler invocation. In modern projects it is common to work on multiple interdependent packages at once, using the support for multiple home units you can load all these local packages into one ghc session and quickly get feedback about how changes affect other dependent packages.</p> <p>In order to specify multiple units, the <a class="reference internal" href="#ghc-flag-unit-filename"><code>-unit @⟨filename⟩</code></a> is given multiple times with a response file containing the arguments for each unit. The response file contains a newline separated list of arguments.</p> <pre data-language="none">ghc -unit @unitA -unit @unitB
</pre> <p>where the <code>unitA</code> response file contains the normal arguments that you would pass to <code>--make</code> mode.</p> <pre data-language="none">-this-unit-id a-0.1.0.0
-i
-isrc
A1
A2
...
</pre> <p>Then when the compiler starts in <code>--make</code> mode it will compile both units <code>a</code> and <code>b</code>.</p> <p>There is also very basic support for multiple home units in GHCi, at the moment you can start a GHCi session with multiple units but only the <a class="reference internal" href="ghci.html#ghci-cmd-reload"><code>:reload</code></a> is supported.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-unit-filename">
<code>-unit @⟨filename⟩</code> </dt> <dd>
<p>This option is passed multiple times to inform the compiler about all the home units which it will compile. The options for each unit are supplied in a response file which contains a newline separated list of normal arguments.</p> </dd>
</dl> <p>There are a few extra flags which have been introduced to make working with multiple units easier.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-working-dir-dir">
<code>-working-dir ⟨dir⟩</code> </dt> <dd>
<p>It is common to assume that a package is compiled in the directory where its cabal file resides. Thus, all paths used in the compiler are assumed to be relative to this directory. When there are multiple home units the compiler is often not operating in the standard directory and instead where the cabal.project file is located. In this case the <code>-working-dir</code> option can be passed which specifies the path from the current directory to the directory the unit assumes to be its root, normally the directory which contains the cabal file.</p> <p>When the flag is passed, any relative paths used by the compiler are offset by the working directory. Notably this includes <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code>-i</code></a> and <a class="reference internal" href="phases.html#ghc-flag-Idir"><code>-I⟨dir⟩</code></a> flags.</p> <p>This option can also be queried by the <code>getPackageRoot</code> Template Haskell function. It is intended to be used with helper functions such as <code>makeRelativeToProject</code> which make relative filepaths relative to the compilation directory rather than the directory which contains the .cabal file.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-this-package-name-unit-id">
<code>-this-package-name ⟨unit-id⟩</code> </dt> <dd>
<p>This flag papers over the awkward interaction of the <a class="reference internal" href="exts/package_qualified_imports.html#extension-PackageImports"><code>PackageImports</code></a> and multiple home units. When using <code>PackageImports</code> you can specify the name of the package in an import to disambiguate between modules which appear in multiple packages with the same name.</p> <p>This flag allows a home unit to be given a package name so that you can also disambiguate between multiple home units which provide modules with the same name.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-hidden-module-module-name">
<code>-hidden-module ⟨module name⟩</code> </dt> <dd>
<p>This flag can be supplied multiple times in order to specify which modules in a home unit should not be visible outside of the unit it belongs to.</p> <p>The main use of this flag is to be able to recreate the difference between an exposed and hidden module for installed packages.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-reexported-module-reexport-spec">
<code>-reexported-module ⟨reexport-spec⟩</code> </dt> <dd>
<p>This flag can be supplied multiple times in order to specify which modules are not defined in a unit but should be reexported. The effect is that other units will see this module as if it was defined in this unit.</p> <p>The simple form of the flag allows the reexport of a single module at the same name:</p> <pre data-language="haskell">-reexported-module A
</pre> <p>the complicated version of the flag allows the module to be renamed when reexported:</p> <pre data-language="haskell">-reexported-module "A as B"
</pre> <p>The use of this flag is to be able to replicate the reexported modules feature of packages with multiple home units.</p> </dd>
</dl> <section id="the-home-unit-closure-requirement"> <h4>
<span class="section-number">5.1.5.3.1. </span>The home unit closure requirement</h4> <p>There is one very important closure property which you must ensure when using multiple home units.</p>  <p>Any external unit must not depend on any home unit.</p>  <p>This closure property is checked by the compiler but it’s up to the tool invoking GHC to ensure that the supplied list of home units obeys this invariant.</p> <p>For example, if we have three units, <code>p</code>, <code>q</code> and <code>r</code>, where <code>p</code> depends on <code>q</code> and <code>q</code> depends on <code>r</code>, then the closure property states that if we load <code>p</code> and <code>r</code> as home units then we must also load <code>q</code>, because <code>q</code> depends on the home unit <code>r</code> and we need <code>q</code> because <code>p</code> depends on it.</p> </section> </section> <section id="expression-evaluation-mode"> <h3 id="eval-mode">
<span class="section-number">5.1.5.4. </span>Expression evaluation mode</h3> <p>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the <code>-e</code> option:</p> <pre data-language="none">ghc -e expr
</pre> <p>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</p> <p>For example, to load and run a Haskell program containing a module <code>Main</code>, we might say:</p> <pre data-language="none">ghc -e Main.main Main.hs
</pre> <p>or we can just use this mode to evaluate expressions in the context of the <code>Prelude</code>:</p> <pre data-language="none">$ ghc -e "interact (unlines.map reverse.lines)"
hello
olleh
</pre> </section> <section id="batch-compiler-mode"> <h3 id="options-order">
<span class="section-number">5.1.5.5. </span>Batch compiler mode</h3> <p>In <em>batch mode</em>, GHC will compile one or more source files given on the command line.</p> <p>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Phase of the compilation system</p></th> <th class="head"><p>Suffix saying “start here”</p></th> <th class="head"><p>Flag saying “stop after”</p></th> <th class="head"><p>(suffix of) output file</p></th> </tr> </thead>  <tr>
<td><p>literate pre-processor</p></td> <td><p><code>.lhs</code></p></td> <td></td> <td><p><code>.hs</code></p></td> </tr> <tr>
<td><p>C pre-processor (opt.)</p></td> <td><p><code>.hs</code> (with <code>-cpp</code>)</p></td> <td><p><code>-E</code></p></td> <td><p><code>.hspp</code></p></td> </tr> <tr>
<td><p>Haskell compiler</p></td> <td><p><code>.hs</code></p></td> <td><p><code>-C</code>, <code>-S</code></p></td> <td><p><code>.hc</code>, <code>.s</code></p></td> </tr> <tr>
<td><p>C compiler (opt.)</p></td> <td><p><code>.hc</code> or <code>.c</code></p></td> <td><p><code>-S</code></p></td> <td><p><code>.s</code></p></td> </tr> <tr>
<td><p>assembler</p></td> <td><p><code>.s</code></p></td> <td><p><code>-c</code></p></td> <td><p><code>.o</code></p></td> </tr> <tr>
<td><p>linker</p></td> <td><p>⟨other⟩</p></td> <td></td> <td><p><code>a.out</code></p></td> </tr>  </table> <p id="index-18">Thus, a common invocation would be:</p> <pre data-language="none">ghc -c Foo.hs
</pre> <p>to compile the Haskell source file <code>Foo.hs</code> to an object file <code>Foo.o</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>What the Haskell compiler proper produces depends on what backend code generator is used. See <a class="reference internal" href="codegens.html#code-generators"><span class="std std-ref">GHC Backends</span></a> for more details.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Pre-processing is optional, the <a class="reference internal" href="phases.html#ghc-flag-cpp"><code>-cpp</code></a> flag turns it on. See <a class="reference internal" href="phases.html#c-pre-processor"><span class="std std-ref">Options affecting the C pre-processor</span></a> for more details.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The option <a class="reference internal" href="#ghc-flag-E"><code>-E</code></a> runs just the pre-processing passes of the compiler, dumping the result in a file.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The option <a class="reference internal" href="#ghc-flag-C"><code>-C</code></a> is only available when GHC is built in unregisterised mode. See <a class="reference internal" href="codegens.html#unreg"><span class="std std-ref">Unregisterised compilation</span></a> for more details.</p> </div> <section id="overriding-the-default-behaviour-for-a-file"> <h4 id="overriding-suffixes">
<span class="section-number">5.1.5.5.1. </span>Overriding the default behaviour for a file</h4> <p>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the <a class="reference internal" href="#ghc-flag-x-suffix"><code>-x ⟨suffix⟩</code></a> option:</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-x-suffix">
<code>-x ⟨suffix⟩</code> </dt> <dd>
<p>Causes all files following this option on the command line to be processed as if they had the suffix ⟨suffix⟩. For example, to compile a Haskell module in the file <code>M.my-hs</code>, use <code>ghc -c -x hs M.my-hs</code>.</p> </dd>
</dl> </section> </section> </section> <section id="verbosity-options"> <h2 id="options-help">
<span class="section-number">5.1.6. </span>Verbosity options</h2> <p id="index-19">See also the <code>--help</code>, <code>--version</code>, <code>--numeric-version</code>, and <code>--print-libdir</code> modes in <a class="reference internal" href="#modes"><span class="std std-ref">Modes of operation</span></a>.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-v">
<code>-v</code> </dt> <dd>
<p>The <a class="reference internal" href="#ghc-flag-v"><code>-v</code></a> option makes GHC <em>verbose</em>: it reports its version number and shows (on stderr) exactly how it invokes each phase of the compilation system. Moreover, it passes the <code>-v</code> flag to most phases; each reports its version number (and possibly some other information).</p> <p>Please, oh please, use the <code>-v</code> option when reporting bugs! Knowing that you ran the right bits in the right order is always the first thing we want to verify.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-vn">
<code>-v⟨n⟩</code> </dt> <dd>
<p>To provide more control over the compiler’s verbosity, the <code>-v</code> flag takes an optional numeric argument. Specifying <code>-v</code> on its own is equivalent to <code>-v3</code>, and the other levels have the following meanings:</p> <dl class="simple"> <dt>
<code>-v0</code> </dt>
<dd>
<p>Disable all non-essential messages (this is the default).</p> </dd> <dt>
<code>-v1</code> </dt>
<dd>
<p>Minimal verbosity: print one line per compilation (this is the default when <a class="reference internal" href="#ghc-flag-make"><code>--make</code></a> or <a class="reference internal" href="#ghc-flag-interactive"><code>--interactive</code></a> is on).</p> </dd> <dt>
<code>-v2</code> </dt>
<dd>
<p>Print the name of each compilation phase as it is executed. (equivalent to <a class="reference internal" href="debugging.html#ghc-flag-dshow-passes"><code>-dshow-passes</code></a>).</p> </dd> <dt>
<code>-v3</code> </dt>
<dd>
<p>The same as <code>-v2</code>, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</p> </dd> <dt>
<code>-v4</code> </dt>
<dd>
<p>The same as <code>-v3</code> except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</p> </dd> </dl> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-potential-instances">
<code>-fprint-potential-instances</code> </dt> <dd>
<p>When GHC can’t find an instance for a class, it displays a short list of some of the instances it knows about. With this flag it prints <em>all</em> the instances it knows about.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fhide-source-paths">
<code>-fhide-source-paths</code> </dt> <dd>
<p>Starting with minimal verbosity (<code>-v1</code>, see <a class="reference internal" href="#ghc-flag-v"><code>-v</code></a>), GHC displays the name, the source path and the target path of each compiled module. This flag can be used to reduce GHC’s output by hiding source paths and target paths.</p> </dd>
</dl> <p>The following flags control the way in which GHC displays types in error messages and in GHCi:</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-unicode-syntax">
<code>-fprint-unicode-syntax</code> </dt> <dd>
<p>When enabled GHC prints type signatures using the unicode symbols from the <a class="reference internal" href="exts/unicode_syntax.html#extension-UnicodeSyntax"><code>UnicodeSyntax</code></a> extension. For instance,</p> <pre data-language="none">ghci&gt; :set -fprint-unicode-syntax
ghci&gt; :t +v (&gt;&gt;)
(&gt;&gt;) ∷ Monad m ⇒ ∀ a b. m a → m b → m b
</pre> </dd>
</dl> <dl class="std ghc-flag" id="pretty-printing-types"> <dt class="sig sig-object std" id="ghc-flag-fprint-explicit-foralls">
<code>-fprint-explicit-foralls</code> </dt> <dd>
<p>Using <a class="reference internal" href="#ghc-flag-fprint-explicit-foralls"><code>-fprint-explicit-foralls</code></a> makes GHC print explicit <code>forall</code> quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</p> <pre data-language="none">ghci&gt; let f x = x
ghci&gt; :t f
f :: a -&gt; a
ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :t f
f :: forall a. a -&gt; a
</pre> <p>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</p> <ul> <li>
<p>For nested <code>foralls</code>, e.g.</p> <pre data-language="none">ghci&gt; :t GHC.ST.runST
GHC.ST.runST :: (forall s. GHC.ST.ST s a) -&gt; a
</pre> </li> <li>
<p>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</p> <pre data-language="none">ghci&gt; :i Data.Type.Equality.sym
Data.Type.Equality.sym ::
  forall k (a :: k) (b :: k).
  (a Data.Type.Equality.:~: b) -&gt; b Data.Type.Equality.:~: a
        -- Defined in Data.Type.Equality
</pre> </li> </ul> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-explicit-kinds">
<code>-fprint-explicit-kinds</code> </dt> <dd>
<p>Using <a class="reference internal" href="#ghc-flag-fprint-explicit-kinds"><code>-fprint-explicit-kinds</code></a> makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</p> <pre data-language="none">ghci&gt; :set -XPolyKinds
ghci&gt; data T a (b :: l) = MkT
ghci&gt; :t MkT
MkT :: forall k l (a :: k) (b :: l). T a b
ghci&gt; :set -fprint-explicit-kinds
ghci&gt; :t MkT
MkT :: forall k l (a :: k) (b :: l). T @{k} @l a b
ghci&gt; :set -XNoPolyKinds
ghci&gt; :t MkT
MkT :: T @{*} @* a b
</pre> <p>In the output above, observe that <code>T</code> has two kind variables (<code>k</code> and <code>l</code>) and two type variables (<code>a</code> and <code>b</code>). Note that <code>k</code> is an <em>inferred</em> variable and <code>l</code> is a <em>specified</em> variable (see <a class="reference internal" href="exts/type_applications.html#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>), so as a result, they are displayed using slightly different syntax in the type <code>T @{k} @l a b</code>. The application of <code>l</code> (with <code>@l</code>) is the standard syntax for visible type application (see <a class="reference internal" href="exts/type_applications.html#visible-type-application"><span class="std std-ref">Visible type application</span></a>). The application of <code>k</code> (with <code>@{k}</code>), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when <a class="reference internal" href="#ghc-flag-fprint-explicit-kinds"><code>-fprint-explicit-kinds</code></a> is enabled.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-explicit-coercions">
<code>-fprint-explicit-coercions</code> </dt> <dd>
<p>Using <a class="reference internal" href="#ghc-flag-fprint-explicit-coercions"><code>-fprint-explicit-coercions</code></a> makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-axiom-incomps">
<code>-fprint-axiom-incomps</code> </dt> <dd>
<p>Using <a class="reference internal" href="#ghc-flag-fprint-axiom-incomps"><code>-fprint-axiom-incomps</code></a> tells GHC to display incompatibilities between closed type families’ equations, whenever they are printed by <a class="reference internal" href="ghci.html#ghci-cmd-info"><code>:info</code></a> or <a class="reference internal" href="#ghc-flag-show-iface-file"><code>--show-iface ⟨file⟩</code></a>.</p> <pre data-language="none">ghci&gt; :i Data.Type.Equality.==
type family (==) (a :: k) (b :: k) :: Bool
  where
      (==) (f a) (g b) = (f == g) &amp;&amp; (a == b)
      (==) a a = 'True
      (==) _1 _2 = 'False
ghci&gt; :set -fprint-axiom-incomps
ghci&gt; :i Data.Type.Equality.==
type family (==) (a :: k) (b :: k) :: Bool
  where
      {- #0 -} (==) (f a) (g b) = (f == g) &amp;&amp; (a == b)
      {- #1 -} (==) a a = 'True
          -- incompatible with: #0
      {- #2 -} (==) _1 _2 = 'False
          -- incompatible with: #1, #0
</pre> <p>The equations are numbered starting from 0, and the comment after each equation refers to all preceding equations it is incompatible with.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-equality-relations">
<code>-fprint-equality-relations</code> </dt> <dd>
<p>Using <a class="reference internal" href="#ghc-flag-fprint-equality-relations"><code>-fprint-equality-relations</code></a> tells GHC to distinguish between its equality relations when printing. For example, <code>~</code> is homogeneous lifted equality (the kinds of its arguments are the same) while <code>~~</code> is heterogeneous lifted equality (the kinds of its arguments might be different) and <code>~#</code> is heterogeneous unlifted equality, the internal equality relation used in GHC’s solver. Generally, users should not need to worry about the subtleties here; <code>~</code> is probably what you want. Without <a class="reference internal" href="#ghc-flag-fprint-equality-relations"><code>-fprint-equality-relations</code></a>, GHC prints all of these as <code>~</code>. See also <a class="reference internal" href="exts/equality_constraints.html#equality-constraints"><span class="std std-ref">Equality constraints</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-expanded-synonyms">
<code>-fprint-expanded-synonyms</code> </dt> <dd>
<p>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</p> <pre data-language="haskell">type Foo = Int
type Bar = Bool
type MyBarST s = ST s Bar
</pre> <p>This error message:</p> <pre data-language="none">Couldn't match type 'Int' with 'Bool'
Expected type: ST s Foo
  Actual type: MyBarST s
</pre> <p>Becomes this:</p> <pre data-language="none">Couldn't match type 'Int' with 'Bool'
Expected type: ST s Foo
  Actual type: MyBarST s
Type synonyms expanded:
Expected type: ST s Int
  Actual type: ST s Bool
</pre> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-redundant-promotion-ticks">
<code>-fprint-redundant-promotion-ticks</code> </dt> <dd>
<p>The <a class="reference internal" href="exts/data_kinds.html#extension-DataKinds"><code>DataKinds</code></a> extension allows us to use data constructors at the type level:</p> <pre data-language="haskell">type B = True     -- refers to the data constructor True (of type Bool)
</pre> <p>When there is a type constructor of the same name, it takes precedence during name resolution:</p> <pre data-language="haskell">data True = MkT
type B = True     -- now refers to the type constructor (of kind Type)
</pre> <p>We can tell GHC to prefer the data constructor over the type constructor using special namespace disambiguation syntax that we call a <em>promotion tick</em>:</p> <pre data-language="haskell">data True = MkT
type B = 'True
    -- refers to the data constructor True (of type Bool)
    -- even in the presence of a type constructor of the same name
</pre> <p>Note that the promotion tick is not a promotion operator. Its only purpose is to instruct GHC to prefer the promoted data constructor over a type constructor in case of a name conflict. Therefore, GHC will not print the tick when the name conflict is absent:</p> <pre data-language="none">ghci&gt; type B = False
ghci&gt; :kind! B
B :: Bool
= False          -- no promotion tick here

ghci&gt; data False -- introduce a name conflict

ghci&gt; :kind! B
B :: Bool
= 'False         -- promotion tick resolves the name conflict
</pre> <p>The <a class="reference internal" href="#ghc-flag-fprint-redundant-promotion-ticks"><code>-fprint-redundant-promotion-ticks</code></a> instructs GHC to print the promotion tick unconditionally.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-typechecker-elaboration">
<code>-fprint-typechecker-elaboration</code> </dt> <dd>
<p>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</p> <pre data-language="haskell">main :: IO ()
main = do
  return $ let a = "hello" in a
  return ()
</pre> <p>This warning message:</p> <pre data-language="none">A do-notation statement discarded a result of type ‘[Char]’
Suppress this warning by saying
  ‘_ &lt;- ($) return let a = "hello" in a’
or by using the flag -fno-warn-unused-do-bind
</pre> <p>Becomes this:</p> <pre data-language="none">A do-notation statement discarded a result of type ‘[Char]’
Suppress this warning by saying
  ‘_ &lt;- ($)
          return
          let
            AbsBinds [] []
              {Exports: [a &lt;= a
                           &lt;&gt;]
               Exported types: a :: [Char]
                               [LclId, Str=DmdType]
               Binds: a = "hello"}
          in a’
or by using the flag -fno-warn-unused-do-bind
</pre> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fdefer-diagnostics">
<code>-fdefer-diagnostics</code> </dt> <dd>
<p>Causes GHC to group diagnostic messages by severity and output them after other messages when building a multi-module Haskell program. This flag can make diagnostic messages more visible when used in conjunction with <a class="reference internal" href="#ghc-flag-make"><code>--make</code></a> and <a class="reference internal" href="#ghc-flag-j-n"><code>-j[⟨n⟩]</code></a>. Otherwise, it can be hard to find the relevant errors or likely to ignore the warnings when they are mixed with many other messages.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fdiagnostics-as-json">
<code>-fdiagnostics-as-json</code> </dt> <dd>
<p>Causes GHC to emit diagnostic messages in a standardized JSON format, and output them directly to <code>stderr</code>. The format follows the <a class="reference external" href="https://jsonlines.org">JSON Lines</a> convention, where each diagnostic is its own JSON object separated by a new line.</p> <p>The structure of the output is described by a <a class="reference external" href="https://json-schema.org/">JSON Schema</a>. The schema can be downloaded <a class="reference download internal" download="" href="_downloads/aade9215bf1b87075759c4d918fa42d3/diagnostics-as-json-schema-1_1.json.html"><code>here</code></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fdiagnostics-color-always-auto-never">
<code>-fdiagnostics-color=⟨always|auto|never⟩</code> </dt> <dd>
<p>Causes GHC to display error messages with colors. To do this, the terminal must have support for ANSI color codes, or else garbled text will appear. The default value is <code>auto</code>, which means GHC will make an attempt to detect whether terminal supports colors and choose accordingly.</p> <p>The precise color scheme is controlled by the environment variable <code>GHC_COLORS</code> (or <code>GHC_COLOURS</code>). This can be set to colon-separated list of <code>key=value</code> pairs. These are the default settings:</p> <pre data-language="none">header=:message=1:warning=1;35:error=1;31:fatal=1;31:margin=1;34
</pre> <p>Each value is expected to be a <a class="reference external" href="https://en.wikipedia.org/wiki/ANSI_escape_code#SGR">Select Graphic Rendition (SGR) substring</a>. The formatting of each element can inherit from parent elements. For example, if <code>header</code> is left empty, it will inherit the formatting of <code>message</code>. Alternatively if <code>header</code> is set to <code>1</code> (bold), it will be bolded but still inherits the color of <code>message</code>.</p> <p>Currently, in the primary message, the following inheritance tree is in place:</p> <ul class="simple"> <li>
<p><code>message</code></p> <ul> <li>
<p><code>header</code></p> <ul> <li><code>warning</code></li> <li><code>error</code></li> <li><code>fatal</code></li> </ul> </li> </ul> </li> </ul> <p>In the caret diagnostics, there is currently no inheritance at all between <code>margin</code>, <code>warning</code>, <code>error</code>, and <code>fatal</code>.</p> <p>The environment variable can also be set to the magical values <code>never</code> or <code>always</code>, which is equivalent to setting the corresponding <code>-fdiagnostics-color</code> flag but with lower precedence.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fdiagnostics-show-caret">
<code>-fdiagnostics-show-caret</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>on</p> </dd> </dl> <p>Controls whether GHC displays a line of the original source code where the error was detected. This also affects the associated caret symbol that points at the region of code at fault.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fshow-error-context">
<code>-fshow-error-context</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>on</p> </dd> </dl> <p>Controls whether GHC displays information about the context in which an error occurred. This controls whether the part of the error message which says “In the equation..”, “In the pattern..” etc is displayed or not.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fprint-error-index-links-always-auto-never">
<code>-fprint-error-index-links=⟨always|auto|never⟩</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>auto</p> </dd> </dl> <p>Controls whether GHC will emit error indices as ANSI hyperlinks to the <a class="reference external" href="https://errors.haskell.org/">Haskell Error Index</a>. When set to auto, this flag will render hyperlinks if the terminal is capable; when set to always, this flag will render the hyperlinks regardless of the capabilities of the terminal.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ferror-spans">
<code>-ferror-spans</code> </dt> <dd>
<p>Causes GHC to emit the full source span of the syntactic entity relating to an error message. Normally, GHC emits the source location of the start of the syntactic entity only.</p> <p>For example:</p> <pre data-language="none">test.hs:3:6: parse error on input `where'
</pre> <p>becomes:</p> <pre data-language="none">test296.hs:3:6-10: parse error on input `where'
</pre> <p>And multi-line spans are possible too:</p> <pre data-language="none">test.hs:(5,4)-(6,7):
    Conflicting definitions for `a'
    Bound at: test.hs:5:4
              test.hs:6:7
    In the binding group for: a, b, a
</pre> <p>Note that line numbers start counting at one, but column numbers start at zero. This choice was made to follow existing convention (i.e. this is how Emacs does it).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fkeep-going">
<code>-fkeep-going</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Since<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>8.10.1</p> </dd> </dl> <p>Causes GHC to continue the compilation if a module has an error. Any reverse dependencies are pruned immediately and the whole compilation is still flagged as an error. This option has no effect if parallel compilation (<a class="reference internal" href="#ghc-flag-j-n"><code>-j[⟨n⟩]</code></a>) is in use.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-freverse-errors">
<code>-freverse-errors</code> </dt> <dd>
<p>Causes GHC to output errors in reverse line-number order, so that the errors and warnings that originate later in the file are displayed first.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-Rghc-timing">
<code>-Rghc-timing</code> </dt> <dd>
<p>Prints a one-line summary of timing statistics for the GHC run. This option is equivalent to <code>+RTS -tstderr</code>, see <a class="reference internal" href="runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a>.</p> </dd>
</dl> </section> <section id="platform-specific-flags"> <h2 id="options-platform">
<span class="section-number">5.1.7. </span>Platform-specific Flags</h2> <p id="index-20">Some flags only make sense for particular target platforms.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx">
<code>-mavx</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx2">
<code>-mavx2</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX2 instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx512cd">
<code>-mavx512cd</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX512-CD instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx512er">
<code>-mavx512er</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX512-ER instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx512f">
<code>-mavx512f</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX512-F instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mavx512pf">
<code>-mavx512pf</code> </dt> <dd>
<p>(x86 only) This flag allows the code generator (whether the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>) to emit x86_64 AVX512-PF instructions.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-msse">
<code>-msse</code> </dt> <dd>
<p>(x86 only) Use the SSE registers and instruction set to implement floating point operations when using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a>. This gives a substantial performance improvement for floating point, but the resulting compiled code will only run on processors that support SSE (Intel Pentium 3 and later, or AMD Athlon XP and later). The <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a> will also use SSE if your processor supports it but detects this automatically so no flag is required.</p> <p>Since GHC 8.10, SSE2 is assumed to be present on both x86 and x86-64 platforms and will be used by default. Even when setting this flag, SSE2 will be used instead.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-msse2">
<code>-msse2</code> </dt> <dd>
<p>(x86 only, added in GHC 7.0.1) Use the SSE2 registers and instruction set to implement floating point operations when using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a>. This gives a substantial performance improvement for floating point, but the resulting compiled code will only run on processors that support SSE2 (Intel Pentium 4 and later, or AMD Athlon 64 and later). The <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a> will also use SSE2 if your processor supports it but detects this automatically so no flag is required.</p> <p>Since GHC 8.10, SSE2 is assumed to be present on both x86 and x86-64 platforms and will be used by default.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-msse3">
<code>-msse3</code> </dt> <dd>
<p>(x86 only) Use the SSE3 instruction set to implement some floating point and bit operations (whether using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-msse4">
<code>-msse4</code> </dt> <dd>
<p>(x86 only) Use the SSE4 instruction set to implement some floating point and bit operations(whether using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-msse4.2">
<code>-msse4.2</code> </dt> <dd>
<p>(x86 only, added in GHC 7.4.1) Use the SSE4.2 instruction set to implement some floating point and bit operations, whether using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>. The resulting compiled code will only run on processors that support SSE4.2 (Intel Core i7 and later).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mbmi">
<code>-mbmi</code> </dt> <dd>
<p>(x86 only) Use the BMI1 instruction set to implement some bit operations.</p> <p>Note that GHC currently does not use BMI specific instructions, so this flag has no effect when used with the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mbmi2">
<code>-mbmi2</code> </dt> <dd>
<p>(x86 only, added in GHC 7.4.1) Use the BMI2 instruction set to implement some bit operations, whether using the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> or the <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM backend</span></a>.</p> <p>The resulting compiled code will only run on processors that support BMI2 (Intel Haswell and newer, AMD Excavator, Zen and newer).</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-mfma">
<code>-mfma</code> </dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Default<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>off by default, except for Aarch64 where it’s on by default.</p> </dd> <dt class="field-even">Since<span class="colon">:</span>
</dt> <dd class="field-even">
<p>9.8.1</p> </dd> </dl> <p>Use native FMA instructions to implement the fused multiply-add floating-point operations of the form <code>x * y + z</code>. This allows computing a multiplication and addition in a single instruction, without an intermediate rounding step. Supported architectures: X86 with the FMA3 instruction set (this includes most consumer processors since 2013), PowerPC and AArch64.</p> <p>When this flag is disabled, GHC falls back to the C implementation of fused multiply-add, which might perform non-IEEE-compliant software emulation on some platforms (depending on the implementation of the C standard library).</p> </dd>
</dl> </section> <section id="haddock"> <h2>
<span class="section-number">5.1.8. </span>Haddock</h2> <dl class="std ghc-flag" id="index-21"> <dt class="sig sig-object std" id="ghc-flag-haddock">
<code>-haddock</code> </dt> <dd>
<p>By default, GHC ignores Haddock comments (<code>-- | ...</code> and <code>-- ^ ...</code>) and does not check that they’re associated with a valid term, such as a top-level type-signature. With this flag GHC will parse Haddock comments and include them in the interface file it produces.</p> <p>Consider using <a class="reference internal" href="using-warnings.html#ghc-flag-Winvalid-haddock"><code>-Winvalid-haddock</code></a> to be informed about discarded documentation comments.</p> </dd>
</dl> </section> <section id="miscellaneous-flags"> <h2>
<span class="section-number">5.1.9. </span>Miscellaneous flags</h2> <p id="index-22">Some flags only make sense for a particular use case.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-ghcversion-file-path-to-ghcversion.h">
<code>-ghcversion-file ⟨path to ghcversion.h⟩</code> </dt> <dd>
<p>When GHC is used to compile C files, GHC adds package include paths and includes <code>ghcversion.h</code> directly. The compiler will lookup the path for the <code>ghcversion.h</code> file from the <code>rts</code> package in the package database. In some cases, the compiler’s package database does not contain the <code>rts</code> package, or one wants to specify a specific <code>ghcversions.h</code> to be included. This option can be used to specify the path to the <code>ghcversions.h</code> file to be included. This is primarily intended to be used by GHC’s build system.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-H-size">
<code>-H ⟨size⟩</code> </dt> <dd>
<p>Set the minimum size of the heap to ⟨size⟩. This option is equivalent to <code>+RTS -Hsize</code>, see <a class="reference internal" href="runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a>.</p> </dd>
</dl> <section id="other-environment-variables"> <h3>
<span class="section-number">5.1.9.1. </span>Other environment variables</h3> <p id="index-23">GHC can also be configured using various environment variables.</p> <dl class="std envvar"> <dt class="sig sig-object std" id="envvar-GHC_NO_UNICODE">
<code>GHC_NO_UNICODE</code> </dt> <dd>
<p>When non-empty, disables Unicode diagnostics output regardless of locale settings. GHC can usually determine that locale is not Unicode-capable and fallback to ASCII automatically, but in some corner cases (e. g., when GHC output is redirected) you might hit <code>invalid argument (cannot encode character '\8216')</code>, in which case do set <code>GHC_NO_UNICODE</code>.</p> </dd>
</dl> <dl class="std envvar"> <dt class="sig sig-object std" id="envvar-GHC_CHARENC">
<code>GHC_CHARENC</code> </dt> <dd>
<p>When set to <code>UTF-8</code> the compiler will always print UTF-8-encoded output, regardless of the current locale.</p> </dd>
</dl> </section> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/using.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/using.html</a>
  </p>
</div>
