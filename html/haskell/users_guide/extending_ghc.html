<h1 id="extending-ghc">7. Extending and using GHC as a Library</h1>
<div class="_sphinx"> <div itemprop="articleBody"> <section id="extending-and-using-ghc-as-a-library">  <p>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC’s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC’s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</p> <p>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</p> <section id="source-annotations"> <h2 id="annotation-pragmas">
<span class="section-number">7.1. </span>Source annotations</h2> <p>Annotations are small pragmas that allow you to attach data to identifiers in source code, which are persisted when compiled. These pieces of data can then inspected and utilized when using GHC as a library or writing a compiler plugin.</p> <section id="annotating-values"> <h3 id="ann-pragma">
<span class="section-number">7.1.1. </span>Annotating values</h3> <p id="index-0">Any expression that has both <code>Typeable</code> and <code>Data</code> instances may be attached to a top-level value binding using an <code>ANN</code> pragma. In particular, this means you can use <code>ANN</code> to annotate data constructors (e.g. <code>Just</code>) as well as normal values (e.g. <code>take</code>). By way of example, to annotate the function <code>foo</code> with the annotation <code>Just "Hello"</code> you would do this:</p> <pre data-language="haskell">{-# ANN foo (Just "Hello") #-}
foo = ...
</pre> <p>A number of restrictions apply to use of annotations:</p> <ul> <li>The binder being annotated must be at the top level (i.e. no nested binders)</li> <li>The binder being annotated must be declared in the current module</li> <li>The expression you are annotating with must have a type with <code>Typeable</code> and <code>Data</code> instances</li> <li>
<p>The <a class="reference internal" href="exts/template_haskell.html#th-usage"><span class="std std-ref">Template Haskell staging restrictions</span></a> apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</p> <p>To be precise, the annotation <code>{-# ANN x e #-}</code> is well staged if and only if <code>$(e)</code> would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - <code>$([|1|])</code> is fine as an annotation, albeit redundant).</p> </li> </ul> <p>If you feel strongly that any of these restrictions are too onerous, <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc">please give the GHC team a shout</a>.</p> <p>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</p> <pre data-language="haskell">{-# ANN f SillyAnnotation { foo = (id 10) + $([| 20 |]), bar = 'f } #-}
f = ...
</pre> </section> <section id="annotating-types"> <h3 id="typeann-pragma">
<span class="section-number">7.1.2. </span>Annotating types</h3> <p id="index-1">You can annotate types with the <code>ANN</code> pragma by using the <code>type</code> keyword. For example:</p> <pre data-language="haskell">{-# ANN type Foo (Just "A `Maybe String' annotation") #-}
data Foo = ...
</pre> </section> <section id="annotating-modules"> <h3 id="modann-pragma">
<span class="section-number">7.1.3. </span>Annotating modules</h3> <p id="index-2">You can annotate modules with the <code>ANN</code> pragma by using the <code>module</code> keyword. For example:</p> <pre data-language="haskell">{-# ANN module (Just "A `Maybe String' annotation") #-}
</pre> </section> </section> <section id="using-ghc-as-a-library"> <h2 id="ghc-as-a-library">
<span class="section-number">7.2. </span>Using GHC as a Library</h2> <p>The <code>ghc</code> package exposes most of GHC’s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC’s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here’s a program which compiles a module, much like ghc itself does by default when invoked:</p> <pre data-language="haskell">import GHC
import GHC.Paths ( libdir )
import GHC.Driver.Session ( defaultFatalMessager, defaultFlushOut )

main =
    defaultErrorHandler defaultFatalMessager defaultFlushOut $ do
      runGhc (Just libdir) $ do
        dflags &lt;- getSessionDynFlags
        setSessionDynFlags dflags
        target &lt;- guessTarget "test_main.hs" Nothing
        setTargets [target]
        load LoadAllTargets
</pre> <p>The argument to <code>runGhc</code> is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by <code>ghc --print-libdir</code> for the same version of GHC that the program is being compiled with. Above we therefore use the <code>ghc-paths</code> package which provides this for us.</p> <p>Compiling it results in:</p> <pre data-language="none">$ cat test_main.hs
main = putStrLn "hi"
$ ghc -package ghc simple_ghc_api.hs
[1 of 1] Compiling Main             ( simple_ghc_api.hs, simple_ghc_api.o )
Linking simple_ghc_api ...
$ ./simple_ghc_api
$ ./test_main
hi
$
</pre> <p>For more information on using the API, as well as more samples and references, please see <a class="reference external" href="https://haskell.org/haskellwiki/GHC/As_a_library">this Haskell.org wiki page</a>.</p> </section> <section id="compiler-plugins"> <h2 id="id1">
<span class="section-number">7.3. </span>Compiler Plugins</h2> <p>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by <a class="reference external" href="https://gcc.gnu.org/wiki/plugins">GCC</a>, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC’s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC’s source code to use.</p> <p>Plugins cannot optimize/inspect C-\-, nor can they implement things like parser/front-end modifications like GCC, apart from limited changes to the constraint solver. If you feel strongly that any of these restrictions are too onerous, <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc">please give the GHC team a shout</a>.</p> <p>Plugins do not work with <code>-fexternal-interpreter</code>. If you need to run plugins with <code>-fexternal-interpreter</code> let GHC developers know in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14335">#14335</a>.</p> <section id="using-compiler-plugins"> <h3 id="id2">
<span class="section-number">7.3.1. </span>Using compiler plugins</h3> <p>Plugins can be added on the command line with the <a class="reference internal" href="#ghc-flag-fplugin-module"><code>-fplugin=⟨module⟩</code></a> option where ⟨module⟩ is a module in a registered package that exports the plugin. Plugins are loaded in order, with command-line and Cabal flags preceding those in OPTIONS pragmas which are processed in file order. Arguments can be passed to the plugins with the <a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code>-fplugin-opt=⟨module⟩:⟨args⟩</code></a> option. The list of enabled plugins can be reset with the <a class="reference internal" href="#ghc-flag-fclear-plugins"><code>-fclear-plugins</code></a> option.</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fplugin-module">
<code>-fplugin=⟨module⟩</code> </dt> <dd>
<p>Load the plugin in the given module. The module must be a member of a package registered in GHC’s package database.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fplugin-opt-module-args">
<code>-fplugin-opt=⟨module⟩:⟨args⟩</code> </dt> <dd>
<p>Give arguments to a plugin module; module must be specified with <a class="reference internal" href="#ghc-flag-fplugin-module"><code>-fplugin=⟨module⟩</code></a>. The order of plugin pragmas matter but the order of arg pragmas does not. The same set of arguments go to all plugins from the same module.</p> <pre data-language="haskell">-- Two Echo plugins will both get args A and B.
{-# OPTIONS -fplugin Echo -fplugin-opt Echo:A #-}
{-# OPTIONS -fplugin Echo -fplugin-opt Echo:B #-}

-- While order of the plugins matters, arg order does not.
{-# OPTIONS -fplugin-opt Echo2:B #-}

{-# OPTIONS -fplugin Echo1 #-}
{-# OPTIONS -fplugin-opt Echo1:A #-}

{-# OPTIONS -fplugin Echo2 #-}
</pre> <p>If you want to use the same plugin with different arguments then rexport the same plugin from different lightweight modules.</p> <pre data-language="haskell">-- Echo1 and Echo2 as lightweight modules re-exporting Echo.plugin.
module Echo1 (plugin) where import Echo (plugin)
module Echo2 (plugin) where import Echo (plugin)

-- Echo1 gets arg A while Echo2 gets arg B.
{-# OPTIONS -fplugin Echo1 -fplugin-opt Echo1:A #-}
{-# OPTIONS -fplugin Echo2 -fplugin-opt Echo2:B #-}
</pre> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fplugin-trustworthy">
<code>-fplugin-trustworthy</code> </dt> <dd>
<p>By default, when a module is compiled with plugins, it will be marked as unsafe. With this flag passed, all plugins are treated as trustworthy and the safety inference will no longer be affected.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fclear-plugins">
<code>-fclear-plugins</code> </dt> <dd>
<p>Clear the list of plugins previously specified with <a class="reference internal" href="#ghc-flag-fplugin-module"><code>-fplugin</code></a>. This is useful in GHCi where simply removing the <a class="reference internal" href="#ghc-flag-fplugin-module"><code>-fplugin</code></a> options from the command line is not possible. Instead <code>:set -fclear-plugins</code> can be used.</p> </dd>
</dl> <p>As an example, in order to load the plugin exported by <code>Foo.Plugin</code> in the package <code>foo-ghc-plugin</code>, and give it the parameter “baz”, we would invoke GHC like this:</p> <pre data-language="none">$ ghc -fplugin Foo.Plugin -fplugin-opt Foo.Plugin:baz Test.hs
[1 of 1] Compiling Main             ( Test.hs, Test.o )
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Loading package foo-ghc-plugin-0.1 ... linking ... done.
...
Linking Test ...
$
</pre> <p>Plugins can be also be loaded from libraries directly. It allows plugins to be loaded in cross-compilers (as a workaround for <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14335">#14335</a>).</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-fplugin-library-file-path-unit-id-module-args">
<code>-fplugin-library=⟨file-path⟩;⟨unit-id⟩;⟨module⟩;⟨args⟩</code> </dt> <dd>
<p>Arguments are specified in a list form, so a plugin specified to <a class="reference internal" href="#ghc-flag-fplugin-library-file-path-unit-id-module-args"><code>-fplugin-library=⟨file-path⟩;⟨unit-id⟩;⟨module⟩;⟨args⟩</code></a> will look like <code>'path/to/plugin;package-123;Plugin.Module;["Argument","List"]'</code>.</p> </dd>
</dl> <p>Alternatively, core plugins can be specified with Template Haskell.</p> <pre data-language="haskell">addCorePlugin "Foo.Plugin"
</pre> <p>This inserts the plugin as a core-to-core pass. Unlike <code>-fplugin=(module)</code>, the plugin module can’t reside in the same package as the module calling <a class="reference external" href="../libraries/template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#v:addCorePlugin">Language.Haskell.TH.Syntax.addCorePlugin</a>. This way, the implementation can expect the plugin to be built by the time it is needed.</p> <p>Plugin modules live in a separate namespace from the user import namespace. By default, these two namespaces are the same; however, there are a few command line options which control specifically plugin packages:</p> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-plugin-package-pkg">
<code>-plugin-package ⟨pkg⟩</code> </dt> <dd>
<p>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as <a class="reference internal" href="#ghc-flag-fplugin-module"><code>-fplugin=⟨module⟩</code></a>. The package ⟨pkg⟩ can be specified in full with its version number (e.g. <code>network-1.0</code>) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and <a class="reference internal" href="#ghc-flag-hide-all-plugin-packages"><code>-hide-all-plugin-packages</code></a> was not specified, then all other versions will become hidden. <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code>-plugin-package ⟨pkg⟩</code></a> supports thinning and renaming described in <a class="reference internal" href="packages.html#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p> <p>Unlike <a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code>-package ⟨pkg⟩</code></a>, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-plugin-package-id-pkg-id">
<code>-plugin-package-id ⟨pkg-id⟩</code> </dt> <dd>
<p>Exposes a package in the plugin namespace like <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code>-plugin-package
⟨pkg⟩</code></a>, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes <a class="reference internal" href="#ghc-flag-plugin-package-id-pkg-id"><code>-plugin-package-id ⟨pkg-id⟩</code></a> flags to GHC. <a class="reference internal" href="#ghc-flag-plugin-package-id-pkg-id"><code>-plugin-package-id ⟨pkg-id⟩</code></a> supports thinning and renaming described in <a class="reference internal" href="packages.html#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p> </dd>
</dl> <dl class="std ghc-flag"> <dt class="sig sig-object std" id="ghc-flag-hide-all-plugin-packages">
<code>-hide-all-plugin-packages</code> </dt> <dd>
<p>By default, all exposed packages in the normal, source import namespace are also available for plugins. This causes those packages to be hidden by default. If you use this flag, then any packages with plugins you require need to be explicitly exposed using <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code>-plugin-package ⟨pkg⟩</code></a> options.</p> </dd>
</dl> <p>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in <code>build-depends</code> (which uses the conventional <a class="reference internal" href="packages.html#ghc-flag-package-id-unit-id"><code>-package-id ⟨unit-id⟩</code></a> flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</p> </section> <section id="writing-compiler-plugins"> <h3 id="id3">
<span class="section-number">7.3.2. </span>Writing compiler plugins</h3> <p>Plugins are modules that export at least a single identifier, <code>plugin</code>, of type <code>GHC.Plugins.Plugin</code>. All plugins should <code>import GHC.Plugins</code> as it defines the interface to the compilation pipeline.</p> <p>A <code>Plugin</code> effectively holds a function which installs a compilation pass into the compiler pipeline. By default there is the empty plugin which does nothing, <code>GHC.Plugins.defaultPlugin</code>, which you should override with record syntax to specify your installation function. Since the exact fields of the <code>Plugin</code> type are open to change, this is the best way to ensure your plugins will continue to work in the future with minimal interface impact.</p> <p><code>Plugin</code> exports a field, <code>installCoreToDos</code> which is a function of type <code>[CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]</code>. A <code>CommandLineOption</code> is effectively just <code>String</code>, and a <code>CoreToDo</code> is basically a function of type <code>Core -&gt; Core</code>. A <code>CoreToDo</code> gives your pass a name and runs it over every compiled module when you invoke GHC.</p> <p>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says ‘Hello’:</p> <pre data-language="haskell">module DoNothing.Plugin (plugin) where
import GHC.Plugins

plugin :: Plugin
plugin = defaultPlugin {
  installCoreToDos = install
  }

install :: [CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]
install _ todo = do
  putMsgS "Hello!"
  return todo
</pre> <p>Provided you compiled this plugin and registered it in a package (with cabal for instance,) you can then use it by just specifying <code>-fplugin=DoNothing.Plugin</code> on the command line, and during the compilation you should see GHC say ‘Hello’.</p> <p>Running multiple plugins is also supported, by passing multiple <code>-fplugin=...</code> options. GHC will load the plugins in the order in which they are specified on the command line and, when appropriate, compose their effects in the same order. That is, if we had two Core plugins, <code>Plugin1</code> and <code>Plugin2</code>, each defining an <code>install</code> function like the one above, then GHC would first run <code>Plugin1.install</code> on the default <code>[CoreToDo]</code>, take the result and feed it to <code>Plugin2.install</code>. <code>-fplugin=Plugin1 -fplugin=Plugin2</code> will update the Core pipeline by applying <code>Plugin1.install opts1 &gt;=&gt; Plugin2.install opts2</code> (where <code>opts1</code> and <code>opts2</code> are the options passed to each plugin using <code>-fplugin-opt=...</code>). This is not specific to Core plugins but holds for all the types of plugins that can be composed or sequenced in some way: the first plugin to appear on the GHC command line will always act first.</p> </section> <section id="core-plugins-in-more-detail"> <h3 id="id4">
<span class="section-number">7.3.3. </span>Core plugins in more detail</h3> <p><code>CoreToDo</code> is effectively a data type that describes all the kinds of optimization passes GHC does on Core. There are passes for simplification, CSE, etc. There is a specific case for plugins, <code>CoreDoPluginPass :: String -&gt; PluginPass -&gt; CoreToDo</code> which should be what you always use when inserting your own pass into the pipeline. The first parameter is the name of the plugin, and the second is the pass you wish to insert.</p> <p><code>CoreM</code> is a monad that all of the Core optimizations live and operate inside of.</p> <p>A plugin’s installation function (<code>install</code> in the above example) takes a list of <code>CoreToDo</code>s and returns a list of <code>CoreToDo</code>. Before GHC begins compiling modules, it enumerates all the needed plugins you tell it to load, and runs all of their installation functions, initially on a list of passes that GHC specifies itself. After doing this for every plugin, the final list of passes is given to the optimizer, and are run by simply going over the list in order.</p> <p>You should be careful with your installation function, because the list of passes you give back isn’t questioned or double checked by GHC at the time of this writing. An installation function like the following:</p> <pre data-language="haskell">install :: [CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]
install _ _ = return []
</pre> <p>is certainly valid, but also certainly not what anyone really wants.</p> <section id="manipulating-bindings"> <h4 id="id5">
<span class="section-number">7.3.3.1. </span>Manipulating bindings</h4> <p>In the last section we saw that besides a name, a <code>CoreDoPluginPass</code> takes a pass of type <code>PluginPass</code>. A <code>PluginPass</code> is a synonym for <code>(ModGuts -&gt; CoreM ModGuts)</code>. <code>ModGuts</code> is a type that represents the one module being compiled by GHC at any given time.</p> <p>A <code>ModGuts</code> holds all of the module’s top level bindings which we can examine. These bindings are of type <code>CoreBind</code> and effectively represent the binding of a name to body of code. Top-level module bindings are part of a <code>ModGuts</code> in the field <code>mg_binds</code>. Implementing a pass that manipulates the top level bindings merely needs to iterate over this field, and return a new <code>ModGuts</code> with an updated <code>mg_binds</code> field. Because this is such a common case, there is a function provided named <code>bindsOnlyPass</code> which lifts a function of type <code>([CoreBind] -&gt; CoreM [CoreBind])</code> to type <code>(ModGuts -&gt; CoreM ModGuts)</code>.</p> <p>Continuing with our example from the last section, we can write a simple plugin that just prints out the name of all the non-recursive bindings in a module it compiles:</p> <pre data-language="haskell">module SayNames.Plugin (plugin) where
import GHC.Plugins

plugin :: Plugin
plugin = defaultPlugin {
  installCoreToDos = install
  }

install :: [CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]
install _ todo = do
  return (CoreDoPluginPass "Say name" pass : todo)

pass :: ModGuts -&gt; CoreM ModGuts
pass guts = do dflags &lt;- getDynFlags
               bindsOnlyPass (mapM (printBind dflags)) guts
  where printBind :: DynFlags -&gt; CoreBind -&gt; CoreM CoreBind
        printBind dflags bndr@(NonRec b _) = do
          putMsgS $ "Non-recursive binding named " ++ showSDoc dflags (ppr b)
          return bndr
        printBind _ bndr = return bndr
</pre> </section> <section id="late-plugins"> <h4 id="id6">
<span class="section-number">7.3.3.2. </span>Late Plugins</h4> <p>If the <code>CoreProgram</code> of a module is modified in a normal core plugin, the modified bindings can end up in unfoldings the interface file for the module. This may be undesireable, as the plugin could make changes which affect inlining or optimization.</p> <p>Late plugins can be used to avoid introducing such changes into the interface file. Late plugins are a bit different from typical core plugins:</p> <ol class="arabic simple"> <li>They do not run in the <code>CoreM</code> monad. Instead, they are explicitly passed the <code>HscEnv</code> and they run in <code>IO</code>.</li> <li>They are given <code>CgGuts</code> instead of <code>ModGuts</code>. <code>CgGuts</code> are a restricted form of <code>ModGuts</code> intended for code generation. The <code>CoreProgram</code> held in the <code>CgGuts</code> given to a late plugin will already be fully optimized.</li> <li>They must maintain a <code>CostCentreState</code> and track any cost centres they introduce by adding them to the <code>cg_ccs</code> field of <code>CgGuts</code>. This is because the automatic collection of cost centres happens before the late plugin stage. If a late plugin does not introduce any cost centres, it may simply return the given cost centre state.</li> </ol> <p>Here is a very simply example of a late plugin that changes the value of a binding in a module. If it finds a non-recursive top-level binding named <code>testBinding</code> with type <code>Int</code>, it will change its value to the <code>Int</code> expression <code>111111</code>.</p> <pre data-language="haskell">plugin :: Plugin
plugin = defaultPlugin { latePlugin = lateP }

lateP :: LatePlugin
lateP _ _ (cg_guts, cc_state) = do
    binds' &lt;- editCoreBinding (cg_binds cg_guts)
    return (cg_guts { cg_binds = binds' }, cc_state)

editCoreBinding :: CoreProgram -&gt; IO CoreProgram
editCoreBinding pgm = pure . go
  where
    go :: [CoreBind] -&gt; [CoreBind]
    go (b@(NonRec v e) : bs)
      | occNameString (getOccName v) == "testBinding" &amp;&amp; exprType e `eqType` intTy =
          NonRec v (mkUncheckedIntExpr 111111) : bs
    go (b:bs) = b : go bs
    go [] = []
</pre> <p>Since this is a late plugin, the changed binding value will not end up in the interface file.</p> </section> <section id="using-annotations"> <h4 id="getting-annotations">
<span class="section-number">7.3.3.3. </span>Using Annotations</h4> <p>Previously we discussed annotation pragmas (<a class="reference internal" href="#annotation-pragmas"><span class="std std-ref">Source annotations</span></a>), which we mentioned could be used to give compiler plugins extra guidance or information. Annotations for a module can be retrieved by a plugin, but you must go through the modules <code>ModGuts</code> in order to get it. Because annotations can be arbitrary instances of <code>Data</code> and <code>Typeable</code>, you need to give a type annotation specifying the proper type of data to retrieve from the interface file, and you need to make sure the annotation type used by your users is the same one your plugin uses. For this reason, we advise distributing annotations as part of the package which also provides compiler plugins if possible.</p> <p>To get the annotations of a single binder, you can use <code>getAnnotations</code> and specify the proper type. Here’s an example that will print out the name of any top-level non-recursive binding with the <code>SomeAnn</code> annotation:</p> <pre data-language="haskell">{-# LANGUAGE DeriveDataTypeable #-}
module SayAnnNames.Plugin (plugin, SomeAnn(..)) where
import GHC.Plugins
import Control.Monad (unless)
import Data.Data

data SomeAnn = SomeAnn deriving Data

plugin :: Plugin
plugin = defaultPlugin {
  installCoreToDos = install
  }

install :: [CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]
install _ todo = do
  return (CoreDoPluginPass "Say name" pass : todo)

pass :: ModGuts -&gt; CoreM ModGuts
pass g = do
          dflags &lt;- getDynFlags
          mapM_ (printAnn dflags g) (mg_binds g) &gt;&gt; return g
  where printAnn :: DynFlags -&gt; ModGuts -&gt; CoreBind -&gt; CoreM CoreBind
        printAnn dflags guts bndr@(NonRec b _) = do
          anns &lt;- annotationsOn guts b :: CoreM [SomeAnn]
          unless (null anns) $ putMsgS $ "Annotated binding found: " ++  showSDoc dflags (ppr b)
          return bndr
        printAnn _ _ bndr = return bndr

annotationsOn :: Data a =&gt; ModGuts -&gt; CoreBndr -&gt; CoreM [a]
annotationsOn guts bndr = do
  (_, anns) &lt;- getAnnotations deserializeWithData guts
  return $ lookupWithDefaultUFM_Directly anns [] (varUnique bndr)
</pre> <p>Please see the GHC API documentation for more about how to use internal APIs, etc.</p> </section> </section> <section id="typechecker-plugins"> <h3 id="id7">
<span class="section-number">7.3.4. </span>Typechecker plugins</h3> <p>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see <a class="reference internal" href="exts/type_literals.html#typelit-tyfuns"><span class="std std-ref">Computing With Type-Level Naturals</span></a>).</p> <p>The <code>Plugin</code> type has a field <code>tcPlugin</code> of type <code>[CommandLineOption] -&gt; Maybe TcPlugin</code>, where the <code>TcPlugin</code> type is defined thus:</p> <pre data-language="haskell">  data TcPlugin = forall s . TcPlugin
    { tcPluginInit    :: TcPluginM s
    , tcPluginSolve   :: s -&gt; TcPluginSolver
    , tcPluginRewrite :: s -&gt; UniqFM TyCon TcPluginRewriter
    , tcPluginStop    :: s -&gt; TcPluginM ()
    }

  type TcPluginSolver = EvBindsVar -&gt; [Ct] -&gt; [Ct] -&gt; TcPluginM TcPluginSolveResult

  type TcPluginRewriter = RewriteEnv -&gt; [Ct] -&gt; [Type] -&gt; TcPluginM TcPluginRewriteResult

data TcPluginSolveResult
  = TcPluginSolveResult
      { tcPluginInsolubleCts :: [Ct]
      , tcPluginSolvedCts    :: [(EvTerm, Ct)]
      , tcPluginNewCts       :: [Ct]
      }

  data TcPluginRewriteResult
    = TcPluginNoRewrite
    | TcPluginRewriteTo
        { tcPluginRewriteTo    :: Reduction
        , tcRewriterNewWanteds :: [Ct]
        }
</pre> <p>(The details of this representation are subject to change as we gain more experience writing typechecker plugins. It should not be assumed to be stable between GHC releases.)</p> <p>The basic idea is as follows:</p> <ul class="simple"> <li>When type checking a module, GHC calls <code>tcPluginInit</code> once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other fields of the <code>TcPlugin</code> record.</li> <li>During constraint solving, GHC repeatedly calls <code>tcPluginSolve</code>. This function is provided with the current set of constraints, and should return a <code>TcPluginSolveResult</code> that indicates whether a contradiction was found or progress was made. If the plugin solver makes progress, GHC will re-start the constraint solving pipeline, looping until a fixed point is reached.</li> <li>When rewriting type family applications, GHC calls <code>tcPluginRewriter</code>. The plugin supplies a collection of type families which it is interested in rewriting. For each of those, the rewriter is provided with the the arguments to that type family, as well as the current collection of Given constraints. The plugin can then specify a rewriting for this type family application, if desired.</li> <li>Finally, GHC calls <code>tcPluginStop</code> after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</li> </ul> <p>Plugin code runs in the <code>TcPluginM</code> monad, which provides a restricted interface to GHC API functionality that is relevant for typechecker plugins, including <code>IO</code> and reading the environment. If you need functionality that is not exposed in the <code>TcPluginM</code> module, you can use <code>unsafeTcPluginTcM :: TcM a -&gt; TcPluginM a</code>, but are encouraged to contact the GHC team to suggest additions to the interface. Note that <code>TcPluginM</code> can perform arbitrary IO via <code>tcPluginIO :: IO a -&gt; TcPluginM a</code>, although some care must be taken with side effects (particularly in <code>tcPluginSolve</code>). In general, it is up to the plugin author to make sure that any IO they do is safe.</p> <section id="constraint-solving-with-plugins"> <h4 id="id8">
<span class="section-number">7.3.4.1. </span>Constraint solving with plugins</h4> <p>The key component of a typechecker plugin is a function of type <code>TcPluginSolver</code>, like this:</p> <pre data-language="haskell">solve :: EvBindsVar -&gt; [Ct] -&gt; [Ct] -&gt; TcPluginM TcPluginSolveResult
solve binds givens wanteds = ...
</pre> <p>This function will be invoked in two different ways:</p> <ol class="arabic simple"> <li>after simplification of Given constraints, where the plugin gets the opportunity to rewrite givens,</li> <li>after GHC has attempted to solve Wanted constraints.</li> </ol> <p>The two ways can be distinguished by checking the Wanted constraints: in the first case (and the first case only), the plugin will be passed an empty list of Wanted constraints.</p> <p>The plugin can then respond with:</p> <ul class="simple"> <li>solved constraints, which will be removed from the inert set,</li> <li>new constraints, which will be added to the work list,</li> <li>insoluble constraints, which will be reported as errors.</li> </ul> <p>The plugin must respond with constraints of the same flavour, i.e. in (1) it should return only Givens, and for (2) it should return only Wanteds; all other constraints will be ignored.</p> <p>If the plugin cannot make any progress, it should return <code>TcPluginSolveResult [] [] []</code>. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</p> <p>Plugins are provided with all available constraints (including equalities and typeclass constraints), but it is easy for them to discard those that are not relevant to their domain, because they need return only those constraints for which they have made progress (either by solving or contradicting them).</p> <p>Constraints that have been solved by the plugin must be provided with evidence in the form of an <code>EvTerm</code> of the type of the constraint. This evidence is ignored for Given constraints, which GHC “solves” simply by discarding them; typically this is used when they are uninformative (e.g. reflexive equations). For Wanted constraints, the evidence will form part of the Core term that is generated after typechecking, and can be checked by <code>-dcore-lint</code>.</p> <p>When solving a Wanted equality constraint (of type <code>t1 ~N# t2</code> or <code>t1 ~R# t2</code> for nominal and representation equalities respectively), the evidence (of type <code>EvTerm</code>) will take the form <code>EvExpr (Coercion co)</code>, where the coercion <code>co</code> has type <code>co :: t1 ~N# t2</code> or <code>co :: t1 ~R# t2</code> respectively.</p> <p>It is up to the plugin to construct a suitable coercion <code>co</code>. However, one possibility is to construct one of form</p> <pre data-language="haskell">UnivCo (PluginProv "my-plugin" gcvs) role t1 t2
</pre> <p>A <code>UnivCo</code> of this form says “trust me: my-plugin has solved this Wanted using (only) <code>gcvs</code>”.</p> <p>Here</p> <ul class="simple"> <li>The <code>role</code> should be the role of the original equality constraint (nominal or representational).</li> <li>The <code>gcvs</code> is a set of “given coercion variables”; these are the coercion variable bound by enclosing Given constraints, which the plugin has used to justify solving the Wanted.</li> </ul> <p>For soundness, it is very important to include the <code>gcvs</code>; otherwise GHC may transform the program into a form that seg-faults. See #23923 for a long dicussion.</p> <p>Evidence is required also when creating new Given constraints, which are usually implied by old ones. It is not uncommon that the evidence of a new Given constraint contains a removed constraint: the new one has replaced the removed one.</p> </section> <section id="type-family-rewriting-with-plugins"> <h4 id="id9">
<span class="section-number">7.3.4.2. </span>Type family rewriting with plugins</h4> <p>Typechecker plugins can also directly rewrite type family applications, by supplying the <code>tcPluginRewrite</code> field of the <code>TcPlugin</code> record.</p> <pre data-language="haskell">tcPluginRewrite :: s -&gt; UniqFM TyCon TcPluginRewriter
</pre> <p>That is, the plugin registers a map, from a type family’s <code>TyCon</code> to its associated rewriting function:</p> <pre data-language="haskell">type TcPluginRewriter = [Ct] -&gt; [Type] -&gt; TcPluginM TcPluginRewriteResult
</pre> <p>This rewriting function is supplied with the Given constraints from the current context, and the type family arguments. Note that the type family application is guaranteed to be exactly saturated. This function should then return a possible rewriting of the type family application, by means of the following datatype:</p> <pre data-language="haskell">data TcPluginRewriteResult
  = TcPluginNoRewrite
  | TcPluginRewriteTo
      { tcPluginRewriteTo    :: Reduction
      , tcRewriterNewWanteds :: [Ct]
      }
</pre> <p>That is, the rewriter can specify a rewriting of the type family application – in which case it can also emit new Wanted constraints – or it can do nothing.</p> <p>To specify a rewriting, the plugin must provide a <code>Reduction</code>, which is defined as follows:</p> <pre data-language="haskell">data Reduction = Reduction Coercion !Type
</pre> <p>That is, on top of specifying what type the type-family application rewrites to, the plugin must also supply a coercion which witnesses this rewriting:</p> <pre data-language="haskell">co :: F orig_arg_1 ... orig_arg_n ~ rewritten_ty
</pre> <p>Note in particular that the LHS type of the coercion should be the original type-family application, while its RHS type is the type that the plugin wants to rewrite the type-family application to.</p> </section> </section> <section id="source-plugins"> <h3 id="id10">
<span class="section-number">7.3.5. </span>Source plugins</h3> <p>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</p> <p>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of <code>CommandLineOption</code> strings that are passed to the compiler using the <a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code>-fplugin-opt=⟨module⟩:⟨args⟩</code></a> flags.</p> <pre data-language="haskell">plugin :: Plugin
plugin = defaultPlugin {
    parsedResultAction = parsed
  , typeCheckResultAction = typechecked
  , spliceRunAction = spliceRun
  , interfaceLoadAction = interfaceLoad
  , renamedResultAction = renamed
  }
</pre> <section id="parsed-representation"> <h4>
<span class="section-number">7.3.5.1. </span>Parsed representation</h4> <p>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the <code>parsedResultAction</code> field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</p> <pre data-language="haskell">parsed :: [CommandLineOption] -&gt; ModSummary
            -&gt; ParsedResult -&gt; Hsc ParsedResult
</pre> <p>The <code>ModSummary</code> contains useful meta-information about the compiled module. The <code>ParsedResult</code> contains a <code>HsParsedModule</code>, which contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don’t want to change the result, just return the <code>ParsedResult</code> that you received as the argument.</p> <p>If the parser encounters any errors that prevent an AST from being constructed, the plugin will not be run, but other kinds of errors, as well as warnings, will be given to the plugin via the <code>PsMessages</code> value of the <code>ParsedResult</code>. This allows you to modify, remove, and add warnings or errors before they are displayed to the user, although in most cases, you will likely want to return the messages unmodified. The parsing pass will fail if the <code>Messages PsError</code> collection inside the return <code>ParsedResult</code> is not empty after all parsing plugins have been run.</p> </section> <section id="type-checked-representation"> <h4>
<span class="section-number">7.3.5.2. </span>Type checked representation</h4> <p>When you want to define a plugin that needs semantic information about the source code, use the <code>typeCheckResultAction</code> field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with <code>typeCheckResultAction</code> or <code>renamedResultAction</code>.</p> <pre data-language="haskell">typechecked :: [CommandLineOption] -&gt; ModSummary -&gt; TcGblEnv -&gt; TcM TcGblEnv
renamed :: [CommandLineOption] -&gt; TcGblEnv -&gt; HsGroup GhcRn -&gt; TcM (TcGblEnv, HsGroup GhcRn)
</pre> <p>By overriding the <code>renamedResultAction</code> field we can modify each <code>HsGroup</code> after it has been renamed. A source file is separated into groups depending on the location of template haskell splices so the contents of these groups may not be intuitive. In order to save the entire renamed AST for inspection at the end of typechecking you can set <code>renamedResultAction</code> to <code>keepRenamedSource</code> which is provided by the <code>Plugins</code> module. This is important because some parts of the renamed syntax tree (for example, imports) are not found in the typechecked one.</p> </section> <section id="evaluated-code"> <h4>
<span class="section-number">7.3.5.3. </span>Evaluated code</h4> <p>When the compiler type checks the source code, <a class="reference internal" href="exts/template_haskell.html#template-haskell"><span class="std std-ref">Template Haskell</span></a> Splices and <a class="reference internal" href="exts/template_haskell.html#th-quasiquotation"><span class="std std-ref">Template Haskell Quasi-quotation</span></a> will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included <code>spliceRunAction</code>. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</p> <pre data-language="haskell">spliceRun :: [CommandLineOption] -&gt; LHsExpr GhcTc -&gt; TcM (LHsExpr GhcTc)
</pre> <p>However take care that the generated definitions are still in the input of <code>typeCheckResultAction</code>. If your don’t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</p> </section> <section id="interface-files"> <h4>
<span class="section-number">7.3.5.4. </span>Interface files</h4> <p>Sometimes when you are writing a tool, knowing the source code is not enough, you also have to know details about the modules that you import. In this case we suggest using the <code>interfaceLoadAction</code>. This will be called each time when the code of an already compiled module is loaded. It will be invoked for modules from installed packages and even modules that are installed with GHC. It will NOT be invoked with your own modules.</p> <pre data-language="haskell">interfaceLoad :: forall lcl . [CommandLineOption] -&gt; ModIface
                                -&gt; IfM lcl ModIface
</pre> <p>In the <code>ModIface</code> datatype you can find lots of useful information, including the exported definitions and type class instances.</p> <p>The <code>ModIface</code> datatype also contains facilities for extending it with extra data, stored in a <code>Map</code> of serialised fields, indexed by field names and using GHC’s internal <code>Binary</code> class. The interface to work with these fields is:</p> <pre data-language="haskell">readIfaceField :: Binary a =&gt; FieldName -&gt; ModIface -&gt; IO (Maybe a)
writeIfaceField :: Binary a =&gt; FieldName -&gt; a -&gt; ModIface -&gt; IO ModIface
deleteIfaceField :: FieldName -&gt; ModIface -&gt; ModIface
</pre> <p>The <code>FieldName</code> is open-ended, but typically it should contain the producing package name, along with the actual field name. Then, the version number can either be attached to the serialised data for that field, or in cases where multiple versions of a field could exist in the same interface file, included in the field name.</p> <p>Depending on if the field version advances with the package version, or independently, the version can be attached to either the package name or the field name. Examples of each case:</p> <pre data-language="haskell">package/field
ghc-n.n.n/core
package/field-n
</pre> <p>To read an interface file from an external tool without linking to GHC, the format is described at <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/Extensible-Interface-Files">Extensible Interface Files</a>.</p> </section> <section id="source-plugin-example"> <h4>
<span class="section-number">7.3.5.5. </span>Source plugin example</h4> <p>In this example, we inspect all available details of the compiled source code. We don’t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</p> <pre data-language="haskell">module SourcePlugin where

import Control.Monad.IO.Class
import GHC.Driver.Session (getDynFlags)
import GHC.Driver.Plugins
import GHC.Plugins
import GHC.Tc.Types
import Language.Haskell.Syntax.Extension
import GHC.Hs.Decls
import GHC.Hs.Expr
import GHC.Hs.ImpExp
import GHC.Types.Avail
import GHC.Utils.Outputable
import GHC.Hs.Doc
import GHC

plugin :: Plugin
plugin = defaultPlugin
  { parsedResultAction = parsedPlugin
  , renamedResultAction = renamedAction
  , typeCheckResultAction = typecheckPlugin
  , spliceRunAction = metaPlugin
  , interfaceLoadAction = interfaceLoadPlugin
  }

parsedPlugin :: [CommandLineOption] -&gt; ModSummary
             -&gt; ParsedResult -&gt; Hsc ParsedResult
parsedPlugin _ _ parsed@(ParsedResult pm msgs)
     = do dflags &lt;- getDynFlags
          liftIO $ putStrLn $ "parsePlugin: \n" ++ (showSDoc dflags $ ppr $ hpm_module pm)
          liftIO $ putStrLn $ "parsePlugin warnings: \n" ++ (showSDoc dflags $ ppr $ psWarnings msgs)
          liftIO $ putStrLn $ "parsePlugin errors: \n" ++ (showSDoc dflags $ ppr $ psErrors msgs)
          return parsed

renamedAction :: [CommandLineOption] -&gt; TcGblEnv -&gt; HsGroup GhcRn -&gt; TcM (TcGblEnv, HsGroup GhcRn)
renamedAction _ tc gr = do
  dflags &lt;- getDynFlags
  liftIO $ putStrLn $ "typeCheckPlugin (rn): " ++ (showSDoc dflags $ ppr gr)
  return (tc, gr)

typecheckPlugin :: [CommandLineOption] -&gt; ModSummary -&gt; TcGblEnv -&gt; TcM TcGblEnv
typecheckPlugin _ _ tc
  = do dflags &lt;- getDynFlags
       liftIO $ putStrLn $ "typeCheckPlugin (rn): \n" ++ (showSDoc dflags $ ppr $ tcg_rn_decls tc)
       liftIO $ putStrLn $ "typeCheckPlugin (tc): \n" ++ (showSDoc dflags $ ppr $ tcg_binds tc)
       return tc

metaPlugin :: [CommandLineOption] -&gt; LHsExpr GhcTc -&gt; TcM (LHsExpr GhcTc)
metaPlugin _ meta
  = do dflags &lt;- getDynFlags
       liftIO $ putStrLn $ "meta: " ++ (showSDoc dflags $ ppr meta)
       return meta

interfaceLoadPlugin :: [CommandLineOption] -&gt; ModIface -&gt; IfM lcl ModIface
interfaceLoadPlugin _ iface
  = do dflags &lt;- getDynFlags
       liftIO $ putStrLn $ "interface loaded: " ++ (showSDoc dflags $ ppr $ mi_module iface)
       return iface
</pre> <p>When you compile a simple module that contains Template Haskell splice</p> <pre data-language="haskell">{-# OPTIONS_GHC -fplugin SourcePlugin #-}
{-# LANGUAGE TemplateHaskell #-}
module A where

a = ()

$(return [])
</pre> <p>with the compiler flags <code>-fplugin SourcePlugin</code> it will give the following output:</p> <pre data-language="none">parsePlugin:
module A where
a = ()
$(return [])
parsePlugin warnings:

parsePlugin errors:

typeCheckPlugin (rn): a = ()
interface loaded: Language.Haskell.TH.Lib.Internal
meta: return []
typeCheckPlugin (rn):
typeCheckPlugin (rn):
Nothing
typeCheckPlugin (tc):
{$trModule = Module (TrNameS "main"#) (TrNameS "A"#), a = ()}
</pre> </section> </section> <section id="hole-fit-plugins"> <h3 id="id11">
<span class="section-number">7.3.6. </span>Hole fit plugins</h3> <p>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</p> <p>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</p> <p>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</p> <pre data-language="haskell">type CandPlugin = TypedHole -&gt; [HoleFitCandidate] -&gt; TcM [HoleFitCandidate]

type FitPlugin =  TypedHole -&gt; [HoleFit] -&gt; TcM [HoleFit]

data HoleFitPlugin = HoleFitPlugin
  { candPlugin :: CandPlugin
     -- ^ A plugin for modifying hole fit candidates before they're checked
  , fitPlugin :: FitPlugin
     -- ^ A plugin for modifying valid hole fits after they've been found.
  }
</pre> <p>Where <code>TypedHole</code> contains all the information about the hole available to GHC at error generation.</p> <pre data-language="haskell">data TypedHole = TyH { tyHRelevantCts :: Cts
                      -- ^ Any relevant Cts to the hole
                    , tyHImplics :: [Implication]
                      -- ^ The nested implications of the hole with the
                      --   innermost implication first.
                    , tyHCt :: Maybe Ct
                      -- ^ The hole constraint itself, if available.
                    }
</pre> <p><code>HoleFitPlugins</code> are then defined as follows</p> <pre data-language="haskell">plugin :: Plugin
plugin = defaultPlugin {
    holeFitPlugin = (fmap . fmap) fromPureHFPlugin hfPlugin
  }


hfPlugin :: [CommandLineOption] -&gt; Maybe HoleFitPlugin
</pre> <p>Where <code>fromPureHFPlugin :: HoleFitPlugin -&gt; HoleFitPluginR</code> is a convenience function provided in the <code>GHC.Tc.Errors.Hole</code> module, for defining plugins that do not require internal state.</p> <section id="stateful-hole-fit-plugins"> <h4>
<span class="section-number">7.3.6.1. </span>Stateful hole fit plugins</h4> <p><code>HoleFitPlugins</code> are wrapped in a <code>HoleFitPluginR</code>, which provides a <code>TcRef</code> for the plugin to use to track internal state, and to facilitate communication between the candidate and fit plugin.</p> <pre data-language="haskell">-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
-- track internal state. Note the existential quantification, ensuring that
-- the state cannot be modified from outside the plugin.
data HoleFitPluginR = forall s. HoleFitPluginR
  { hfPluginInit :: TcM (TcRef s)
    -- ^ Initializes the TcRef to be passed to the plugin
  , hfPluginRun :: TcRef s -&gt; HoleFitPlugin
    -- ^ The function defining the plugin itself
  , hfPluginStop :: TcRef s -&gt; TcM ()
    -- ^ Cleanup of state, guaranteed to be called even on error
  }
</pre> <p>The plugin is then defined as by providing a value for the <code>holeFitPlugin</code> field, a function that takes the <code>CommandLineOption</code> strings that are passed to the compiler using the <a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code>-fplugin-opt=⟨module⟩:⟨args⟩</code></a> flags and returns a <code>HoleFitPluginR</code>. This function can be used to pass the <code>CommandLineOption</code> strings along to the candidate and fit plugins respectively.</p> </section> <section id="hole-fit-plugin-example"> <h4>
<span class="section-number">7.3.6.2. </span>Hole fit plugin example</h4> <p>The following plugins allows users to limit the search for valid hole fits to certain modules, to sort the hole fits by where they originated (in ascending or descending order), as well as allowing users to put a limit on how much time is spent on searching for valid hole fits, after which new searches are aborted.</p> <pre data-language="haskell">{-# LANGUAGE TypeApplications, RecordWildCards #-}
module HolePlugin where

import GHC.Plugins hiding ((&lt;&gt;))

import GHC.Tc.Errors.Hole

import Data.List (stripPrefix, sortOn)

import GHC.Tc.Types

import GHC.Tc.Utils.Monad

import Data.Time (UTCTime, NominalDiffTime)
import qualified Data.Time as Time

import Text.Read


data HolePluginState = HPS { timeAlloted :: Maybe NominalDiffTime
                          , elapsedTime :: NominalDiffTime
                          , timeCurStarted :: UTCTime }

bumpElapsed :: NominalDiffTime -&gt; HolePluginState -&gt; HolePluginState
bumpElapsed ad (HPS a e t) = HPS a (e + ad) t

setAlloted :: Maybe NominalDiffTime -&gt; HolePluginState -&gt; HolePluginState
setAlloted a (HPS _ e t) = HPS a e t

setCurStarted :: UTCTime -&gt; HolePluginState -&gt; HolePluginState
setCurStarted nt (HPS a e _) = HPS a e nt

hpStartState :: HolePluginState
hpStartState = HPS Nothing zero undefined
  where zero = fromInteger @NominalDiffTime 0

initPlugin :: [CommandLineOption] -&gt; TcM (TcRef HolePluginState)
initPlugin [msecs] = newTcRef $ hpStartState { timeAlloted = alloted }
  where
    errMsg = "Invalid amount of milliseconds given to plugin: " &lt;&gt; show msecs
    alloted = case readMaybe @Integer msecs of
      Just millisecs -&gt; Just $ fromInteger @NominalDiffTime millisecs / 1000
      _ -&gt; error errMsg
initPlugin _ = newTcRef hpStartState

fromModule :: HoleFitCandidate -&gt; [String]
fromModule (GreHFCand gre) =
  map (moduleNameString . importSpecModule) $ gre_imp gre
fromModule _ = []

toHoleFitCommand :: TypedHole -&gt; String -&gt; Maybe String
toHoleFitCommand TyH{tyHCt = Just (CHoleCan _ h)} str
    = stripPrefix ("_" &lt;&gt; str) $ occNameString $ holeOcc h
toHoleFitCommand _ _ = Nothing

-- | This candidate plugin filters the candidates by module,
-- using the name of the hole as module to search in
modFilterTimeoutP :: [CommandLineOption] -&gt; TcRef HolePluginState -&gt; CandPlugin
modFilterTimeoutP _ ref hole cands = do
  curTime &lt;- liftIO Time.getCurrentTime
  HPS {..} &lt;- readTcRef ref
  updTcRef ref (setCurStarted curTime)
  return $ case timeAlloted of
    -- If we're out of time we remove all the candidates. Then nothing is checked.
    Just sofar | elapsedTime &gt; sofar -&gt; []
    _ -&gt; case toHoleFitCommand hole "only_" of

          Just modName -&gt; filter (inScopeVia modName) cands
          _ -&gt; cands
  where inScopeVia modNameStr cand@(GreHFCand _) =
          elem (toModName modNameStr) $ fromModule cand
        inScopeVia _ _ = False
        toModName = replace '_' '.'
        replace :: Eq a =&gt; a -&gt; a -&gt; [a] -&gt; [a]
        replace _ _ [] = []
        replace a b (x:xs) = (if x == a then b else x):replace a b xs

modSortP :: [CommandLineOption] -&gt; TcRef HolePluginState -&gt; FitPlugin
modSortP _ ref hole hfs = do
  curTime &lt;- liftIO Time.getCurrentTime
  HPS {..} &lt;- readTcRef ref
  updTcRef ref $ bumpElapsed (Time.diffUTCTime curTime timeCurStarted)
  return $ case timeAlloted of
    -- If we're out of time, remove any candidates, so nothing is checked.
    Just sofar | elapsedTime &gt; sofar -&gt; [RawHoleFit $ text msg]
    _ -&gt; case toHoleFitCommand hole "sort_by_mod" of
            -- If only_ is on, the fits will all be from the same module.
            Just ('_':'d':'e':'s':'c':_) -&gt; reverse hfs
            Just _ -&gt; orderByModule hfs
            _ -&gt;  hfs
  where orderByModule :: [HoleFit] -&gt; [HoleFit]
        orderByModule = sortOn (fmap fromModule . mbHFCand)
        mbHFCand :: HoleFit -&gt; Maybe HoleFitCandidate
        mbHFCand HoleFit {hfCand = c} = Just c
        mbHFCand _ = Nothing
        msg = hang (text "Error: The time ran out, and the search was aborted for this hole.")
               7 $ text "Try again with a longer timeout."

plugin :: Plugin
plugin = defaultPlugin { holeFitPlugin = holeFitP, pluginRecompile = purePlugin}

holeFitP :: [CommandLineOption] -&gt; Maybe HoleFitPluginR
holeFitP opts = Just (HoleFitPluginR initP pluginDef stopP)
  where initP = initPlugin opts
        stopP = const $ return ()
        pluginDef ref = HoleFitPlugin { candPlugin = modFilterTimeoutP opts ref
                                      , fitPlugin  = modSortP opts ref }
</pre> <p>When you then compile a module containing the following</p> <pre data-language="haskell">{-# OPTIONS -fplugin=HolePlugin
            -fplugin-opt=HolePlugin:600
            -funclutter-valid-hole-fits #-}
module Main where

import Prelude hiding (head, last)

import Data.List (head, last)


f, g, h, i, j :: [Int] -&gt; Int
f = _too_long
j = _
i = _sort_by_mod_desc
g = _only_Data_List
h = _only_Prelude

main :: IO ()
main = return ()
</pre> <p>The output is as follows:</p> <pre data-language="none">Main.hs:12:5: error:
    • Found hole: _too_long :: [Int] -&gt; Int
      Or perhaps ‘_too_long’ is mis-spelled, or not in scope
    • In the expression: _too_long
      In an equation for ‘f’: f = _too_long
    • Relevant bindings include
        f :: [Int] -&gt; Int (bound at Main.hs:12:1)
      Valid hole fits include
        Error: The time ran out, and the search was aborted for this hole.
               Try again with a longer timeout.
  |
12 | f = _too_long
  |     ^^^^^^^^^

Main.hs:13:5: error:
    • Found hole: _ :: [Int] -&gt; Int
    • In the expression: _
      In an equation for ‘j’: j = _
    • Relevant bindings include
        j :: [Int] -&gt; Int (bound at Main.hs:13:1)
      Valid hole fits include
        j :: [Int] -&gt; Int
        f :: [Int] -&gt; Int
        g :: [Int] -&gt; Int
        h :: [Int] -&gt; Int
        i :: [Int] -&gt; Int
        head :: forall a. [a] -&gt; a
        (Some hole fits suppressed; use -fmax-valid-hole-fits=N or -fno-max-valid-hole-fits)
  |
13 | j = _
  |     ^

Main.hs:14:5: error:
    • Found hole: _sort_by_mod_desc :: [Int] -&gt; Int
      Or perhaps ‘_sort_by_mod_desc’ is mis-spelled, or not in scope
    • In the expression: _sort_by_mod_desc
      In an equation for ‘i’: i = _sort_by_mod_desc
    • Relevant bindings include
        i :: [Int] -&gt; Int (bound at Main.hs:14:1)
      Valid hole fits include
        sum :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        product :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        minimum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        maximum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        length :: forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
        last :: forall a. [a] -&gt; a
        (Some hole fits suppressed; use -fmax-valid-hole-fits=N or -fno-max-valid-hole-fits)
  |
14 | i = _sort_by_mod_desc
  |     ^^^^^^^^^^^^^^^^^

Main.hs:15:5: error:
    • Found hole: _only_Data_List :: [Int] -&gt; Int
      Or perhaps ‘_only_Data_List’ is mis-spelled, or not in scope
    • In the expression: _only_Data_List
      In an equation for ‘g’: g = _only_Data_List
    • Relevant bindings include
        g :: [Int] -&gt; Int (bound at Main.hs:15:1)
      Valid hole fits include
        head :: forall a. [a] -&gt; a
        last :: forall a. [a] -&gt; a
  |
15 | g = _only_Data_List
  |     ^^^^^^^^^^^^^^^

Main.hs:16:5: error:
    • Found hole: _only_Prelude :: [Int] -&gt; Int
      Or perhaps ‘_only_Prelude’ is mis-spelled, or not in scope
    • In the expression: _only_Prelude
      In an equation for ‘h’: h = _only_Prelude
    • Relevant bindings include
        h :: [Int] -&gt; Int (bound at Main.hs:16:1)
      Valid hole fits include
        length :: forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
        maximum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        minimum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        product :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        sum :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
  |
16 | h = _only_Prelude
  |     ^^^^^^^^^^^^^
</pre> </section> </section> <section id="defaulting-plugins"> <h3 id="id12">
<span class="section-number">7.3.7. </span>Defaulting plugins</h3> <p>Defaulting plugins are called when ambiguous variables might otherwise cause errors, in the same way as the built-in defaulting mechanism.</p> <p>A defaulting plugin can propose potential ways to fill ambiguous variables according to whatever criteria you would like. GHC will verify that those proposals will not lead to type errors in a context that you declare.</p> <p>Defaulting plugins have a single access point in the <code>GHC.Tc.Types</code> module</p> <pre data-language="haskell">-- | A collection of candidate default types for sets of type variables.
data DefaultingProposal
  = DefaultingProposal
    { deProposals :: [[(TcTyVar, Type)]]
      -- ^ The type variable assignments to try.
    , deProposalCts :: [Ct]
      -- ^ The constraints against which defaults are checked.
  }

type FillDefaulting = WantedConstraints -&gt; TcPluginM [DefaultingProposal]

-- | A plugin for controlling defaulting.
data DefaultingPlugin = forall s. DefaultingPlugin
  { dePluginInit :: TcPluginM s
    -- ^ Initialize plugin, when entering type-checker.
  , dePluginRun :: s -&gt; FillDefaulting
    -- ^ Default some types
  , dePluginStop :: s -&gt; TcPluginM ()
   -- ^ Clean up after the plugin, when exiting the type-checker.
  }
</pre> <p>The plugin has type <code>WantedConstraints -&gt; [DefaultingProposal]</code>.</p> <ul class="simple"> <li>It is given the currently unsolved constraints.</li> <li>It returns a list of independent “defaulting proposals”.</li> <li>
<p>Each proposal of type <code>DefaultingProposal</code> specifies:</p> <ul> <li>
<code>deProposals</code>: specifies a list, in priority order, of sets of type variable assignments</li> <li>
<code>deProposalCts :: [Ct]</code> gives a set of constraints (always a subset of the incoming <code>WantedConstraints</code>) to use as a criterion for acceptance</li> </ul> </li> </ul> <p>After calling the plugin, GHC executes each <code>DefaultingProposal</code> in turn. To “execute” a proposal, GHC tries each of the proposed type assignments in <code>deProposals</code> in turn:</p> <ul class="simple"> <li>It assigns the proposed types to the type variables, and then tries to solve <code>deProposalCts</code>
</li> <li>If those constraints are completely solved by the assignment, GHC accepts the assignment and moves on to the next <code>DefaultingProposal</code>
</li> <li>If not, GHC tries the next assignment in <code>deProposals</code>.</li> </ul> <p>The plugin can assume that the incoming constraints are fully “zonked” (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/zonking">the Wiki page on zonking</a>).</p> <p>The most robust <code>deProposalCts</code> to provide is the list of all wanted constraints that mention the variable you are defaulting. If you leave out a constraint, the default may be accepted, and then potentially result in a type checker error if it is incompatible with one of the constraints you left out. This can be a useful way of forcing a default and reporting errors to the user.</p> <p>There is an example of defaulting lifted types in the GHC test suite. In the <code>testsuite/tests/plugins/</code> directory see <code>defaulting-plugin/</code> for the implementation, <code>test-defaulting-plugin.hs</code> for an example of when defaulting happens, and <code>test-defaulting-plugin-fail.hs</code> for an example of when defaults don’t fit and aren’t applied.</p> </section> <section id="controlling-recompilation"> <h3 id="plugin-recompilation">
<span class="section-number">7.3.8. </span>Controlling Recompilation</h3> <p>By default, modules compiled with plugins are always recompiled even if the source file is unchanged. This most conservative option is taken due to the ability of plugins to perform arbitrary IO actions. In order to control the recompilation behaviour you can modify the <code>pluginRecompile</code> field in <code>Plugin</code>.</p> <pre data-language="haskell">plugin :: Plugin
plugin = defaultPlugin {
  installCoreToDos = install,
  pluginRecompile = purePlugin
  }
</pre> <p>By inspecting the example <code>plugin</code> defined above, we can see that it is pure. This means that if the two modules have the same fingerprint then the plugin will always return the same result. Declaring a plugin as pure means that the plugin will never cause a module to be recompiled.</p> <p>In general, the <code>pluginRecompile</code> field has the following type:</p> <pre data-language="haskell">pluginRecompile :: [CommandLineOption] -&gt; IO PluginRecompile
</pre> <p>The <code>PluginRecompile</code> data type is an enumeration determining how the plugin should affect recompilation.</p> <pre data-language="haskell">data PluginRecompile = ForceRecompile | NoForceRecompile | MaybeRecompile Fingerprint
</pre> <p>A plugin which declares itself impure using <code>ForceRecompile</code> will always trigger a recompilation of the current module. <code>NoForceRecompile</code> is used for “pure” plugins which don’t need to be rerun unless a module would ordinarily be recompiled. <code>MaybeRecompile</code> computes a <code>Fingerprint</code> and if this <code>Fingerprint</code> is different to a previously computed <code>Fingerprint</code> for the plugin, then we recompile the module.</p> <p>As such, <code>purePlugin</code> is defined as a function which always returns <code>NoForceRecompile</code>.</p> <pre data-language="haskell">purePlugin :: [CommandLineOption] -&gt; IO PluginRecompile
purePlugin _ = return NoForceRecompile
</pre> <p>Users can use the same functions that GHC uses internally to compute fingerprints. The <a class="reference external" href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html">GHC.Fingerprint</a> module provides useful functions for constructing fingerprints. For example, combining together <code>fingerprintFingerprints</code> and <code>fingerprintString</code> provides an easy to to naively fingerprint the arguments to a plugin.</p> <pre data-language="haskell">pluginFlagRecompile :: [CommandLineOption] -&gt; IO PluginRecompile
pluginFlagRecompile =
  return . MaybeRecompile . fingerprintFingerprints . map fingerprintString . sort
</pre> <p><code>defaultPlugin</code> defines <code>pluginRecompile</code> to be <code>impurePlugin</code> which is the most conservative and backwards compatible option.</p> <pre data-language="haskell">impurePlugin :: [CommandLineOption] -&gt; IO PluginRecompile
impurePlugin _ = return ForceRecompile
</pre> </section> <section id="frontend-plugins"> <h3 id="id13">
<span class="section-number">7.3.9. </span>Frontend plugins</h3> <p>A frontend plugin allows you to add new major modes to GHC. You may prefer this over a traditional program which calls the GHC API, as GHC manages a lot of parsing flags and administrative nonsense which can be difficult to manage manually. To load a frontend plugin exported by <code>Foo.FrontendPlugin</code>, we just invoke GHC with the <a class="reference internal" href="using.html#ghc-flag-frontend-module"><code>--frontend ⟨module⟩</code></a> flag as follows:</p> <pre data-language="none">$ ghc --frontend Foo.FrontendPlugin ...other options...
</pre> <p>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier <code>frontendPlugin</code> of type <code>GHC.Plugins.FrontendPlugin</code>.</p> <p><code>FrontendPlugin</code> exports a field <code>frontend</code>, which is a function <code>[String] -&gt; [(String, Maybe Phase)] -&gt; Ghc ()</code>. The first argument is a list of extra flags passed to the frontend with <code>-ffrontend-opt</code>; the second argument is the list of arguments, usually source files and module names to be compiled (the <code>Phase</code> indicates if an <code>-x</code> flag was set), and a frontend simply executes some operation in the <code>Ghc</code> monad (which, among other things, has a <code>Session</code>).</p> <p>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</p> <pre data-language="haskell">module DoNothing.FrontendPlugin (frontendPlugin) where
import GHC.Plugins

frontendPlugin :: FrontendPlugin
frontendPlugin = defaultFrontendPlugin {
  frontend = doNothing
  }

doNothing :: [String] -&gt; [(String, Maybe Phase)] -&gt; Ghc ()
doNothing flags args = do
    liftIO $ print flags
    liftIO $ print args
</pre> <p>Provided you have compiled this plugin and registered it in a package, you can just use it by specifying <code>--frontend DoNothing.FrontendPlugin</code> on the command line to GHC.</p> </section> <section id="dynflags-plugins"> <h3 id="id14">
<span class="section-number">7.3.10. </span>DynFlags plugins</h3> <p>A DynFlags plugin allows you to modify the <code>DynFlags</code> that GHC is going to use when processing a given (set of) file(s). <code>DynFlags</code> is a record containing all sorts of configuration and command line data, from verbosity level to the integer library to use, including compiler hooks, plugins and pretty-printing options. DynFlags plugins allow plugin authors to update any of those values before GHC starts doing any actual work, effectively meaning that the updates specified by the plugin will be taken into account and influence GHC’s behaviour.</p> <p>One of the motivating examples was the ability to register compiler hooks from a plugin. For example, one might want to modify the way Template Haskell code is executed. This is achievable by updating the <code>hooks</code> field of the <code>DynFlags</code> type, recording our custom “meta hook” in the right place. A simple application of this idea can be seen below:</p> <pre data-language="haskell">module DynFlagsPlugin (plugin) where

import BasicTypes
import GHC.Plugins
import GHC.Hs.Expr
import Language.Haskell.Syntax.Extension
import GHC.Hs.Lit
import Hooks
import GHC.Tc.Utils.Monad

plugin :: Plugin
plugin = driverPlugin { driverPlugin = hooksP }

hooksP :: [CommandLineOption] -&gt; HscEnv -&gt; IO HscEnv
hooksP opts hsc_env = do
    let hooks'   = (hsc_hooks hsc_env)
                    { runMetaHook = Just (fakeRunMeta opts) }
        hsc_env' = hsc_env { hsc_hooks = hooks' }
    return hsc_env'

-- This meta hook doesn't actually care running code in splices,
-- it just replaces any expression splice with the "0"
-- integer literal, and errors out on all other types of
-- meta requests.
fakeRunMeta :: [CommandLineOption] -&gt; MetaHook TcM
fakeRunMeta opts (MetaE r) _ = do
  liftIO . putStrLn $ "Options = " ++ show opts
  pure $ r zero

  where zero :: LHsExpr GhcPs
        zero = L noSrcSpan $ HsLit NoExtField $
          HsInt NoExtField (mkIntegralLit (0 :: Int))

fakeRunMeta _ _ _ = error "fakeRunMeta: unimplemented"
</pre> <p>This simple plugin takes over the execution of Template Haskell code, replacing any expression splice it encounters by <code>0</code> (at type <code>Int</code>), and errors out on any other type of splice.</p> <p>Therefore, if we run GHC against the following code using the plugin from above:</p> <pre data-language="haskell">{-# OPTIONS -fplugin=DynFlagsPlugin #-}
{-# LANGUAGE TemplateHaskell #-}
module Main where

main :: IO ()
main = print $( [|1|] )
</pre> <p>This will not actually evaluate <code>[|1|]</code>, but instead replace it with the <code>0 :: Int</code> literal.</p> <p>Just like the other types of plugins, you can write <code>DynFlags</code> plugins that can take and make use of some options that you can then specify using the <code>-fplugin-opt</code> flag. In the <code>DynFlagsPlugin</code> code from above, the said options would be available in the <code>opts</code> argument of <code>hooksP</code>.</p> <p>Finally, since those <code>DynFlags</code> updates happen after the plugins are loaded, you cannot from a <code>DynFlags</code> plugin register other plugins by just adding them to the <code>plugins</code> field of <code>DynFlags</code>. In order to achieve this, you would have to load them yourself and store the result into the <code>cachedPlugins</code> field of <code>DynFlags</code>.</p> </section> </section> <section id="referring-to-back-ends"> <h2>
<span class="section-number">7.4. </span>Referring to back ends</h2> <p>In versions of GHC numbered up to and including 9.4, a back end is referred to by name: type <code>Backend</code>, from module <code>GHC.Driver.Backend</code>, is a simple enumeration type. In versions of GHC numbered 9.6 and higher, <code>Backend</code> is an abstract type. The module specifies predicates and functions associated with a back end.</p> <p>This change in representation requires changes in client code.</p> <section id="client-code-that-only-names-back-ends"> <h3>
<span class="section-number">7.4.1. </span>Client code that only names back ends</h3> <p>Suppose your client uses <code>Backend</code> only to mention back ends by name. That is, it never discriminates between back ends in a <code>case</code> expression, function definition, or equality comparison. Then the simplest way for you to migrate your code is to replace each value constructor from version 9.4 with the corresponding value from 9.6:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Old value</p></th> <th class="head"><p>New value</p></th> </tr> </thead>  <tr>
<td><p><code>NCG</code></p></td> <td><p><code>ncgBackend</code></p></td> </tr> <tr>
<td><p><code>LLVM</code></p></td> <td><p><code>llvmBackend</code></p></td> </tr> <tr>
<td><p><code>ViaC</code></p></td> <td><p><code>viaCBackend</code></p></td> </tr> <tr>
<td><p><code>Interpreter</code></p></td> <td><p><code>interpreterBackend</code></p></td> </tr> <tr>
<td><p><code>NoBackend</code></p></td> <td><p><code>noBackend</code></p></td> </tr>  </table> </section> <section id="client-code-that-discriminates-among-back-ends"> <h3>
<span class="section-number">7.4.2. </span>Client code that discriminates among back ends</h3> <p>Suppose your code makes decisions based on the value of an expression of type <code>Backend</code>. Then the simplest way for you to migrate your decision-making code depends on the code’s form.</p> <ul> <li>
<p>If your decision-making is driven by an equality or inequality predicate, an equivalent predicate may already be defined in module <code>GHC.Driver.Backend</code>. For example, if your client wants to be sure that optimization levels above <code>-O0</code> are permitted, it might have originally compared <code>backend /= Interpreter</code>. But now there is a predicate for that: it is <code>not (backendForcesOptimization0 backend)</code>.</p> <p>If the predicate you want is not already defined, you will have to fall back on the more general strategy defined below.</p> </li> <li>If your decision-making is still driven by a predicate, but the implementation of the predicate inspects the form of <code>Backend</code>, you may still be in luck. For example, if your client needs to know whether the <code>Backend</code> wishes to write files to disk, it can query <code>backendWritesFiles backend</code>. In version 9.4, this predicate holds for the NCG, LLVM, and Via-C back ends, but not for the interpreter or for <code>NoBackend</code>.</li> <li>In the general case, for any function definition, case expression, or equality test that discriminates among back ends, you can use the general migration strategy described below.</li> </ul> </section> <section id="general-migration-strategy-for-client-code"> <h3>
<span class="section-number">7.4.3. </span>General migration strategy for client code</h3> <p>From version 9.6 onward, each back end may be queried for its name:</p> <pre data-language="haskell">backendName :: Backend -&gt; BackendName
</pre> <p>The <code>BackendName</code> type must be imported from module <code>GHC.Driver.Backend.Internal</code>. It is defined to look the same as the old <code>Backend</code> type:</p> <pre data-language="haskell">data BackendName
   = NCG
   | LLVM
   | ViaC
   | Interpreter
   | NoBackend
</pre> <p>This type is also an instance of the <code>Eq</code> and <code>Show</code> classes.</p> <p>If your existing code discriminates among existing back ends using a <code>case</code> expression, you need to apply <code>backendName</code> to the scrutinee.</p> <pre data-language="haskell">case backend dflags of  -- code using the 9.4 interface
  NCG -&gt; ...
  LLVM -&gt; ...
  ...
</pre> <p>can become</p> <pre data-language="haskell">case backendName $ backend dflags of  -- code using the 9.6 interface
  NCG -&gt; ...
  LLVM -&gt; ...
  ...
</pre> <p>Only the scrutinee changes, not the pattern matches. And if your pattern matches were complete before, they are still complete.</p> </section> </section> </section> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/extending_ghc.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/users_guide/extending_ghc.html</a>
  </p>
</div>
