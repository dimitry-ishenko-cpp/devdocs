<h1 class="caption">Data.ByteString.Lazy.Char8</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) Don Stewart 2006-2008<br>(c) Duncan Coutts 2006-2011</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>dons00@gmail.com, duncan@community.haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>stable</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">The <code class="inline-code">ByteString</code> type</a></li>
<li><a href="#g:2">Introducing and eliminating <code>ByteString</code>s</a></li>
<li><a href="#g:3">Basic interface</a></li>
<li><a href="#g:4">Transforming ByteStrings</a></li>
<li>
<a href="#g:5">Reducing <code>ByteString</code>s (folds)</a><ul><li><a href="#g:6">Special folds</a></li></ul>
</li>
<li>
<a href="#g:7">Building ByteStrings</a><ul>
<li><a href="#g:8">Scans</a></li>
<li><a href="#g:9">Accumulating maps</a></li>
<li><a href="#g:10">Infinite ByteStrings</a></li>
<li><a href="#g:11">Unfolding ByteStrings</a></li>
</ul>
</li>
<li>
<a href="#g:12">Substrings</a><ul>
<li><a href="#g:13">Breaking strings</a></li>
<li><a href="#g:14">Breaking into many substrings</a></li>
<li><a href="#g:15">Breaking into lines and words</a></li>
</ul>
</li>
<li><a href="#g:16">Predicates</a></li>
<li>
<a href="#g:17">Searching ByteStrings</a><ul>
<li><a href="#g:18">Searching by equality</a></li>
<li><a href="#g:19">Searching with a predicate</a></li>
</ul>
</li>
<li><a href="#g:20">Indexing ByteStrings</a></li>
<li><a href="#g:21">Zipping and unzipping ByteStrings</a></li>
<li><a href="#g:22">Ordered ByteStrings</a></li>
<li>
<a href="#g:23">Low level conversions</a><ul><li><a href="#g:24">Copying ByteStrings</a></li></ul>
</li>
<li><a href="#g:25">Reading from ByteStrings</a></li>
<li>
<a href="#g:26">I/O with <code>ByteString</code>s</a><ul>
<li><a href="#g:27">Standard input and output</a></li>
<li><a href="#g:28">Files</a></li>
<li><a href="#g:29">I/O with Handles</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>Manipulate <em>lazy</em> <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>s using <code><a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a></code> operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their <code><a href="../base-4.21.0.0-8e62/data-word.html#v:Word8" title="Data.Word">Word8</a></code> equivalents in <a href="data-bytestring-lazy.html">Data.ByteString.Lazy</a>.</p>
<p>This module is intended to be imported <code class="inline-code">qualified</code>, to avoid name clashes with <a href="../base-4.21.0.0-8e62/prelude.html">Prelude</a> functions. eg.</p>
<pre>import qualified Data.ByteString.Lazy.Char8 as C</pre>
<p>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use <code class="inline-code">{-# LANGUAGE OverloadedStrings #-}</code> to enable this.</p>
</div>
<a href="#g:1" id="g:1"><h2>The ByteString type</h2></a><p class="src">data <a id="t:ByteString" class="def">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#ByteString" class="link">Source</a> </p>
<p>A space-efficient representation of a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code> vector, supporting many efficient operations.</p>
<p>A <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> contains 8-bit bytes, or by using the operations from <a href="data-bytestring-lazy-char8.html">Data.ByteString.Lazy.Char8</a> it can be interpreted as containing 8-bit characters.</p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:ByteString">Instances</h5>
<details id="i:ByteString" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../deepseq-1.5.1.0-18b1/control-deepseq.html#t:NFData" title="Control.DeepSeq">NFData</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-123" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:NFData:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:rnf">rnf</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/deepseq-1.5.1.0-18b1/src/Control.DeepSeq.html#rnf" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-118" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Monoid:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mempty">mempty</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:mappend">mappend</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-113" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Semigroup:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:stimes">stimes</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-144" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Data:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:gfoldl">gfoldl</a> :: (forall d b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (d -&gt; b) -&gt; d -&gt; c b) -&gt; (forall g. g -&gt; c g) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; c <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:gunfold">gunfold</a> :: (forall b r. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; c (b -&gt; r) -&gt; c r) -&gt; (forall r. r -&gt; c r) -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> -&gt; c <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:toConstr">toConstr</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> </p>
<p class="src"><a href="#v:dataTypeOf">dataTypeOf</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:DataType" title="Data.Data">DataType</a> </p>
<p class="src"><a href="#v:dataCast1">dataCast1</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (t d)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) </p>
<p class="src"><a href="#v:dataCast2">dataCast2</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d e. (<a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d, <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> e) =&gt; c (t d e)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) </p>
<p class="src"><a href="#v:gmapT">gmapT</a> :: (forall b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; b -&gt; b) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:gmapQl">gmapQl</a> :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; r </p>
<p class="src"><a href="#v:gmapQr">gmapQr</a> :: forall r r'. (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; r </p>
<p class="src"><a href="#v:gmapQ">gmapQ</a> :: (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [u] </p>
<p class="src"><a href="#v:gmapQi">gmapQi</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; u </p>
<p class="src"><a href="#v:gmapM">gmapM</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; m <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:gmapMp">gmapMp</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; m <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:gmapMo">gmapMo</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; m <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-string.html#t:IsString" title="Data.String">IsString</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-141" class="link">Source</a> </td>
<td class="doc"><p>Beware: <code><a href="../base-4.21.0.0-8e62/data-string.html#v:fromString" title="Data.String">fromString</a></code> truncates multi-byte characters to octets. e.g. "枯朶に烏のとまりけり秋の暮" becomes �6k�nh~�Q��n�</p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:IsString:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromString">fromString</a> :: <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:IsList" title="GHC.Exts">IsList</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-134" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: bytestring-0.10.12.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:IsList:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:if:D:R:ItemByteString:Item:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> = <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromList">fromList</a> :: [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:toList">toList</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-130" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Read:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:readList">readList</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] </p>
<p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
<p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-127" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Show:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-107" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Eq:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3D%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%2F%3D" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-110" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Ord:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:compare">compare</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#compare" class="link">Source</a> </p>
<p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:max">max</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#max" class="link">Source</a> </p>
<p class="src"><a href="#v:min">min</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#min" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-99" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Lift:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:lift">lift</a> :: <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; m <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> </p>
<p class="src"><a href="#v:liftTyped">liftTyped</a> :: forall (m :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>). <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Code" title="Language.Haskell.TH.Syntax">Code</a> m <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#line-135" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Item:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-lazy-internal.html">Data.ByteString.Lazy.Internal</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> = <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</div></details></td></tr>
</table></details>
</div>
<a href="#g:2" id="g:2"><h2>Introducing and eliminating ByteStrings</h2></a><p class="src"><a id="v:empty" class="def">empty</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#empty" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> The empty <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code></p>
<p class="src"><a id="v:singleton" class="def">singleton</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#singleton" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Convert a <code><a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a></code> into a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code></p>
<p class="src"><a id="v:pack" class="def">pack</a> :: [<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#pack" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Convert a <code><a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a></code> into a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>.</p>
<p class="src"><a id="v:unpack" class="def">unpack</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unpack" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Converts a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to a <code><a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a></code>.</p>
<p class="src"><a id="v:fromChunks" class="def">fromChunks</a> :: [<a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a>] -&gt; <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#fromChunks" class="link">Source</a> </p>
<p><span class="complexity">O(c)</span> Convert a list of <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code> into a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code></p>
<p class="src"><a id="v:toChunks" class="def">toChunks</a> :: <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> -&gt; [<a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#toChunks" class="link">Source</a> </p>
<p><span class="complexity">O(c)</span> Convert a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> into a list of <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code></p>
<p class="src"><a id="v:fromStrict" class="def">fromStrict</a> :: <a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a> -&gt; <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#fromStrict" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Convert a <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code> into a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code>.</p>
<p class="src"><a id="v:toStrict" class="def">toStrict</a> :: <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> -&gt; <a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#toStrict" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Convert a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> into a <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code>.</p>
<p>Note that this is an <em>expensive</em> operation that forces the whole <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</p>
<a href="#g:3" id="g:3"><h2>Basic interface</h2></a><p class="src"><a id="v:cons" class="def">cons</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#cons" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring-lazy-char8.html#v:cons" title="Data.ByteString.Lazy.Char8">cons</a></code> is analogous to <code><a href="../base-4.21.0.0-8e62/prelude.html#v::" title="Prelude">(:)</a></code> for lists.</p>
<p class="src"><a id="v:cons-39-" class="def">cons'</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#cons%27" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Unlike <code><a href="data-bytestring-lazy-char8.html#v:cons" title="Data.ByteString.Lazy.Char8">cons</a></code>, <code><a href="data-bytestring-lazy-char8.html#v:cons-39-" title="Data.ByteString.Lazy.Char8">cons'</a></code> is strict in the ByteString that we are consing onto. More precisely, it forces the head and the first chunk. It does this because, for space efficiency, it may coalesce the new byte onto the first 'chunk' rather than starting a new 'chunk'.</p>
<p>So that means you can't use a lazy recursive contruction like this:</p>
<pre>let xs = cons' c xs in xs</pre>
<p>You can however use <code><a href="data-bytestring-lazy-char8.html#v:cons" title="Data.ByteString.Lazy.Char8">cons</a></code>, as well as <code><a href="data-bytestring-lazy-char8.html#v:repeat" title="Data.ByteString.Lazy.Char8">repeat</a></code> and <code><a href="data-bytestring-lazy-char8.html#v:cycle" title="Data.ByteString.Lazy.Char8">cycle</a></code>, to build infinite lazy ByteStrings.</p>
<p class="src"><a id="v:snoc" class="def">snoc</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <span class="fixity">infixl 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#snoc" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Append a Char to the end of a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. Similar to <code><a href="data-bytestring-lazy-char8.html#v:cons" title="Data.ByteString.Lazy.Char8">cons</a></code>, this function performs a memcpy.</p>
<p class="src"><a id="v:append" class="def">append</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#append" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> Append two ByteStrings</p>
<p class="src"><a id="v:head" class="def">head</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#head" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the first element of a ByteString, which must be non-empty.</p>
<p class="src"><a id="v:uncons" class="def">uncons</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#uncons" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the head and tail of a ByteString, returning Nothing if it is empty.</p>
<p class="src"><a id="v:last" class="def">last</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#last" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the last element of a packed string, which must be non-empty.</p>
<p class="src"><a id="v:tail" class="def">tail</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#tail" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the elements after the head of a ByteString, which must be non-empty.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring-lazy.html#v:uncons" title="Data.ByteString.Lazy">uncons</a></code> instead.</p>
<p class="src"><a id="v:unsnoc" class="def">unsnoc</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unsnoc" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> Extract the <code><a href="data-bytestring-lazy-char8.html#v:init" title="Data.ByteString.Lazy.Char8">init</a></code> and <code><a href="data-bytestring-lazy-char8.html#v:last" title="Data.ByteString.Lazy.Char8">last</a></code> of a ByteString, returning Nothing if it is empty.</p>
<p class="src"><a id="v:init" class="def">init</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#init" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> Returns all the elements of a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> except the last one.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring-lazy.html#v:unsnoc" title="Data.ByteString.Lazy">unsnoc</a></code> instead.</p>
<p class="src"><a id="v:null" class="def">null</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#null" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Test whether a ByteString is empty.</p>
<p class="src"><a id="v:length" class="def">length</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#length" class="link">Source</a> </p>
<p><span class="complexity">O(c)</span> <code><a href="data-bytestring-lazy-char8.html#v:length" title="Data.ByteString.Lazy.Char8">length</a></code> returns the length of a ByteString as an <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a></code></p>
<a href="#g:4" id="g:4"><h2>Transforming ByteStrings</h2></a><p class="src"><a id="v:map" class="def">map</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#map" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:map" title="Data.ByteString.Lazy.Char8">map</a></code> <code class="inline-code">f xs</code> is the ByteString obtained by applying <code class="inline-code">f</code> to each element of <code class="inline-code">xs</code></p>
<p class="src"><a id="v:reverse" class="def">reverse</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#reverse" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:reverse" title="Data.ByteString.Lazy.Char8">reverse</a></code> <code class="inline-code">xs</code> returns the elements of <code class="inline-code">xs</code> in reverse order.</p>
<p class="src"><a id="v:intersperse" class="def">intersperse</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#intersperse" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:intersperse" title="Data.ByteString.Lazy.Char8">intersperse</a></code> function takes a Char and a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> and `intersperses' that Char between the elements of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. It is analogous to the intersperse function on Lists.</p>
<p class="src"><a id="v:intercalate" class="def">intercalate</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#intercalate" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:intercalate" title="Data.ByteString.Lazy.Char8">intercalate</a></code> function takes a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> and a list of <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>s and concatenates the list after interspersing the first argument between each element of the list.</p>
<p class="src"><a id="v:transpose" class="def">transpose</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#transpose" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:transpose" title="Data.ByteString.Lazy.Char8">transpose</a></code> function transposes the rows and columns of its <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> argument.</p>
<a href="#g:5" id="g:5"><h2>Reducing ByteStrings (folds)</h2></a><p class="src"><a id="v:foldl" class="def">foldl</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldl" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldl" title="Data.ByteString.Lazy.Char8">foldl</a></code>, applied to a binary operator, a starting value (typically the left-identity of the operator), and a ByteString, reduces the ByteString using the binary operator, from left to right.</p>
<p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldl%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldl-39-" title="Data.ByteString.Lazy.Char8">foldl'</a></code> is like foldl, but strict in the accumulator.</p>
<p class="src"><a id="v:foldl1" class="def">foldl1</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldl1" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldl1" title="Data.ByteString.Lazy.Char8">foldl1</a></code> is a variant of <code><a href="data-bytestring-lazy-char8.html#v:foldl" title="Data.ByteString.Lazy.Char8">foldl</a></code> that has no starting value argument, and thus must be applied to non-empty <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>s.</p>
<p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldl1%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldl1-39-" title="Data.ByteString.Lazy.Char8">foldl1'</a></code> is like <code><a href="data-bytestring-lazy-char8.html#v:foldl1" title="Data.ByteString.Lazy.Char8">foldl1</a></code>, but strict in the accumulator.</p>
<p class="src"><a id="v:foldr" class="def">foldr</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldr" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldr" title="Data.ByteString.Lazy.Char8">foldr</a></code>, applied to a binary operator, a starting value (typically the right-identity of the operator), and a packed string, reduces the packed string using the binary operator, from right to left.</p>
<p class="src"><a id="v:foldr-39-" class="def">foldr'</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldr%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldr-39-" title="Data.ByteString.Lazy.Char8">foldr'</a></code> is like <code><a href="data-bytestring-lazy-char8.html#v:foldr" title="Data.ByteString.Lazy.Char8">foldr</a></code>, but strict in the accumulator.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:foldr1" class="def">foldr1</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldr1" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldr1" title="Data.ByteString.Lazy.Char8">foldr1</a></code> is a variant of <code><a href="data-bytestring-lazy-char8.html#v:foldr" title="Data.ByteString.Lazy.Char8">foldr</a></code> that has no starting value argument, and thus must be applied to non-empty <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>s</p>
<p class="src"><a id="v:foldr1-39-" class="def">foldr1'</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#foldr1%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:foldr1-39-" title="Data.ByteString.Lazy.Char8">foldr1'</a></code> is like <code><a href="data-bytestring-lazy-char8.html#v:foldr1" title="Data.ByteString.Lazy.Char8">foldr1</a></code>, but strict in the accumulator.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<a href="#g:6" id="g:6"><h3>Special folds</h3></a><p class="src"><a id="v:concat" class="def">concat</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#concat" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Concatenate a list of ByteStrings.</p>
<p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#concatMap" class="link">Source</a> </p>
<p>Map a function over a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> and concatenate the results</p>
<p class="src"><a id="v:any" class="def">any</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#any" class="link">Source</a> </p>
<p>Applied to a predicate and a ByteString, <code><a href="data-bytestring-lazy-char8.html#v:any" title="Data.ByteString.Lazy.Char8">any</a></code> determines if any element of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> satisfies the predicate.</p>
<p class="src"><a id="v:all" class="def">all</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#all" class="link">Source</a> </p>
<p>Applied to a predicate and a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, <code><a href="data-bytestring-lazy-char8.html#v:all" title="Data.ByteString.Lazy.Char8">all</a></code> determines if all elements of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> satisfy the predicate.</p>
<p class="src"><a id="v:maximum" class="def">maximum</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#maximum" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:maximum" title="Data.ByteString.Lazy.Char8">maximum</a></code> returns the maximum value from a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code></p>
<p class="src"><a id="v:minimum" class="def">minimum</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#minimum" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:minimum" title="Data.ByteString.Lazy.Char8">minimum</a></code> returns the minimum value from a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code></p>
<p class="src"><a id="v:compareLength" class="def">compareLength</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#compareLength" class="link">Source</a> </p>
<p><span class="complexity">O(c)</span> <code><a href="data-bytestring-lazy-char8.html#v:compareLength" title="Data.ByteString.Lazy.Char8">compareLength</a></code> compares the length of a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to an <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a></code></p>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<a href="#g:7" id="g:7"><h2>Building ByteStrings</h2></a><a href="#g:8" id="g:8"><h3>Scans</h3></a><p class="src"><a id="v:scanl" class="def">scanl</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#scanl" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:scanl" title="Data.ByteString.Lazy.Char8">scanl</a></code> is similar to <code><a href="data-bytestring-lazy-char8.html#v:foldl" title="Data.ByteString.Lazy.Char8">foldl</a></code>, but returns a list of successive reduced values from the left.</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>last (scanl f z xs) == foldl f z xs.</pre>
<p class="src"><a id="v:scanl1" class="def">scanl1</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#scanl1" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:scanl1" title="Data.ByteString.Lazy.Char8">scanl1</a></code> is a variant of <code><a href="data-bytestring-lazy-char8.html#v:scanl" title="Data.ByteString.Lazy.Char8">scanl</a></code> that has no starting value argument.</p>
<pre>scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</pre>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:scanr" class="def">scanr</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#scanr" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>)</td>
<td class="doc"><p>element -&gt; accumulator -&gt; new accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>
</td>
<td class="doc"><p>starting value of accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>
</td>
<td class="doc"><p>input of length n</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>
</td>
<td class="doc"><p>output of length n+1</p></td>
</tr>
</table>
</div>
<p><code><a href="data-bytestring-lazy-char8.html#v:scanr" title="Data.ByteString.Lazy.Char8">scanr</a></code> is similar to <code><a href="data-bytestring-lazy-char8.html#v:foldr" title="Data.ByteString.Lazy.Char8">foldr</a></code>, but returns a list of successive reduced values from the right.</p>
<pre>scanr f z [..., x{n-1}, xn] == [..., x{n-1} `f` (xn `f` z), xn `f` z, z]</pre>
<p>Note that</p>
<pre>head (scanr f z xs) == foldr f z xs
last (scanr f z xs) == z</pre>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:scanr1" class="def">scanr1</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#scanr1" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:scanr1" title="Data.ByteString.Lazy.Char8">scanr1</a></code> is a variant of <code><a href="data-bytestring-lazy-char8.html#v:scanr" title="Data.ByteString.Lazy.Char8">scanr</a></code> that has no starting value argument.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<a href="#g:9" id="g:9"><h3>Accumulating maps</h3></a><p class="src"><a id="v:mapAccumL" class="def">mapAccumL</a> :: (acc -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; (acc, <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>)) -&gt; acc -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (acc, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#mapAccumL" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:mapAccumL" title="Data.ByteString.Lazy.Char8">mapAccumL</a></code> function behaves like a combination of <code><a href="data-bytestring-lazy-char8.html#v:map" title="Data.ByteString.Lazy.Char8">map</a></code> and <code><a href="data-bytestring-lazy-char8.html#v:foldl" title="Data.ByteString.Lazy.Char8">foldl</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</p>
<p class="src"><a id="v:mapAccumR" class="def">mapAccumR</a> :: (acc -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; (acc, <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>)) -&gt; acc -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (acc, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#mapAccumR" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:mapAccumR" title="Data.ByteString.Lazy.Char8">mapAccumR</a></code> function behaves like a combination of <code><a href="data-bytestring-lazy-char8.html#v:map" title="Data.ByteString.Lazy.Char8">map</a></code> and <code><a href="data-bytestring-lazy-char8.html#v:foldr" title="Data.ByteString.Lazy.Char8">foldr</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</p>
<a href="#g:10" id="g:10"><h3>Infinite ByteStrings</h3></a><p class="src"><a id="v:repeat" class="def">repeat</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#repeat" class="link">Source</a> </p>
<p><code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:repeat" title="Data.ByteString.Lazy.Char8">repeat</a> x</code> is an infinite ByteString, with <code class="inline-code">x</code> the value of every element.</p>
<p class="src"><a id="v:replicate" class="def">replicate</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#replicate" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:replicate" title="Data.ByteString.Lazy.Char8">replicate</a> n x</code> is a ByteString of length <code class="inline-code">n</code> with <code class="inline-code">x</code> the value of every element.</p>
<p class="src"><a id="v:cycle" class="def">cycle</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#cycle" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:cycle" title="Data.ByteString.Lazy.Char8">cycle</a></code> ties a finite ByteString into a circular one, or equivalently, the infinite repetition of the original ByteString.</p>
<p class="src"><a id="v:iterate" class="def">iterate</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#iterate" class="link">Source</a> </p>
<p><code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:iterate" title="Data.ByteString.Lazy.Char8">iterate</a> f x</code> returns an infinite ByteString of repeated applications of <code class="inline-code">f</code> to <code class="inline-code">x</code>:</p>
<pre>iterate f x == [x, f x, f (f x), ...]</pre>
<a href="#g:11" id="g:11"><h3>Unfolding ByteStrings</h3></a><p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>, a)) -&gt; a -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unfoldr" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:unfoldr" title="Data.ByteString.Lazy.Char8">unfoldr</a></code> function is analogous to the List 'unfoldr'. <code><a href="data-bytestring-lazy-char8.html#v:unfoldr" title="Data.ByteString.Lazy.Char8">unfoldr</a></code> builds a ByteString from a seed value. The function takes the element and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is done producing the ByteString or returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> <code class="inline-code">(a,b)</code>, in which case, <code class="inline-code">a</code> is a prepending to the ByteString and <code class="inline-code">b</code> is used as the next element in a recursive call.</p>
<a href="#g:12" id="g:12"><h2>Substrings</h2></a><a href="#g:13" id="g:13"><h3>Breaking strings</h3></a><p class="src"><a id="v:take" class="def">take</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#take" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy-char8.html#v:take" title="Data.ByteString.Lazy.Char8">take</a></code> <code class="inline-code">n</code>, applied to a ByteString <code class="inline-code">xs</code>, returns the prefix of <code class="inline-code">xs</code> of length <code class="inline-code">n</code>, or <code class="inline-code">xs</code> itself if <code class="inline-code">n &gt; <a href="data-bytestring-lazy-char8.html#v:length" title="Data.ByteString.Lazy.Char8">length</a> xs</code>.</p>
<p class="src"><a id="v:takeEnd" class="def">takeEnd</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#takeEnd" class="link">Source</a> </p>
<p><span class="complexity">O(c)</span> <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:takeEnd" title="Data.ByteString.Lazy.Char8">takeEnd</a> n xs</code> is equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:drop" title="Data.ByteString.Lazy.Char8">drop</a> (<a href="data-bytestring-lazy-char8.html#v:length" title="Data.ByteString.Lazy.Char8">length</a> xs - n) xs</code>. Takes <code class="inline-code">n</code> elements from end of bytestring.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeEnd 3 "abcdefg"
</strong>"efg"
&gt;&gt;&gt; <strong class="userinput">takeEnd 0 "abcdefg"
</strong>""
&gt;&gt;&gt; <strong class="userinput">takeEnd 4 "abc"
</strong>"abc"
</pre>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:drop" class="def">drop</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#drop" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy-char8.html#v:drop" title="Data.ByteString.Lazy.Char8">drop</a></code> <code class="inline-code">n xs</code> returns the suffix of <code class="inline-code">xs</code> after the first <code class="inline-code">n</code> elements, or <code><a href="data-bytestring-lazy-char8.html#v:empty" title="Data.ByteString.Lazy.Char8">empty</a></code> if <code class="inline-code">n &gt; <a href="data-bytestring-lazy-char8.html#v:length" title="Data.ByteString.Lazy.Char8">length</a> xs</code>.</p>
<p class="src"><a id="v:dropEnd" class="def">dropEnd</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#dropEnd" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:dropEnd" title="Data.ByteString.Lazy.Char8">dropEnd</a> n xs</code> is equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:take" title="Data.ByteString.Lazy.Char8">take</a> (<a href="data-bytestring-lazy-char8.html#v:length" title="Data.ByteString.Lazy.Char8">length</a> xs - n) xs</code>. Drops <code class="inline-code">n</code> elements from end of bytestring.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropEnd 3 "abcdefg"
</strong>"abcd"
&gt;&gt;&gt; <strong class="userinput">dropEnd 0 "abcdefg"
</strong>"abcdefg"
&gt;&gt;&gt; <strong class="userinput">dropEnd 4 "abc"
</strong>""
</pre>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#splitAt" class="link">Source</a> </p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy-char8.html#v:splitAt" title="Data.ByteString.Lazy.Char8">splitAt</a></code> <code class="inline-code">n xs</code> is equivalent to <code class="inline-code">(<a href="data-bytestring-lazy-char8.html#v:take" title="Data.ByteString.Lazy.Char8">take</a> n xs, <a href="data-bytestring-lazy-char8.html#v:drop" title="Data.ByteString.Lazy.Char8">drop</a> n xs)</code>.</p>
<p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#takeWhile" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:takeWhile" title="Data.ByteString.Lazy.Char8">takeWhile</a></code>, applied to a predicate <code class="inline-code">p</code> and a ByteString <code class="inline-code">xs</code>, returns the longest prefix (possibly empty) of <code class="inline-code">xs</code> of elements that satisfy <code class="inline-code">p</code>.</p>
<p class="src"><a id="v:takeWhileEnd" class="def">takeWhileEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#takeWhileEnd" class="link">Source</a> </p>
<p>Returns the longest (possibly empty) suffix of elements satisfying the predicate.</p>
<p><code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:takeWhileEnd" title="Data.ByteString.Lazy.Char8">takeWhileEnd</a> p</code> is equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:reverse" title="Data.ByteString.Lazy.Char8">reverse</a> . <a href="data-bytestring-lazy-char8.html#v:takeWhile" title="Data.ByteString.Lazy.Char8">takeWhile</a> p . <a href="data-bytestring-lazy-char8.html#v:reverse" title="Data.ByteString.Lazy.Char8">reverse</a></code>.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#dropWhile" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:dropWhile" title="Data.ByteString.Lazy.Char8">dropWhile</a></code> <code class="inline-code">p xs</code> returns the suffix remaining after <code><a href="data-bytestring-lazy-char8.html#v:takeWhile" title="Data.ByteString.Lazy.Char8">takeWhile</a></code> <code class="inline-code">p xs</code>.</p>
<p class="src"><a id="v:dropWhileEnd" class="def">dropWhileEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#dropWhileEnd" class="link">Source</a> </p>
<p>Similar to <code><a href="p.html#v:dropWhileEnd" title="P">dropWhileEnd</a></code>, drops the longest (possibly empty) suffix of elements satisfying the predicate and returns the remainder.</p>
<p><code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:dropWhileEnd" title="Data.ByteString.Lazy.Char8">dropWhileEnd</a> p</code> is equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:reverse" title="Data.ByteString.Lazy.Char8">reverse</a> . <a href="data-bytestring-lazy-char8.html#v:dropWhile" title="Data.ByteString.Lazy.Char8">dropWhile</a> p . <a href="data-bytestring-lazy-char8.html#v:reverse" title="Data.ByteString.Lazy.Char8">reverse</a></code>.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:span" class="def">span</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#span" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:span" title="Data.ByteString.Lazy.Char8">span</a></code> <code class="inline-code">p xs</code> breaks the ByteString into two segments. It is equivalent to <code class="inline-code">(<a href="data-bytestring-lazy-char8.html#v:takeWhile" title="Data.ByteString.Lazy.Char8">takeWhile</a> p xs, <a href="data-bytestring-lazy-char8.html#v:dropWhile" title="Data.ByteString.Lazy.Char8">dropWhile</a> p xs)</code></p>
<p class="src"><a id="v:spanEnd" class="def">spanEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#spanEnd" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:spanEnd" title="Data.ByteString.Lazy.Char8">spanEnd</a></code> behaves like <code><a href="data-bytestring-lazy-char8.html#v:span" title="Data.ByteString.Lazy.Char8">span</a></code> but from the end of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. We have</p>
<pre>spanEnd (not.isSpace) "x y z" == ("x y ","z")</pre>
<p>and</p>
<pre>spanEnd (not . isSpace) ps
   ==
let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)</pre>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:break" class="def">break</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#break" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:break" title="Data.ByteString.Lazy.Char8">break</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:span" title="Data.ByteString.Lazy.Char8">span</a> (<a href="../base-4.21.0.0-8e62/data-bool.html#v:not" title="Data.Bool">not</a> . p)</code>.</p>
<p class="src"><a id="v:breakEnd" class="def">breakEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#breakEnd" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:breakEnd" title="Data.ByteString.Lazy.Char8">breakEnd</a></code> behaves like <code><a href="data-bytestring-lazy-char8.html#v:break" title="Data.ByteString.Lazy.Char8">break</a></code> but from the end of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code></p>
<p>breakEnd p == spanEnd (not.p)</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:group" class="def">group</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#group" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:group" title="Data.ByteString.Lazy.Char8">group</a></code> function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each string in the result contains only equal elements. For example,</p>
<pre>group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</pre>
<p>It is a special case of <code><a href="data-bytestring-lazy.html#v:groupBy" title="Data.ByteString.Lazy">groupBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#groupBy" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:groupBy" title="Data.ByteString.Lazy.Char8">groupBy</a></code> function is the non-overloaded version of <code><a href="data-bytestring-lazy-char8.html#v:group" title="Data.ByteString.Lazy.Char8">group</a></code>.</p>
<p class="src"><a id="v:inits" class="def">inits</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#inits" class="link">Source</a> </p>
<p>Returns all initial segments of the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, shortest first.</p>
<p class="src"><a id="v:tails" class="def">tails</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#tails" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all final segments of the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, longest first.</p>
<p class="src"><a id="v:initsNE" class="def">initsNE</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#initsNE" class="link">Source</a> </p>
<p>Returns all initial segments of the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, shortest first.</p>
<p><span class="version">Since: bytestring-0.11.4.0</span></p>
<p class="src"><a id="v:tailsNE" class="def">tailsNE</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#tailsNE" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all final segments of the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, longest first.</p>
<p><span class="version">Since: bytestring-0.11.4.0</span></p>
<p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#stripPrefix" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:stripPrefix" title="Data.ByteString.Lazy.Char8">stripPrefix</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the remainder of the second iff the first is its prefix, and otherwise <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<p><span class="version">Since: bytestring-0.10.8.0</span></p>
<p class="src"><a id="v:stripSuffix" class="def">stripSuffix</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#stripSuffix" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:stripSuffix" title="Data.ByteString.Lazy.Char8">stripSuffix</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the remainder of the second iff the first is its suffix, and otherwise <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<a href="#g:14" id="g:14"><h3>Breaking into many substrings</h3></a><p class="src"><a id="v:split" class="def">split</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#split" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Break a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> into pieces separated by the byte argument, consuming the delimiter. I.e.</p>
<pre>split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
split 'a'  "aXaXaXa"    == ["","X","X","X"]
split 'x'  "x"          == ["",""]
split undefined ""      == []  -- and not [""]</pre>
<p>and</p>
<pre>intercalate [c] . split c == id
split == splitWith . (==)</pre>
<p>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>s that are slices of the original.</p>
<p class="src"><a id="v:splitWith" class="def">splitWith</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#splitWith" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Splits a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</p>
<pre>splitWith (=='a') "aabbaca" == ["","","bb","c",""]
splitWith undefined ""      == []  -- and not [""]</pre>
<a href="#g:15" id="g:15"><h3>Breaking into lines and words</h3></a><p class="src"><a id="v:lines" class="def">lines</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#lines" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:lines" title="Data.ByteString.Lazy.Char8">lines</a></code> lazily splits a ByteString into a list of ByteStrings at newline Chars (<code class="inline-code">'\n'</code>). The resulting strings do not contain newlines. The first chunk of the result is only strict in the first chunk of the input.</p>
<p>Note that it <strong>does not</strong> regard CR (<code class="inline-code">'\r'</code>) as a newline character.</p>
<p class="src"><a id="v:words" class="def">words</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#words" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:words" title="Data.ByteString.Lazy.Char8">words</a></code> breaks a ByteString up into a list of words, which were delimited by Chars representing white space. And</p>
<pre>tokens isSpace = words</pre>
<p class="src"><a id="v:unlines" class="def">unlines</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unlines" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:unlines" title="Data.ByteString.Lazy.Char8">unlines</a></code> joins lines, appending a terminating newline after each.</p>
<p>Equivalent to <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:concat" title="Data.ByteString.Lazy.Char8">concat</a> . Data.List.concatMap (\x -&gt; [x, <a href="data-bytestring-lazy-char8.html#v:singleton" title="Data.ByteString.Lazy.Char8">singleton</a> '\n'])</code>.</p>
<p class="src"><a id="v:unwords" class="def">unwords</a> :: [<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>] -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unwords" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:unwords" title="Data.ByteString.Lazy.Char8">unwords</a></code> function is analogous to the <code><a href="data-bytestring-lazy-char8.html#v:unlines" title="Data.ByteString.Lazy.Char8">unlines</a></code> function, on words.</p>
<a href="#g:16" id="g:16"><h2>Predicates</h2></a><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#isPrefixOf" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:isPrefixOf" title="Data.ByteString.Lazy.Char8">isPrefixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first is a prefix of the second.</p>
<p class="src"><a id="v:isSuffixOf" class="def">isSuffixOf</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#isSuffixOf" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:isSuffixOf" title="Data.ByteString.Lazy.Char8">isSuffixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first is a suffix of the second.</p>
<p>The following holds:</p>
<pre>isSuffixOf x y == reverse x `isPrefixOf` reverse y</pre>
<a href="#g:17" id="g:17"><h2>Searching ByteStrings</h2></a><a href="#g:18" id="g:18"><h3>Searching by equality</h3></a><p class="src"><a id="v:elem" class="def">elem</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#elem" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:elem" title="Data.ByteString.Lazy.Char8">elem</a></code> is the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> membership predicate. This implementation uses <code class="inline-code">memchr(3)</code>.</p>
<p class="src"><a id="v:notElem" class="def">notElem</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#notElem" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:notElem" title="Data.ByteString.Lazy.Char8">notElem</a></code> is the inverse of <code><a href="data-bytestring-lazy-char8.html#v:elem" title="Data.ByteString.Lazy.Char8">elem</a></code></p>
<a href="#g:19" id="g:19"><h3>Searching with a predicate</h3></a><p class="src"><a id="v:find" class="def">find</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#find" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:find" title="Data.ByteString.Lazy.Char8">find</a></code> function takes a predicate and a ByteString, and returns the first element in matching the predicate, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<p class="src"><a id="v:filter" class="def">filter</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#filter" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:filter" title="Data.ByteString.Lazy.Char8">filter</a></code>, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</p>
<p class="src"><a id="v:partition" class="def">partition</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#partition" class="link">Source</a> </p>
<p><span class="version">Since: bytestring-0.10.12.0</span></p>
<a href="#g:20" id="g:20"><h2>Indexing ByteStrings</h2></a><p class="src"><a id="v:index" class="def">index</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#index" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> index (subscript) operator, starting from 0.</p>
<p class="src"><a id="v:indexMaybe" class="def">indexMaybe</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#indexMaybe" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> index, starting from 0, that returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> if:</p>
<pre>0 &lt;= n &lt; length bs</pre>
<p><span class="version">Since: bytestring-0.11.0.0</span></p>
<p class="src"><a id="v:-33--63-" class="def">(!?)</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#%21%3F" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> index, starting from 0, that returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> if:</p>
<pre>0 &lt;= n &lt; length bs</pre>
<p><span class="version">Since: bytestring-0.11.0.0</span></p>
<p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#elemIndex" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:elemIndex" title="Data.ByteString.Lazy.Char8">elemIndex</a></code> function returns the index of the first element in the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> which is equal (by memchr) to the query element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<p class="src"><a id="v:elemIndexEnd" class="def">elemIndexEnd</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#elemIndexEnd" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:elemIndexEnd" title="Data.ByteString.Lazy.Char8">elemIndexEnd</a></code> function returns the last index of the element in the given <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> which is equal to the query element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element. The following holds:</p>
<pre>elemIndexEnd c xs = case elemIndex c (reverse xs) of
  Nothing -&gt; Nothing
  Just i  -&gt; Just (length xs - 1 - i)</pre>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#elemIndices" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy-char8.html#v:elemIndices" title="Data.ByteString.Lazy.Char8">elemIndices</a></code> function extends <code><a href="data-bytestring-lazy-char8.html#v:elemIndex" title="Data.ByteString.Lazy.Char8">elemIndex</a></code>, by returning the indices of all elements equal to the query element, in ascending order.</p>
<p class="src"><a id="v:findIndex" class="def">findIndex</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#findIndex" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:findIndex" title="Data.ByteString.Lazy.Char8">findIndex</a></code> function takes a predicate and a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> and returns the index of the first element in the ByteString satisfying the predicate.</p>
<p class="src"><a id="v:findIndexEnd" class="def">findIndexEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#findIndexEnd" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:findIndexEnd" title="Data.ByteString.Lazy.Char8">findIndexEnd</a></code> function takes a predicate and a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> and returns the index of the last element in the ByteString satisfying the predicate.</p>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#findIndices" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring-lazy-char8.html#v:findIndices" title="Data.ByteString.Lazy.Char8">findIndices</a></code> function extends <code><a href="data-bytestring-lazy-char8.html#v:findIndex" title="Data.ByteString.Lazy.Char8">findIndex</a></code>, by returning the indices of all elements satisfying the predicate, in ascending order.</p>
<p class="src"><a id="v:count" class="def">count</a> :: <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#count" class="link">Source</a> </p>
<p>count returns the number of times its argument appears in the ByteString</p>
<pre>count      == length . elemIndices
count '\n' == length . lines</pre>
<p>But more efficiently than using length on the intermediate list.</p>
<a href="#g:21" id="g:21"><h2>Zipping and unzipping ByteStrings</h2></a><p class="src"><a id="v:zip" class="def">zip</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [(<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#zip" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:zip" title="Data.ByteString.Lazy.Char8">zip</a></code> takes two ByteStrings and returns a list of corresponding pairs of Chars. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of <code><a href="data-bytestring-lazy-char8.html#v:unpack" title="Data.ByteString.Lazy.Char8">unpack</a></code> operations, and so space usage may be large for multi-megabyte ByteStrings</p>
<p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; a) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#zipWith" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:zipWith" title="Data.ByteString.Lazy.Char8">zipWith</a></code> generalises <code><a href="data-bytestring-lazy-char8.html#v:zip" title="Data.ByteString.Lazy.Char8">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function. For example, <code class="inline-code"><a href="data-bytestring-lazy-char8.html#v:zipWith" title="Data.ByteString.Lazy.Char8">zipWith</a> (+)</code> is applied to two ByteStrings to produce the list of corresponding sums.</p>
<p class="src"><a id="v:packZipWith" class="def">packZipWith</a> :: (<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>) -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#packZipWith" class="link">Source</a> </p>
<p>A specialised version of <code><a href="data-bytestring-lazy-char8.html#v:zipWith" title="Data.ByteString.Lazy.Char8">zipWith</a></code> for the common case of a simultaneous map over two ByteStrings, to build a 3rd.</p>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:unzip" class="def">unzip</a> :: [(<a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a>)] -&gt; (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#unzip" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy-char8.html#v:unzip" title="Data.ByteString.Lazy.Char8">unzip</a></code> transforms a list of pairs of chars into a pair of ByteStrings. Note that this performs two <code><a href="data-bytestring-lazy-char8.html#v:pack" title="Data.ByteString.Lazy.Char8">pack</a></code> operations.</p>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<a href="#g:22" id="g:22"><h2>Ordered ByteStrings</h2></a><a href="#g:23" id="g:23"><h2>Low level conversions</h2></a><a href="#g:24" id="g:24"><h3>Copying ByteStrings</h3></a><p class="src"><a id="v:copy" class="def">copy</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#copy" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Make a copy of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> with its own storage. This is mainly useful to allow the rest of the data pointed to by the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</p>
<a href="#g:25" id="g:25"><h2>Reading from ByteStrings</h2></a><p>Note that a lazy <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> may hold an unbounded stream of <code class="inline-code">'0'</code> digits, in which case the functions below may never return. If that's a concern, you can use <code><a href="data-bytestring-lazy-char8.html#v:take" title="Data.ByteString.Lazy.Char8">take</a></code> to first truncate the input to an acceptable length. Non-termination is also possible when reading arbitrary precision numbers via <code><a href="data-bytestring-lazy-char8.html#v:readInteger" title="Data.ByteString.Lazy.Char8">readInteger</a></code> or <code><a href="data-bytestring-lazy-char8.html#v:readNatural" title="Data.ByteString.Lazy.Char8">readNatural</a></code>, if the input is an unbounded stream of arbitrary decimal digits.</p>
<p class="src"><a id="v:readInt" class="def">readInt</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readInt" class="link">Source</a> </p>
<p>Try to read a signed <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a></code> value from the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, returning <code class="inline-code">Just (val, str)</code> on success, where <code class="inline-code">val</code> is the value read and <code class="inline-code">str</code> is the rest of the input string. If the sequence of digits decodes to a value larger than can be represented by an <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a></code>, the returned value will be <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readInt" title="Data.ByteString.Lazy.Char8">readInt</a></code> does not ignore leading whitespace, the value must start immediately at the beginning of the input string.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:readInt0">Examples</h5>
<details id="ch:readInt0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">readInt "-1729 sum of cubes"
</strong>Just (-1729," sum of cubes")
&gt;&gt;&gt; <strong class="userinput">readInt "+1: readInt also accepts a leading '+'"
</strong>Just (1, ": readInt also accepts a leading '+'")
&gt;&gt;&gt; <strong class="userinput">readInt "not a decimal number"
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">readInt "12345678901234567890 overflows maxBound"
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">readInt "-12345678901234567890 underflows minBound"
</strong>Nothing
</pre></details><p class="src"><a id="v:readInt64" class="def">readInt64</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readInt64" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readInt" title="Data.ByteString.Lazy.Char8">readInt</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int64" title="Data.Int">Int64</a></code>.</p>
<p class="src"><a id="v:readInt32" class="def">readInt32</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int32" title="Data.Int">Int32</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readInt32" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readInt" title="Data.ByteString.Lazy.Char8">readInt</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int32" title="Data.Int">Int32</a></code>.</p>
<p class="src"><a id="v:readInt16" class="def">readInt16</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int16" title="Data.Int">Int16</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readInt16" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readInt" title="Data.ByteString.Lazy.Char8">readInt</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int16" title="Data.Int">Int16</a></code>.</p>
<p class="src"><a id="v:readInt8" class="def">readInt8</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int8" title="Data.Int">Int8</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readInt8" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readInt" title="Data.ByteString.Lazy.Char8">readInt</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int8" title="Data.Int">Int8</a></code>.</p>
<p class="src"><a id="v:readWord" class="def">readWord</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word" title="Data.Word">Word</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readWord" class="link">Source</a> </p>
<p>Try to read a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word" title="Data.Word">Word</a></code> value from the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, returning <code class="inline-code">Just (val, str)</code> on success, where <code class="inline-code">val</code> is the value read and <code class="inline-code">str</code> is the rest of the input string. If the sequence of digits decodes to a value larger than can be represented by a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word" title="Data.Word">Word</a></code>, the returned value will be <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readWord" title="Data.ByteString.Lazy.Char8">readWord</a></code> does not ignore leading whitespace, the value must start with a decimal digit immediately at the beginning of the input string. Leading <code class="inline-code">+</code> signs are not accepted.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:readWord0">Examples</h5>
<details id="ch:readWord0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">readWord "1729 sum of cubes"
</strong>Just (1729," sum of cubes")
&gt;&gt;&gt; <strong class="userinput">readWord "+1729 has an explicit sign"
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">readWord "not a decimal number"
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">readWord "98765432109876543210 overflows maxBound"
</strong>Nothing
</pre></details><p class="src"><a id="v:readWord64" class="def">readWord64</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word64" title="Data.Word">Word64</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readWord64" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readWord" title="Data.ByteString.Lazy.Char8">readWord</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word64" title="Data.Word">Word64</a></code>.</p>
<p class="src"><a id="v:readWord32" class="def">readWord32</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word32" title="Data.Word">Word32</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readWord32" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readWord" title="Data.ByteString.Lazy.Char8">readWord</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word32" title="Data.Word">Word32</a></code>.</p>
<p class="src"><a id="v:readWord16" class="def">readWord16</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word16" title="Data.Word">Word16</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readWord16" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readWord" title="Data.ByteString.Lazy.Char8">readWord</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word16" title="Data.Word">Word16</a></code>.</p>
<p class="src"><a id="v:readWord8" class="def">readWord8</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadInt.html#readWord8" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bytestring-lazy-char8.html#v:readWord" title="Data.ByteString.Lazy.Char8">readWord</a></code> specialised to <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code>.</p>
<p class="src"><a id="v:readInteger" class="def">readInteger</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadNat.html#readInteger" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readInteger" title="Data.ByteString.Lazy.Char8">readInteger</a></code> reads an <code><a href="../base-4.21.0.0-8e62/prelude.html#t:Integer" title="Prelude">Integer</a></code> from the beginning of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. If there is no <code><a href="../base-4.21.0.0-8e62/prelude.html#t:Integer" title="Prelude">Integer</a></code> at the beginning of the string, it returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, otherwise it just returns the <code><a href="../base-4.21.0.0-8e62/prelude.html#t:Integer" title="Prelude">Integer</a></code> read, and the rest of the string.</p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readInteger" title="Data.ByteString.Lazy.Char8">readInteger</a></code> does not ignore leading whitespace, the value must start immediately at the beginning of the input string.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:readInteger0">Examples</h5>
<details id="ch:readInteger0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">readInteger "-000111222333444555666777888999 all done"
</strong>Just (-111222333444555666777888999," all done")
&gt;&gt;&gt; <strong class="userinput">readInteger "+1: readInteger also accepts a leading '+'"
</strong>Just (1, ": readInteger also accepts a leading '+'")
&gt;&gt;&gt; <strong class="userinput">readInteger "not a decimal number"
</strong>Nothing
</pre></details><p class="src"><a id="v:readNatural" class="def">readNatural</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/ghc-typelits.html#t:Natural" title="GHC.TypeLits">Natural</a>, <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.ReadNat.html#readNatural" class="link">Source</a> </p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readNatural" title="Data.ByteString.Lazy.Char8">readNatural</a></code> reads a <code><a href="../base-4.21.0.0-8e62/ghc-typelits.html#t:Natural" title="GHC.TypeLits">Natural</a></code> number from the beginning of the <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. If there is no <code><a href="../base-4.21.0.0-8e62/ghc-typelits.html#t:Natural" title="GHC.TypeLits">Natural</a></code> number at the beginning of the string, it returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, otherwise it just returns the number read, and the rest of the string.</p>
<p><code><a href="data-bytestring-lazy-char8.html#v:readNatural" title="Data.ByteString.Lazy.Char8">readNatural</a></code> does not ignore leading whitespace, the value must start with a decimal digit immediately at the beginning of the input string. Leading <code class="inline-code">+</code> signs are not accepted.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:readNatural0">Examples</h5>
<details id="ch:readNatural0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">readNatural "000111222333444555666777888999 all done"
</strong>Just (111222333444555666777888999," all done")
&gt;&gt;&gt; <strong class="userinput">readNatural "+000111222333444555666777888999 explicit sign"
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">readNatural "not a decimal number"
</strong>Nothing
</pre></details><a href="#g:26" id="g:26"><h2>I/O with ByteStrings</h2></a><p>ByteString I/O uses binary mode, without any character decoding or newline conversion. The fact that it does not respect the Handle newline mode is considered a flaw and may be changed in a future version.</p>
<a href="#g:27" id="g:27"><h3>Standard input and output</h3></a><p class="src"><a id="v:getContents" class="def">getContents</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#getContents" class="link">Source</a> </p>
<p>getContents. Equivalent to hGetContents stdin. Will read <em>lazily</em></p>
<p class="src"><a id="v:putStr" class="def">putStr</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#putStr" class="link">Source</a> </p>
<p>Write a ByteString to <code><a href="../base-4.21.0.0-8e62/ghc-io-stdhandles.html#v:stdout" title="GHC.IO.StdHandles">stdout</a></code>.</p>
<p>The chunks will be written one at a time. Other threads might write to the <code><a href="../base-4.21.0.0-8e62/ghc-io-stdhandles.html#v:stdout" title="GHC.IO.StdHandles">stdout</a></code> in between, and hence <code><a href="data-bytestring-lazy-char8.html#v:putStr" title="Data.ByteString.Lazy.Char8">putStr</a></code> alone is not suitable for concurrent writes.</p>
<p class="src"><a id="v:putStrLn" class="def">putStrLn</a> :: <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#putStrLn" class="link">Source</a> </p>
<p>Write a ByteString to <code><a href="../base-4.21.0.0-8e62/ghc-io-stdhandles.html#v:stdout" title="GHC.IO.StdHandles">stdout</a></code>, appending a newline byte.</p>
<p>The chunks will be written one at a time, followed by a newline. Other threads might write to the <code><a href="../base-4.21.0.0-8e62/ghc-io-stdhandles.html#v:stdout" title="GHC.IO.StdHandles">stdout</a></code> in between, and hence <code><a href="data-bytestring-lazy-char8.html#v:putStrLn" title="Data.ByteString.Lazy.Char8">putStrLn</a></code> alone is not suitable for concurrent writes.</p>
<p class="src"><a id="v:interact" class="def">interact</a> :: (<a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a>) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#interact" class="link">Source</a> </p>
<p>The interact function takes a function of type <code class="inline-code">ByteString -&gt; ByteString</code> as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</p>
<a href="#g:28" id="g:28"><h3>Files</h3></a><p class="src"><a id="v:readFile" class="def">readFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#readFile" class="link">Source</a> </p>
<p>Read an entire file <em>lazily</em> into a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>.</p>
<p>The <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code> will be held open until EOF is encountered.</p>
<p>Note that this function's implementation relies on <code><a href="data-bytestring-lazy-char8.html#v:hGetContents" title="Data.ByteString.Lazy.Char8">hGetContents</a></code>. The reader is advised to read its documentation.</p>
<p class="src"><a id="v:writeFile" class="def">writeFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#writeFile" class="link">Source</a> </p>
<p>Write a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to a file.</p>
<p class="src"><a id="v:appendFile" class="def">appendFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#appendFile" class="link">Source</a> </p>
<p>Append a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to a file.</p>
<a href="#g:29" id="g:29"><h3>I/O with Handles</h3></a><p class="src"><a id="v:hGetContents" class="def">hGetContents</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hGetContents" class="link">Source</a> </p>
<p>Read entire handle contents <em>lazily</em> into a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>. Chunks are read on demand, using the default chunk size.</p>
<p>File handles are closed on EOF if all the file is read, or through garbage collection otherwise.</p>
<p class="src"><a id="v:hGet" class="def">hGet</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hGet" class="link">Source</a> </p>
<p>Read <code class="inline-code">n</code> bytes into a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code>, directly from the specified <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code>.</p>
<p class="src"><a id="v:hGetNonBlocking" class="def">hGetNonBlocking</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hGetNonBlocking" class="link">Source</a> </p>
<p>hGetNonBlocking is similar to <code><a href="data-bytestring-lazy-char8.html#v:hGet" title="Data.ByteString.Lazy.Char8">hGet</a></code>, except that it will never block waiting for data to become available, instead it returns only whatever data is available. If there is no data available to be read, <code><a href="data-bytestring-lazy-char8.html#v:hGetNonBlocking" title="Data.ByteString.Lazy.Char8">hGetNonBlocking</a></code> returns <code><a href="data-bytestring-lazy-char8.html#v:empty" title="Data.ByteString.Lazy.Char8">empty</a></code>.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring-lazy-char8.html#v:hGet" title="Data.ByteString.Lazy.Char8">hGet</a></code>.</p>
<p class="src"><a id="v:hPut" class="def">hPut</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hPut" class="link">Source</a> </p>
<p>Outputs a <code><a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a></code> to the specified <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code>.</p>
<p>The chunks will be written one at a time. Other threads might write to the <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code> in between, and hence <code><a href="data-bytestring-lazy-char8.html#v:hPut" title="Data.ByteString.Lazy.Char8">hPut</a></code> alone is not suitable for concurrent writes.</p>
<p class="src"><a id="v:hPutNonBlocking" class="def">hPutNonBlocking</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hPutNonBlocking" class="link">Source</a> </p>
<p>Similar to <code><a href="data-bytestring-lazy-char8.html#v:hPut" title="Data.ByteString.Lazy.Char8">hPut</a></code> except that it will never block. Instead it returns any tail that did not get written. This tail may be <code><a href="data-bytestring-lazy-char8.html#v:empty" title="Data.ByteString.Lazy.Char8">empty</a></code> in the case that the whole string was written, or the whole original string if nothing was written. Partial writes are also possible.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring-lazy-char8.html#v:hPut" title="Data.ByteString.Lazy.Char8">hPut</a></code>.</p>
<p class="src"><a id="v:hPutStr" class="def">hPutStr</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.html#hPutStr" class="link">Source</a> </p>
<p>A synonym for <code><a href="data-bytestring-lazy-char8.html#v:hPut" title="Data.ByteString.Lazy.Char8">hPut</a></code>, for compatibility</p>
<p class="src"><a id="v:hPutStrLn" class="def">hPutStrLn</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring-lazy-char8.html#t:ByteString" title="Data.ByteString.Lazy.Char8">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Char8.html#hPutStrLn" class="link">Source</a> </p>
<p>Write a ByteString to a handle, appending a newline byte.</p>
<p>The chunks will be written one at a time, followed by a newline. Other threads might write to the <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code> in between, and hence <code><a href="data-bytestring-lazy-char8.html#v:hPutStrLn" title="Data.ByteString.Lazy.Char8">hPutStrLn</a></code> alone is not suitable for concurrent writes.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/Data-ByteString-Lazy-Char8.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/Data-ByteString-Lazy-Char8.html</a>
  </p>
</div>
