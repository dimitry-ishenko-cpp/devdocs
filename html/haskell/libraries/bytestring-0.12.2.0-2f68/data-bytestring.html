<h1 class="caption">Data.ByteString</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 2001<br>(c) David Roundy 2003-2005<br>(c) Simon Marlow 2005<br>(c) Bjorn Bringert 2006<br>(c) Don Stewart 2005-2008<br>(c) Duncan Coutts 2006-2013</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>dons00@gmail.com, duncan@community.haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>stable</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li>
<a href="#g:1">Strict <code class="inline-code">ByteString</code></a><ul><li><a href="#g:2">Heap fragmentation</a></li></ul>
</li>
<li><a href="#g:3">Introducing and eliminating <code>ByteString</code>s</a></li>
<li><a href="#g:4">Basic interface</a></li>
<li><a href="#g:5">Transforming ByteStrings</a></li>
<li>
<a href="#g:6">Reducing <code>ByteString</code>s (folds)</a><ul><li><a href="#g:7">Special folds</a></li></ul>
</li>
<li>
<a href="#g:8">Building ByteStrings</a><ul>
<li><a href="#g:9">Scans</a></li>
<li><a href="#g:10">Accumulating maps</a></li>
<li><a href="#g:11">Generating and unfolding ByteStrings</a></li>
</ul>
</li>
<li>
<a href="#g:12">Substrings</a><ul>
<li><a href="#g:13">Breaking strings</a></li>
<li><a href="#g:14">Breaking into many substrings</a></li>
</ul>
</li>
<li>
<a href="#g:15">Predicates</a><ul>
<li><a href="#g:16">Encoding validation</a></li>
<li><a href="#g:17">Search for arbitrary substrings</a></li>
</ul>
</li>
<li>
<a href="#g:18">Searching ByteStrings</a><ul>
<li><a href="#g:19">Searching by equality</a></li>
<li><a href="#g:20">Searching with a predicate</a></li>
</ul>
</li>
<li><a href="#g:21">Indexing ByteStrings</a></li>
<li><a href="#g:22">Zipping and unzipping ByteStrings</a></li>
<li><a href="#g:23">Ordered ByteStrings</a></li>
<li>
<a href="#g:24">Low level conversions</a><ul>
<li><a href="#g:25">Copying ByteStrings</a></li>
<li><a href="#g:26">Packing <code>CString</code>s and pointers</a></li>
<li><a href="#g:27">Using ByteStrings as <code>CString</code>s</a></li>
</ul>
</li>
<li>
<a href="#g:28">I/O with <code>ByteString</code>s</a><ul>
<li><a href="#g:29">Standard input and output</a></li>
<li><a href="#g:30">Files</a></li>
<li><a href="#g:31">I/O with Handles</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code> arrays of bytes, held in a <code><a href="../base-4.21.0.0-8e62/foreign-foreignptr.html#t:ForeignPtr" title="Foreign.ForeignPtr">ForeignPtr</a></code>, and can be passed between C and Haskell with little effort.</p>
<p>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from <a href="data-bytestring-builder.html">Data.ByteString.Builder</a>.</p>
<p>This module is intended to be imported <code class="inline-code">qualified</code>, to avoid name clashes with <a href="../base-4.21.0.0-8e62/prelude.html">Prelude</a> functions. eg.</p>
<pre>import qualified Data.ByteString as B</pre>
<p>Original GHC implementation by Bryan O'Sullivan. Rewritten to use <code><a href="data-array-unboxed.html#v:UArray" title="Data.Array.Unboxed">UArray</a></code> by Simon Marlow. Rewritten to support slices and use <code><a href="../base-4.21.0.0-8e62/foreign-foreignptr.html#t:ForeignPtr" title="Foreign.ForeignPtr">ForeignPtr</a></code> by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</p>
</div>
<a href="#g:1" id="g:1"><h2>Strict ByteString</h2></a><p class="src">data <a id="t:ByteString" class="def">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#ByteString" class="link">Source</a> </p>
<p>A space-efficient representation of a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code> vector, supporting many efficient operations.</p>
<p>A <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> contains 8-bit bytes, or by using the operations from <a href="data-bytestring-char8.html">Data.ByteString.Char8</a> it can be interpreted as containing 8-bit characters.</p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:ByteString">Instances</h5>
<details id="i:ByteString" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../deepseq-1.5.1.0-18b1/control-deepseq.html#t:NFData" title="Control.DeepSeq">NFData</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-327" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:NFData:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:rnf">rnf</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/deepseq-1.5.1.0-18b1/src/Control.DeepSeq.html#rnf" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-322" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Monoid:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mempty">mempty</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:mappend">mappend</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-316" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Semigroup:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:stimes">stimes</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-348" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Data:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:gfoldl">gfoldl</a> :: (forall d b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (d -&gt; b) -&gt; d -&gt; c b) -&gt; (forall g. g -&gt; c g) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; c <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:gunfold">gunfold</a> :: (forall b r. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; c (b -&gt; r) -&gt; c r) -&gt; (forall r. r -&gt; c r) -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> -&gt; c <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:toConstr">toConstr</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> </p>
<p class="src"><a href="#v:dataTypeOf">dataTypeOf</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:DataType" title="Data.Data">DataType</a> </p>
<p class="src"><a href="#v:dataCast1">dataCast1</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (t d)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) </p>
<p class="src"><a href="#v:dataCast2">dataCast2</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d e. (<a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d, <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> e) =&gt; c (t d e)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) </p>
<p class="src"><a href="#v:gmapT">gmapT</a> :: (forall b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; b -&gt; b) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:gmapQl">gmapQl</a> :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; r </p>
<p class="src"><a href="#v:gmapQr">gmapQr</a> :: forall r r'. (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; r </p>
<p class="src"><a href="#v:gmapQ">gmapQ</a> :: (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [u] </p>
<p class="src"><a href="#v:gmapQi">gmapQi</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; u </p>
<p class="src"><a href="#v:gmapM">gmapM</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:gmapMp">gmapMp</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:gmapMo">gmapMo</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-string.html#t:IsString" title="Data.String">IsString</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-344" class="link">Source</a> </td>
<td class="doc"><p>Beware: <code><a href="../base-4.21.0.0-8e62/data-string.html#v:fromString" title="Data.String">fromString</a></code> truncates multi-byte characters to octets. e.g. "枯朶に烏のとまりけり秋の暮" becomes �6k�nh~�Q��n�</p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:IsString:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromString">fromString</a> :: <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:IsList" title="GHC.Exts">IsList</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-337" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: bytestring-0.10.12.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:IsList:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:if:D:R:ItemByteString:Item:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> = <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromList">fromList</a> :: [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:toList">toList</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-333" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Read:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:readList">readList</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] </p>
<p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
<p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-330" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Show:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-310" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Eq:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3D%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%2F%3D" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-313" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Ord:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:compare">compare</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#compare" class="link">Source</a> </p>
<p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:max">max</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#max" class="link">Source</a> </p>
<p class="src"><a href="#v:min">min</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#min" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-363" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: bytestring-0.11.2.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Lift:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:lift">lift</a> :: <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> </p>
<p class="src"><a href="#v:liftTyped">liftTyped</a> :: forall (m :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>). <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Code" title="Language.Haskell.TH.Syntax">Code</a> m <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#line-338" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:ByteString:Item:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bytestring-internal-type.html">Data.ByteString.Internal.Type</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> = <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</div></details></td></tr>
</table></details>
</div>
<p class="src">type <a id="t:StrictByteString" class="def">StrictByteString</a> = <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#StrictByteString" class="link">Source</a> </p>
<p>Type synonym for the strict flavour of <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<a href="#g:2" id="g:2"><h3>Heap fragmentation</h3></a><p>With GHC, the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> representation uses <em>pinned memory</em>, meaning it cannot be moved by GC. While this is ideal for use with the foreign function interface and is usually efficient, this representation may lead to issues with heap fragmentation and wasted space if the program selectively retains a fraction of many small <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s, keeping them live in memory over long durations.</p>
<p>While <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> is indispensable when working with large blobs of data and especially when interfacing with native C libraries, be sure to also check the <code><a href="data-bytestring-short.html#v:ShortByteString" title="Data.ByteString.Short">ShortByteString</a></code> type. As a type backed by <em>unpinned</em> memory, <code class="inline-code">ShortByteString</code> behaves similarly to <code class="inline-code">Text</code> (from the <code class="inline-code">text</code> package) on the heap, completely avoids fragmentation issues, and in many use-cases may better suit your bytestring-storage needs.</p>
<a href="#g:3" id="g:3"><h2>Introducing and eliminating ByteStrings</h2></a><p class="src"><a id="v:empty" class="def">empty</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Internal.Type.html#empty" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> The empty <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code></p>
<p class="src"><a id="v:singleton" class="def">singleton</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#singleton" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Convert a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code> into a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code></p>
<p class="src"><a id="v:pack" class="def">pack</a> :: [<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#pack" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Convert a <code class="inline-code">[<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>]</code> into a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p>For applications with large numbers of string literals, <code><a href="data-bytestring.html#v:pack" title="Data.ByteString">pack</a></code> can be a bottleneck. In such cases, consider using <code><a href="data-bytestring-unsafe.html#v:unsafePackAddress" title="Data.ByteString.Unsafe">unsafePackAddress</a></code> (GHC only).</p>
<p class="src"><a id="v:unpack" class="def">unpack</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#unpack" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Converts a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to a <code class="inline-code">[<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>]</code>.</p>
<p class="src"><a id="v:fromStrict" class="def">fromStrict</a> :: <a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a> -&gt; <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#fromStrict" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Convert a <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code> into a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code>.</p>
<p class="src"><a id="v:toStrict" class="def">toStrict</a> :: <a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a> -&gt; <a href="data-bytestring.html#t:StrictByteString" title="Data.ByteString">StrictByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.Lazy.Internal.html#toStrict" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Convert a <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> into a <code><a href="s.html#v:StrictByteString" title="S">StrictByteString</a></code>.</p>
<p>Note that this is an <em>expensive</em> operation that forces the whole <code><a href="data-bytestring-lazy.html#t:LazyByteString" title="Data.ByteString.Lazy">LazyByteString</a></code> into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</p>
<p class="src"><a id="v:fromFilePath" class="def">fromFilePath</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#fromFilePath" class="link">Source</a> </p>
<p>Convert a <code><a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a></code> to a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p>The <code><a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a></code> type is expected to use the file system encoding as reported by <code><a href="../base-4.21.0.0-8e62/ghc-io-encoding.html#v:getFileSystemEncoding" title="GHC.IO.Encoding">getFileSystemEncoding</a></code>. This encoding allows for round-tripping of arbitrary data on platforms that allow arbitrary bytes in their paths. This conversion function does the same thing that <code><a href="../base-4.21.0.0-8e62/system-io.html#v:openFile" title="System.IO">openFile</a></code> would do when decoding the <code><a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a></code>.</p>
<p>This function is in <code><a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a></code> because the file system encoding can be changed. If the encoding can be assumed to be constant in your use case, you may invoke this function via <code class="inline-code">unsafePerformIO</code>.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<p class="src"><a id="v:toFilePath" class="def">toFilePath</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#toFilePath" class="link">Source</a> </p>
<p>Convert a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to a <code><a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a></code>.</p>
<p>This function uses the file system encoding, and resulting <code><a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a></code>s can be safely used with standard IO functions and will reference the correct path in the presence of arbitrary non-UTF-8 encoded paths.</p>
<p>This function is in <code><a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a></code> because the file system encoding can be changed. If the encoding can be assumed to be constant in your use case, you may invoke this function via <code class="inline-code">unsafePerformIO</code>.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<a href="#g:4" id="g:4"><h2>Basic interface</h2></a><p class="src"><a id="v:cons" class="def">cons</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#cons" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:cons" title="Data.ByteString">cons</a></code> is analogous to (:) for lists, but of different complexity, as it requires making a copy.</p>
<p class="src"><a id="v:snoc" class="def">snoc</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <span class="fixity">infixl 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#snoc" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Append a byte to the end of a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code></p>
<p class="src"><a id="v:append" class="def">append</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#append" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Append two ByteStrings</p>
<p class="src"><a id="v:head" class="def">head</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#head" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the first element of a ByteString, which must be non-empty. An exception will be thrown in the case of an empty ByteString.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring.html#v:uncons" title="Data.ByteString">uncons</a></code> instead.</p>
<p class="src"><a id="v:uncons" class="def">uncons</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#uncons" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the <code><a href="data-bytestring.html#v:head" title="Data.ByteString">head</a></code> and <code><a href="data-bytestring.html#v:tail" title="Data.ByteString">tail</a></code> of a ByteString, returning <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is empty.</p>
<p class="src"><a id="v:unsnoc" class="def">unsnoc</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#unsnoc" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the <code><a href="data-bytestring.html#v:init" title="Data.ByteString">init</a></code> and <code><a href="data-bytestring.html#v:last" title="Data.ByteString">last</a></code> of a ByteString, returning <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is empty.</p>
<p class="src"><a id="v:last" class="def">last</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#last" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the last element of a ByteString, which must be finite and non-empty. An exception will be thrown in the case of an empty ByteString.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring.html#v:unsnoc" title="Data.ByteString">unsnoc</a></code> instead.</p>
<p class="src"><a id="v:tail" class="def">tail</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#tail" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Extract the elements after the head of a ByteString, which must be non-empty. An exception will be thrown in the case of an empty ByteString.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring.html#v:uncons" title="Data.ByteString">uncons</a></code> instead.</p>
<p class="src"><a id="v:init" class="def">init</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#init" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Returns all the elements of a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> except the last one. An exception will be thrown in the case of an empty ByteString.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring.html#v:unsnoc" title="Data.ByteString">unsnoc</a></code> instead.</p>
<p class="src"><a id="v:null" class="def">null</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#null" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> Test whether a ByteString is empty.</p>
<p class="src"><a id="v:length" class="def">length</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#length" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#v:length" title="Data.ByteString">length</a></code> returns the length of a ByteString as an <code><a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a></code>.</p>
<a href="#g:5" id="g:5"><h2>Transforming ByteStrings</h2></a><p class="src"><a id="v:map" class="def">map</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#map" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:map" title="Data.ByteString">map</a></code> <code class="inline-code">f xs</code> is the ByteString obtained by applying <code class="inline-code">f</code> to each element of <code class="inline-code">xs</code>.</p>
<p class="src"><a id="v:reverse" class="def">reverse</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#reverse" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:reverse" title="Data.ByteString">reverse</a></code> <code class="inline-code">xs</code> efficiently returns the elements of <code class="inline-code">xs</code> in reverse order.</p>
<p class="src"><a id="v:intersperse" class="def">intersperse</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#intersperse" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:intersperse" title="Data.ByteString">intersperse</a></code> function takes a <code><a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a></code> and a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> and `intersperses' that byte between the elements of the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>. It is analogous to the intersperse function on Lists.</p>
<p class="src"><a id="v:intercalate" class="def">intercalate</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#intercalate" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:intercalate" title="Data.ByteString">intercalate</a></code> function takes a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> and a list of <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s and concatenates the list after interspersing the first argument between each element of the list.</p>
<p class="src"><a id="v:transpose" class="def">transpose</a> :: [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#transpose" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring.html#v:transpose" title="Data.ByteString">transpose</a></code> function transposes the rows and columns of its <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> argument.</p>
<a href="#g:6" id="g:6"><h2>Reducing ByteStrings (folds)</h2></a><p class="src"><a id="v:foldl" class="def">foldl</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldl" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldl" title="Data.ByteString">foldl</a></code>, applied to a binary operator, a starting value (typically the left-identity of the operator), and a ByteString, reduces the ByteString using the binary operator, from left to right.</p>
<p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldl%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldl-39-" title="Data.ByteString">foldl'</a></code> is like <code><a href="data-bytestring.html#v:foldl" title="Data.ByteString">foldl</a></code>, but strict in the accumulator.</p>
<p class="src"><a id="v:foldl1" class="def">foldl1</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldl1" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldl1" title="Data.ByteString">foldl1</a></code> is a variant of <code><a href="data-bytestring.html#v:foldl" title="Data.ByteString">foldl</a></code> that has no starting value argument, and thus must be applied to non-empty <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s. An exception will be thrown in the case of an empty ByteString.</p>
<p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldl1%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldl1-39-" title="Data.ByteString">foldl1'</a></code> is like <code><a href="data-bytestring.html#v:foldl1" title="Data.ByteString">foldl1</a></code>, but strict in the accumulator. An exception will be thrown in the case of an empty ByteString.</p>
<p class="src"><a id="v:foldr" class="def">foldr</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldr" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldr" title="Data.ByteString">foldr</a></code>, applied to a binary operator, a starting value (typically the right-identity of the operator), and a ByteString, reduces the ByteString using the binary operator, from right to left.</p>
<p class="src"><a id="v:foldr-39-" class="def">foldr'</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldr%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldr-39-" title="Data.ByteString">foldr'</a></code> is like <code><a href="data-bytestring.html#v:foldr" title="Data.ByteString">foldr</a></code>, but strict in the accumulator.</p>
<p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldr1" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldr1" title="Data.ByteString">foldr1</a></code> is a variant of <code><a href="data-bytestring.html#v:foldr" title="Data.ByteString">foldr</a></code> that has no starting value argument, and thus must be applied to non-empty <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s An exception will be thrown in the case of an empty ByteString.</p>
<p class="src"><a id="v:foldr1-39-" class="def">foldr1'</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#foldr1%27" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:foldr1-39-" title="Data.ByteString">foldr1'</a></code> is a variant of <code><a href="data-bytestring.html#v:foldr1" title="Data.ByteString">foldr1</a></code>, but is strict in the accumulator.</p>
<a href="#g:7" id="g:7"><h3>Special folds</h3></a><p class="src"><a id="v:concat" class="def">concat</a> :: [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#concat" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Concatenate a list of ByteStrings.</p>
<p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#concatMap" class="link">Source</a> </p>
<p>Map a function over a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> and concatenate the results</p>
<p class="src"><a id="v:any" class="def">any</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#any" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Applied to a predicate and a ByteString, <code><a href="data-bytestring.html#v:any" title="Data.ByteString">any</a></code> determines if any element of the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> satisfies the predicate.</p>
<p class="src"><a id="v:all" class="def">all</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#all" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Applied to a predicate and a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, <code><a href="data-bytestring.html#v:all" title="Data.ByteString">all</a></code> determines if all elements of the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> satisfy the predicate.</p>
<p class="src"><a id="v:maximum" class="def">maximum</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#maximum" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:maximum" title="Data.ByteString">maximum</a></code> returns the maximum value from a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> An exception will be thrown in the case of an empty ByteString.</p>
<p class="src"><a id="v:minimum" class="def">minimum</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#minimum" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:minimum" title="Data.ByteString">minimum</a></code> returns the minimum value from a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> An exception will be thrown in the case of an empty ByteString.</p>
<a href="#g:8" id="g:8"><h2>Building ByteStrings</h2></a><a href="#g:9" id="g:9"><h3>Scans</h3></a><p class="src"><a id="v:scanl" class="def">scanl</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#scanl" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)</td>
<td class="doc"><p>accumulator -&gt; element -&gt; new accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</td>
<td class="doc"><p>starting value of accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>input of length n</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>output of length n+1</p></td>
</tr>
</table>
</div>
<p><code><a href="data-bytestring.html#v:scanl" title="Data.ByteString">scanl</a></code> is similar to <code><a href="data-bytestring.html#v:foldl" title="Data.ByteString">foldl</a></code>, but returns a list of successive reduced values from the left.</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>head (scanl f z xs) == z
last (scanl f z xs) == foldl f z xs</pre>
<p class="src"><a id="v:scanl1" class="def">scanl1</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#scanl1" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:scanl1" title="Data.ByteString">scanl1</a></code> is a variant of <code><a href="data-bytestring.html#v:scanl" title="Data.ByteString">scanl</a></code> that has no starting value argument.</p>
<pre>scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</pre>
<p class="src"><a id="v:scanr" class="def">scanr</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#scanr" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)</td>
<td class="doc"><p>element -&gt; accumulator -&gt; new accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>
</td>
<td class="doc"><p>starting value of accumulator</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>input of length n</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>output of length n+1</p></td>
</tr>
</table>
</div>
<p><code><a href="data-bytestring.html#v:scanr" title="Data.ByteString">scanr</a></code> is similar to <code><a href="data-bytestring.html#v:foldr" title="Data.ByteString">foldr</a></code>, but returns a list of successive reduced values from the right.</p>
<pre>scanr f z [..., x{n-1}, xn] == [..., x{n-1} `f` (xn `f` z), xn `f` z, z]</pre>
<p>Note that</p>
<pre>head (scanr f z xs) == foldr f z xs
last (scanr f z xs) == z</pre>
<p class="src"><a id="v:scanr1" class="def">scanr1</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#scanr1" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:scanr1" title="Data.ByteString">scanr1</a></code> is a variant of <code><a href="data-bytestring.html#v:scanr" title="Data.ByteString">scanr</a></code> that has no starting value argument.</p>
<a href="#g:10" id="g:10"><h3>Accumulating maps</h3></a><p class="src"><a id="v:mapAccumL" class="def">mapAccumL</a> :: (acc -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; (acc, <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)) -&gt; acc -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (acc, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#mapAccumL" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring.html#v:mapAccumL" title="Data.ByteString">mapAccumL</a></code> function behaves like a combination of <code><a href="data-bytestring.html#v:map" title="Data.ByteString">map</a></code> and <code><a href="data-bytestring.html#v:foldl" title="Data.ByteString">foldl</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</p>
<p class="src"><a id="v:mapAccumR" class="def">mapAccumR</a> :: (acc -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; (acc, <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)) -&gt; acc -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (acc, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#mapAccumR" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring.html#v:mapAccumR" title="Data.ByteString">mapAccumR</a></code> function behaves like a combination of <code><a href="data-bytestring.html#v:map" title="Data.ByteString">map</a></code> and <code><a href="data-bytestring.html#v:foldr" title="Data.ByteString">foldr</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</p>
<a href="#g:11" id="g:11"><h3>Generating and unfolding ByteStrings</h3></a><p class="src"><a id="v:replicate" class="def">replicate</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#replicate" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:replicate" title="Data.ByteString">replicate</a></code> <code class="inline-code">n x</code> is a ByteString of length <code class="inline-code">n</code> with <code class="inline-code">x</code> the value of every element. The following holds:</p>
<pre>replicate w c = fst (unfoldrN w (\u -&gt; Just (u,u)) c)</pre>
<p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, a)) -&gt; a -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#unfoldr" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span>, where <em>n</em> is the length of the result. The <code><a href="data-bytestring.html#v:unfoldr" title="Data.ByteString">unfoldr</a></code> function is analogous to the List 'unfoldr'. <code><a href="data-bytestring.html#v:unfoldr" title="Data.ByteString">unfoldr</a></code> builds a ByteString from a seed value. The function takes the element and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is done producing the ByteString or returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> <code class="inline-code">(a,b)</code>, in which case, <code class="inline-code">a</code> is the next byte in the string, and <code class="inline-code">b</code> is the seed value for further production.</p>
<p>Examples:</p>
<pre>   unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
== pack [0, 1, 2, 3, 4, 5]</pre>
<p class="src"><a id="v:unfoldrN" class="def">unfoldrN</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, a)) -&gt; a -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#unfoldrN" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Like <code><a href="data-bytestring.html#v:unfoldr" title="Data.ByteString">unfoldr</a></code>, <code><a href="data-bytestring.html#v:unfoldrN" title="Data.ByteString">unfoldrN</a></code> builds a ByteString from a seed value. However, the length of the result is limited by the first argument to <code><a href="data-bytestring.html#v:unfoldrN" title="Data.ByteString">unfoldrN</a></code>. This function is more efficient than <code><a href="data-bytestring.html#v:unfoldr" title="Data.ByteString">unfoldr</a></code> when the maximum length of the result is known.</p>
<p>The following equation relates <code><a href="data-bytestring.html#v:unfoldrN" title="Data.ByteString">unfoldrN</a></code> and <code><a href="data-bytestring.html#v:unfoldr" title="Data.ByteString">unfoldr</a></code>:</p>
<pre>fst (unfoldrN n f s) == take n (unfoldr f s)</pre>
<a href="#g:12" id="g:12"><h2>Substrings</h2></a><a href="#g:13" id="g:13"><h3>Breaking strings</h3></a><p class="src"><a id="v:take" class="def">take</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#take" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#v:take" title="Data.ByteString">take</a></code> <code class="inline-code">n</code>, applied to a ByteString <code class="inline-code">xs</code>, returns the prefix of <code class="inline-code">xs</code> of length <code class="inline-code">n</code>, or <code class="inline-code">xs</code> itself if <code class="inline-code">n &gt; <a href="data-bytestring.html#v:length" title="Data.ByteString">length</a> xs</code>.</p>
<p class="src"><a id="v:takeEnd" class="def">takeEnd</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#takeEnd" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code class="inline-code"><a href="data-bytestring.html#v:takeEnd" title="Data.ByteString">takeEnd</a> n xs</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:drop" title="Data.ByteString">drop</a> (<a href="data-bytestring.html#v:length" title="Data.ByteString">length</a> xs - n) xs</code>. Takes <code class="inline-code">n</code> elements from end of bytestring.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeEnd 3 "abcdefg"
</strong>"efg"
&gt;&gt;&gt; <strong class="userinput">takeEnd 0 "abcdefg"
</strong>""
&gt;&gt;&gt; <strong class="userinput">takeEnd 4 "abc"
</strong>"abc"
</pre>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:drop" class="def">drop</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#drop" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#v:drop" title="Data.ByteString">drop</a></code> <code class="inline-code">n xs</code> returns the suffix of <code class="inline-code">xs</code> after the first <code class="inline-code">n</code> elements, or <code><a href="data-bytestring.html#v:empty" title="Data.ByteString">empty</a></code> if <code class="inline-code">n &gt; <a href="data-bytestring.html#v:length" title="Data.ByteString">length</a> xs</code>.</p>
<p class="src"><a id="v:dropEnd" class="def">dropEnd</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#dropEnd" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code class="inline-code"><a href="data-bytestring.html#v:dropEnd" title="Data.ByteString">dropEnd</a> n xs</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:take" title="Data.ByteString">take</a> (<a href="data-bytestring.html#v:length" title="Data.ByteString">length</a> xs - n) xs</code>. Drops <code class="inline-code">n</code> elements from end of bytestring.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropEnd 3 "abcdefg"
</strong>"abcd"
&gt;&gt;&gt; <strong class="userinput">dropEnd 0 "abcdefg"
</strong>"abcdefg"
&gt;&gt;&gt; <strong class="userinput">dropEnd 4 "abc"
</strong>""
</pre>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#splitAt" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#v:splitAt" title="Data.ByteString">splitAt</a></code> <code class="inline-code">n xs</code> is equivalent to <code class="inline-code">(<a href="data-bytestring.html#v:take" title="Data.ByteString">take</a> n xs, <a href="data-bytestring.html#v:drop" title="Data.ByteString">drop</a> n xs)</code>.</p>
<p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#takeWhile" class="link">Source</a> </p>
<p>Similar to <code><a href="../base-4.21.0.0-8e62/prelude.html#v:takeWhile" title="Prelude">takeWhile</a></code>, returns the longest (possibly empty) prefix of elements satisfying the predicate.</p>
<p class="src"><a id="v:takeWhileEnd" class="def">takeWhileEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#takeWhileEnd" class="link">Source</a> </p>
<p>Returns the longest (possibly empty) suffix of elements satisfying the predicate.</p>
<p><code class="inline-code"><a href="data-bytestring.html#v:takeWhileEnd" title="Data.ByteString">takeWhileEnd</a> p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:reverse" title="Data.ByteString">reverse</a> . <a href="data-bytestring.html#v:takeWhile" title="Data.ByteString">takeWhile</a> p . <a href="data-bytestring.html#v:reverse" title="Data.ByteString">reverse</a></code>.</p>
<p><span class="version">Since: bytestring-0.10.12.0</span></p>
<p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#dropWhile" class="link">Source</a> </p>
<p>Similar to <code><a href="../base-4.21.0.0-8e62/prelude.html#v:dropWhile" title="Prelude">dropWhile</a></code>, drops the longest (possibly empty) prefix of elements satisfying the predicate and returns the remainder.</p>
<p class="src"><a id="v:dropWhileEnd" class="def">dropWhileEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#dropWhileEnd" class="link">Source</a> </p>
<p>Similar to <code><a href="../base-4.21.0.0-8e62/prelude.html#v:dropWhileEnd" title="Prelude">dropWhileEnd</a></code>, drops the longest (possibly empty) suffix of elements satisfying the predicate and returns the remainder.</p>
<p><code class="inline-code"><a href="data-bytestring.html#v:dropWhileEnd" title="Data.ByteString">dropWhileEnd</a> p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:reverse" title="Data.ByteString">reverse</a> . <a href="data-bytestring.html#v:dropWhile" title="Data.ByteString">dropWhile</a> p . <a href="data-bytestring.html#v:reverse" title="Data.ByteString">reverse</a></code>.</p>
<p><span class="version">Since: bytestring-0.10.12.0</span></p>
<p class="src"><a id="v:span" class="def">span</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#span" class="link">Source</a> </p>
<p>Similar to <code><a href="../base-4.21.0.0-8e62/prelude.html#v:span" title="Prelude">span</a></code>, returns the longest (possibly empty) prefix of elements satisfying the predicate and the remainder of the string.</p>
<p><code><a href="data-bytestring.html#v:span" title="Data.ByteString">span</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:break" title="Data.ByteString">break</a> (not . p)</code> and to <code class="inline-code">(<a href="data-bytestring.html#v:takeWhile" title="Data.ByteString">takeWhile</a> p &amp;&amp;&amp; <a href="data-bytestring.html#v:dropWhile" title="Data.ByteString">dropWhile</a> p)</code>.</p>
<p class="src"><a id="v:spanEnd" class="def">spanEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#spanEnd" class="link">Source</a> </p>
<p>Returns the longest (possibly empty) suffix of elements satisfying the predicate and the remainder of the string.</p>
<p><code><a href="data-bytestring.html#v:spanEnd" title="Data.ByteString">spanEnd</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:breakEnd" title="Data.ByteString">breakEnd</a> (not . p)</code> and to <code class="inline-code">(<a href="data-bytestring.html#v:dropWhileEnd" title="Data.ByteString">dropWhileEnd</a> p &amp;&amp;&amp; <a href="data-bytestring.html#v:takeWhileEnd" title="Data.ByteString">takeWhileEnd</a> p)</code>.</p>
<p>We have</p>
<pre>spanEnd (not . isSpace) "x y z" == ("x y ", "z")</pre>
<p>and</p>
<pre>spanEnd (not . isSpace) ps
   ==
let (x, y) = span (not . isSpace) (reverse ps) in (reverse y, reverse x)</pre>
<p class="src"><a id="v:break" class="def">break</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#break" class="link">Source</a> </p>
<p>Similar to <code><a href="../base-4.21.0.0-8e62/prelude.html#v:break" title="Prelude">break</a></code>, returns the longest (possibly empty) prefix of elements which <strong>do not</strong> satisfy the predicate and the remainder of the string.</p>
<p><code><a href="data-bytestring.html#v:break" title="Data.ByteString">break</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:span" title="Data.ByteString">span</a> (not . p)</code> and to <code class="inline-code">(<a href="data-bytestring.html#v:takeWhile" title="Data.ByteString">takeWhile</a> (not . p) &amp;&amp;&amp; <a href="data-bytestring.html#v:dropWhile" title="Data.ByteString">dropWhile</a> (not . p))</code>.</p>
<p>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</p>
<pre>break ((==) x) = breakByte x
break (==x) = breakByte x</pre>
<p class="src"><a id="v:breakEnd" class="def">breakEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#breakEnd" class="link">Source</a> </p>
<p>Returns the longest (possibly empty) suffix of elements which <strong>do not</strong> satisfy the predicate and the remainder of the string.</p>
<p><code><a href="data-bytestring.html#v:breakEnd" title="Data.ByteString">breakEnd</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-bytestring.html#v:spanEnd" title="Data.ByteString">spanEnd</a> (not . p)</code> and to <code class="inline-code">(<a href="data-bytestring.html#v:dropWhileEnd" title="Data.ByteString">dropWhileEnd</a> (not . p) &amp;&amp;&amp; <a href="data-bytestring.html#v:takeWhileEnd" title="Data.ByteString">takeWhileEnd</a> (not . p))</code>.</p>
<p class="src"><a id="v:group" class="def">group</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#group" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring.html#v:group" title="Data.ByteString">group</a></code> function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each string in the result contains only equal elements. For example,</p>
<pre>group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</pre>
<p>It is a special case of <code><a href="data-bytestring.html#v:groupBy" title="Data.ByteString">groupBy</a></code>, which allows the programmer to supply their own equality test. It is about 40% faster than <em>groupBy (==)</em></p>
<p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#groupBy" class="link">Source</a> </p>
<p>The <code><a href="data-bytestring.html#v:groupBy" title="Data.ByteString">groupBy</a></code> function is the non-overloaded version of <code><a href="data-bytestring.html#v:group" title="Data.ByteString">group</a></code>.</p>
<p class="src"><a id="v:inits" class="def">inits</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#inits" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all initial segments of the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, shortest first.</p>
<p class="src"><a id="v:tails" class="def">tails</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#tails" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all final segments of the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, longest first.</p>
<p class="src"><a id="v:initsNE" class="def">initsNE</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#initsNE" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all initial segments of the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, shortest first.</p>
<p><span class="version">Since: bytestring-0.11.4.0</span></p>
<p class="src"><a id="v:tailsNE" class="def">tailsNE</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#tailsNE" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Returns all final segments of the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, longest first.</p>
<p><span class="version">Since: bytestring-0.11.4.0</span></p>
<p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#stripPrefix" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:stripPrefix" title="Data.ByteString">stripPrefix</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the remainder of the second iff the first is its prefix, and otherwise <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<p><span class="version">Since: bytestring-0.10.8.0</span></p>
<p class="src"><a id="v:stripSuffix" class="def">stripSuffix</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#stripSuffix" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:stripSuffix" title="Data.ByteString">stripSuffix</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the remainder of the second iff the first is its suffix, and otherwise <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<a href="#g:14" id="g:14"><h3>Breaking into many substrings</h3></a><p class="src"><a id="v:split" class="def">split</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#split" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Break a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> into pieces separated by the byte argument, consuming the delimiter. I.e.</p>
<pre>split 10  "a\nb\nd\ne" == ["a","b","d","e"]   -- fromEnum '\n' == 10
split 97  "aXaXaXa"    == ["","X","X","X",""] -- fromEnum 'a' == 97
split 120 "x"          == ["",""]             -- fromEnum 'x' == 120
split undefined ""     == []                  -- and not [""]</pre>
<p>and</p>
<pre>intercalate [c] . split c == id
split == splitWith . (==)</pre>
<p>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s that are slices of the original.</p>
<p class="src"><a id="v:splitWith" class="def">splitWith</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#splitWith" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Splits a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</p>
<pre>splitWith (==97) "aabbaca" == ["","","bb","c",""] -- fromEnum 'a' == 97
splitWith undefined ""     == []                  -- and not [""]</pre>
<a href="#g:15" id="g:15"><h2>Predicates</h2></a><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#isPrefixOf" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:isPrefixOf" title="Data.ByteString">isPrefixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> if the first is a prefix of the second.</p>
<p class="src"><a id="v:isSuffixOf" class="def">isSuffixOf</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#isSuffixOf" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:isSuffixOf" title="Data.ByteString">isSuffixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first is a suffix of the second.</p>
<p>The following holds:</p>
<pre>isSuffixOf x y == reverse x `isPrefixOf` reverse y</pre>
<p>However, the real implementation uses memcmp to compare the end of the string only, with no reverse required..</p>
<p class="src"><a id="v:isInfixOf" class="def">isInfixOf</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#isInfixOf" class="link">Source</a> </p>
<p>Check whether one string is a substring of another.</p>
<a href="#g:16" id="g:16"><h3>Encoding validation</h3></a><p class="src"><a id="v:isValidUtf8" class="def">isValidUtf8</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#isValidUtf8" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Check whether a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> represents valid UTF-8.</p>
<p><span class="version">Since: bytestring-0.11.2.0</span></p>
<a href="#g:17" id="g:17"><h3>Search for arbitrary substrings</h3></a><p class="src"><a id="v:breakSubstring" class="def">breakSubstring</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#breakSubstring" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>String to search for</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>
</td>
<td class="doc"><p>String to search in</p></td>
</tr>
<tr>
<td class="src">-&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>)</td>
<td class="doc"><p>Head and tail of string broken at substring</p></td>
</tr>
</table>
</div>
<p>Break a string on a substring, returning a pair of the part of the string prior to the match, and the rest of the string.</p>
<p>The following relationships hold:</p>
<pre>break (== c) l == breakSubstring (singleton c) l</pre>
<p>For example, to tokenise a string, dropping delimiters:</p>
<pre>tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
    where (h,t) = breakSubstring x y</pre>
<p>To skip to the first occurrence of a string:</p>
<pre>snd (breakSubstring x y)</pre>
<p>To take the parts of a string before a delimiter:</p>
<pre>fst (breakSubstring x y)</pre>
<p>Note that calling `breakSubstring x` does some preprocessing work, so you should avoid unnecessarily duplicating breakSubstring calls with the same pattern.</p>
<a href="#g:18" id="g:18"><h2>Searching ByteStrings</h2></a><a href="#g:19" id="g:19"><h3>Searching by equality</h3></a><p class="src"><a id="v:elem" class="def">elem</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#elem" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:elem" title="Data.ByteString">elem</a></code> is the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> membership predicate.</p>
<p class="src"><a id="v:notElem" class="def">notElem</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#notElem" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:notElem" title="Data.ByteString">notElem</a></code> is the inverse of <code><a href="data-bytestring.html#v:elem" title="Data.ByteString">elem</a></code></p>
<a href="#g:20" id="g:20"><h3>Searching with a predicate</h3></a><p class="src"><a id="v:find" class="def">find</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#find" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:find" title="Data.ByteString">find</a></code> function takes a predicate and a ByteString, and returns the first element in matching the predicate, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<pre>find f p = case findIndex f p of Just n -&gt; Just (p ! n) ; _ -&gt; Nothing</pre>
<p class="src"><a id="v:filter" class="def">filter</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#filter" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:filter" title="Data.ByteString">filter</a></code>, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</p>
<p class="src"><a id="v:partition" class="def">partition</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#partition" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:partition" title="Data.ByteString">partition</a></code> function takes a predicate a ByteString and returns the pair of ByteStrings with elements which do and do not satisfy the predicate, respectively; i.e.,</p>
<pre>partition p bs == (filter p xs, filter (not . p) xs)</pre>
<a href="#g:21" id="g:21"><h2>Indexing ByteStrings</h2></a><p class="src"><a id="v:index" class="def">index</a> :: <a href="../base-4.21.0.0-8e62/ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#index" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> index (subscript) operator, starting from 0.</p>
<p>This is a partial function, consider using <code><a href="data-bytestring.html#v:indexMaybe" title="Data.ByteString">indexMaybe</a></code> instead.</p>
<p class="src"><a id="v:indexMaybe" class="def">indexMaybe</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#indexMaybe" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> index, starting from 0, that returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> if:</p>
<pre>0 &lt;= n &lt; length bs</pre>
<p><span class="version">Since: bytestring-0.11.0.0</span></p>
<p class="src"><a id="v:-33--63-" class="def">(!?)</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#%21%3F" class="link">Source</a> </p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> index, starting from 0, that returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> if:</p>
<pre>0 &lt;= n &lt; length bs</pre>
<p><span class="version">Since: bytestring-0.11.0.0</span></p>
<p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#elemIndex" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:elemIndex" title="Data.ByteString">elemIndex</a></code> function returns the index of the first element in the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> which is equal to the query element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element. This implementation uses memchr(3).</p>
<p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#elemIndices" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:elemIndices" title="Data.ByteString">elemIndices</a></code> function extends <code><a href="data-bytestring.html#v:elemIndex" title="Data.ByteString">elemIndex</a></code>, by returning the indices of all elements equal to the query element, in ascending order. This implementation uses memchr(3).</p>
<p class="src"><a id="v:elemIndexEnd" class="def">elemIndexEnd</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#elemIndexEnd" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:elemIndexEnd" title="Data.ByteString">elemIndexEnd</a></code> function returns the last index of the element in the given <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> which is equal to the query element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element. The following holds:</p>
<pre>elemIndexEnd c xs = case elemIndex c (reverse xs) of
  Nothing -&gt; Nothing
  Just i  -&gt; Just (length xs - 1 - i)</pre>
<p class="src"><a id="v:findIndex" class="def">findIndex</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#findIndex" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:findIndex" title="Data.ByteString">findIndex</a></code> function takes a predicate and a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> and returns the index of the first element in the ByteString satisfying the predicate.</p>
<p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#findIndices" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:findIndices" title="Data.ByteString">findIndices</a></code> function extends <code><a href="data-bytestring.html#v:findIndex" title="Data.ByteString">findIndex</a></code>, by returning the indices of all elements satisfying the predicate, in ascending order.</p>
<p class="src"><a id="v:findIndexEnd" class="def">findIndexEnd</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#findIndexEnd" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring.html#v:findIndexEnd" title="Data.ByteString">findIndexEnd</a></code> function takes a predicate and a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> and returns the index of the last element in the ByteString satisfying the predicate.</p>
<p><span class="version">Since: bytestring-0.10.12.0</span></p>
<p class="src"><a id="v:count" class="def">count</a> :: <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#count" class="link">Source</a> </p>
<p>count returns the number of times its argument appears in the ByteString</p>
<pre>count = length . elemIndices</pre>
<p>But more efficiently than using length on the intermediate list.</p>
<a href="#g:22" id="g:22"><h2>Zipping and unzipping ByteStrings</h2></a><p class="src"><a id="v:zip" class="def">zip</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [(<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#zip" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:zip" title="Data.ByteString">zip</a></code> takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of <code><a href="data-bytestring.html#v:unpack" title="Data.ByteString">unpack</a></code> operations.</p>
<p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; a) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#zipWith" class="link">Source</a> </p>
<p><code><a href="data-bytestring.html#v:zipWith" title="Data.ByteString">zipWith</a></code> generalises <code><a href="data-bytestring.html#v:zip" title="Data.ByteString">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function. For example, <code class="inline-code"><a href="data-bytestring.html#v:zipWith" title="Data.ByteString">zipWith</a> (+)</code> is applied to two ByteStrings to produce the list of corresponding sums.</p>
<p class="src"><a id="v:packZipWith" class="def">packZipWith</a> :: (<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>) -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#packZipWith" class="link">Source</a> </p>
<p>A specialised version of <code><a href="data-bytestring.html#v:zipWith" title="Data.ByteString">zipWith</a></code> for the common case of a simultaneous map over two ByteStrings, to build a 3rd.</p>
<p><span class="version">Since: bytestring-0.11.1.0</span></p>
<p class="src"><a id="v:unzip" class="def">unzip</a> :: [(<a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a>)] -&gt; (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#unzip" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring.html#v:unzip" title="Data.ByteString">unzip</a></code> transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two <code><a href="data-bytestring.html#v:pack" title="Data.ByteString">pack</a></code> operations.</p>
<a href="#g:23" id="g:23"><h2>Ordered ByteStrings</h2></a><p class="src"><a id="v:sort" class="def">sort</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#sort" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Sort a ByteString efficiently, using counting sort.</p>
<a href="#g:24" id="g:24"><h2>Low level conversions</h2></a><a href="#g:25" id="g:25"><h3>Copying ByteStrings</h3></a><p class="src"><a id="v:copy" class="def">copy</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#copy" class="link">Source</a> </p>
<p><span class="complexity">O(n)</span> Make a copy of the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> with its own storage. This is mainly useful to allow the rest of the data pointed to by the <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</p>
<a href="#g:26" id="g:26"><h3>Packing <code>CString</code>s and pointers</h3></a><p class="src"><a id="v:packCString" class="def">packCString</a> :: <a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CString" title="Foreign.C.String">CString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#packCString" class="link">Source</a> </p>
<p><span class="complexity">O(n).</span> Construct a new <code class="inline-code">ByteString</code> from a <code class="inline-code">CString</code>. The resulting <code class="inline-code">ByteString</code> is an immutable copy of the original <code class="inline-code">CString</code>, and is managed on the Haskell heap. The original <code class="inline-code">CString</code> must be null terminated.</p>
<p class="src"><a id="v:packCStringLen" class="def">packCStringLen</a> :: <a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CStringLen" title="Foreign.C.String">CStringLen</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#packCStringLen" class="link">Source</a> </p>
<p><span class="complexity">O(n).</span> Construct a new <code class="inline-code">ByteString</code> from a <code class="inline-code">CStringLen</code>. The resulting <code class="inline-code">ByteString</code> is an immutable copy of the original <code class="inline-code">CStringLen</code>. The <code class="inline-code">ByteString</code> is a normal Haskell value and will be managed on the Haskell heap.</p>
<a href="#g:27" id="g:27"><h3>Using ByteStrings as <code>CString</code>s</h3></a><p class="src"><a id="v:useAsCString" class="def">useAsCString</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CString" title="Foreign.C.String">CString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> a) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#useAsCString" class="link">Source</a> </p>
<p><span class="complexity">O(n) construction</span> Use a <code class="inline-code">ByteString</code> with a function requiring a null-terminated <code class="inline-code">CString</code>. The <code class="inline-code">CString</code> is a copy and will be freed automatically; it must not be stored or used after the subcomputation finishes.</p>
<p class="src"><a id="v:useAsCStringLen" class="def">useAsCStringLen</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CStringLen" title="Foreign.C.String">CStringLen</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> a) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#useAsCStringLen" class="link">Source</a> </p>
<p><span class="complexity">O(n) construction</span> Use a <code class="inline-code">ByteString</code> with a function requiring a <code><a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CStringLen" title="Foreign.C.String">CStringLen</a></code>. As for <code><a href="data-bytestring.html#v:useAsCString" title="Data.ByteString">useAsCString</a></code> this function makes a copy of the original <code class="inline-code">ByteString</code>. It must not be stored or used after the subcomputation finishes.</p>
<p>Beware that this function is not required to add a terminating <code class="inline-code">NUL</code> byte at the end of the <code><a href="../base-4.21.0.0-8e62/foreign-c-string.html#t:CStringLen" title="Foreign.C.String">CStringLen</a></code> it provides. If you need to construct a pointer to a null-terminated sequence, use <code><a href="data-bytestring.html#v:useAsCString" title="Data.ByteString">useAsCString</a></code> (and measure length independently if desired).</p>
<a href="#g:28" id="g:28"><h2>I/O with ByteStrings</h2></a><a href="#g:29" id="g:29"><h3>Standard input and output</h3></a><p class="src"><a id="v:getLine" class="def">getLine</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#getLine" class="link">Source</a> </p>
<div class="warning"><p>Deprecated: Deprecated since <code class="inline-code">bytestring-0.12</code>. Use <code><a href="data-bytestring-char8.html#v:getLine" title="Data.ByteString.Char8">getLine</a></code> instead. (Functions that rely on ASCII encodings belong in <a href="data-bytestring-char8.html">Data.ByteString.Char8</a>)</p></div>
<p>Read a line from stdin.</p>
<p class="src"><a id="v:getContents" class="def">getContents</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#getContents" class="link">Source</a> </p>
<p>getContents. Read stdin strictly. Equivalent to hGetContents stdin The <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code> is closed after the contents have been read.</p>
<p class="src"><a id="v:putStr" class="def">putStr</a> :: <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#putStr" class="link">Source</a> </p>
<p>Write a ByteString to <code><a href="../base-4.21.0.0-8e62/ghc-io-stdhandles.html#v:stdout" title="GHC.IO.StdHandles">stdout</a></code>.</p>
<p class="src"><a id="v:interact" class="def">interact</a> :: (<a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#interact" class="link">Source</a> </p>
<p>The interact function takes a function of type <code class="inline-code">ByteString -&gt; ByteString</code> as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</p>
<a href="#g:30" id="g:30"><h3>Files</h3></a><p class="src"><a id="v:readFile" class="def">readFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#readFile" class="link">Source</a> </p>
<p>Read an entire file strictly into a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p class="src"><a id="v:writeFile" class="def">writeFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#writeFile" class="link">Source</a> </p>
<p>Write a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to a file.</p>
<p class="src"><a id="v:appendFile" class="def">appendFile</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#appendFile" class="link">Source</a> </p>
<p>Append a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to a file.</p>
<a href="#g:31" id="g:31"><h3>I/O with Handles</h3></a><p class="src"><a id="v:hGetLine" class="def">hGetLine</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hGetLine" class="link">Source</a> </p>
<div class="warning"><p>Deprecated: Deprecated since <code class="inline-code">bytestring-0.12</code>. Use <code><a href="data-bytestring-char8.html#v:hGetLine" title="Data.ByteString.Char8">hGetLine</a></code> instead. (Functions that rely on ASCII encodings belong in <a href="data-bytestring-char8.html">Data.ByteString.Char8</a>)</p></div>
<p>Read a line from a handle</p>
<p class="src"><a id="v:hGetContents" class="def">hGetContents</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hGetContents" class="link">Source</a> </p>
<p>Read a handle's entire contents strictly into a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &gt; half of available memory, this may lead to memory exhaustion. Consider using <code><a href="data-bytestring.html#v:readFile" title="Data.ByteString">readFile</a></code> in this case.</p>
<p>The Handle is closed once the contents have been read, or if an exception is thrown.</p>
<p class="src"><a id="v:hGet" class="def">hGet</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hGet" class="link">Source</a> </p>
<p>Read a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> directly from the specified <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code>. This is far more efficient than reading the characters into a <code><a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a></code> and then using <code><a href="data-bytestring.html#v:pack" title="Data.ByteString">pack</a></code>. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or <code><a href="data-bytestring.html#v:empty" title="Data.ByteString">empty</a></code> if EOF has been reached.</p>
<p><code><a href="data-bytestring.html#v:hGet" title="Data.ByteString">hGet</a></code> is implemented in terms of <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#v:hGetBuf" title="GHC.IO.Handle">hGetBuf</a></code>.</p>
<p>If the handle is a pipe or socket, and the writing end is closed, <code><a href="data-bytestring.html#v:hGet" title="Data.ByteString">hGet</a></code> will behave as if EOF was reached.</p>
<p class="src"><a id="v:hGetSome" class="def">hGetSome</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hGetSome" class="link">Source</a> </p>
<p>Like <code><a href="data-bytestring.html#v:hGet" title="Data.ByteString">hGet</a></code>, except that a shorter <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> may be returned if there are not enough bytes immediately available to satisfy the whole request. <code><a href="data-bytestring.html#v:hGetSome" title="Data.ByteString">hGetSome</a></code> only blocks if there is no data available, and EOF has not yet been reached.</p>
<p class="src"><a id="v:hGetNonBlocking" class="def">hGetNonBlocking</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hGetNonBlocking" class="link">Source</a> </p>
<p>hGetNonBlocking is similar to <code><a href="data-bytestring.html#v:hGet" title="Data.ByteString">hGet</a></code>, except that it will never block waiting for data to become available, instead it returns only whatever data is available. If there is no data available to be read, <code><a href="data-bytestring.html#v:hGetNonBlocking" title="Data.ByteString">hGetNonBlocking</a></code> returns <code><a href="data-bytestring.html#v:empty" title="Data.ByteString">empty</a></code>.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring.html#v:hGet" title="Data.ByteString">hGet</a></code>.</p>
<p class="src"><a id="v:hPut" class="def">hPut</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hPut" class="link">Source</a> </p>
<p>Outputs a <code><a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> to the specified <code><a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a></code>.</p>
<p class="src"><a id="v:hPutNonBlocking" class="def">hPutNonBlocking</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hPutNonBlocking" class="link">Source</a> </p>
<p>Similar to <code><a href="data-bytestring.html#v:hPut" title="Data.ByteString">hPut</a></code> except that it will never block. Instead it returns any tail that did not get written. This tail may be <code><a href="data-bytestring.html#v:empty" title="Data.ByteString">empty</a></code> in the case that the whole string was written, or the whole original string if nothing was written. Partial writes are also possible.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring.html#v:hPut" title="Data.ByteString">hPut</a></code>.</p>
<p class="src"><a id="v:hPutStr" class="def">hPutStr</a> :: <a href="../base-4.21.0.0-8e62/ghc-io-handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/src/Data.ByteString.html#hPutStr" class="link">Source</a> </p>
<p>A synonym for <code><a href="data-bytestring.html#v:hPut" title="Data.ByteString">hPut</a></code>, for compatibility</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/Data-ByteString.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/bytestring-0.12.2.0-2f68/Data-ByteString.html</a>
  </p>
</div>
