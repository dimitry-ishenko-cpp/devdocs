<h1 class="caption">Data.Sequence.Internal.Sorting</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th>Safe Haskell</th>
<td>Safe-Inferred</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Sort Functions</a></li>
<li><a href="#g:2">Heaps</a></li>
<li><a href="#g:3">Merges</a></li>
<li><a href="#g:4">popMin</a></li>
<li><a href="#g:5">Building</a></li>
<li><a href="#g:6">Special folds</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<h2>WARNING</h2>
<p>This module is considered <strong>internal</strong>.</p>
<p>The Package Versioning Policy <strong>does not apply</strong>.</p>
<p>The contents of this module may change <strong>in any way whatsoever</strong> and <strong>without any warning</strong> between minor versions of this package.</p>
<p>Authors importing this module are expected to track development closely.</p>
<h2>Description</h2>
<p>This module provides the various sorting implementations for <a href="data-sequence.html">Data.Sequence</a>. Further notes are available in the file sorting.md (in this directory).</p>
</div>
<a href="#g:1" id="g:1"><h2>Sort Functions</h2></a><p class="src"><a id="v:sort" class="def">sort</a> :: <a href="../base-4.17.0.0/data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#sort" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. <code><a href="data-sequence-internal-sorting.html#v:sort" title="Data.Sequence.Internal.Sorting">sort</a></code> sorts the specified <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> by the natural ordering of its elements. The sort is stable. If stability is not required, <code><a href="data-sequence-internal-sorting.html#v:unstableSort" title="Data.Sequence.Internal.Sorting">unstableSort</a></code> can be slightly faster.</p>
<p><span class="version">Since: containers-0.3.0</span></p>
<p class="src"><a id="v:sortBy" class="def">sortBy</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#sortBy" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. <code><a href="data-sequence-internal-sorting.html#v:sortBy" title="Data.Sequence.Internal.Sorting">sortBy</a></code> sorts the specified <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> according to the specified comparator. The sort is stable. If stability is not required, <code><a href="data-sequence-internal-sorting.html#v:unstableSortBy" title="Data.Sequence.Internal.Sorting">unstableSortBy</a></code> can be slightly faster.</p>
<p><span class="version">Since: containers-0.3.0</span></p>
<p class="src"><a id="v:sortOn" class="def">sortOn</a> :: <a href="../base-4.17.0.0/data-ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#sortOn" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. <code><a href="data-sequence-internal-sorting.html#v:sortOn" title="Data.Sequence.Internal.Sorting">sortOn</a></code> sorts the specified <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> by comparing the results of a key function applied to each element. <code><a href="data-sequence-internal-sorting.html#v:sortOn" title="Data.Sequence.Internal.Sorting">sortOn</a> f</code> is equivalent to <code><a href="data-sequence-internal-sorting.html#v:sortBy" title="Data.Sequence.Internal.Sorting">sortBy</a> (<a href="../base-4.17.0.0/data-ord.html#v:compare" title="Data.Ord">compare</a> <a href="../base-4.17.0.0/data-function.html#v:on" title="Data.Function">`on`</a> f)</code>, but has the performance advantage of only evaluating <code>f</code> once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</p>
<p>An example of using <code><a href="data-sequence-internal-sorting.html#v:sortOn" title="Data.Sequence.Internal.Sorting">sortOn</a></code> might be to sort a <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> of strings according to their length:</p>
<pre>sortOn length (fromList ["alligator", "monkey", "zebra"]) == fromList ["zebra", "monkey", "alligator"]</pre>
<p>If, instead, <code><a href="data-sequence-internal-sorting.html#v:sortBy" title="Data.Sequence.Internal.Sorting">sortBy</a></code> had been used, <code><a href="../base-4.17.0.0/data-foldable.html#v:length" title="Data.Foldable">length</a></code> would be evaluated on every comparison, giving <span class="mathjax">\( O(n \log n) \)</span> evaluations, rather than <span class="mathjax">\( O(n) \)</span>.</p>
<p>If <code>f</code> is very cheap (for example a record selector, or <code><a href="../base-4.17.0.0/data-tuple.html#v:fst" title="Data.Tuple">fst</a></code>), <code><a href="data-sequence-internal-sorting.html#v:sortBy" title="Data.Sequence.Internal.Sorting">sortBy</a> (<a href="../base-4.17.0.0/data-ord.html#v:compare" title="Data.Ord">compare</a> <a href="../base-4.17.0.0/data-function.html#v:on" title="Data.Function">`on`</a> f)</code> will be faster than <code><a href="data-sequence-internal-sorting.html#v:sortOn" title="Data.Sequence.Internal.Sorting">sortOn</a> f</code>.</p>
<p><span class="version">Since: containers-0.5.11</span></p>
<p class="src"><a id="v:unstableSort" class="def">unstableSort</a> :: <a href="../base-4.17.0.0/data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#unstableSort" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. <code><a href="data-sequence-internal-sorting.html#v:unstableSort" title="Data.Sequence.Internal.Sorting">unstableSort</a></code> sorts the specified <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than <code><a href="data-sequence-internal-sorting.html#v:sort" title="Data.Sequence.Internal.Sorting">sort</a></code>.</p>
<p class="src"><a id="v:unstableSortBy" class="def">unstableSortBy</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#unstableSortBy" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. A generalization of <code><a href="data-sequence-internal-sorting.html#v:unstableSort" title="Data.Sequence.Internal.Sorting">unstableSort</a></code>, <code><a href="data-sequence-internal-sorting.html#v:unstableSortBy" title="Data.Sequence.Internal.Sorting">unstableSortBy</a></code> takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than <code><a href="data-sequence-internal-sorting.html#v:sortBy" title="Data.Sequence.Internal.Sorting">sortBy</a></code>.</p>
<p><span class="version">Since: containers-0.3.0</span></p>
<p class="src"><a id="v:unstableSortOn" class="def">unstableSortOn</a> :: <a href="../base-4.17.0.0/data-ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a -&gt; <a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#unstableSortOn" class="link">Source</a> </p>
<p><span class="mathjax">\( O(n \log n) \)</span>. <code><a href="data-sequence-internal-sorting.html#v:unstableSortOn" title="Data.Sequence.Internal.Sorting">unstableSortOn</a></code> sorts the specified <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> by comparing the results of a key function applied to each element. <code><a href="data-sequence-internal-sorting.html#v:unstableSortOn" title="Data.Sequence.Internal.Sorting">unstableSortOn</a> f</code> is equivalent to <code><a href="data-sequence-internal-sorting.html#v:unstableSortBy" title="Data.Sequence.Internal.Sorting">unstableSortBy</a> (<a href="../base-4.17.0.0/data-ord.html#v:compare" title="Data.Ord">compare</a> <a href="../base-4.17.0.0/data-function.html#v:on" title="Data.Function">`on`</a> f)</code>, but has the performance advantage of only evaluating <code>f</code> once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</p>
<p>An example of using <code><a href="data-sequence-internal-sorting.html#v:unstableSortOn" title="Data.Sequence.Internal.Sorting">unstableSortOn</a></code> might be to sort a <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> of strings according to their length:</p>
<pre>unstableSortOn length (fromList ["alligator", "monkey", "zebra"]) == fromList ["zebra", "monkey", "alligator"]</pre>
<p>If, instead, <code><a href="data-sequence-internal-sorting.html#v:unstableSortBy" title="Data.Sequence.Internal.Sorting">unstableSortBy</a></code> had been used, <code><a href="../base-4.17.0.0/data-foldable.html#v:length" title="Data.Foldable">length</a></code> would be evaluated on every comparison, giving <span class="mathjax">\( O(n \log n) \)</span> evaluations, rather than <span class="mathjax">\( O(n) \)</span>.</p>
<p>If <code>f</code> is very cheap (for example a record selector, or <code><a href="../base-4.17.0.0/data-tuple.html#v:fst" title="Data.Tuple">fst</a></code>), <code><a href="data-sequence-internal-sorting.html#v:unstableSortBy" title="Data.Sequence.Internal.Sorting">unstableSortBy</a> (<a href="../base-4.17.0.0/data-ord.html#v:compare" title="Data.Ord">compare</a> <a href="../base-4.17.0.0/data-function.html#v:on" title="Data.Function">`on`</a> f)</code> will be faster than <code><a href="data-sequence-internal-sorting.html#v:unstableSortOn" title="Data.Sequence.Internal.Sorting">unstableSortOn</a> f</code>.</p>
<p><span class="version">Since: containers-0.5.11</span></p>
<a href="#g:2" id="g:2"><h2>Heaps</h2></a><p>The following are definitions for various specialized pairing heaps.</p>
<p>All of the heaps are defined to be non-empty, which speeds up the merge functions.</p>
<p class="src">data <a id="t:Queue" class="def">Queue</a> e <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#Queue" class="link">Source</a> </p>
<p>A simple pairing heap.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a id="v:Q" class="def">Q</a> !e (<a href="data-sequence-internal-sorting.html#t:QList" title="Data.Sequence.Internal.Sorting">QList</a> e)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<p class="src">data <a id="t:QList" class="def">QList</a> e <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#QList" class="link">Source</a> </p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:Nil" class="def">Nil</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">
<a id="v:QCons" class="def">QCons</a> !(<a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> e) (<a href="data-sequence-internal-sorting.html#t:QList" title="Data.Sequence.Internal.Sorting">QList</a> e) <span class="fixity">infixr 8</span>
</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p class="src">data <a id="t:IndexedQueue" class="def">IndexedQueue</a> e <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#IndexedQueue" class="link">Source</a> </p>
<p>A pairing heap tagged with the original position of elements, to allow for stable sorting.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a id="v:IQ" class="def">IQ</a> !<a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> !e (<a href="data-sequence-internal-sorting.html#t:IQList" title="Data.Sequence.Internal.Sorting">IQList</a> e)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<p class="src">data <a id="t:IQList" class="def">IQList</a> e <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#IQList" class="link">Source</a> </p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:IQNil" class="def">IQNil</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">
<a id="v:IQCons" class="def">IQCons</a> !(<a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> e) (<a href="data-sequence-internal-sorting.html#t:IQList" title="Data.Sequence.Internal.Sorting">IQList</a> e) <span class="fixity">infixr 8</span>
</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p class="src">data <a id="t:TaggedQueue" class="def">TaggedQueue</a> a b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#TaggedQueue" class="link">Source</a> </p>
<p>A pairing heap tagged with some key for sorting elements, for use in <code><a href="data-sequence-internal-sorting.html#v:unstableSortOn" title="Data.Sequence.Internal.Sorting">unstableSortOn</a></code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a id="v:TQ" class="def">TQ</a> !a b (<a href="data-sequence-internal-sorting.html#t:TQList" title="Data.Sequence.Internal.Sorting">TQList</a> a b)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<p class="src">data <a id="t:TQList" class="def">TQList</a> a b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#TQList" class="link">Source</a> </p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:TQNil" class="def">TQNil</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">
<a id="v:TQCons" class="def">TQCons</a> !(<a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b) (<a href="data-sequence-internal-sorting.html#t:TQList" title="Data.Sequence.Internal.Sorting">TQList</a> a b) <span class="fixity">infixr 8</span>
</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p class="src">data <a id="t:IndexedTaggedQueue" class="def">IndexedTaggedQueue</a> e a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#IndexedTaggedQueue" class="link">Source</a> </p>
<p>A pairing heap tagged with both a key and the original position of its elements, for use in <code><a href="data-sequence-internal-sorting.html#v:sortOn" title="Data.Sequence.Internal.Sorting">sortOn</a></code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a id="v:ITQ" class="def">ITQ</a> !<a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> !e a (<a href="data-sequence-internal-sorting.html#t:ITQList" title="Data.Sequence.Internal.Sorting">ITQList</a> e a)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<p class="src">data <a id="t:ITQList" class="def">ITQList</a> e a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#ITQList" class="link">Source</a> </p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:ITQNil" class="def">ITQNil</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">
<a id="v:ITQCons" class="def">ITQCons</a> !(<a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> e a) (<a href="data-sequence-internal-sorting.html#t:ITQList" title="Data.Sequence.Internal.Sorting">ITQList</a> e a) <span class="fixity">infixr 8</span>
</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<a href="#g:3" id="g:3"><h2>Merges</h2></a><p>The following are definitions for "merge" for each of the heaps above. Each takes a comparison function which is used to order the elements.</p>
<p class="src"><a id="v:mergeQ" class="def">mergeQ</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> a -&gt; <a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> a -&gt; <a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#mergeQ" class="link">Source</a> </p>
<p><code><a href="data-sequence-internal-sorting.html#v:mergeQ" title="Data.Sequence.Internal.Sorting">mergeQ</a></code> merges two <code><a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a></code>s.</p>
<p class="src"><a id="v:mergeIQ" class="def">mergeIQ</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> a -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> a -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#mergeIQ" class="link">Source</a> </p>
<p><code><a href="data-sequence-internal-sorting.html#v:mergeIQ" title="Data.Sequence.Internal.Sorting">mergeIQ</a></code> merges two <code><a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a></code>s, taking into account the original position of the elements.</p>
<p class="src"><a id="v:mergeTQ" class="def">mergeTQ</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b -&gt; <a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b -&gt; <a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#mergeTQ" class="link">Source</a> </p>
<p><code><a href="data-sequence-internal-sorting.html#v:mergeTQ" title="Data.Sequence.Internal.Sorting">mergeTQ</a></code> merges two <code><a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a></code>s, based on the tag value.</p>
<p class="src"><a id="v:mergeITQ" class="def">mergeITQ</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> a b -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> a b -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> a b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#mergeITQ" class="link">Source</a> </p>
<p><code><a href="data-sequence-internal-sorting.html#v:mergeITQ" title="Data.Sequence.Internal.Sorting">mergeITQ</a></code> merges two <code><a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a></code>s, based on the tag value, taking into account the original position of the elements.</p>
<a href="#g:4" id="g:4"><h2>popMin</h2></a><p>The following are definitions for <code>popMin</code>, a function which constructs a stateful action which pops the smallest element from the queue, where "smallest" is according to the supplied comparison function.</p>
<p>All of the functions fail on an empty queue.</p>
<p>Each of these functions is structured something like this:</p>
<pre>popMinQ cmp (Q x ts) = (mergeQs ts, x)</pre>
<p>The reason the call to <code>mergeQs</code> is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</p>
<p class="src"><a id="v:popMinQ" class="def">popMinQ</a> :: (e -&gt; e -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> e -&gt; (<a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> e, e) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#popMinQ" class="link">Source</a> </p>
<p>Pop the smallest element from the queue, using the supplied comparator.</p>
<p class="src"><a id="v:popMinIQ" class="def">popMinIQ</a> :: (e -&gt; e -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> e -&gt; (<a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> e, e) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#popMinIQ" class="link">Source</a> </p>
<p>Pop the smallest element from the queue, using the supplied comparator, deferring to the item's original position when the comparator returns <code><a href="../base-4.17.0.0/data-ord.html#v:EQ" title="Data.Ord">EQ</a></code>.</p>
<p class="src"><a id="v:popMinTQ" class="def">popMinTQ</a> :: (a -&gt; a -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b -&gt; (<a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> a b, b) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#popMinTQ" class="link">Source</a> </p>
<p>Pop the smallest element from the queue, using the supplied comparator on the tag.</p>
<p class="src"><a id="v:popMinITQ" class="def">popMinITQ</a> :: (e -&gt; e -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> e b -&gt; (<a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> e b, b) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#popMinITQ" class="link">Source</a> </p>
<p>Pop the smallest element from the queue, using the supplied comparator on the tag, deferring to the item's original position when the comparator returns <code><a href="../base-4.17.0.0/data-ord.html#v:EQ" title="Data.Ord">EQ</a></code>.</p>
<a href="#g:5" id="g:5"><h2>Building</h2></a><p>The following are definitions for functions to build queues, given a comparison function.</p>
<p class="src"><a id="v:buildQ" class="def">buildQ</a> :: (b -&gt; b -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; (a -&gt; <a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> b) -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> a -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-sequence-internal-sorting.html#t:Queue" title="Data.Sequence.Internal.Sorting">Queue</a> b) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#buildQ" class="link">Source</a> </p>
<p class="src"><a id="v:buildIQ" class="def">buildIQ</a> :: (b -&gt; b -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; (<a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> b) -&gt; <a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> (<a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y) -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-sequence-internal-sorting.html#t:IndexedQueue" title="Data.Sequence.Internal.Sorting">IndexedQueue</a> b) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#buildIQ" class="link">Source</a> </p>
<p class="src"><a id="v:buildTQ" class="def">buildTQ</a> :: (b -&gt; b -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; (a -&gt; <a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> b c) -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> a -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-sequence-internal-sorting.html#t:TaggedQueue" title="Data.Sequence.Internal.Sorting">TaggedQueue</a> b c) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#buildTQ" class="link">Source</a> </p>
<p class="src"><a id="v:buildITQ" class="def">buildITQ</a> :: (b -&gt; b -&gt; <a href="../base-4.17.0.0/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; (<a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y -&gt; <a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> b c) -&gt; <a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> (<a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y) -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="data-sequence-internal-sorting.html#t:IndexedTaggedQueue" title="Data.Sequence.Internal.Sorting">IndexedTaggedQueue</a> b c) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#buildITQ" class="link">Source</a> </p>
<a href="#g:6" id="g:6"><h2>Special folds</h2></a><p>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of <code><a href="../base-4.17.0.0/data-foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> and <code><a href="data-sequence.html#v:foldMapWithIndex" title="Data.Sequence">foldMapWithIndex</a></code>, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like <code><a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Node" title="Data.Sequence.Internal">Node</a></code> and <code><a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Digit" title="Data.Sequence.Internal">Digit</a></code>), and the <code><a href="data-semirgroup.html#v:Option" title="Data.Semirgroup">Option</a></code>-like mappend, when folding over structures which can be empty (like <code><a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a></code>).</p>
<p class="src"><a id="v:foldToMaybeTree" class="def">foldToMaybeTree</a> :: (b -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> a -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#foldToMaybeTree" class="link">Source</a> </p>
<p>A <code><a href="../base-4.17.0.0/data-foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code>-like function, specialized to the <code><a href="../base-4.17.0.0/data-semigroup.html#v:Option" title="Data.Semigroup">Option</a></code> monoid, which takes advantage of the internal structure of <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> to avoid wrapping in <code><a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> at certain points.</p>
<p class="src"><a id="v:foldToMaybeWithIndexTree" class="def">foldToMaybeWithIndexTree</a> :: (b -&gt; b -&gt; b) -&gt; (<a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y -&gt; b) -&gt; <a href="../base-4.17.0.0/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:FingerTree" title="Data.Sequence.Internal">FingerTree</a> (<a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal.html#t:Elem" title="Data.Sequence.Internal">Elem</a> y) -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.Sequence.Internal.Sorting.html#foldToMaybeWithIndexTree" class="link">Source</a> </p>
<p>A <code><a href="data-sequence.html#v:foldMapWithIndex" title="Data.Sequence">foldMapWithIndex</a></code>-like function, specialized to the <code><a href="../base-4.17.0.0/data-semigroup.html#v:Option" title="Data.Semigroup">Option</a></code> monoid, which takes advantage of the internal structure of <code><a href="data-sequence.html#t:Seq" title="Data.Sequence">Seq</a></code> to avoid wrapping in <code><a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> at certain points.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal-Sorting.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Sequence-Internal-Sorting.html</a>
  </p>
</div>
