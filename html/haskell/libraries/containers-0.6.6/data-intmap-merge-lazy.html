<h1 class="caption">Data.IntMap.Merge.Lazy</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) wren romano 2016</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Simple merge tactic types</a></li>
<li>
<a href="#g:2">General combining function</a><ul>
<li><a href="#g:3"><code>WhenMatched</code> tactics</a></li>
<li><a href="#g:4"><code>WhenMissing</code> tactics</a></li>
</ul>
</li>
<li><a href="#g:5">Applicative merge tactic types</a></li>
<li>
<a href="#g:6">Applicative general combining function</a><ul>
<li><a href="#g:7"><code>WhenMatched</code> tactics</a></li>
<li><a href="#g:8"><code>WhenMissing</code> tactics</a></li>
<li><a href="#g:9">Covariant maps for tactics</a></li>
<li><a href="#g:10">Contravariant maps for tactics</a></li>
<li><a href="#g:11">Miscellaneous tactic functions</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>This module defines an API for writing functions that merge two maps. The key functions are <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> and <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code>. Each of these can be used with several different "merge tactics".</p>
<p>The <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> and <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use <code><a href="data-map-merge-strict.html#v:mapMissing" title="Data.Map.Merge.Strict">mapMissing</a></code> from <a href="data-map-merge-strict.html">Data.Map.Merge.Strict</a> then the results will be forced before they are inserted. If you use <code><a href="data-map-merge-lazy.html#v:mapMissing" title="Data.Map.Merge.Lazy">mapMissing</a></code> from this module then they will not.</p>
<h3>Efficiency note</h3>
<p>The <code><a href="../base-4.17.0.0/control-category.html#v:Category" title="Control.Category">Category</a></code>, <code><a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>, and <code><a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a></code> instances for <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a></code> tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a></code> tactics should not pose any major efficiency problems.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div>
<a href="#g:1" id="g:1"><h3>Simple merge tactic types</h3></a><p class="src">type <a id="t:SimpleWhenMissing" class="def">SimpleWhenMissing</a> = <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#SimpleWhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code>.</p>
<p>A tactic of type <code>SimpleWhenMissing x z</code> is an abstract representation of a function of type <code>Key -&gt; x -&gt; Maybe z</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src">type <a id="t:SimpleWhenMatched" class="def">SimpleWhenMatched</a> = <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#SimpleWhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code>.</p>
<p>A tactic of type <code>SimpleWhenMatched x y z</code> is an abstract representation of a function of type <code>Key -&gt; x -&gt; y -&gt; Maybe z</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:2" id="g:2"><h3>General combining function</h3></a><p class="src"><a id="v:merge" class="def">merge</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#merge" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="data-intmap-merge-lazy.html#t:SimpleWhenMissing" title="Data.IntMap.Merge.Lazy">SimpleWhenMissing</a> a c</td>
<td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-merge-lazy.html#t:SimpleWhenMissing" title="Data.IntMap.Merge.Lazy">SimpleWhenMissing</a> b c</td>
<td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-merge-lazy.html#t:SimpleWhenMatched" title="Data.IntMap.Merge.Lazy">SimpleWhenMatched</a> a b c</td>
<td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> a</td>
<td class="doc"><p>Map <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> b</td>
<td class="doc"><p>Map <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> c</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>Merge two maps.</p>
<p><code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> takes two <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a></code> tactics, a <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-intmap-merge-lazy.html#v:mapMaybeMissing" title="Data.IntMap.Merge.Lazy">mapMaybeMissing</a></code> and <code><a href="data-intmap-merge-lazy.html#v:zipWithMaybeMatched" title="Data.IntMap.Merge.Lazy">zipWithMaybeMatched</a></code>.</p>
<p>Consider</p>
<pre>merge (mapMaybeMissing g1)
             (mapMaybeMissing g2)
             (zipWithMaybeMatched f)
             m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p>
<pre>maybes = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>This produces a <code><a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> for each key:</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code>Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-intmap-merge-lazy.html#v:mapMaybeMissing" title="Data.IntMap.Merge.Lazy">mapMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-intmap-merge-lazy.html#v:dropMissing" title="Data.IntMap.Merge.Lazy">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-intmap-merge-lazy.html#v:preserveMissing" title="Data.IntMap.Merge.Lazy">preserveMissing</a></code> leaves all the entries alone.</li>
</ul>
<p>When <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> to define your custom combining functions.</p>
<p>Examples:</p>
<pre>unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)</pre>
<pre>intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)</pre>
<pre>differenceWith f = merge diffPreserve diffDrop f</pre>
<pre>symmetricDifference = merge diffPreserve diffPreserve (\ _ _ _ -&gt; Nothing)</pre>
<pre>mapEachPiece f g h = merge (diffMapWithKey f) (diffMapWithKey g)</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:3" id="g:3"><h4>
<code>WhenMatched</code> tactics</h4></a><p class="src"><a id="v:zipWithMaybeMatched" class="def">zipWithMaybeMatched</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#zipWithMaybeMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</p>
<pre>zipWithMaybeMatched
  :: (Key -&gt; x -&gt; y -&gt; Maybe z)
  -&gt; SimpleWhenMatched x y z</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:zipWithMatched" class="def">zipWithMatched</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y -&gt; z) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#zipWithMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</p>
<pre>zipWithMatched
  :: (Key -&gt; x -&gt; y -&gt; z)
  -&gt; SimpleWhenMatched x y z</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:4" id="g:4"><h4>
<code>WhenMissing</code> tactics</h4></a><p class="src"><a id="v:mapMaybeMissing" class="def">mapMaybeMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; <a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#mapMaybeMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful <code><a href="data-intmap-merge-lazy.html#t:SimpleWhenMissing" title="Data.IntMap.Merge.Lazy">SimpleWhenMissing</a></code> tactic, but others are usually more efficient.</p>
<pre>mapMaybeMissing :: (Key -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing x y</pre>
<pre>mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</pre>
<p>but <code>mapMaybeMissing</code> uses fewer unnecessary <code><a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> operations.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:dropMissing" class="def">dropMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#dropMissing" class="link">Source</a> </p>
<p>Drop all the entries whose keys are missing from the other map.</p>
<pre>dropMissing :: SimpleWhenMissing x y</pre>
<pre>dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)</pre>
<p>but <code>dropMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:preserveMissing" class="def">preserveMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x x <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#preserveMissing" class="link">Source</a> </p>
<p>Preserve, unchanged, the entries whose keys are missing from the other map.</p>
<pre>preserveMissing :: SimpleWhenMissing x x</pre>
<pre>preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)</pre>
<p>but <code>preserveMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:mapMissing" class="def">mapMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#mapMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map.</p>
<pre>mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing x y</pre>
<pre>mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</pre>
<p>but <code>mapMissing</code> is somewhat faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:filterMissing" class="def">filterMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; <a href="../base-4.17.0.0/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x x <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#filterMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map.</p>
<pre>filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing x x</pre>
<pre>filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:5" id="g:5"><h3>Applicative merge tactic types</h3></a><p class="src">data <a id="t:WhenMissing" class="def">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#WhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> or <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code>.</p>
<p>A tactic of type <code>WhenMissing f k x z</code> is an abstract representation of a function of type <code>Key -&gt; x -&gt; f (Maybe z)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMissing">Instances</h5>
<details id="i:WhenMissing" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.17.0.0/control-category.html#t:Category" title="Control.Category">Category</a> (<a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f :: <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1424" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: forall (a :: k). <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f a a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Control.Category.html#id" class="link">Source</a> </p>
<p class="src"><a href="#v:.">(.)</a> :: forall (b :: k) (c :: k) (a :: k). <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f b c -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f a b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f a c <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Control.Category.html#." class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1440" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code>ReaderT k (ReaderT x (MaybeT f))</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#pure" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x c <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#liftA2" class="link">Source</a> </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%2A" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.17.0.0/data-functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1418" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#fmap" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%24" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1455" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code>ReaderT k (ReaderT x (MaybeT f))</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; (a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3E%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3E%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#return" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src">data <a id="t:WhenMatched" class="def">WhenMatched</a> f x y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#WhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> or <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code>.</p>
<p>A tactic of type <code>WhenMatched f x y z</code> is an abstract representation of a function of type <code>Key -&gt; x -&gt; y -&gt; f (Maybe z)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMatched">Instances</h5>
<details id="i:WhenMatched" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.17.0.0/control-category.html#t:Category" title="Control.Category">Category</a> (<a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x :: <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.17.0.0/data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1584" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: forall (a :: k). <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x a a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Control.Category.html#id" class="link">Source</a> </p>
<p class="src"><a href="#v:.">(.)</a> :: forall (b :: k) (c :: k) (a :: k). <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x b c -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x a b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x a c <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Control.Category.html#." class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1600" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code>ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))</code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#pure" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y c <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#liftA2" class="link">Source</a> </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%2A" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.17.0.0/data-functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; <a href="../base-4.17.0.0/data-functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1578" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#fmap" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3C%24" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#line-1615" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code>ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))</code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Internal.html">Data.IntMap.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; (a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3E%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%3E%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#return" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<a href="#g:6" id="g:6"><h3>Applicative general combining function</h3></a><p class="src"><a id="v:mergeA" class="def">mergeA</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#mergeA" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f a c</td>
<td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f b c</td>
<td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f a b c</td>
<td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> a</td>
<td class="doc"><p>Map <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> b</td>
<td class="doc"><p>Map <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; f (<a href="data-intmap-strict-internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> c)</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>An applicative version of <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code>.</p>
<p><code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> takes two <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a></code> tactics, a <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-intmap-merge-lazy.html#v:traverseMaybeMissing" title="Data.IntMap.Merge.Lazy">traverseMaybeMissing</a></code> and <code><a href="data-intmap-merge-lazy.html#v:zipWithMaybeAMatched" title="Data.IntMap.Merge.Lazy">zipWithMaybeAMatched</a></code>.</p>
<p>Consider</p>
<pre>mergeA (traverseMaybeMissing g1)
              (traverseMaybeMissing g2)
              (zipWithMaybeAMatched f)
              m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3,'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p>
<pre>actions = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>Next, it will perform the actions in the <code>actions</code> list in order from left to right.</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code>Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-intmap-merge-lazy.html#v:traverseMaybeMissing" title="Data.IntMap.Merge.Lazy">traverseMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-intmap-merge-lazy.html#v:dropMissing" title="Data.IntMap.Merge.Lazy">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-intmap-merge-lazy.html#v:preserveMissing" title="Data.IntMap.Merge.Lazy">preserveMissing</a></code> leaves all the entries alone.</li>
<li>
<code><a href="data-intmap-merge-lazy.html#v:mapMaybeMissing" title="Data.IntMap.Merge.Lazy">mapMaybeMissing</a></code> does not use the <code><a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context.</li>
</ul>
<p>When <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> to define custom combining functions.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:7" id="g:7"><h4>
<code>WhenMatched</code> tactics</h4></a><p>The tactics described for <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> work for <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:zipWithMaybeAMatched" class="def">zipWithMaybeAMatched</a> :: (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y -&gt; f (<a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z)) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#zipWithMaybeAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</p>
<p>This is the fundamental <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a></code> tactic.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:zipWithAMatched" class="def">zipWithAMatched</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y -&gt; f z) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#zipWithAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:8" id="g:8"><h4>
<code>WhenMissing</code> tactics</h4></a><p>The tactics described for <code><a href="data-intmap-merge-lazy.html#v:merge" title="Data.IntMap.Merge.Lazy">merge</a></code> work for <code><a href="data-intmap-merge-lazy.html#v:mergeA" title="Data.IntMap.Merge.Lazy">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:traverseMaybeMissing" class="def">traverseMaybeMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; f (<a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y)) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#traverseMaybeMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a></code> tactic, but others are usually more efficient.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:traverseMissing" class="def">traverseMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; f y) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#traverseMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:filterAMissing" class="def">filterAMissing</a> :: <a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (<a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; f <a href="../base-4.17.0.0/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x x <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#filterAMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map using some <code><a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> action.</p>
<pre>filterAMissing f = Merge.Lazy.traverseMaybeMissing $
  \k x -&gt; (\b -&gt; guard b *&gt; Just x) &lt;$&gt; f k x</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:9" id="g:9"><h4>Covariant maps for tactics</h4></a><p class="src"><a id="v:mapWhenMissing" class="def">mapWhenMissing</a> :: (<a href="../base-4.17.0.0/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.17.0.0/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#mapWhenMissing" class="link">Source</a> </p>
<p>Map covariantly over a <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:mapWhenMatched" class="def">mapWhenMatched</a> :: <a href="../base-4.17.0.0/data-functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y a -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#mapWhenMatched" class="link">Source</a> </p>
<p>Map covariantly over a <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:10" id="g:10"><h4>Contravariant maps for tactics</h4></a><p class="src"><a id="v:lmapWhenMissing" class="def">lmapWhenMissing</a> :: (b -&gt; a) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f a x -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f b x <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#lmapWhenMissing" class="link">Source</a> </p>
<p>Map contravariantly over a <code><a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f _ x</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:contramapFirstWhenMatched" class="def">contramapFirstWhenMatched</a> :: (b -&gt; a) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f a y z -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f b y z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#contramapFirstWhenMatched" class="link">Source</a> </p>
<p>Map contravariantly over a <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f _ y z</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:contramapSecondWhenMatched" class="def">contramapSecondWhenMatched</a> :: (b -&gt; a) -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x a z -&gt; <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x b z <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#contramapSecondWhenMatched" class="link">Source</a> </p>
<p>Map contravariantly over a <code><a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x _ z</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:11" id="g:11"><h4>Miscellaneous tactic functions</h4></a><p class="src"><a id="v:runWhenMatched" class="def">runWhenMatched</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMatched" title="Data.IntMap.Merge.Lazy">WhenMatched</a> f x y z -&gt; <a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; y -&gt; f (<a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#runWhenMatched" class="link">Source</a> </p>
<p>Along with zipWithMaybeAMatched, witnesses the isomorphism between <code>WhenMatched f x y z</code> and <code>Key -&gt; x -&gt; y -&gt; f (Maybe z)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:runWhenMissing" class="def">runWhenMissing</a> :: <a href="data-intmap-merge-lazy.html#t:WhenMissing" title="Data.IntMap.Merge.Lazy">WhenMissing</a> f x y -&gt; <a href="data-intset.html#t:Key" title="Data.IntSet">Key</a> -&gt; x -&gt; f (<a href="../base-4.17.0.0/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/src/Data.IntMap.Internal.html#runWhenMissing" class="link">Source</a> </p>
<p>Along with traverseMaybeMissing, witnesses the isomorphism between <code>WhenMissing f x y</code> and <code>Key -&gt; x -&gt; f (Maybe y)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Merge-Lazy.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/containers-0.6.6/Data-IntMap-Merge-Lazy.html</a>
  </p>
</div>
