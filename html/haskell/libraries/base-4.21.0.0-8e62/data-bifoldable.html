<h1 class="caption">Data.Bifoldable</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(C) 2011-2016 Edward Kmett</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>provisional</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="description">
<h4 class="caption">Description</h4>
<p><span class="version">Since: base-4.10.0.0</span></p>
</div>
<p class="src">class <a id="t:Bifoldable" class="def">Bifoldable</a> (p :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) where <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#Bifoldable" class="link">Source</a> </p>
<p><code><a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a></code> identifies foldable structures with two different varieties of elements (as opposed to <code><a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>, which has one variety of element). Common examples are <code><a href="data-either.html#t:Either" title="Data.Either">Either</a></code> and <code class="inline-code">(,)</code>:</p>
<pre>instance Bifoldable Either where
  bifoldMap f _ (Left  a) = f a
  bifoldMap _ g (Right b) = g b

instance Bifoldable (,) where
  bifoldr f g z (a, b) = f a (g b z)</pre>
<p>Some examples below also use the following BiList to showcase empty Bifoldable behaviors when relevant (<code><a href="data-either.html#t:Either" title="Data.Either">Either</a></code> and <code class="inline-code">(,)</code> containing always exactly resp. 1 and 2 elements):</p>
<pre>data BiList a b = BiList [a] [b]

instance Bifoldable BiList where
  bifoldr f g z (BiList as bs) = foldr f (foldr g z bs) as</pre>
<p>A minimal <code><a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a></code> definition consists of either <code><a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a></code> or <code><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a></code>. When defining more than this minimal set, one should ensure that the following identities hold:</p>
<pre><a href="data-bifoldable.html#v:bifold" title="Data.Bifoldable">bifold</a> ≡ <a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> <a href="data-function.html#v:id" title="Data.Function">id</a> <a href="data-function.html#v:id" title="Data.Function">id</a>
<a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> f g ≡ <a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> (<a href="data-monoid.html#v:mappend" title="Data.Monoid">mappend</a> . f) (<a href="data-monoid.html#v:mappend" title="Data.Monoid">mappend</a> . g) <a href="data-monoid.html#v:mempty" title="Data.Monoid">mempty</a>
<a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> f g z t ≡ <a href="data-monoid.html#v:appEndo" title="Data.Monoid">appEndo</a> (<a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> (Endo . f) (Endo . g) t) z
</pre>
<p>If the type is also an instance of <code><a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>, then it must satisfy (up to laziness):</p>
<pre><a href="data-bifoldable.html#v:bifoldl" title="Data.Bifoldable">bifoldl</a> <a href="data-function.html#v:const" title="Data.Function">const</a> ≡ <a href="data-foldable.html#v:foldl" title="Data.Foldable">foldl</a>
<a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> (<a href="data-function.html#v:flip" title="Data.Function">flip</a> <a href="data-function.html#v:const" title="Data.Function">const</a>) ≡ <a href="data-foldable.html#v:foldr" title="Data.Foldable">foldr</a>
<a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> (<a href="data-function.html#v:const" title="Data.Function">const</a> <a href="data-monoid.html#v:mempty" title="Data.Monoid">mempty</a>) ≡ <a href="data-foldable.html#v:foldMap" title="Data.Foldable">foldMap</a>
</pre>
<p>If the type is also a <code><a href="data-bifunctor.html#v:Bifunctor" title="Data.Bifunctor">Bifunctor</a></code> instance, it should satisfy:</p>
<pre><a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> f g ≡ <a href="data-bifoldable.html#v:bifold" title="Data.Bifoldable">bifold</a> . <a href="data-bifunctor.html#v:bimap" title="Data.Bifunctor">bimap</a> f g
</pre>
<p>which implies that</p>
<pre><a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> f g . <a href="data-bifunctor.html#v:bimap" title="Data.Bifunctor">bimap</a> h i ≡ <a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> (f . h) (g . i)
</pre>
<p><span class="version">Since: base-4.10.0.0</span></p>
<div class="subs minimal">
<h4 class="caption">Minimal complete definition</h4>
<p class="src"><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> | <a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a></p>
</div>
<div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a id="v:bifold" class="def">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; p m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p>Combines the elements of a structure using a monoid.</p>
<pre><a href="data-bifoldable.html#v:bifold" title="Data.Bifoldable">bifold</a> ≡ <a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> <a href="data-function.html#v:id" title="Data.Function">id</a> <a href="data-function.html#v:id" title="Data.Function">id</a></pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifold0">Examples</h5>
<details id="ch:bifold0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifold (Right [1, 2, 3])
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifold (Left [5, 6])
</strong>[5,6]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifold ([1, 2, 3], [4, 5])
</strong>[1,2,3,4,5]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifold (Product 6, Product 7)
</strong>Product {getProduct = 42}
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifold (Sum 6, Sum 7)
</strong>Sum {getSum = 13}
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldMap" class="def">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; p a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p>Combines the elements of a structure, given ways of mapping them to a common monoid.</p>
<pre><a href="data-bifoldable.html#v:bifoldMap" title="Data.Bifoldable">bifoldMap</a> f g ≡ <a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> (<a href="data-monoid.html#v:mappend" title="Data.Monoid">mappend</a> . f) (<a href="data-monoid.html#v:mappend" title="Data.Monoid">mappend</a> . g) <a href="data-monoid.html#v:mempty" title="Data.Monoid">mempty</a></pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldMap0">Examples</h5>
<details id="ch:bifoldMap0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldMap (take 3) (fmap digitToInt) ([1..], "89")
</strong>[1,2,3,8,9]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldMap (take 3) (fmap digitToInt) (Left [1..])
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldMap (take 3) (fmap digitToInt) (Right "89")
</strong>[8,9]
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldr" class="def">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; p a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p>Combines the elements of a structure in a right associative manner. Given a hypothetical function <code class="inline-code">toEitherList :: p a b -&gt; [Either a b]</code> yielding a list of all elements of a structure in order, the following would hold:</p>
<pre><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> f g z ≡ <a href="data-foldable.html#v:foldr" title="Data.Foldable">foldr</a> (<a href="data-either.html#v:either" title="Data.Either">either</a> f g) z . toEitherList</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldr0">Examples</h5>
<details id="ch:bifoldr0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre>&gt; bifoldr (+) (*) 3 (5, 7)
26 -- 5 + (7 * 3)

&gt; bifoldr (+) (*) 3 (7, 5)
22 -- 7 + (5 * 3)

&gt; bifoldr (+) (*) 3 (Right 5)
15 -- 5 * 3

&gt; bifoldr (+) (*) 3 (Left 5)
8 -- 5 + 3
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldl" class="def">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; p a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
<p>Combines the elements of a structure in a left associative manner. Given a hypothetical function <code class="inline-code">toEitherList :: p a b -&gt; [Either a b]</code> yielding a list of all elements of a structure in order, the following would hold:</p>
<pre><a href="data-bifoldable.html#v:bifoldl" title="Data.Bifoldable">bifoldl</a> f g z
     ≡ <a href="data-foldable.html#v:foldl" title="Data.Foldable">foldl</a> (acc -&gt; <a href="data-either.html#v:either" title="Data.Either">either</a> (f acc) (g acc)) z . toEitherList</pre>
<p>Note that if you want an efficient left-fold, you probably want to use <code><a href="data-bifoldable.html#v:bifoldl-39-" title="Data.Bifoldable">bifoldl'</a></code> instead of <code><a href="data-bifoldable.html#v:bifoldl" title="Data.Bifoldable">bifoldl</a></code>. The reason is that the latter does not force the "inner" results, resulting in a thunk chain which then must be evaluated from the outside-in.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldl0">Examples</h5>
<details id="ch:bifoldl0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre>&gt; bifoldl (+) (*) 3 (5, 7)
56 -- (5 + 3) * 7

&gt; bifoldl (+) (*) 3 (7, 5)
50 -- (7 + 3) * 5

&gt; bifoldl (+) (*) 3 (Right 5)
15 -- 5 * 3

&gt; bifoldl (+) (*) 3 (Left 5)
8 -- 5 + 3
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
</div>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:Bifoldable">Instances</h5>
<details id="i:Bifoldable" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> <a href="data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Semigroup.html#line-441" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-semigroup.html">Data.Semigroup</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; <a href="data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; <a href="data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; <a href="data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> <a href="data-either.html#t:Either" title="Data.Either">Either</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-277" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="data-either.html#t:Either" title="Data.Either">Either</a> m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; <a href="data-either.html#t:Either" title="Data.Either">Either</a> a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; <a href="data-either.html#t:Either" title="Data.Either">Either</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; <a href="data-either.html#t:Either" title="Data.Either">Either</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple2" title="GHC.Tuple">(,)</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-245" class="link">Source</a> </td>
<td class="doc">
<p>Class laws for tuples hold only up to laziness. The Bifoldable methods are lazier than their Foldable counterparts. For example the law <code class="inline-code"><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a> (<a href="data-function.html#v:flip" title="Data.Function">flip</a> <a href="data-function.html#v:const" title="Data.Function">const</a>) ≡ <a href="data-foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> does not hold for tuples if laziness is exploited:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr (flip const) (:) [] (undefined :: (Int, Word)) `seq` ()
</strong>()
&gt;&gt;&gt; <strong class="userinput">foldr (:) [] (errorWithoutStackTrace "error!" :: (Int, Word)) `seq` ()
</strong>*** Exception: error!
</pre>
<p><span class="version">Since: base-4.10.0.0</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a> :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-249" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a> m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; <a href="data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a> a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; <a href="data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; <a href="data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple3" title="GHC.Tuple">(,,)</a> x) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-257" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (x, m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (x, a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (x, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (x, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="ghc-generics.html#t:K1" title="GHC.Generics">K1</a> i :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-253" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="ghc-generics.html#t:K1" title="GHC.Generics">K1</a> i m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; <a href="ghc-generics.html#t:K1" title="GHC.Generics">K1</a> i a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; <a href="ghc-generics.html#t:K1" title="GHC.Generics">K1</a> i a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; <a href="ghc-generics.html#t:K1" title="GHC.Generics">K1</a> i a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple4" title="GHC.Tuple">(,,,)</a> x y) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-261" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (x, y, m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (x, y, a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (x, y, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (x, y, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple5" title="GHC.Tuple">(,,,,)</a> x y z) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-265" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (x, y, z, m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (x, y, z, a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (x, y, z, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (x, y, z, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple6" title="GHC.Tuple">(,,,,,)</a> x y z w) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-269" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (x, y, z, w, m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (x, y, z, w, a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (x, y, z, w, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (x, y, z, w, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> (<a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Tuple.html#t:Tuple7" title="GHC.Tuple">(,,,,,,)</a> x y z w v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#line-273" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.10.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:ic:Bifoldable:Bifoldable:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-bifoldable.html">Data.Bifoldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (x, y, z, w, v, m, m) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (x, y, z, w, v, a, b) -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; (x, y, z, w, v, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; (x, y, z, w, v, a, b) -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src"><a id="v:bifoldr-39-" class="def">bifoldr'</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; t a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr%27" class="link">Source</a> </p>
<p>As <code><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a></code>, but strict in the result of the reduction functions at each step.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldr1" class="def">bifoldr1</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; a -&gt; a) -&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr1" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bifoldable.html#v:bifoldr" title="Data.Bifoldable">bifoldr</a></code> that has no base case, and thus may only be applied to non-empty structures.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldr10">Examples</h5>
<details id="ch:bifoldr10"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr1 (+) (5, 7)
</strong>12
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr1 (+) (Right 7)
</strong>7
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr1 (+) (Left 5)
</strong>5
</pre>
<pre>&gt; bifoldr1 (+) (BiList [1, 2] [3, 4])
10 -- 1 + (2 + (3 + 4))
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr1 (+) (BiList [1, 2] [])
</strong>3
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldr1 (+) (BiList [] [])
</strong>*** Exception: bifoldr1: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldrM" class="def">bifoldrM</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; c -&gt; m c) -&gt; (b -&gt; c -&gt; m c) -&gt; c -&gt; t a b -&gt; m c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldrM" class="link">Source</a> </p>
<p>Right associative monadic bifold over a structure.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldl-39-" class="def">bifoldl'</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; b -&gt; a) -&gt; (a -&gt; c -&gt; a) -&gt; a -&gt; t b c -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl%27" class="link">Source</a> </p>
<p>As <code><a href="data-bifoldable.html#v:bifoldl" title="Data.Bifoldable">bifoldl</a></code>, but strict in the result of the reduction functions at each step.</p>
<p>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., <code><a href="data-bifoldable.html#v:bilength" title="Data.Bifoldable">bilength</a></code>).</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldl1" class="def">bifoldl1</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; a -&gt; a) -&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl1" class="link">Source</a> </p>
<p>A variant of <code><a href="data-bifoldable.html#v:bifoldl" title="Data.Bifoldable">bifoldl</a></code> that has no base case, and thus may only be applied to non-empty structures.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldl10">Examples</h5>
<details id="ch:bifoldl10"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldl1 (+) (5, 7)
</strong>12
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldl1 (+) (Right 7)
</strong>7
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldl1 (+) (Left 5)
</strong>5
</pre>
<pre>&gt; bifoldl1 (+) (BiList [1, 2] [3, 4])
10 -- ((1 + 2) + 3) + 4
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldl1 (+) (BiList [1, 2] [])
</strong>3
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldl1 (+) (BiList [] [])
</strong>*** Exception: bifoldl1: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifoldlM" class="def">bifoldlM</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m a) -&gt; (a -&gt; c -&gt; m a) -&gt; a -&gt; t b c -&gt; m a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldlM" class="link">Source</a> </p>
<p>Left associative monadic bifold over a structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifoldlM0">Examples</h5>
<details id="ch:bifoldlM0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 ("Hello", True)
</strong>"Hello"
"True"
42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Right True)
</strong>"True"
42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Left "Hello")
</strong>"Hello"
42
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bitraverse_" class="def">bitraverse_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; t a b -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bitraverse_" class="link">Source</a> </p>
<p>Map each element of a structure using one of two actions, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results, see <code><a href="data-bitraversable.html#v:bitraverse" title="Data.Bitraversable">bitraverse</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bitraverse_0">Examples</h5>
<details id="ch:bitraverse_0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bitraverse_ print (print . show) ("Hello", True)
</strong>"Hello"
"True"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bitraverse_ print (print . show) (Right True)
</strong>"True"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bitraverse_ print (print . show) (Left "Hello")
</strong>"Hello"
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifor_" class="def">bifor_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; t a b -&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifor_" class="link">Source</a> </p>
<p>As <code><a href="data-bifoldable.html#v:bitraverse_" title="Data.Bifoldable">bitraverse_</a></code>, but with the structure as the primary argument. For a version that doesn't ignore the results, see <code><a href="data-bitraversable.html#v:bifor" title="Data.Bitraversable">bifor</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifor_0">Examples</h5>
<details id="ch:bifor_0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifor_ ("Hello", True) print (print . show)
</strong>"Hello"
"True"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifor_ (Right True) print (print . show)
</strong>"True"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifor_ (Left "Hello") print (print . show)
</strong>"Hello"
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bimapM_" class="def">bimapM_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; t a b -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bimapM_" class="link">Source</a> </p>
<p>Alias for <code><a href="data-bifoldable.html#v:bitraverse_" title="Data.Bifoldable">bitraverse_</a></code>.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biforM_" class="def">biforM_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; t a b -&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biforM_" class="link">Source</a> </p>
<p>Alias for <code><a href="data-bifoldable.html#v:bifor_" title="Data.Bifoldable">bifor_</a></code>.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bimsum" class="def">bimsum</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f) =&gt; t (f a) (f a) -&gt; f a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bimsum" class="link">Source</a> </p>
<p>Alias for <code><a href="data-bifoldable.html#v:biasum" title="Data.Bifoldable">biasum</a></code>.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bisequenceA_" class="def">bisequenceA_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; t (f a) (f b) -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bisequenceA_" class="link">Source</a> </p>
<p>Alias for <code><a href="data-bifoldable.html#v:bisequence_" title="Data.Bifoldable">bisequence_</a></code>.</p>
<p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bisequence_" class="def">bisequence_</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; t (f a) (f b) -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bisequence_" class="link">Source</a> </p>
<p>Evaluate each action in the structure from left to right, and ignore the results. For a version that doesn't ignore the results, see <code><a href="data-bitraversable.html#v:bisequence" title="Data.Bitraversable">bisequence</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bisequence_0">Examples</h5>
<details id="ch:bisequence_0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisequence_ (print "Hello", print "World")
</strong>"Hello"
"World"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisequence_ (Left (print "Hello"))
</strong>"Hello"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisequence_ (Right (print "World"))
</strong>"World"
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biasum" class="def">biasum</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="control-applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f) =&gt; t (f a) (f a) -&gt; f a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biasum" class="link">Source</a> </p>
<p>The sum of a collection of actions, generalizing <code><a href="data-bifoldable.html#v:biconcat" title="Data.Bifoldable">biconcat</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biasum0">Examples</h5>
<details id="ch:biasum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biasum (Nothing, Nothing)
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biasum (Nothing, Just 42)
</strong>Just 42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biasum (Just 18, Nothing)
</strong>Just 18
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biasum (Just 18, Just 42)
</strong>Just 18
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biList" class="def">biList</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t a a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biList" class="link">Source</a> </p>
<p>Collects the list of elements of a structure, from left to right.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biList0">Examples</h5>
<details id="ch:biList0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biList (18, 42)
</strong>[18,42]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biList (Left 18)
</strong>[18]
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:binull" class="def">binull</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t a b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#binull" class="link">Source</a> </p>
<p>Test whether the structure is empty.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:binull0">Examples</h5>
<details id="ch:binull0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binull (18, 42)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binull (Right 42)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binull (BiList [] [])
</strong>True
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bilength" class="def">bilength</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t a b -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bilength" class="link">Source</a> </p>
<p>Returns the size/length of a finite structure as an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bilength0">Examples</h5>
<details id="ch:bilength0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bilength (True, 42)
</strong>2
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bilength (Right 42)
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bilength (BiList [1,2,3] [4,5])
</strong>5
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bilength (BiList [] [])
</strong>0
</pre>
<p>On infinite structures, this function hangs:</p>
<pre>&gt; bilength (BiList [1..] [])
* Hangs forever *
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bielem" class="def">bielem</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; t a a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bielem" class="link">Source</a> </p>
<p>Does the element occur in the structure?</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bielem0">Examples</h5>
<details id="ch:bielem0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (17, 42)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (17, 43)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (Left 42)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (Right 13)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (BiList [1..5] [1..100])
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bielem 42 (BiList [1..5] [1..41])
</strong>False
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bimaximum" class="def">bimaximum</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bimaximum" class="link">Source</a> </p>
<p>The largest element of a non-empty structure. This function is equivalent to <code class="inline-code"><a href="data-bifoldable.html#v:bifoldr1" title="Data.Bifoldable">bifoldr1</a> <a href="data-ord.html#v:max" title="Data.Ord">max</a></code>, and its behavior on structures with multiple largest elements depends on the relevant implementation of <code><a href="data-ord.html#v:max" title="Data.Ord">max</a></code>. For the default implementation of <code><a href="data-ord.html#v:max" title="Data.Ord">max</a></code> (<code class="inline-code">max x y = if x &lt;= y then y else x</code>), structure order is used as a tie-breaker: if there are multiple largest elements, the rightmost of them is chosen (this is equivalent to <code class="inline-code"><a href="data-bifoldable.html#v:bimaximumBy" title="Data.Bifoldable">bimaximumBy</a>
 <a href="data-ord.html#v:compare" title="Data.Ord">compare</a></code>).</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bimaximum0">Examples</h5>
<details id="ch:bimaximum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximum (42, 17)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximum (Right 42)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximum (BiList [13, 29, 4] [18, 1, 7])
</strong>29
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximum (BiList [13, 29, 4] [])
</strong>29
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximum (BiList [] [])
</strong>*** Exception: bimaximum: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biminimum" class="def">biminimum</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biminimum" class="link">Source</a> </p>
<p>The least element of a non-empty structure. This function is equivalent to <code class="inline-code"><a href="data-bifoldable.html#v:bifoldr1" title="Data.Bifoldable">bifoldr1</a> <a href="data-ord.html#v:min" title="Data.Ord">min</a></code>, and its behavior on structures with multiple least elements depends on the relevant implementation of <code><a href="data-ord.html#v:min" title="Data.Ord">min</a></code>. For the default implementation of <code><a href="data-ord.html#v:min" title="Data.Ord">min</a></code> (<code class="inline-code">min x y = if x &lt;= y then x else y</code>), structure order is used as a tie-breaker: if there are multiple least elements, the leftmost of them is chosen (this is equivalent to <code class="inline-code"><a href="data-bifoldable.html#v:biminimumBy" title="Data.Bifoldable">biminimumBy</a>
 <a href="data-ord.html#v:compare" title="Data.Ord">compare</a></code>).</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biminimum0">Examples</h5>
<details id="ch:biminimum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimum (42, 17)
</strong>17
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimum (Right 42)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimum (BiList [13, 29, 4] [18, 1, 7])
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimum (BiList [13, 29, 4] [])
</strong>4
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimum (BiList [] [])
</strong>*** Exception: biminimum: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bisum" class="def">bisum</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bisum" class="link">Source</a> </p>
<p>The <code><a href="data-bifoldable.html#v:bisum" title="Data.Bifoldable">bisum</a></code> function computes the sum of the numbers of a structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bisum0">Examples</h5>
<details id="ch:bisum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisum (42, 17)
</strong>59
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisum (Right 42)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisum (BiList [13, 29, 4] [18, 1, 7])
</strong>72
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisum (BiList [13, 29, 4] [])
</strong>46
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bisum (BiList [] [])
</strong>0
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biproduct" class="def">biproduct</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biproduct" class="link">Source</a> </p>
<p>The <code><a href="data-bifoldable.html#v:biproduct" title="Data.Bifoldable">biproduct</a></code> function computes the product of the numbers of a structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biproduct0">Examples</h5>
<details id="ch:biproduct0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biproduct (42, 17)
</strong>714
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biproduct (Right 42)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biproduct (BiList [13, 29, 4] [18, 1, 7])
</strong>190008
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biproduct (BiList [13, 29, 4] [])
</strong>1508
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biproduct (BiList [] [])
</strong>1
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biconcat" class="def">biconcat</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t [a] [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biconcat" class="link">Source</a> </p>
<p>Reduces a structure of lists to the concatenation of those lists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biconcat0">Examples</h5>
<details id="ch:biconcat0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcat ([1, 2, 3], [4, 5])
</strong>[1,2,3,4,5]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcat (Left [1, 2, 3])
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcat (BiList [[1, 2, 3, 4, 5], [6, 7, 8]] [[9]])
</strong>[1,2,3,4,5,6,7,8,9]
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biconcatMap" class="def">biconcatMap</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; [c]) -&gt; (b -&gt; [c]) -&gt; t a b -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biconcatMap" class="link">Source</a> </p>
<p>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biconcatMap0">Examples</h5>
<details id="ch:biconcatMap0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcatMap (take 3) (fmap digitToInt) ([1..], "89")
</strong>[1,2,3,8,9]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcatMap (take 3) (fmap digitToInt) (Left [1..])
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biconcatMap (take 3) (fmap digitToInt) (Right "89")
</strong>[8,9]
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biand" class="def">biand</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biand" class="link">Source</a> </p>
<p><code><a href="data-bifoldable.html#v:biand" title="Data.Bifoldable">biand</a></code> returns the conjunction of a container of Bools. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the container must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value finitely far from the left end.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biand0">Examples</h5>
<details id="ch:biand0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biand (True, False)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biand (True, True)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biand (Left True)
</strong>True
</pre>
<p>Empty structures yield <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biand (BiList [] [])
</strong>True
</pre>
<p>A <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value finitely far from the left end yields <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> (short circuit):</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biand (BiList [True, True, False, True] (repeat True))
</strong>False
</pre>
<p>A <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value infinitely far from the left end hangs:</p>
<pre>&gt; biand (BiList (repeat True) [False])
* Hangs forever *
</pre>
<p>An infinitely <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value hangs:</p>
<pre>&gt; biand (BiList (repeat True) [])
* Hangs forever *
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bior" class="def">bior</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; t <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bior" class="link">Source</a> </p>
<p><code><a href="data-bifoldable.html#v:bior" title="Data.Bifoldable">bior</a></code> returns the disjunction of a container of Bools. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the container must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value finitely far from the left end.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bior0">Examples</h5>
<details id="ch:bior0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bior (True, False)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bior (False, False)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bior (Left True)
</strong>True
</pre>
<p>Empty structures yield <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bior (BiList [] [])
</strong>False
</pre>
<p>A <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value finitely far from the left end yields <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> (short circuit):</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bior (BiList [False, False, True, False] (repeat False))
</strong>True
</pre>
<p>A <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value infinitely far from the left end hangs:</p>
<pre>&gt; bior (BiList (repeat False) [True])
* Hangs forever *
</pre>
<p>An infinitely <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value hangs:</p>
<pre>&gt; bior (BiList (repeat False) [])
* Hangs forever *
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biany" class="def">biany</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biany" class="link">Source</a> </p>
<p>Determines whether any element of the structure satisfies its appropriate predicate argument. Empty structures yield <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biany0">Examples</h5>
<details id="ch:biany0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (27, 't')
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (27, '8')
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (26, 't')
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (Left 27)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (Left 26)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (BiList [27, 53] ['t', '8'])
</strong>True
</pre>
<p>Empty structures yield <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biany even isDigit (BiList [] [])
</strong>False
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biall" class="def">biall</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biall" class="link">Source</a> </p>
<p>Determines whether all elements of the structure satisfy their appropriate predicate argument. Empty structures yield <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biall0">Examples</h5>
<details id="ch:biall0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (27, 't')
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (26, '8')
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (Left 27)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (Left 26)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (BiList [26, 52] ['3', '8'])
</strong>True
</pre>
<p>Empty structures yield <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biall even isDigit (BiList [] [])
</strong>True
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bimaximumBy" class="def">bimaximumBy</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bimaximumBy" class="link">Source</a> </p>
<p>The largest element of a non-empty structure with respect to the given comparison function. Structure order is used as a tie-breaker: if there are multiple largest elements, the rightmost of them is chosen.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bimaximumBy0">Examples</h5>
<details id="ch:bimaximumBy0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximumBy compare (42, 17)
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximumBy compare (Left 17)
</strong>17
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximumBy compare (BiList [42, 17, 23] [-5, 18])
</strong>42
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bimaximumBy compare (BiList [] [])
</strong>*** Exception: bifoldr1: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:biminimumBy" class="def">biminimumBy</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t a a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#biminimumBy" class="link">Source</a> </p>
<p>The least element of a non-empty structure with respect to the given comparison function. Structure order is used as a tie-breaker: if there are multiple least elements, the leftmost of them is chosen.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:biminimumBy0">Examples</h5>
<details id="ch:biminimumBy0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimumBy compare (42, 17)
</strong>17
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimumBy compare (Left 17)
</strong>17
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimumBy compare (BiList [42, 17, 23] [-5, 18])
</strong>-5
</pre>
<p>On empty structures, this function throws an exception:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">biminimumBy compare (BiList [] [])
</strong>*** Exception: bifoldr1: empty structure
...
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:binotElem" class="def">binotElem</a> :: (<a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t, <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; t a a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#binotElem" class="link">Source</a> </p>
<p><code><a href="data-bifoldable.html#v:binotElem" title="Data.Bifoldable">binotElem</a></code> is the negation of <code><a href="data-bifoldable.html#v:bielem" title="Data.Bifoldable">bielem</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:binotElem0">Examples</h5>
<details id="ch:binotElem0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (17, 42)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (17, 43)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (Left 42)
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (Right 13)
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (BiList [1..5] [1..100])
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">binotElem 42 (BiList [1..5] [1..41])
</strong>True
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
<p class="src"><a id="v:bifind" class="def">bifind</a> :: <a href="data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a a -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifind" class="link">Source</a> </p>
<p>The <code><a href="data-bifoldable.html#v:bifind" title="Data.Bifoldable">bifind</a></code> function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:bifind0">Examples</h5>
<details id="ch:bifind0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifind even (27, 53)
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifind even (27, 52)
</strong>Just 52
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifind even (26, 52)
</strong>Just 26
</pre>
<p>Empty structures always yield <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">bifind even (BiList [] [])
</strong>Nothing
</pre></details><p><span class="version">Since: base-4.10.0.0</span></p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Data-Bifoldable.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Data-Bifoldable.html</a>
  </p>
</div>
