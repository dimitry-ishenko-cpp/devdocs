<h1 class="caption">Debug.Trace</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 2001</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file libraries/base/LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>provisional</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>None</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Tracing</a></li>
<li><a href="#g:2">Eventlog tracing</a></li>
<li><a href="#g:3">Execution phase markers</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>Functions for tracing and monitoring execution.</p>
<p>These can be useful for investigating bugs or performance problems. They should <em>not</em> be used in production code.</p>
</div>
<a href="#g:1" id="g:1"><h2>Tracing</h2></a><p>The <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code>, <code><a href="debug-trace.html#v:traceShow" title="Debug.Trace">traceShow</a></code> and <code><a href="debug-trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> functions print messages to an output stream. They are intended for "printf debugging", that is: tracing the flow of execution and printing interesting values.</p>
<p>All these functions evaluate the message completely before printing it; so if the message is not fully defined, none of it will be printed.</p>
<p>The usual output stream is <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-System-IO.html#v:stderr" title="GHC.Internal.System.IO">stderr</a></code>. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</p>
<p class="src"><a id="v:trace" class="def">trace</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#trace" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code> function outputs the trace message given as its first argument, before returning the second argument as its result.</p>
<p>For example, this returns the value of <code class="inline-code">f x</code> and outputs the message to stderr. Depending on your terminal (settings), they may or may not be mixed.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">let x = 123; f = show
</strong>&gt;&gt;&gt; <strong class="userinput">trace ("calling f with x = " ++ show x) (f x)
</strong>calling f with x = 123
"123"
</pre>
<p>The <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code> function should <em>only</em> be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</p>
<p class="src"><a id="v:traceId" class="def">traceId</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceId" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code> but returns the message instead of a third value.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">traceId "hello"
</strong>hello
"hello"
</pre>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:traceShow" class="def">traceShow</a> :: <a href="prelude.html#t:Show" title="Prelude">Show</a> a =&gt; a -&gt; b -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceShow" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code>, but uses <code><a href="prelude.html#v:show" title="Prelude">show</a></code> on the argument to convert it to a <code><a href="data-string.html#t:String" title="Data.String">String</a></code>.</p>
<p>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example, here we print the values of the variables <code class="inline-code">x</code> and <code class="inline-code">y</code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">let f x y = traceShow ("x", x, "y", y) (x + y) in f (1+2) 5
</strong>("x",3,"y",5)
8
</pre>
<p>Note in this example we also create simple labels just by including some strings.</p>
<p class="src"><a id="v:traceShowId" class="def">traceShowId</a> :: <a href="prelude.html#t:Show" title="Prelude">Show</a> a =&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceShowId" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:traceShow" title="Debug.Trace">traceShow</a></code> but returns the shown value instead of a third value.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">traceShowId (1+2+3, "hello" ++ "world")
</strong>(6,"helloworld")
(6,"helloworld")
</pre>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:traceWith" class="def">traceWith</a> :: (a -&gt; <a href="data-string.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceWith" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code>, but outputs the result of calling a function on the argument.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">traceWith fst ("hello","world")
</strong>hello
("hello","world")
</pre>
<p><span class="version">Since: base-4.18.0.0</span></p>
<p class="src"><a id="v:traceShowWith" class="def">traceShowWith</a> :: <a href="prelude.html#t:Show" title="Prelude">Show</a> b =&gt; (a -&gt; b) -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceShowWith" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:traceWith" title="Debug.Trace">traceWith</a></code>, but uses <code><a href="prelude.html#v:show" title="Prelude">show</a></code> on the result of the function to convert it to a <code><a href="data-string.html#t:String" title="Data.String">String</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">traceShowWith length [1,2,3]
</strong>3
[1,2,3]
</pre>
<p><span class="version">Since: base-4.18.0.0</span></p>
<p class="src"><a id="v:traceStack" class="def">traceStack</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceStack" class="link">Source</a> </p>
<p>like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code>, but additionally prints a call stack if one is available.</p>
<p>In the current GHC implementation, the call stack is only available if the program was compiled with <code class="inline-code">-prof</code>; otherwise <code><a href="debug-trace.html#v:traceStack" title="Debug.Trace">traceStack</a></code> behaves exactly like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code>. Entries in the call stack correspond to <code class="inline-code">SCC</code> annotations, so it is a good idea to use <code class="inline-code">-fprof-auto</code> or <code class="inline-code">-fprof-auto-calls</code> to add SCC annotations automatically.</p>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:traceIO" class="def">traceIO</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceIO" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</p>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:traceM" class="def">traceM</a> :: <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceM" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code> but returning unit in an arbitrary <code><a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context. Allows for convenient use in do-notation.</p>
<p>Note that the application of <code><a href="debug-trace.html#v:traceM" title="Debug.Trace">traceM</a></code> is not an action in the <code><a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context, as <code><a href="debug-trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> is in the <code><a href="prelude.html#t:IO" title="Prelude">IO</a></code> type. While the fresh bindings in the following example will force the <code><a href="debug-trace.html#v:traceM" title="Debug.Trace">traceM</a></code> expressions to be reduced every time the <code class="inline-code">do</code>-block is executed, <code class="inline-code">traceM "not crashed"</code> would only be reduced once, and the message would only be printed once. If your monad is in <code><a href="control-monad-io-class.html#v:MonadIO" title="Control.Monad.IO.Class">MonadIO</a></code>, <code class="inline-code"><a href="control-monad-io-class.html#v:liftIO" title="Control.Monad.IO.Class">liftIO</a> . <a href="debug-trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> may be a better option.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">:{
</strong>do
    x &lt;- Just 3
    traceM ("x: " ++ show x)
    y &lt;- pure 12
    traceM ("y: " ++ show y)
    pure (x*2 + y)
:}
x: 3
y: 12
Just 18
</pre>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:traceShowM" class="def">traceShowM</a> :: (<a href="prelude.html#t:Show" title="Prelude">Show</a> a, <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; a -&gt; f () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceShowM" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:traceM" title="Debug.Trace">traceM</a></code>, but uses <code><a href="prelude.html#v:show" title="Prelude">show</a></code> on the argument to convert it to a <code><a href="data-string.html#t:String" title="Data.String">String</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">:{
</strong>do
    x &lt;- Just 3
    traceShowM x
    y &lt;- pure 12
    traceShowM y
    pure (x*2 + y)
:}
3
12
Just 18
</pre>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:putTraceMsg" class="def">putTraceMsg</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#putTraceMsg" class="link">Source</a> </p>
<div class="warning"><p>Deprecated: Use <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Debug-Trace.html#v:traceIO" title="GHC.Internal.Debug.Trace">traceIO</a></code></p></div>
<a href="#g:2" id="g:2"><h2>Eventlog tracing</h2></a><p>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</p>
<p>Currently only GHC provides eventlog profiling, see the GHC user guide for details on how to use it. These function exists for other Haskell implementations but no events are emitted. Note that the string message is always evaluated, whether or not profiling is available or enabled.</p>
<p class="src"><a id="v:traceEvent" class="def">traceEvent</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceEvent" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code> function behaves like <code><a href="debug-trace.html#v:trace" title="Debug.Trace">trace</a></code> with the difference that the message is emitted to the eventlog, if eventlog tracing is available and user event tracing is enabled at runtime.</p>
<p>It is suitable for use in pure code. In an IO context use <code><a href="debug-trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code> instead.</p>
<p>Note that when using GHC's SMP runtime, it is possible (but rare) to get duplicate events emitted if two CPUs simultaneously evaluate the same thunk that uses <code><a href="debug-trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>.</p>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:traceEventWith" class="def">traceEventWith</a> :: (a -&gt; <a href="data-string.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceEventWith" class="link">Source</a> </p>
<p>Like <code><a href="debug-trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>, but emits the result of calling a function on its argument.</p>
<p><span class="version">Since: base-4.18.0.0</span></p>
<p class="src"><a id="v:traceEventIO" class="def">traceEventIO</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceEventIO" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code> function emits a message to the eventlog, if eventlog tracing is available and user event tracing is enabled at runtime.</p>
<p>Compared to <code><a href="debug-trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>, <code><a href="debug-trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code> sequences the event with respect to other IO actions.</p>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:flushEventLog" class="def">flushEventLog</a> :: <a href="prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#flushEventLog" class="link">Source</a> </p>
<p>Immediately flush the event log, if enabled.</p>
<p><span class="version">Since: base-4.15.0.0</span></p>
<a href="#g:3" id="g:3"><h2>Execution phase markers</h2></a><p>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</p>
<p>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</p>
<p>Markers let us do this: we can annotate the program to emit a marker at an appropriate point during execution and then see that in a profile.</p>
<p>Currently this feature is only supported in GHC by the eventlog tracing system, but in future it may also be supported by the heap profiling or other profiling tools. These function exists for other Haskell implementations but they have no effect. Note that the string message is always evaluated, whether or not profiling is available or enabled.</p>
<p class="src"><a id="v:traceMarker" class="def">traceMarker</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceMarker" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code> function emits a marker to the eventlog, if eventlog tracing is available and enabled at runtime. The <code class="inline-code">String</code> is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</p>
<p>This function is suitable for use in pure code. In an IO context use <code><a href="debug-trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> instead.</p>
<p>Note that when using GHC's SMP runtime, it is possible (but rare) to get duplicate events emitted if two CPUs simultaneously evaluate the same thunk that uses <code><a href="debug-trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code>.</p>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:traceMarkerIO" class="def">traceMarkerIO</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="prelude.html#t:IO" title="Prelude">IO</a> () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Debug.Trace.html#traceMarkerIO" class="link">Source</a> </p>
<p>The <code><a href="debug-trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> function emits a marker to the eventlog, if eventlog tracing is available and user event tracing is enabled at runtime.</p>
<p>Compared to <code><a href="debug-trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code>, <code><a href="debug-trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> sequences the event with respect to other IO actions.</p>
<p><span class="version">Since: base-4.7.0.0</span></p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Debug-Trace.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Debug-Trace.html</a>
  </p>
</div>
