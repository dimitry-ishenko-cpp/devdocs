<h1 class="caption">Data.List</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 2001</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file libraries/base/LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>stable</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Basic functions</a></li>
<li><a href="#g:2">List transformations</a></li>
<li>
<a href="#g:3">Reducing lists (folds)</a><ul><li><a href="#g:4">Special folds</a></li></ul>
</li>
<li>
<a href="#g:5">Building lists</a><ul>
<li><a href="#g:6">Scans</a></li>
<li><a href="#g:7">Accumulating maps</a></li>
<li><a href="#g:8">Infinite lists</a></li>
<li><a href="#g:9">Unfolding</a></li>
</ul>
</li>
<li>
<a href="#g:10">Sublists</a><ul>
<li><a href="#g:11">Extracting sublists</a></li>
<li><a href="#g:12">Predicates</a></li>
</ul>
</li>
<li>
<a href="#g:13">Searching lists</a><ul>
<li><a href="#g:14">Searching by equality</a></li>
<li><a href="#g:15">Searching with a predicate</a></li>
</ul>
</li>
<li><a href="#g:16">Indexing lists</a></li>
<li><a href="#g:17">Zipping and unzipping lists</a></li>
<li>
<a href="#g:18">Special lists</a><ul>
<li><a href="#g:19">Functions on strings</a></li>
<li><a href="#g:20">"Set" operations</a></li>
<li><a href="#g:21">Ordered lists</a></li>
</ul>
</li>
<li>
<a href="#g:22">Generalized functions</a><ul>
<li>
<a href="#g:23">The "<code class="inline-code">By</code>" operations</a><ul>
<li><a href="#g:24">User-supplied equality (replacing an <code class="inline-code">Eq</code> context)</a></li>
<li><a href="#g:25">User-supplied comparison (replacing an <code class="inline-code">Ord</code> context)</a></li>
</ul>
</li>
<li><a href="#g:26">The "<code class="inline-code">generic</code>" operations</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>Operations on lists.</p>
</div>
<p class="src">data <a id="t:List" class="def">List</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Types.html#List" class="link">Source</a> </p>
<p>The builtin linked list type.</p>
<p>In Haskell, lists are one of the most important data types as they are often used analogous to loops in imperative programming languages. These lists are singly linked, which makes them unsuited for operations that require <span class="mathjax">\(\mathcal{O}(1)\)</span> access. Instead, they are intended to be traversed.</p>
<p>You can use <code class="inline-code">List a</code> or <code class="inline-code">[a]</code> in type signatures:</p>
<pre>length :: [a] -&gt; Int</pre>
<p>or</p>
<pre>length :: List a -&gt; Int</pre>
<p>They are fully equivalent, and <code class="inline-code">List a</code> will be normalised to <code class="inline-code">[a]</code>.</p>
<h5>Usage</h5>
<p>Lists are constructed recursively using the right-associative constructor operator (or <em>cons</em>) <code class="inline-code">(:) :: a -&gt; [a] -&gt; [a]</code>, which prepends an element to a list, and the empty list <code class="inline-code">[]</code>.</p>
<pre>(1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
</pre>
<p>Lists can also be constructed using list literals of the form <code class="inline-code">[x_1, x_2, ..., x_n]</code> which are syntactic sugar and, unless <code class="inline-code">-XOverloadedLists</code> is enabled, are translated into uses of <code class="inline-code">(:)</code> and <code class="inline-code">[]</code></p>
<p><code><a href="data-string.html#v:String" title="Data.String">String</a></code> literals, like <code class="inline-code">"I ðŸ’œ hs"</code>, are translated into Lists of characters, <code class="inline-code">['I', ' ', 'ðŸ’œ', ' ', 'h', 's']</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:List0">Implementation</h5>
<details id="ch:List0"><summary class="hide-when-js-enabled">Expand</summary><p>Internally and in memory, all the above are represented like this, with arrows being pointers to locations in memory.</p>
<pre>â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”€â•®
â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚ [] â”‚
â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”€â•¯
      v              v              v
      1              2              3</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:List1">Examples</h5>
<details id="ch:List1"><summary class="hide-when-js-enabled">Expand</summary><pre>&gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
"Haskell"
</pre>
<pre>&gt;&gt;&gt; 1 : [4, 1, 5, 9]
[1,4,1,5,9]
</pre>
<pre>&gt;&gt;&gt; [] : [] : []
[[],[]]
</pre></details><p><span class="version">Since: ghc-prim-0.10.0</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:List">Instances</h5>
<details id="i:List" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="data-functor-classes.html#t:Eq1" title="Data.Functor.Classes">Eq1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#line-511" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Eq1:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-functor-classes.html">Data.Functor.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftEq">liftEq</a> :: (a -&gt; b -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [b] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftEq" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-functor-classes.html#t:Ord1" title="Data.Functor.Classes">Ord1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#line-518" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Ord1:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-functor-classes.html">Data.Functor.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftCompare">liftCompare</a> :: (a -&gt; b -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; [a] -&gt; [b] -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftCompare" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-functor-classes.html#t:Read1" title="Data.Functor.Classes">Read1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#line-525" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Read1:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-functor-classes.html">Data.Functor.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftReadsPrec">liftReadsPrec</a> :: (<a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> a) -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadList">liftReadList</a> :: (<a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> a) -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadList" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadPrec">liftReadPrec</a> :: <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> a -&gt; <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] -&gt; <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadListPrec">liftReadListPrec</a> :: <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> a -&gt; <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] -&gt; <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadListPrec" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-functor-classes.html#t:Show1" title="Data.Functor.Classes">Show1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#line-531" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Show1:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-functor-classes.html">Data.Functor.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftShowsPrec">liftShowsPrec</a> :: (<a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftShowList">liftShowList</a> :: (<a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; [[a]] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowList" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-1760" class="link">Source</a> </td>
<td class="doc">
<p>Combines lists by concatenation, starting from the empty list.</p>
<p><span class="version">Since: base-2.1</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Alternative:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:empty">empty</a> :: [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#empty" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3C%7C%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:some">some</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#some" class="link">Source</a> </p>
<p class="src"><a href="#v:many">many</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#many" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-1739" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Applicative:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#pure" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: [a -&gt; b] -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3C%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#liftA2" class="link">Source</a> </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: [a] -&gt; [b] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: [a] -&gt; [b] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3C%2A" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad.html#t:Functor" title="Control.Monad">Functor</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-1733" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#fmap" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; [b] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3C%24" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-1751" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Monad:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: [a] -&gt; (a -&gt; [b]) -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3E%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: [a] -&gt; [b] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3E%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#return" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-1767" class="link">Source</a> </td>
<td class="doc">
<p>Combines lists by concatenation, starting from the empty list.</p>
<p><span class="version">Since: base-2.1</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:List:MonadPlus:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mzero">mzero</a> :: [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#mzero" class="link">Source</a> </p>
<p class="src"><a href="#v:mplus">mplus</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#mplus" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad.html#t:MonadFail" title="Control.Monad">MonadFail</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Fail.html#line-53" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:MonadFail:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Control-Monad-Fail.html">GHC.Internal.Control.Monad.Fail</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fail">fail</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Fail.html#fail" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad-fix.html#t:MonadFix" title="Control.Monad.Fix">MonadFix</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Fix.html#line-87" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:MonadFix:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Control-Monad-Fix.html">GHC.Internal.Control.Monad.Fix</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mfix">mfix</a> :: (a -&gt; [a]) -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Fix.html#mfix" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="control-monad-zip.html#t:MonadZip" title="Control.Monad.Zip">MonadZip</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Zip.html#line-65" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: ghc-internal-4.3.1.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:MonadZip:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Control-Monad-Zip.html">GHC.Internal.Control.Monad.Zip</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mzip">mzip</a> :: [a] -&gt; [b] -&gt; [(a, b)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Zip.html#mzip" class="link">Source</a> </p>
<p class="src"><a href="#v:mzipWith">mzipWith</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Zip.html#mzipWith" class="link">Source</a> </p>
<p class="src"><a href="#v:munzip">munzip</a> :: [(a, b)] -&gt; ([a], [b]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Control.Monad.Zip.html#munzip" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#line-692" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Foldable:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-Foldable.html">GHC.Internal.Data.Foldable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fold">fold</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; [m] -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#fold" class="link">Source</a> </p>
<p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; [a] -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:foldMap-39-">foldMap'</a> :: <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; [a] -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldMap%27" class="link">Source</a> </p>
<p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldr" class="link">Source</a> </p>
<p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldr%27" class="link">Source</a> </p>
<p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl" class="link">Source</a> </p>
<p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl%27" class="link">Source</a> </p>
<p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldr1" class="link">Source</a> </p>
<p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl1" class="link">Source</a> </p>
<p class="src"><a href="#v:toList">toList</a> :: [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#toList" class="link">Source</a> </p>
<p class="src"><a href="#v:null">null</a> :: [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#null" class="link">Source</a> </p>
<p class="src"><a href="#v:length">length</a> :: [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#length" class="link">Source</a> </p>
<p class="src"><a href="#v:elem">elem</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#elem" class="link">Source</a> </p>
<p class="src"><a href="#v:maximum">maximum</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#maximum" class="link">Source</a> </p>
<p class="src"><a href="#v:minimum">minimum</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#minimum" class="link">Source</a> </p>
<p class="src"><a href="#v:sum">sum</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#sum" class="link">Source</a> </p>
<p class="src"><a href="#v:product">product</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#product" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#line-241" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Traversable:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-Traversable.html">GHC.Internal.Data.Traversable</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:traverse">traverse</a> :: <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; [a] -&gt; f [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#traverse" class="link">Source</a> </p>
<p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; [f a] -&gt; f [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#sequenceA" class="link">Source</a> </p>
<p class="src"><a href="#v:mapM">mapM</a> :: <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#mapM" class="link">Source</a> </p>
<p class="src"><a href="#v:sequence">sequence</a> :: <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; [m a] -&gt; m [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#sequence" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="ghc-generics.html#t:Generic1" title="GHC.Generics">Generic1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#line-1645" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Generic1:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a>
</td>
<td class="doc"><p><span class="version">Since: base-4.6.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:if:Rep1_List:Rep1:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="src">type <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> = <a href="ghc-generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="ghc-generics.html#v:MetaData" title="GHC.Generics">MetaData</a> "List" "GHC.Types" "ghc-prim" '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> "[]" '<a href="ghc-generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:U1" title="GHC.Generics">U1</a> :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="ghc-generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> ":" ('<a href="ghc-generics.html#v:InfixI" title="GHC.Generics">InfixI</a> '<a href="ghc-generics.html#v:RightAssociative" title="GHC.Generics">RightAssociative</a> 5) '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) <a href="ghc-generics.html#t:Par1" title="GHC.Generics">Par1</a> <a href="ghc-generics.html#t::-42-:" title="GHC.Generics">:*:</a> <a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec1" title="GHC.Generics">Rec1</a> <a href="data-list.html#t:List" title="Data.List">[]</a>)))</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:from1">from1</a> :: [a] -&gt; <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#from1" class="link">Source</a> </p>
<p class="src"><a href="#v:to1">to1</a> :: <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#to1" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Lift.html#t:Lift" title="GHC.Internal.TH.Lift">Lift</a> a =&gt; <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Lift.html#t:Lift" title="GHC.Internal.TH.Lift">Lift</a> ([a] :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.TH.Lift.html#line-206" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Lift:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Lift.html">GHC.Internal.TH.Lift</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:lift">lift</a> :: <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Syntax.html#t:Quote" title="GHC.Internal.TH.Syntax">Quote</a> m =&gt; [a] -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.TH.Lift.html#lift" class="link">Source</a> </p>
<p class="src"><a href="#v:liftTyped">liftTyped</a> :: forall (m :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Syntax.html#t:Quote" title="GHC.Internal.TH.Syntax">Quote</a> m =&gt; [a] -&gt; <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-TH-Syntax.html#t:Code" title="GHC.Internal.TH.Syntax">Code</a> m [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.TH.Lift.html#liftTyped" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="text-printf.html#t:IsChar" title="Text.Printf">IsChar</a> c =&gt; <a href="text-printf.html#t:PrintfArg" title="Text.Printf">PrintfArg</a> [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Text.Printf.html#line-331" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:PrintfArg:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="text-printf.html">Text.Printf</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:formatArg">formatArg</a> :: [c] -&gt; <a href="text-printf.html#t:FieldFormatter" title="Text.Printf">FieldFormatter</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Text.Printf.html#formatArg" class="link">Source</a> </p>
<p class="src"><a href="#v:parseFormat">parseFormat</a> :: [c] -&gt; <a href="text-printf.html#t:ModifierParser" title="Text.Printf">ModifierParser</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Text.Printf.html#parseFormat" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="text-printf.html#t:IsChar" title="Text.Printf">IsChar</a> c =&gt; <a href="text-printf.html#t:PrintfType" title="Text.Printf">PrintfType</a> [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Text.Printf.html#line-285" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:PrintfType:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="text-printf.html">Text.Printf</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:spr">spr</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [UPrintf] -&gt; [c]</p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-725" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Monoid:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mempty">mempty</a> :: [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#mempty" class="link">Source</a> </p>
<p class="src"><a href="#v:mappend">mappend</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#mappend" class="link">Source</a> </p>
<p class="src"><a href="#v:mconcat">mconcat</a> :: [[a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#mconcat" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="prelude.html#t:Semigroup" title="Prelude">Semigroup</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#line-713" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.9.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Semigroup:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Base.html">GHC.Internal.Base</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%3C%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#sconcat" class="link">Source</a> </p>
<p class="src"><a href="#v:stimes">stimes</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#stimes" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-data.html#t:Data" title="Data.Data">Data</a> a =&gt; <a href="data-data.html#t:Data" title="Data.Data">Data</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#line-1136" class="link">Source</a> </td>
<td class="doc">
<p>For historical reasons, the constructor name used for <code class="inline-code">(:)</code> is <code class="inline-code">"(:)"</code>. In a derived instance, it would be <code class="inline-code">":"</code>.</p>
<p><span class="version">Since: base-4.0.0.0</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Data:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-Data.html">GHC.Internal.Data.Data</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:gfoldl">gfoldl</a> :: (forall d b. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (d -&gt; b) -&gt; d -&gt; c b) -&gt; (forall g. g -&gt; c g) -&gt; [a] -&gt; c [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gfoldl" class="link">Source</a> </p>
<p class="src"><a href="#v:gunfold">gunfold</a> :: (forall b r. <a href="data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; c (b -&gt; r) -&gt; c r) -&gt; (forall r. r -&gt; c r) -&gt; <a href="data-data.html#t:Constr" title="Data.Data">Constr</a> -&gt; c [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gunfold" class="link">Source</a> </p>
<p class="src"><a href="#v:toConstr">toConstr</a> :: [a] -&gt; <a href="data-data.html#t:Constr" title="Data.Data">Constr</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#toConstr" class="link">Source</a> </p>
<p class="src"><a href="#v:dataTypeOf">dataTypeOf</a> :: [a] -&gt; <a href="data-data.html#t:DataType" title="Data.Data">DataType</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#dataTypeOf" class="link">Source</a> </p>
<p class="src"><a href="#v:dataCast1">dataCast1</a> :: <a href="data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (t d)) -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#dataCast1" class="link">Source</a> </p>
<p class="src"><a href="#v:dataCast2">dataCast2</a> :: <a href="data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d e. (<a href="data-data.html#t:Data" title="Data.Data">Data</a> d, <a href="data-data.html#t:Data" title="Data.Data">Data</a> e) =&gt; c (t d e)) -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#dataCast2" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapT">gmapT</a> :: (forall b. <a href="data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; b -&gt; b) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapT" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapQl">gmapQl</a> :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; [a] -&gt; r <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapQl" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapQr">gmapQr</a> :: forall r r'. (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; [a] -&gt; r <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapQr" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapQ">gmapQ</a> :: (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; [a] -&gt; [u] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapQ" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapQi">gmapQi</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; [a] -&gt; u <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapQi" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapM">gmapM</a> :: <a href="control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; [a] -&gt; m [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapM" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapMp">gmapMp</a> :: <a href="control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; [a] -&gt; m [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapMp" class="link">Source</a> </p>
<p class="src"><a href="#v:gmapMo">gmapMo</a> :: <a href="control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; [a] -&gt; m [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Data.html#gmapMo" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 a <a href="data-type-equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="data-char.html#t:Char" title="Data.Char">Char</a> =&gt; <a href="data-string.html#t:IsString" title="Data.String">IsString</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.String.html#line-105" class="link">Source</a> </td>
<td class="doc">
<p><code class="inline-code">(a ~ Char)</code> context was introduced in <code class="inline-code">4.9.0.0</code></p>
<p><span class="version">Since: base-2.1</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:List:IsString:22"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-String.html">GHC.Internal.Data.String</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromString">fromString</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.String.html#fromString" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="ghc-generics.html#t:Generic" title="GHC.Generics">Generic</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#line-1564" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Generic:23"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a]</td>
<td class="doc"><p><span class="version">Since: base-4.6.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:if:Rep_List:Rep:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="src">type <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a] = <a href="ghc-generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="ghc-generics.html#v:MetaData" title="GHC.Generics">MetaData</a> "List" "GHC.Types" "ghc-prim" '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> "[]" '<a href="ghc-generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:U1" title="GHC.Generics">U1</a> :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="ghc-generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> ":" ('<a href="ghc-generics.html#v:InfixI" title="GHC.Generics">InfixI</a> '<a href="ghc-generics.html#v:RightAssociative" title="GHC.Generics">RightAssociative</a> 5) '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec0" title="GHC.Generics">Rec0</a> a) <a href="ghc-generics.html#t::-42-:" title="GHC.Generics">:*:</a> <a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec0" title="GHC.Generics">Rec0</a> [a])))</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:from">from</a> :: [a] -&gt; <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a] x <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#from" class="link">Source</a> </p>
<p class="src"><a href="#v:to">to</a> :: <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a] x -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#to" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="ghc-exts.html#t:IsList" title="GHC.Exts">IsList</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.IsList.html#line-54" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.7.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:IsList:24"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-IsList.html">GHC.Internal.IsList</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a]</td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:if:D:R:ItemList:Item:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-IsList.html">GHC.Internal.IsList</a></p> <div class="src">type <a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a] = a</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromList">fromList</a> :: [<a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.IsList.html#fromList" class="link">Source</a> </p>
<p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.IsList.html#fromListN" class="link">Source</a> </p>
<p class="src"><a href="#v:toList">toList</a> :: [a] -&gt; [<a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.IsList.html#toList" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="prelude.html#t:Read" title="Prelude">Read</a> a =&gt; <a href="prelude.html#t:Read" title="Prelude">Read</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Read.html#line-528" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Read:25"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Read.html">GHC.Internal.Read</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Read.html#readsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:readList">readList</a> :: <a href="prelude.html#t:ReadS" title="Prelude">ReadS</a> [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Read.html#readList" class="link">Source</a> </p>
<p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Read.html#readPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Read.html#readListPrec" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="prelude.html#t:Show" title="Prelude">Show</a> a =&gt; <a href="prelude.html#t:Show" title="Prelude">Show</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Show.html#line-178" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-2.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Show:26"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Show.html">GHC.Internal.Show</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Show.html#showsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:show">show</a> :: [a] -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Show.html#show" class="link">Source</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [[a]] -&gt; <a href="prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Show.html#showList" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#line-261" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Eq:27"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Classes.html">GHC.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3D%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%2F%3D" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#line-482" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Ord:28"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/GHC-Classes.html">GHC.Classes</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:compare">compare</a> :: [a] -&gt; [a] -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#compare" class="link">Source</a> </p>
<p class="src"><a href="#v:-60-">(&lt;)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3C%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62-">(&gt;)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:max">max</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#max" class="link">Source</a> </p>
<p class="src"><a href="#v:min">min</a> :: [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#min" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#line-" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.6.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Rep1:29"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="src">type <a href="ghc-generics.html#t:Rep1" title="GHC.Generics">Rep1</a> <a href="data-list.html#t:List" title="Data.List">[]</a> = <a href="ghc-generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="ghc-generics.html#v:MetaData" title="GHC.Generics">MetaData</a> "List" "GHC.Types" "ghc-prim" '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> "[]" '<a href="ghc-generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:U1" title="GHC.Generics">U1</a> :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="ghc-generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> ":" ('<a href="ghc-generics.html#v:InfixI" title="GHC.Generics">InfixI</a> '<a href="ghc-generics.html#v:RightAssociative" title="GHC.Generics">RightAssociative</a> 5) '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) <a href="ghc-generics.html#t:Par1" title="GHC.Generics">Par1</a> <a href="ghc-generics.html#t::-42-:" title="GHC.Generics">:*:</a> <a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec1" title="GHC.Generics">Rec1</a> <a href="data-list.html#t:List" title="Data.List">[]</a>)))</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Generics.html#line-" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: base-4.6.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Rep:30"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Generics.html">GHC.Internal.Generics</a></p> <div class="src">type <a href="ghc-generics.html#t:Rep" title="GHC.Generics">Rep</a> [a] = <a href="ghc-generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="ghc-generics.html#v:MetaData" title="GHC.Generics">MetaData</a> "List" "GHC.Types" "ghc-prim" '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> "[]" '<a href="ghc-generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:U1" title="GHC.Generics">U1</a> :: <a href="data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="ghc-generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="ghc-generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="ghc-generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> ":" ('<a href="ghc-generics.html#v:InfixI" title="GHC.Generics">InfixI</a> '<a href="ghc-generics.html#v:RightAssociative" title="GHC.Generics">RightAssociative</a> 5) '<a href="data-bool.html#v:False" title="Data.Bool">False</a>) (<a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec0" title="GHC.Generics">Rec0</a> a) <a href="ghc-generics.html#t::-42-:" title="GHC.Generics">:*:</a> <a href="ghc-generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="ghc-generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="ghc-exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="ghc-generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="ghc-generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="ghc-generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="ghc-generics.html#t:Rec0" title="GHC.Generics">Rec0</a> [a])))</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.IsList.html#line-" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:List:Item:31"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-IsList.html">GHC.Internal.IsList</a></p> <div class="src">type <a href="ghc-exts.html#t:Item" title="GHC.Exts">Item</a> [a] = a</div></details></td></tr>
</table></details>
</div>
<a href="#g:1" id="g:1"><h2>Basic functions</h2></a><p class="src"><a id="v:-43--43-" class="def">(++)</a> :: [a] -&gt; [a] -&gt; [a] <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#%2B%2B" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:-43--43-" title="Data.List">(++)</a></code> appends two lists, i.e.,</p>
<pre>[x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
[x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</pre>
<p>If the first list is not finite, the result is the first list.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:-43--43-0">Performance considerations</h5>
<details id="ch:-43--43-0"><summary class="hide-when-js-enabled">Expand</summary><p>This function takes linear time in the number of elements of the <strong>first</strong> list. Thus it is better to associate repeated applications of <code><a href="data-list.html#v:-43--43-" title="Data.List">(++)</a></code> to the right (which is the default behaviour): <code class="inline-code">xs ++ (ys ++ zs)</code> or simply <code class="inline-code">xs ++ ys ++ zs</code>, but not <code class="inline-code">(xs ++ ys) ++ zs</code>. For the same reason <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:concat" title="GHC.Internal.Data.List">concat</a></code> <code class="inline-code">=</code> <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:foldr" title="GHC.Internal.Data.List">foldr</a></code> <code><a href="data-list.html#v:-43--43-" title="Data.List">(++)</a></code> <code class="inline-code">[]</code> has linear performance, while <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:foldl" title="GHC.Internal.Data.List">foldl</a></code> <code><a href="data-list.html#v:-43--43-" title="Data.List">(++)</a></code> <code class="inline-code">[]</code> is prone to quadratic slowdown</p></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:-43--43-1">Examples</h5>
<details id="ch:-43--43-1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">[1, 2, 3] ++ [4, 5, 6]
</strong>[1,2,3,4,5,6]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[] ++ [1, 2, 3]
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[3, 2, 1] ++ []
</strong>[3,2,1]
</pre></details><p class="src"><a id="v:head" class="def">head</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#head" class="link">Source</a> </p>
<div class="warning"><p>Warning: This is a partial function, it throws an error on empty lists. Use pattern matching, <code><a href="data-list.html#v:uncons" title="Data.List">uncons</a></code> or <code><a href="data-maybe.html#v:listToMaybe" title="Data.Maybe">listToMaybe</a></code> instead. Consider refactoring to use <a href="data-list-nonempty.html">Data.List.NonEmpty</a>.</p></div>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the first element of a list, which must be non-empty.</p>
<p>To disable the warning about partiality put <code class="inline-code">{-# OPTIONS_GHC -Wno-x-partial -Wno-unrecognised-warning-flags #-}</code> at the top of the file. To disable it throughout a package put the same options into <code class="inline-code">ghc-options</code> section of Cabal file. To disable it in GHCi put <code class="inline-code">:set -Wno-x-partial -Wno-unrecognised-warning-flags</code> into <code class="inline-code">~/.ghci</code> config file. See also the <a href="https://github.com/haskell/core-libraries-committee/blob/main/guides/warning-for-head-and-tail.md">migration guide</a>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:head0">Examples</h5>
<details id="ch:head0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">head [1, 2, 3]
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head [1..]
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head []
</strong>*** Exception: Prelude.head: empty list
</pre></details><p class="src"><a id="v:last" class="def">last</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#last" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Extract the last element of a list, which must be finite and non-empty.</p>
<p>WARNING: This function is partial. Consider using <code><a href="data-list.html#v:unsnoc" title="Data.List">unsnoc</a></code> instead.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:last0">Examples</h5>
<details id="ch:last0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">last [1, 2, 3]
</strong>3
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last [1..]
</strong>* Hangs forever *
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last []
</strong>*** Exception: Prelude.last: empty list
</pre></details><p class="src"><a id="v:tail" class="def">tail</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#tail" class="link">Source</a> </p>
<div class="warning"><p>Warning: This is a partial function, it throws an error on empty lists. Replace it with <code><a href="data-list.html#v:drop" title="Data.List">drop</a></code> 1, or use pattern matching or <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:uncons" title="GHC.Internal.Data.List">uncons</a></code> instead. Consider refactoring to use <a href="data-list-nonempty.html">Data.List.NonEmpty</a>.</p></div>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the elements after the head of a list, which must be non-empty.</p>
<p>To disable the warning about partiality put <code class="inline-code">{-# OPTIONS_GHC -Wno-x-partial -Wno-unrecognised-warning-flags #-}</code> at the top of the file. To disable it throughout a package put the same options into <code class="inline-code">ghc-options</code> section of Cabal file. To disable it in GHCi put <code class="inline-code">:set -Wno-x-partial -Wno-unrecognised-warning-flags</code> into <code class="inline-code">~/.ghci</code> config file. See also the <a href="https://github.com/haskell/core-libraries-committee/blob/main/guides/warning-for-head-and-tail.md">migration guide</a>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:tail0">Examples</h5>
<details id="ch:tail0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">tail [1, 2, 3]
</strong>[2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tail [1]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tail []
</strong>*** Exception: Prelude.tail: empty list
</pre></details><p class="src"><a id="v:init" class="def">init</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#init" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Return all the elements of a list except the last one. The list must be non-empty.</p>
<p>WARNING: This function is partial. Consider using <code><a href="data-list.html#v:unsnoc" title="Data.List">unsnoc</a></code> instead.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:init0">Examples</h5>
<details id="ch:init0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">init [1, 2, 3]
</strong>[1,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">init [1]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">init []
</strong>*** Exception: Prelude.init: empty list
</pre></details><p class="src"><a id="v:uncons" class="def">uncons</a> :: [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#uncons" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Decompose a list into its <code><a href="data-list.html#v:head" title="Data.List">head</a></code> and <code><a href="data-list.html#v:tail" title="Data.List">tail</a></code>.</p>
<ul>
<li>If the list is empty, returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li>
<li>If the list is non-empty, returns <code class="inline-code"><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a> (x, xs)</code>, where <code class="inline-code">x</code> is the <code><a href="data-list.html#v:head" title="Data.List">head</a></code> of the list and <code class="inline-code">xs</code> its <code><a href="data-list.html#v:tail" title="Data.List">tail</a></code>.</li>
</ul>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:uncons0">Examples</h5>
<details id="ch:uncons0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">uncons []
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">uncons [1]
</strong>Just (1,[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">uncons [1, 2, 3]
</strong>Just (1,[2,3])
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:unsnoc" class="def">unsnoc</a> :: [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ([a], a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#unsnoc" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Decompose a list into <code><a href="data-list.html#v:init" title="Data.List">init</a></code> and <code><a href="data-list.html#v:last" title="Data.List">last</a></code>.</p>
<ul>
<li>If the list is empty, returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li>
<li>If the list is non-empty, returns <code class="inline-code"><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a> (xs, x)</code>, where <code class="inline-code">xs</code> is the <code><a href="data-list.html#v:init" title="Data.List">init</a></code>ial part of the list and <code class="inline-code">x</code> is its <code><a href="data-list.html#v:last" title="Data.List">last</a></code> element.</li>
</ul>
<p><code><a href="data-list.html#v:unsnoc" title="Data.List">unsnoc</a></code> is dual to <code><a href="data-list.html#v:uncons" title="Data.List">uncons</a></code>: for a finite list <code class="inline-code">xs</code></p>
<pre>unsnoc xs = (\(hd, tl) -&gt; (reverse tl, hd)) &lt;$&gt; uncons (reverse xs)</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unsnoc0">Examples</h5>
<details id="ch:unsnoc0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unsnoc []
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unsnoc [1]
</strong>Just ([],1)
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unsnoc [1, 2, 3]
</strong>Just ([1,2],3)
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unsnoc1">Laziness</h5>
<details id="ch:unsnoc1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">fst &lt;$&gt; unsnoc [undefined]
</strong>Just []
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head . fst &lt;$&gt; unsnoc (1 : undefined)
</strong>Just *** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head . fst &lt;$&gt; unsnoc (1 : 2 : undefined)
</strong>Just 1
</pre></details><p><span class="version">Since: base-4.19.0.0</span></p>
<p class="src"><a id="v:singleton" class="def">singleton</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#singleton" class="link">Source</a> </p>
<p>Construct a list from a single element.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:singleton0">Examples</h5>
<details id="ch:singleton0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">singleton True
</strong>[True]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">singleton [1, 2, 3]
</strong>[[1,2,3]]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">singleton 'c'
</strong>"c"
</pre></details><p><span class="version">Since: base-4.15.0.0</span></p>
<p class="src"><a id="v:null" class="def">null</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; t a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#null" class="link">Source</a> </p>
<p>Test whether the structure is empty. The default implementation is Left-associative and lazy in both the initial element and the accumulator. Thus optimised for structures where the first element can be accessed in constant time. Structures where this is not the case should have a non-default implementation.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:null0">Examples</h5>
<details id="ch:null0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">null []
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">null [1]
</strong>False
</pre>
<p><code><a href="data-list.html#v:null" title="Data.List">null</a></code> is expected to terminate even for infinite structures. The default implementation terminates provided the structure is bounded on the left (there is a leftmost element).</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">null [1..]
</strong>False
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:length" class="def">length</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; t a -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#length" class="link">Source</a> </p>
<p>Returns the size/length of a finite structure as an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>. The default implementation just counts elements starting with the leftmost. Instances for structures that can compute the element count faster than via element-by-element counting, should provide a specialised implementation.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:length0">Examples</h5>
<details id="ch:length0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">length []
</strong>0
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">length ['a', 'b', 'c']
</strong>3
&gt;&gt;&gt; <strong class="userinput">length [1..]
</strong>* Hangs forever *
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:compareLength" class="def">compareLength</a> :: [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.List.html#compareLength" class="link">Source</a> </p>
<p>Use <code><a href="data-list.html#v:compareLength" title="Data.List">compareLength</a></code> <code class="inline-code">xs</code> <code class="inline-code">n</code> as a safer and faster alternative to <code class="inline-code">compare</code> (<code><a href="data-list.html#v:length" title="Data.List">length</a></code> <code class="inline-code">xs</code>) <code class="inline-code">n</code>. Similarly, it's better to write <code class="inline-code">compareLength xs 10 == LT</code> instead of <code class="inline-code">length xs &lt; 10</code>.</p>
<p>While <code><a href="data-list.html#v:length" title="Data.List">length</a></code> would force and traverse the entire spine of <code class="inline-code">xs</code> (which could even diverge if <code class="inline-code">xs</code> is infinite), <code><a href="data-list.html#v:compareLength" title="Data.List">compareLength</a></code> traverses at most <code class="inline-code">n</code> elements to determine its result.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">compareLength [] 0
</strong>EQ
&gt;&gt;&gt; <strong class="userinput">compareLength [] 1
</strong>LT
&gt;&gt;&gt; <strong class="userinput">compareLength ['a'] 1
</strong>EQ
&gt;&gt;&gt; <strong class="userinput">compareLength ['a', 'b'] 1
</strong>GT
&gt;&gt;&gt; <strong class="userinput">compareLength [0..] 100
</strong>GT
&gt;&gt;&gt; <strong class="userinput">compareLength undefined (-1)
</strong>GT
&gt;&gt;&gt; <strong class="userinput">compareLength ('a' : undefined) 0
</strong>GT
</pre>
<p><span class="version">Since: base-4.21.0.0</span></p>
<a href="#g:2" id="g:2"><h2>List transformations</h2></a><p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Base.html#map" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:map" title="Data.List">map</a></code> <code class="inline-code">f xs</code> is the list obtained by applying <code class="inline-code">f</code> to each element of <code class="inline-code">xs</code>, i.e.,</p>
<pre>map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
map f [x1, x2, ...] == [f x1, f x2, ...]</pre>
<p>this means that <code class="inline-code">map id == id</code></p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:map0">Examples</h5>
<details id="ch:map0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">map (+1) [1, 2, 3]
</strong>[2,3,4]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">map id [1, 2, 3]
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">map (\n -&gt; 3 * n + 1) [1, 2, 3]
</strong>[4,7,10]
</pre></details><p class="src"><a id="v:reverse" class="def">reverse</a> :: [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#reverse" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:reverse" title="Data.List">reverse</a></code> <code class="inline-code">xs</code> returns the elements of <code class="inline-code">xs</code> in reverse order. <code class="inline-code">xs</code> must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:reverse0">Laziness</h5>
<details id="ch:reverse0"><summary class="hide-when-js-enabled">Expand</summary><p><code><a href="data-list.html#v:reverse" title="Data.List">reverse</a></code> is lazy in its elements.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head (reverse [undefined, 1])
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse (1 : 2 : undefined)
</strong>*** Exception: Prelude.undefined
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:reverse1">Examples</h5>
<details id="ch:reverse1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse []
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse [42]
</strong>[42]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse [2,5,7]
</strong>[7,5,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse [1..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:intersperse" class="def">intersperse</a> :: a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#intersperse" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:intersperse" title="Data.List">intersperse</a></code> function takes an element and a list and `intersperses' that element between the elements of the list.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:intersperse0">Laziness</h5>
<details id="ch:intersperse0"><summary class="hide-when-js-enabled">Expand</summary><p><code><a href="data-list.html#v:intersperse" title="Data.List">intersperse</a></code> has the following properties</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (intersperse undefined ('a' : undefined))
</strong>"a"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 2 (intersperse ',' ('a' : undefined))
</strong>"a*** Exception: Prelude.undefined
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:intersperse1">Examples</h5>
<details id="ch:intersperse1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">intersperse ',' "abcde"
</strong>"a,b,c,d,e"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intersperse 1 [3, 4, 5]
</strong>[3,1,4,1,5]
</pre></details><p class="src"><a id="v:intercalate" class="def">intercalate</a> :: [a] -&gt; [[a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#intercalate" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:intercalate" title="Data.List">intercalate</a></code> <code class="inline-code">xs xss</code> is equivalent to <code class="inline-code">(<a href="ghc-list.html#v:concat" title="GHC.List">concat</a> (<a href="data-list.html#v:intersperse" title="Data.List">intersperse</a> xs xss))</code>. It inserts the list <code class="inline-code">xs</code> in between the lists in <code class="inline-code">xss</code> and concatenates the result.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:intercalate0">Laziness</h5>
<details id="ch:intercalate0"><summary class="hide-when-js-enabled">Expand</summary><p><code><a href="data-list.html#v:intercalate" title="Data.List">intercalate</a></code> has the following properties:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 (intercalate undefined ("Lorem" : undefined))
</strong>"Lorem"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 6 (intercalate ", " ("Lorem" : undefined))
</strong>"Lorem*** Exception: Prelude.undefined
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:intercalate1">Examples</h5>
<details id="ch:intercalate1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">intercalate ", " ["Lorem", "ipsum", "dolor"]
</strong>"Lorem, ipsum, dolor"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intercalate [0, 1] [[2, 3], [4, 5, 6], []]
</strong>[2,3,0,1,4,5,6,0,1]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intercalate [1, 2, 3] [[], []]
</strong>[1,2,3]
</pre></details><p class="src"><a id="v:transpose" class="def">transpose</a> :: [[a]] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#transpose" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:transpose" title="Data.List">transpose</a></code> function transposes the rows and columns of its argument.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:transpose0">Laziness</h5>
<details id="ch:transpose0"><summary class="hide-when-js-enabled">Expand</summary><p><code><a href="data-list.html#v:transpose" title="Data.List">transpose</a></code> is lazy in its elements</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (transpose ['a' : undefined, 'b' : undefined])
</strong>["ab"]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:transpose1">Examples</h5>
<details id="ch:transpose1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">transpose [[1,2,3],[4,5,6]]
</strong>[[1,4],[2,5],[3,6]]
</pre>
<p>If some of the rows are shorter than the following rows, their elements are skipped:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">transpose [[10,11],[20],[],[30,31,32]]
</strong>[[10,20,30],[11,31],[32]]
</pre>
<p>For this reason the outer list must be finite; otherwise <code><a href="data-list.html#v:transpose" title="Data.List">transpose</a></code> hangs:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">transpose (repeat [])
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:subsequences" class="def">subsequences</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#subsequences" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:subsequences" title="Data.List">subsequences</a></code> function returns the list of all subsequences of the argument.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:subsequences0">Laziness</h5>
<details id="ch:subsequences0"><summary class="hide-when-js-enabled">Expand</summary><p><code><a href="data-list.html#v:subsequences" title="Data.List">subsequences</a></code> does not look ahead unless it must:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (subsequences undefined)
</strong>[[]]
&gt;&gt;&gt; <strong class="userinput">take 2 (subsequences ('a' : undefined))
</strong>["","a"]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:subsequences1">Examples</h5>
<details id="ch:subsequences1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">subsequences "abc"
</strong>["","a","b","ab","c","ac","bc","abc"]
</pre>
<p>This function is productive on infinite inputs:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 8 $ subsequences ['a'..]
</strong>["","a","b","ab","c","ac","bc","abc"]
</pre></details><p class="src"><a id="v:permutations" class="def">permutations</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#permutations" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:permutations" title="Data.List">permutations</a></code> function returns the list of all permutations of the argument.</p>
<p>Note that the order of permutations is not lexicographic. It satisfies the following property:</p>
<pre>map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:permutations0">Laziness</h5>
<details id="ch:permutations0"><summary class="hide-when-js-enabled">Expand</summary><p>The <code><a href="data-list.html#v:permutations" title="Data.List">permutations</a></code> function is maximally lazy: for each <code class="inline-code">n</code>, the value of <code class="inline-code"><a href="data-list.html#v:permutations" title="Data.List">permutations</a> xs</code> starts with those permutations that permute <code class="inline-code"><a href="data-list.html#v:take" title="Data.List">take</a> n xs</code> and keep <code class="inline-code"><a href="data-list.html#v:drop" title="Data.List">drop</a> n xs</code>.</p></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:permutations1">Examples</h5>
<details id="ch:permutations1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">permutations "abc"
</strong>["abc","bac","cba","bca","cab","acb"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">permutations [1, 2]
</strong>[[1,2],[2,1]]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">permutations []
</strong>[[]]
</pre>
<p>This function is productive on infinite inputs:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 6 $ map (take 3) $ permutations ['a'..]
</strong>["abc","bac","cba","bca","cab","acb"]
</pre></details><a href="#g:3" id="g:3"><h2>Reducing lists (folds)</h2></a><p class="src"><a id="v:foldl" class="def">foldl</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl" class="link">Source</a> </p>
<p>Left-associative fold of a structure, lazy in the accumulator. This is rarely what you want, but can work well for structures with efficient right-to-left sequencing and an operator that is lazy in its left argument.</p>
<p>In the case of lists, <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</p>
<pre>foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn</pre>
<p>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code> will diverge if given an infinite list.</p>
<p>If you want an efficient strict left-fold, you probably want to use <code><a href="data-list.html#v:foldl-39-" title="Data.List">foldl'</a></code> instead of <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>. The reason for this is that the latter does not force the <em>inner</em> results (e.g. <code class="inline-code">z `f` x1</code> in the above example) before applying them to the operator (e.g. to <code class="inline-code">(`f` x2)</code>). This results in a thunk chain <span class="complexity">O(n)</span> elements long, which then must be evaluated from the outside-in.</p>
<p>For a general <code><a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> structure this should be semantically identical to:</p>
<pre>foldl f z = <a href="list.html#v:foldl" title="List">foldl</a> f z . <a href="data-foldable.html#v:toList" title="Data.Foldable">toList</a></pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:foldl0">Examples</h5>
<details id="ch:foldl0"><summary class="hide-when-js-enabled">Expand</summary><p>The first example is a strict fold, which in practice is best performed with <code><a href="data-list.html#v:foldl-39-" title="Data.List">foldl'</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl (+) 42 [1,2,3,4]
</strong>52
</pre>
<p>Though the result below is lazy, the input is reversed before prepending it to the initial accumulator, so corecursion begins only after traversing the entire input string.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl (\acc c -&gt; c : acc) "abcd" "efgh"
</strong>"hgfeabcd"
</pre>
<p>A left fold of a structure that is infinite on the right cannot terminate, even when for any finite input the fold just returns the initial accumulator:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl (\a _ -&gt; a) 0 $ repeat 1
</strong>* Hangs forever *
</pre>
<p>WARNING: When it comes to lists, you always want to use either <code><a href="data-list.html#v:foldl-39-" title="Data.List">foldl'</a></code> or <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code> instead.</p></details><p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl%27" class="link">Source</a> </p>
<p>Left-associative fold of a structure but with strict application of the operator.</p>
<p>This ensures that each step of the fold is forced to Weak Head Normal Form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single strict result (e.g. <code><a href="data-list.html#v:sum" title="Data.List">sum</a></code>).</p>
<p>For a general <code><a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> structure this should be semantically identical to,</p>
<pre>foldl' f z = <a href="list.html#v:foldl-39-" title="List">foldl'</a> f z . <a href="data-foldable.html#v:toList" title="Data.Foldable">toList</a></pre>
<p><span class="version">Since: base-4.6.0.0</span></p>
<p class="src"><a id="v:foldl1" class="def">foldl1</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldl1" class="link">Source</a> </p>
<p>A variant of <code><a href="data-list.html#v:foldl" title="Data.List">foldl</a></code> that has no base case, and thus may only be applied to non-empty structures.</p>
<p>This function is non-total and will raise a runtime exception if the structure happens to be empty.</p>
<pre><a href="ghc-list.html#v:foldl1" title="GHC.List">foldl1</a> f = <a href="list.html#v:foldl1" title="List">foldl1</a> f . <a href="data-foldable.html#v:toList" title="Data.Foldable">toList</a></pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:foldl10">Examples</h5>
<details id="ch:foldl10"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..4]
</strong>10
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) []
</strong>*** Exception: Prelude.foldl1: empty list
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) Nothing
</strong>*** Exception: foldl1: empty structure
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (-) [1..4]
</strong>-8
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (&amp;&amp;) [True, False, True, True]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (||) [False, False, True, True]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#foldl1%27" class="link">Source</a> </p>
<p>A strict version of <code><a href="ghc-list.html#v:foldl1" title="GHC.List">foldl1</a></code>.</p>
<p class="src"><a id="v:foldr" class="def">foldr</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldr" class="link">Source</a> </p>
<p>Right-associative fold of a structure, lazy in the accumulator.</p>
<p>In the case of lists, <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code>, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</p>
<pre>foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</pre>
<p>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code> can produce a terminating expression from an unbounded list.</p>
<p>For a general <code><a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> structure this should be semantically identical to,</p>
<pre>foldr f z = <a href="list.html#v:foldr" title="List">foldr</a> f z . <a href="data-foldable.html#v:toList" title="Data.Foldable">toList</a></pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:foldr0">Examples</h5>
<details id="ch:foldr0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr (||) False [False, True, False]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr (||) False []
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
</strong>"foodcba"
</pre>
<h5>Infinite structures</h5>
<p>âš ï¸ Applying <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code> to infinite structures usually doesn't terminate.</p>
<p>It may still terminate under one of the following conditions:</p>
<ul>
<li>the folding function is short-circuiting</li>
<li>the folding function is lazy on its second argument</li>
</ul>
<h6>Short-circuiting</h6>
<p><code class="inline-code">(<a href="data-bool.html#v:-124--124-" title="Data.Bool">||</a>)</code> short-circuits on <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> values, so the following terminates because there is a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value finitely far from the left side:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr (||) False (True : repeat False)
</strong>True
</pre>
<p>But the following doesn't terminate:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr (||) False (repeat False ++ [True])
</strong>* Hangs forever *
</pre>
<h6>Laziness in the second argument</h6>
<p>Applying <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code> to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left <code><a href="prelude.html#v:undefined" title="Prelude">undefined</a></code>, but <code class="inline-code">[]</code> is more clear):</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
</strong>[1,4,7,10,13]
</pre></details><p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#foldr1" class="link">Source</a> </p>
<p>A variant of <code><a href="data-list.html#v:foldr" title="Data.List">foldr</a></code> that has no base case, and thus may only be applied to non-empty structures.</p>
<p>This function is non-total and will raise a runtime exception if the structure happens to be empty.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:foldr10">Examples</h5>
<details id="ch:foldr10"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) [1..4]
</strong>10
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) []
</strong>Exception: Prelude.foldr1: empty list
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) Nothing
</strong>*** Exception: foldr1: empty structure
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (-) [1..4]
</strong>-2
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (&amp;&amp;) [True, False, True, True]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (||) [False, False, True, True]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) [1..]
</strong>* Hangs forever *
</pre></details><a href="#g:4" id="g:4"><h3>Special folds</h3></a><p class="src"><a id="v:concat" class="def">concat</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; t [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#concat" class="link">Source</a> </p>
<p>The concatenation of all the elements of a container of lists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:concat0">Examples</h5>
<details id="ch:concat0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concat (Just [1, 2, 3])
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concat (Left 42)
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concat [[1, 2, 3], [4, 5], [6], []]
</strong>[1,2,3,4,5,6]
</pre></details><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#concatMap" class="link">Source</a> </p>
<p>Map a function over all the elements of a container and concatenate the resulting lists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:concatMap0">Examples</h5>
<details id="ch:concatMap0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concatMap (take 3) [[1..], [10..], [100..], [1000..]]
</strong>[1,2,3,10,11,12,100,101,102,1000,1001,1002]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concatMap (take 3) (Just [1..])
</strong>[1,2,3]
</pre></details><p class="src"><a id="v:and" class="def">and</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; t <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#and" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:and" title="Data.List">and</a></code> returns the conjunction of a container of Bools. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the container must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value finitely far from the left end.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:and0">Examples</h5>
<details id="ch:and0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and []
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and [True]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and [False]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and [True, True, False]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and (False : repeat True) -- Infinite list [False,True,True,True,...
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and (repeat True)
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:or" class="def">or</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; t <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#or" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:or" title="Data.List">or</a></code> returns the disjunction of a container of Bools. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the container must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value finitely far from the left end.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:or0">Examples</h5>
<details id="ch:or0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or []
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or [True]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or [False]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or [True, True, False]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or (True : repeat False) -- Infinite list [True,False,False,False,...
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or (repeat False)
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:any" class="def">any</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#any" class="link">Source</a> </p>
<p>Determines whether any element of the structure satisfies the predicate.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:any0">Examples</h5>
<details id="ch:any0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) []
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2,3,4,5]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1..]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [0, -1..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:all" class="def">all</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#all" class="link">Source</a> </p>
<p>Determines whether all elements of the structure satisfy the predicate.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:all0">Examples</h5>
<details id="ch:all0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) []
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2,3,4,5]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1..]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [4..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:sum" class="def">sum</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#sum" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:sum" title="Data.List">sum</a></code> function computes the sum of the numbers of a structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:sum0">Examples</h5>
<details id="ch:sum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum []
</strong>0
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum [42]
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum [1..10]
</strong>55
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum [4.1, 2.0, 1.7]
</strong>7.8
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum [1..]
</strong>* Hangs forever *
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:product" class="def">product</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#product" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:product" title="Data.List">product</a></code> function computes the product of the numbers of a structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:product0">Examples</h5>
<details id="ch:product0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product []
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product [42]
</strong>42
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product [1..10]
</strong>3628800
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product [4.1, 2.0, 1.7]
</strong>13.939999999999998
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product [1..]
</strong>* Hangs forever *
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#maximum" class="link">Source</a> </p>
<p>The largest element of a non-empty structure. This function is equivalent to <code class="inline-code"><a href="data-list.html#v:foldr1" title="Data.List">foldr1</a> <a href="data-ord.html#v:max" title="Data.Ord">max</a></code>, and its behavior on structures with multiple largest elements depends on the relevant implementation of <code><a href="data-ord.html#v:max" title="Data.Ord">max</a></code>. For the default implementation of <code><a href="data-ord.html#v:max" title="Data.Ord">max</a></code> (<code class="inline-code">max x y = if x &lt;= y
 then y else x</code>), structure order is used as a tie-breaker: if there are multiple largest elements, the rightmost of them is chosen (this is equivalent to <code class="inline-code"><a href="data-list.html#v:maximumBy" title="Data.List">maximumBy</a> <a href="data-ord.html#v:compare" title="Data.Ord">compare</a></code>).</p>
<p>This function is non-total and will raise a runtime exception if the structure happens to be empty. A structure that supports random access and maintains its elements in order should provide a specialised implementation to return the maximum in faster than linear time.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:maximum0">Examples</h5>
<details id="ch:maximum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximum [1..10]
</strong>10
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximum []
</strong>*** Exception: Prelude.maximum: empty list
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximum Nothing
</strong>*** Exception: maximum: empty structure
</pre>
<p>WARNING: This function is partial for possibly-empty structures like lists.</p></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#minimum" class="link">Source</a> </p>
<p>The least element of a non-empty structure. This function is equivalent to <code class="inline-code"><a href="data-list.html#v:foldr1" title="Data.List">foldr1</a> <a href="data-ord.html#v:min" title="Data.Ord">min</a></code>, and its behavior on structures with multiple largest elements depends on the relevant implementation of <code><a href="data-ord.html#v:min" title="Data.Ord">min</a></code>. For the default implementation of <code><a href="data-ord.html#v:min" title="Data.Ord">min</a></code> (<code class="inline-code">min x y = if x &lt;= y
 then x else y</code>), structure order is used as a tie-breaker: if there are multiple least elements, the leftmost of them is chosen (this is equivalent to <code class="inline-code"><a href="data-list.html#v:minimumBy" title="Data.List">minimumBy</a> <a href="data-ord.html#v:compare" title="Data.Ord">compare</a></code>).</p>
<p>This function is non-total and will raise a runtime exception if the structure happens to be empty. A structure that supports random access and maintains its elements in order should provide a specialised implementation to return the minimum in faster than linear time.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:minimum0">Examples</h5>
<details id="ch:minimum0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimum [1..10]
</strong>1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimum []
</strong>*** Exception: Prelude.minimum: empty list
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimum Nothing
</strong>*** Exception: minimum: empty structure
</pre>
<p>WARNING: This function is partial for possibly-empty structures like lists.</p></details><p><span class="version">Since: base-4.8.0.0</span></p>
<a href="#g:5" id="g:5"><h2>Building lists</h2></a><a href="#g:6" id="g:6"><h3>Scans</h3></a><p class="src"><a id="v:scanl" class="def">scanl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#scanl" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:scanl" title="Data.List">scanl</a></code> is similar to <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>, but returns a list of successive reduced values from the left:</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>last (scanl f z xs) == foldl f z xs</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:scanl0">Examples</h5>
<details id="ch:scanl0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (+) 0 [1..4]
</strong>[0,1,3,6,10]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (+) 42 []
</strong>[42]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (-) 100 [1..4]
</strong>[100,99,97,94,90]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["foo","afoo","bafoo","cbafoo","dcbafoo"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (scanl (+) 0 [1..])
</strong>[0,1,3,6,10,15,21,28,36,45]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (scanl undefined 'a' undefined)
</strong>"a"
</pre></details><p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#scanl%27" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. A strict version of <code><a href="data-list.html#v:scanl" title="Data.List">scanl</a></code>.</p>
<p class="src"><a id="v:scanl1" class="def">scanl1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#scanl1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:scanl1" title="Data.List">scanl1</a></code> is a variant of <code><a href="data-list.html#v:scanl" title="Data.List">scanl</a></code> that has no starting value argument:</p>
<pre>scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:scanl10">Examples</h5>
<details id="ch:scanl10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (+) [1..4]
</strong>[1,3,6,10]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (+) []
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (-) [1..4]
</strong>[1,-1,-4,-8]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (&amp;&amp;) [True, False, True, True]
</strong>[True,False,False,False]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (||) [False, False, True, True]
</strong>[False,False,True,True]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (scanl1 (+) [1..])
</strong>[1,3,6,10,15,21,28,36,45,55]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (scanl1 undefined ('a' : undefined))
</strong>"a"
</pre></details><p class="src"><a id="v:scanr" class="def">scanr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#scanr" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:scanr" title="Data.List">scanr</a></code> is the right-to-left dual of <code><a href="data-list.html#v:scanl" title="Data.List">scanl</a></code>. Note that the order of parameters on the accumulating function are reversed compared to <code><a href="data-list.html#v:scanl" title="Data.List">scanl</a></code>. Also note that</p>
<pre>head (scanr f z xs) == foldr f z xs.</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:scanr0">Examples</h5>
<details id="ch:scanr0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (+) 0 [1..4]
</strong>[10,9,7,4,0]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (+) 42 []
</strong>[42]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (-) 100 [1..4]
</strong>[98,-97,99,-96,100]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">force $ scanr (+) 0 [1..]
</strong>*** Exception: stack overflow
</pre></details><p class="src"><a id="v:scanr1" class="def">scanr1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#scanr1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:scanr1" title="Data.List">scanr1</a></code> is a variant of <code><a href="data-list.html#v:scanr" title="Data.List">scanr</a></code> that has no starting value argument.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:scanr10">Examples</h5>
<details id="ch:scanr10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (+) [1..4]
</strong>[10,9,7,4]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (+) []
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (-) [1..4]
</strong>[-2,3,-1,4]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (&amp;&amp;) [True, False, True, True]
</strong>[False,False,True,True]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (||) [True, True, False, False]
</strong>[True,True,False,False]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">force $ scanr1 (+) [1..]
</strong>*** Exception: stack overflow
</pre></details><a href="#g:7" id="g:7"><h3>Accumulating maps</h3></a><p class="src"><a id="v:mapAccumL" class="def">mapAccumL</a> :: <a href="data-traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t =&gt; (s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#mapAccumL" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:mapAccumL" title="Data.List">mapAccumL</a></code> function behaves like a combination of <code><a href="control-monad.html#v:fmap" title="Control.Monad">fmap</a></code> and <code><a href="data-foldable.html#v:foldl" title="Data.Foldable">foldl</a></code>; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:mapAccumL0">Examples</h5>
<details id="ch:mapAccumL0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
</strong>(55,[0,1,3,6,10,15,21,28,36,45])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
</strong>("012345",["0","01","012","0123","01234"])
</pre></details><p class="src"><a id="v:mapAccumR" class="def">mapAccumR</a> :: <a href="data-traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t =&gt; (s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Traversable.html#mapAccumR" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:mapAccumR" title="Data.List">mapAccumR</a></code> function behaves like a combination of <code><a href="control-monad.html#v:fmap" title="Control.Monad">fmap</a></code> and <code><a href="data-foldable.html#v:foldr" title="Data.Foldable">foldr</a></code>; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:mapAccumR0">Examples</h5>
<details id="ch:mapAccumR0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
</strong>(55,[54,52,49,45,40,34,27,19,10,0])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
</strong>("054321",["05432","0543","054","05","0"])
</pre></details><a href="#g:8" id="g:8"><h3>Infinite lists</h3></a><p class="src"><a id="v:iterate" class="def">iterate</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#iterate" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:iterate" title="Data.List">iterate</a></code> <code class="inline-code">f x</code> returns an infinite list of repeated applications of <code class="inline-code">f</code> to <code class="inline-code">x</code>:</p>
<pre>iterate f x == [x, f x, f (f x), ...]</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:iterate0">Laziness</h5>
<details id="ch:iterate0"><summary class="hide-when-js-enabled">Expand</summary><p>Note that <code><a href="data-list.html#v:iterate" title="Data.List">iterate</a></code> is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See <code><a href="data-list.html#v:iterate-39-" title="Data.List">iterate'</a></code> for a strict variant of this function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 $ iterate undefined 42
</strong>[42]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:iterate1">Examples</h5>
<details id="ch:iterate1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate not True
</strong>[True,False,True,False,True,False,True,False,True,False]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate (+3) 42
</strong>[42,45,48,51,54,57,60,63,66,69]
</pre>
<p><code class="inline-code">iterate id == <a href="data-list.html#v:repeat" title="Data.List">repeat</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate id 1
</strong>[1,1,1,1,1,1,1,1,1,1]
</pre></details><p class="src"><a id="v:iterate-39-" class="def">iterate'</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#iterate%27" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:iterate-39-" title="Data.List">iterate'</a></code> is the strict version of <code><a href="data-list.html#v:iterate" title="Data.List">iterate</a></code>.</p>
<p>It forces the result of each application of the function to weak head normal form (WHNF) before proceeding.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 $ iterate' undefined 42
</strong>*** Exception: Prelude.undefined
</pre>
<p class="src"><a id="v:repeat" class="def">repeat</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#repeat" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:repeat" title="Data.List">repeat</a></code> <code class="inline-code">x</code> is an infinite list, with <code class="inline-code">x</code> the value of every element.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:repeat0">Examples</h5>
<details id="ch:repeat0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ repeat 17
</strong>[17,17,17,17,17,17,17,17,17, 17]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">repeat undefined
</strong>[*** Exception: Prelude.undefined
</pre></details><p class="src"><a id="v:replicate" class="def">replicate</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#replicate" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:replicate" title="Data.List">replicate</a></code> <code class="inline-code">n x</code> is a list of length <code class="inline-code">n</code> with <code class="inline-code">x</code> the value of every element. It is an instance of the more general <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:genericReplicate" title="GHC.Internal.Data.List">genericReplicate</a></code>, in which <code class="inline-code">n</code> may be of any integral type.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:replicate0">Examples</h5>
<details id="ch:replicate0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">replicate 0 True
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">replicate (-1) True
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">replicate 4 True
</strong>[True,True,True,True]
</pre></details><p class="src"><a id="v:cycle" class="def">cycle</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#cycle" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:cycle" title="Data.List">cycle</a></code> ties a finite list into a circular one, or equivalently, the infinite repetition of the original list. It is the identity on infinite lists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:cycle0">Examples</h5>
<details id="ch:cycle0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">cycle []
</strong>*** Exception: Prelude.cycle: empty list
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (cycle [42])
</strong>[42,42,42,42,42,42,42,42,42,42]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (cycle [2, 5, 7])
</strong>[2,5,7,2,5,7,2,5,7,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (cycle (42 : undefined))
</strong>[42]
</pre></details><a href="#g:9" id="g:9"><h3>Unfolding</h3></a><p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (b -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unfoldr" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unfoldr" title="Data.List">unfoldr</a></code> function is a `dual' to <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>: while <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code> reduces a list to a summary value, <code><a href="data-list.html#v:unfoldr" title="Data.List">unfoldr</a></code> builds a list from a seed value. The function takes the element and returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is done producing the list or returns <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> <code class="inline-code">(a,b)</code>, in which case, <code class="inline-code">a</code> is a prepended to the list and <code class="inline-code">b</code> is used as the next element in a recursive call. For example,</p>
<pre>iterate f == unfoldr (\x -&gt; Just (x, f x))</pre>
<p>In some cases, <code><a href="data-list.html#v:unfoldr" title="Data.List">unfoldr</a></code> can undo a <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code> operation:</p>
<pre>unfoldr f' (foldr f z xs) == xs</pre>
<p>if the following holds:</p>
<pre>f' (f x y) = Just (x,y)
f' z       = Nothing</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unfoldr0">Laziness</h5>
<details id="ch:unfoldr0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (unfoldr (\x -&gt; Just (x, undefined)) 'a')
</strong>"a"
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unfoldr1">Examples</h5>
<details id="ch:unfoldr1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
</strong>[10,9,8,7,6,5,4,3,2,1]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ unfoldr (\(x, y) -&gt; Just (x, (y, x + y))) (0, 1)
</strong>[0,1,1,2,3,5,8,13,21,54]
</pre></details><a href="#g:10" id="g:10"><h2>Sublists</h2></a><a href="#g:11" id="g:11"><h3>Extracting sublists</h3></a><p class="src"><a id="v:take" class="def">take</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#take" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:take" title="Data.List">take</a></code> <code class="inline-code">n</code>, applied to a list <code class="inline-code">xs</code>, returns the prefix of <code class="inline-code">xs</code> of length <code class="inline-code">n</code>, or <code class="inline-code">xs</code> itself if <code class="inline-code">n &gt;= <a href="ghc-list.html#v:length" title="GHC.List">length</a> xs</code>.</p>
<p>It is an instance of the more general <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:genericTake" title="GHC.Internal.Data.List">genericTake</a></code>, in which <code class="inline-code">n</code> may be of any integral type.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:take0">Laziness</h5>
<details id="ch:take0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 0 undefined
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take 2 (1 : 2 : undefined)
</strong>[1,2]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:take1">Examples</h5>
<details id="ch:take1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 "Hello World!"
</strong>"Hello"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 3 [1,2,3,4,5]
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 3 [1,2]
</strong>[1,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 3 []
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take (-1) [1,2]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 0 [1,2]
</strong>[]
</pre></details><p class="src"><a id="v:drop" class="def">drop</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#drop" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:drop" title="Data.List">drop</a></code> <code class="inline-code">n xs</code> returns the suffix of <code class="inline-code">xs</code> after the first <code class="inline-code">n</code> elements, or <code class="inline-code">[]</code> if <code class="inline-code">n &gt;= <a href="ghc-list.html#v:length" title="GHC.List">length</a> xs</code>.</p>
<p>It is an instance of the more general <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:genericDrop" title="GHC.Internal.Data.List">genericDrop</a></code>, in which <code class="inline-code">n</code> may be of any integral type.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:drop0">Examples</h5>
<details id="ch:drop0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 6 "Hello World!"
</strong>"World!"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2,3,4,5]
</strong>[4,5]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 3 []
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop (-1) [1,2]
</strong>[1,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 0 [1,2]
</strong>[1,2]
</pre></details><p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#splitAt" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:splitAt" title="Data.List">splitAt</a></code> <code class="inline-code">n xs</code> returns a tuple where first element is <code class="inline-code">xs</code> prefix of length <code class="inline-code">n</code> and second element is the remainder of the list:</p>
<p><code><a href="data-list.html#v:splitAt" title="Data.List">splitAt</a></code> is an instance of the more general <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:genericSplitAt" title="GHC.Internal.Data.List">genericSplitAt</a></code>, in which <code class="inline-code">n</code> may be of any integral type.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:splitAt0">Laziness</h5>
<details id="ch:splitAt0"><summary class="hide-when-js-enabled">Expand</summary><p>It is equivalent to <code class="inline-code">(<a href="data-list.html#v:take" title="Data.List">take</a> n xs, <a href="data-list.html#v:drop" title="Data.List">drop</a> n xs)</code> unless <code class="inline-code">n</code> is <code class="inline-code">_|_</code>: <code class="inline-code">splitAt _|_ xs = _|_</code>, not <code class="inline-code">(_|_, _|_)</code>).</p>
<p>The first component of the tuple is produced lazily:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">fst (splitAt 0 undefined)
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (fst (splitAt 10 (1 : undefined)))
</strong>[1]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:splitAt1">Examples</h5>
<details id="ch:splitAt1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 6 "Hello World!"
</strong>("Hello ","World!")
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3,4,5]
</strong>([1,2,3],[4,5])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 1 [1,2,3]
</strong>([1],[2,3])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3]
</strong>([1,2,3],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 4 [1,2,3]
</strong>([1,2,3],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 0 [1,2,3]
</strong>([],[1,2,3])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt (-1) [1,2,3]
</strong>([],[1,2,3])
</pre></details><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#takeWhile" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:takeWhile" title="Data.List">takeWhile</a></code>, applied to a predicate <code class="inline-code">p</code> and a list <code class="inline-code">xs</code>, returns the longest prefix (possibly empty) of <code class="inline-code">xs</code> of elements that satisfy <code class="inline-code">p</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:takeWhile0">Laziness</h5>
<details id="ch:takeWhile0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (const False) undefined
</strong>*** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (const False) (undefined : undefined)
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (takeWhile (const True) (1 : undefined))
</strong>[1]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:takeWhile1">Examples</h5>
<details id="ch:takeWhile1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>[1,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 9) [1,2,3]
</strong>[1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 0) [1,2,3]
</strong>[]
</pre></details><p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#dropWhile" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:dropWhile" title="Data.List">dropWhile</a></code> <code class="inline-code">p xs</code> returns the suffix remaining after <code><a href="data-list.html#v:takeWhile" title="Data.List">takeWhile</a></code> <code class="inline-code">p xs</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:dropWhile0">Examples</h5>
<details id="ch:dropWhile0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
</strong>[3,4,5,1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 9) [1,2,3]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 0) [1,2,3]
</strong>[1,2,3]
</pre></details><p class="src"><a id="v:dropWhileEnd" class="def">dropWhileEnd</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#dropWhileEnd" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:dropWhileEnd" title="Data.List">dropWhileEnd</a></code> function drops the largest suffix of a list in which the given predicate holds for all elements.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:dropWhileEnd0">Laziness</h5>
<details id="ch:dropWhileEnd0"><summary class="hide-when-js-enabled">Expand</summary><p>This function is lazy in spine, but strict in elements, which makes it different from <code><a href="data-list.html#v:reverse" title="Data.List">reverse</a></code> <code><a href="data-function.html#v:." title="Data.Function">.</a></code> <code><a href="data-list.html#v:dropWhile" title="Data.List">dropWhile</a></code> <code class="inline-code">p</code> <code><a href="data-function.html#v:." title="Data.Function">.</a></code> <code><a href="data-list.html#v:reverse" title="Data.List">reverse</a></code>, which is strict in spine, but lazy in elements. For instance:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (dropWhileEnd (&lt; 0) (1 : undefined))
</strong>[1]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (reverse $ dropWhile (&lt; 0) $ reverse (1 : undefined))
</strong>*** Exception: Prelude.undefined
</pre>
<p>but on the other hand</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last (dropWhileEnd (&lt; 0) [undefined, 1])
</strong>*** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last (reverse $ dropWhile (&lt; 0) $ reverse [undefined, 1])
</strong>1
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:dropWhileEnd1">Examples</h5>
<details id="ch:dropWhileEnd1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhileEnd isSpace "foo\n"
</strong>"foo"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhileEnd isSpace "foo bar"
</strong>"foo bar"
&gt;&gt;&gt; <strong class="userinput">dropWhileEnd (&gt; 10) [1..20]
</strong>[1,2,3,4,5,6,7,8,9,10]
</pre></details><p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:span" class="def">span</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#span" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:span" title="Data.List">span</a></code>, applied to a predicate <code class="inline-code">p</code> and a list <code class="inline-code">xs</code>, returns a tuple where first element is the longest prefix (possibly empty) of <code class="inline-code">xs</code> of elements that satisfy <code class="inline-code">p</code> and second element is the remainder of the list:</p>
<p><code><a href="data-list.html#v:span" title="Data.List">span</a></code> <code class="inline-code">p xs</code> is equivalent to <code class="inline-code">(<a href="data-list.html#v:takeWhile" title="Data.List">takeWhile</a> p xs, <a href="data-list.html#v:dropWhile" title="Data.List">dropWhile</a> p xs)</code>, even if <code class="inline-code">p</code> is <code class="inline-code">_|_</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:span0">Laziness</h5>
<details id="ch:span0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">span undefined []
</strong>([],[])
&gt;&gt;&gt; <strong class="userinput">fst (span (const False) undefined)
</strong>*** Exception: Prelude.undefined
&gt;&gt;&gt; <strong class="userinput">fst (span (const False) (undefined : undefined))
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take 1 (fst (span (const True) (1 : undefined)))
</strong>[1]
</pre>
<p><code><a href="data-list.html#v:span" title="Data.List">span</a></code> produces the first component of the tuple lazily:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (fst (span (const True) [1..]))
</strong>[1,2,3,4,5,6,7,8,9,10]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:span1">Examples</h5>
<details id="ch:span1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">span (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2],[3,4,1,2,3,4])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">span (&lt; 9) [1,2,3]
</strong>([1,2,3],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">span (&lt; 0) [1,2,3]
</strong>([],[1,2,3])
</pre></details><p class="src"><a id="v:break" class="def">break</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#break" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:break" title="Data.List">break</a></code>, applied to a predicate <code class="inline-code">p</code> and a list <code class="inline-code">xs</code>, returns a tuple where first element is longest prefix (possibly empty) of <code class="inline-code">xs</code> of elements that <em>do not satisfy</em> <code class="inline-code">p</code> and second element is the remainder of the list:</p>
<p><code><a href="data-list.html#v:break" title="Data.List">break</a></code> <code class="inline-code">p</code> is equivalent to <code class="inline-code"><a href="data-list.html#v:span" title="Data.List">span</a> (<a href="data-bool.html#v:not" title="Data.Bool">not</a> . p)</code> and consequently to <code class="inline-code">(<a href="data-list.html#v:takeWhile" title="Data.List">takeWhile</a> (<a href="data-bool.html#v:not" title="Data.Bool">not</a> . p) xs, <a href="data-list.html#v:dropWhile" title="Data.List">dropWhile</a> (<a href="data-bool.html#v:not" title="Data.Bool">not</a> . p) xs)</code>, even if <code class="inline-code">p</code> is <code class="inline-code">_|_</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:break0">Laziness</h5>
<details id="ch:break0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">break undefined []
</strong>([],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">fst (break (const True) undefined)
</strong>*** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">fst (break (const True) (undefined : undefined))
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 1 (fst (break (const False) (1 : undefined)))
</strong>[1]
</pre>
<p><code><a href="data-list.html#v:break" title="Data.List">break</a></code> produces the first component of the tuple lazily:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 (fst (break (const False) [1..]))
</strong>[1,2,3,4,5,6,7,8,9,10]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:break1">Examples</h5>
<details id="ch:break1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">break (&gt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2,3],[4,1,2,3,4])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">break (&lt; 9) [1,2,3]
</strong>([],[1,2,3])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">break (&gt; 9) [1,2,3]
</strong>([1,2,3],[])
</pre></details><p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#stripPrefix" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. The <code><a href="data-list.html#v:stripPrefix" title="Data.List">stripPrefix</a></code> function drops the given prefix from a list. It returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the list did not start with the prefix given, or <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the list after the prefix, if it does.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:stripPrefix0">Examples</h5>
<details id="ch:stripPrefix0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "foobar"
</strong>Just "bar"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "foo"
</strong>Just ""
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "barfoo"
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "barfoobaz"
</strong>Nothing
</pre></details><p class="src"><a id="v:group" class="def">group</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#group" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:group" title="Data.List">group</a></code> function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result is non-empty, all elements are equal to the first one, and consecutive equal elements of the input end up in the same element of the output list.</p>
<p><code><a href="data-list.html#v:group" title="Data.List">group</a></code> is a special case of <code><a href="data-list.html#v:groupBy" title="Data.List">groupBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p>It's often preferable to use <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:group" title="Data.List.NonEmpty">group</a></code>, which provides type-level guarantees of non-emptiness of inner lists. A common idiom to squash repeating elements <code><a href="data-list.html#v:map" title="Data.List">map</a></code> <code><a href="data-list.html#v:head" title="Data.List">head</a></code> <code><a href="data-function.html#v:." title="Data.Function">.</a></code> <code><a href="data-list.html#v:group" title="Data.List">group</a></code> is better served by <code><a href="data-list.html#v:map" title="Data.List">map</a></code> <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:head" title="Data.List.NonEmpty">head</a></code> <code><a href="data-function.html#v:." title="Data.Function">.</a></code> <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:group" title="Data.List.NonEmpty">group</a></code> because it avoids partial functions.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:group0">Examples</h5>
<details id="ch:group0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">group "Mississippi"
</strong>["M","i","ss","i","ss","i","pp","i"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">group [1, 1, 1, 2, 2, 3, 4, 5, 5]
</strong>[[1,1,1],[2,2],[3],[4],[5,5]]
</pre></details><p class="src"><a id="v:inits" class="def">inits</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#inits" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:inits" title="Data.List">inits</a></code> function returns all initial segments of the argument, shortest first.</p>
<p><code><a href="data-list.html#v:inits" title="Data.List">inits</a></code> is semantically equivalent to <code class="inline-code"><a href="data-list.html#v:map" title="Data.List">map</a> <a href="data-list.html#v:reverse" title="Data.List">reverse</a> . <a href="data-list.html#v:scanl" title="Data.List">scanl</a> (<a href="data-function.html#v:flip" title="Data.Function">flip</a> (:)) []</code>, but under the hood uses a queue to amortize costs of <code><a href="data-list.html#v:reverse" title="Data.List">reverse</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:inits0">Laziness</h5>
<details id="ch:inits0"><summary class="hide-when-js-enabled">Expand</summary><p>Note that <code><a href="data-list.html#v:inits" title="Data.List">inits</a></code> has the following strictness property: <code class="inline-code">inits (xs ++ _|_) = inits xs ++ _|_</code></p>
<p>In particular, <code class="inline-code">inits _|_ = [] : _|_</code></p></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:inits1">Examples</h5>
<details id="ch:inits1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">inits "abc"
</strong>["","a","ab","abc"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">inits []
</strong>[[]]
</pre>
<p>inits is productive on infinite lists:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 $ inits [1..]
</strong>[[],[1],[1,2],[1,2,3],[1,2,3,4]]
</pre></details><p class="src"><a id="v:inits1" class="def">inits1</a> :: [a] -&gt; [<a href="data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.List.html#inits1" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:inits1" title="Data.List">inits1</a></code> function returns all non-empty initial segments of the argument, shortest first.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:inits10">Laziness</h5>
<details id="ch:inits10"><summary class="hide-when-js-enabled">Expand</summary><p>Note that <code><a href="data-list.html#v:inits1" title="Data.List">inits1</a></code> has the following strictness property: <code class="inline-code">inits1 (xs ++ _|_) = inits1 xs ++ _|_</code></p>
<p>In particular, <code class="inline-code">inits1 _|_ = _|_</code></p></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:inits11">Examples</h5>
<details id="ch:inits11"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">inits1 "abc"
</strong>['a' :| "",'a' :| "b",'a' :| "bc"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">inits1 []
</strong>[]
</pre>
<p>inits1 is productive on infinite lists:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 3 $ inits1 [1..]
</strong>[1 :| [],1 :| [2],1 :| [2,3]]
</pre></details><p><span class="version">Since: base-4.21.0.0</span></p>
<p class="src"><a id="v:tails" class="def">tails</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#tails" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:tails" title="Data.List">tails</a></code> function returns all final segments of the argument, longest first.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:tails0">Laziness</h5>
<details id="ch:tails0"><summary class="hide-when-js-enabled">Expand</summary><p>Note that <code><a href="data-list.html#v:tails" title="Data.List">tails</a></code> has the following strictness property: <code class="inline-code">tails _|_ = _|_ : _|_</code></p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails undefined
</strong>[*** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 1 (tails [undefined, 1, 2])
</strong>[[1, 2], [2], []]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:tails1">Examples</h5>
<details id="ch:tails1"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails "abc"
</strong>["abc","bc","c",""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails [1, 2, 3]
</strong>[[1,2,3],[2,3],[3],[]]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails []
</strong>[[]]
</pre></details><p class="src"><a id="v:tails1" class="def">tails1</a> :: [a] -&gt; [<a href="data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.List.html#tails1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:tails1" title="Data.List">tails1</a></code> function returns all non-empty final segments of the argument, longest first.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:tails10">Laziness</h5>
<details id="ch:tails10"><summary class="hide-when-js-enabled">Expand</summary><p>Note that <code><a href="data-list.html#v:tails1" title="Data.List">tails1</a></code> has the following strictness property: <code class="inline-code">tails1 _|_ = _|_</code></p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails1 undefined
</strong>*** Exception: Prelude.undefined
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 1 (tails1 [undefined, 1, 2])
</strong>[1 :| [2],2 :| []]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:tails11">Examples</h5>
<details id="ch:tails11"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails1 "abc"
</strong>['a' :| "bc",'b' :| "c",'c' :| ""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails1 [1, 2, 3]
</strong>[1 :| [2,3],2 :| [3],3 :| []]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails1 []
</strong>[]
</pre></details><p><span class="version">Since: base-4.21.0.0</span></p>
<a href="#g:12" id="g:12"><h3>Predicates</h3></a><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#isPrefixOf" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. The <code><a href="data-list.html#v:isPrefixOf" title="Data.List">isPrefixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is a prefix of the second.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:isPrefixOf0">Examples</h5>
<details id="ch:isPrefixOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello" `isPrefixOf` "Hello World!"
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello" `isPrefixOf` "Wello Horld!"
</strong>False
</pre>
<p>For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the first list must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from any mismatch:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isPrefixOf` [1..]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isPrefixOf` [0..99]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..99] `isPrefixOf` [0..]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isPrefixOf` [0..]
</strong>* Hangs forever *
</pre>
<p><code><a href="data-list.html#v:isPrefixOf" title="Data.List">isPrefixOf</a></code> shortcuts when the first argument is empty:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">isPrefixOf [] undefined
</strong>True
</pre></details><p class="src"><a id="v:isSuffixOf" class="def">isSuffixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#isSuffixOf" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:isSuffixOf" title="Data.List">isSuffixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is a suffix of the second.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:isSuffixOf0">Examples</h5>
<details id="ch:isSuffixOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">"ld!" `isSuffixOf` "Hello World!"
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"World" `isSuffixOf` "Hello World!"
</strong>False
</pre>
<p>The second list must be finite; however the first list may be infinite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isSuffixOf` [0..99]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..99] `isSuffixOf` [0..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:isInfixOf" class="def">isInfixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#isInfixOf" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:isInfixOf" title="Data.List">isInfixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is contained, wholly and intact, anywhere within the second.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:isInfixOf0">Examples</h5>
<details id="ch:isInfixOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">isInfixOf "Haskell" "I really like Haskell."
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">isInfixOf "Ial" "I really like Haskell."
</strong>False
</pre>
<p>For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the first list must be finite; for the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the second list must be finite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[20..50] `isInfixOf` [0..]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isInfixOf` [20..50]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isInfixOf` [0..]
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:isSubsequenceOf" class="def">isSubsequenceOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.List.html#isSubsequenceOf" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:isSubsequenceOf" title="Data.List">isSubsequenceOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</p>
<p><code class="inline-code"><a href="data-list.html#v:isSubsequenceOf" title="Data.List">isSubsequenceOf</a> x y</code> is equivalent to <code class="inline-code">x `<a href="data-list.html#v:elem" title="Data.List">elem</a>` (<a href="data-list.html#v:subsequences" title="Data.List">subsequences</a> y)</code>.</p>
<p>Note: <code><a href="data-list.html#v:isSubsequenceOf" title="Data.List">isSubsequenceOf</a></code> is often used in infix form.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:isSubsequenceOf0">Examples</h5>
<details id="ch:isSubsequenceOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">"GHC" `isSubsequenceOf` "The Glorious Haskell Compiler"
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a','d'..'z'] `isSubsequenceOf` ['a'..'z']
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[1..10] `isSubsequenceOf` [10,9..0]
</strong>False
</pre>
<p>For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the first list must be finite; for the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the second list must be finite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0,2..10] `isSubsequenceOf` [0..]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0..] `isSubsequenceOf` [0,2..10]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0,2..] `isSubsequenceOf` [0..]
</strong>* Hangs forever*
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<a href="#g:13" id="g:13"><h2>Searching lists</h2></a><a href="#g:14" id="g:14"><h3>Searching by equality</h3></a><p class="src"><a id="v:elem" class="def">elem</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; t a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#elem" class="link">Source</a> </p>
<p>Does the element occur in the structure?</p>
<p>Note: <code><a href="data-list.html#v:elem" title="Data.List">elem</a></code> is often used in infix form.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:elem0">Examples</h5>
<details id="ch:elem0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` []
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2,3,4,5]
</strong>True
</pre>
<p>For infinite structures, the default implementation of <code><a href="data-list.html#v:elem" title="Data.List">elem</a></code> terminates if the sought-after value exists at a finite distance from the left side of the structure:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` [1..]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` ([4..] ++ [3])
</strong>* Hangs forever *
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:notElem" class="def">notElem</a> :: (<a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t, <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; t a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#notElem" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:notElem" title="Data.List">notElem</a></code> is the negation of <code><a href="data-list.html#v:elem" title="Data.List">elem</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:notElem0">Examples</h5>
<details id="ch:notElem0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` []
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2]
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2,3,4,5]
</strong>False
</pre>
<p>For infinite structures, <code><a href="data-list.html#v:notElem" title="Data.List">notElem</a></code> terminates if the value exists at a finite distance from the left side of the structure:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1..]
</strong>False
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` ([4..] ++ [3])
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:lookup" class="def">lookup</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [(a, b)] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#lookup" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:lookup" title="Data.List">lookup</a></code> <code class="inline-code">key assocs</code> looks up a key in an association list. For the result to be <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the list must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:lookup0">Examples</h5>
<details id="ch:lookup0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">lookup 2 []
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first")]
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first"), (2, "second"), (3, "third")]
</strong>Just "second"
</pre></details><a href="#g:15" id="g:15"><h3>Searching with a predicate</h3></a><p class="src"><a id="v:find" class="def">find</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t a -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#find" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:find" title="Data.List">find</a></code> function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:find0">Examples</h5>
<details id="ch:find0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">find (&gt; 42) [0, 5..]
</strong>Just 45
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">find (&gt; 12) [1..7]
</strong>Nothing
</pre></details><p class="src"><a id="v:filter" class="def">filter</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#filter" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:filter" title="Data.List">filter</a></code>, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</p>
<pre>filter p xs = [ x | x &lt;- xs, p x]</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:filter0">Examples</h5>
<details id="ch:filter0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">filter odd [1, 2, 3]
</strong>[1,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">filter (\l -&gt; length l &gt; 3) ["Hello", ", ", "World", "!"]
</strong>["Hello","World"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">filter (/= 3) [1, 2, 3, 4, 3, 2, 1]
</strong>[1,2,4,2,1]
</pre></details><p class="src"><a id="v:partition" class="def">partition</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#partition" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:partition" title="Data.List">partition</a></code> function takes a predicate and a list, and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</p>
<pre>partition p xs == (filter p xs, filter (not . p) xs)</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:partition0">Examples</h5>
<details id="ch:partition0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">partition (`elem` "aeiou") "Hello World!"
</strong>("eoo","Hll Wrld!")
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">partition even [1..10]
</strong>([2,4,6,8,10],[1,3,5,7,9])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">partition (&lt; 5) [1..10]
</strong>([1,2,3,4],[5,6,7,8,9,10])
</pre></details><a href="#g:16" id="g:16"><h2>Indexing lists</h2></a><p>These functions treat a list <code class="inline-code">xs</code> as an indexed collection, with indices ranging from 0 to <code class="inline-code"><a href="data-list.html#v:length" title="Data.List">length</a> xs - 1</code>.</p>
<p class="src"><a id="v:-33--63-" class="def">(!?)</a> :: [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#%21%3F" class="link">Source</a> </p>
<p>List index (subscript) operator, starting from 0. Returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the index is out of bounds</p>
<p>This is the total variant of the partial <code><a href="data-list.html#v:-33--33-" title="Data.List">!!</a></code> operator.</p>
<p>WARNING: This function takes linear time in the index.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:-33--63-0">Examples</h5>
<details id="ch:-33--63-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !? 0
</strong>Just 'a'
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !? 2
</strong>Just 'c'
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !? 3
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !? (-1)
</strong>Nothing
</pre></details><p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#%21%21" class="link">Source</a> </p>
<p>List index (subscript) operator, starting from 0. It is an instance of the more general <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/GHC-Internal-Data-List.html#v:genericIndex" title="GHC.Internal.Data.List">genericIndex</a></code>, which takes an index of any integral type.</p>
<p>WARNING: This function is partial, and should only be used if you are sure that the indexing will not fail. Otherwise, use <code><a href="data-list.html#v:-33--63-" title="Data.List">!?</a></code>.</p>
<p>WARNING: This function takes linear time in the index.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:-33--33-0">Examples</h5>
<details id="ch:-33--33-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 0
</strong>'a'
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 2
</strong>'c'
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 3
</strong>*** Exception: Prelude.!!: index too large
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! (-1)
</strong>*** Exception: Prelude.!!: negative index
</pre></details><p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#elemIndex" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:elemIndex" title="Data.List">elemIndex</a></code> function returns the index of the first element in the given list which is equal (by <code><a href="data-eq.html#v:-61--61-" title="Data.Eq">==</a></code>) to the query element, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element. For the result to be <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the list must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:elemIndex0">Examples</h5>
<details id="ch:elemIndex0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndex 4 [0..]
</strong>Just 4
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndex 'o' "haskell"
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndex 0 [1..]
</strong>* hangs forever *
</pre></details><p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; [<a href="data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#elemIndices" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:elemIndices" title="Data.List">elemIndices</a></code> function extends <code><a href="data-list.html#v:elemIndex" title="Data.List">elemIndex</a></code>, by returning the indices of all elements equal to the query element, in ascending order.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:elemIndices0">Examples</h5>
<details id="ch:elemIndices0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndices 'o' "Hello World"
</strong>[4,7]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndices 1 [1, 2, 3, 1, 2, 3]
</strong>[0,3]
</pre></details><p class="src"><a id="v:findIndex" class="def">findIndex</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#findIndex" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:findIndex" title="Data.List">findIndex</a></code> function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element. For the result to be <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the list must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:findIndex0">Examples</h5>
<details id="ch:findIndex0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndex isSpace "Hello World!"
</strong>Just 5
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndex odd [0, 2, 4, 6]
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndex even [1..]
</strong>Just 1
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndex odd [0, 2 ..]
</strong>* hangs forever *
</pre></details><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [<a href="data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#findIndices" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:findIndices" title="Data.List">findIndices</a></code> function extends <code><a href="data-list.html#v:findIndex" title="Data.List">findIndex</a></code>, by returning the indices of all elements satisfying the predicate, in ascending order.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:findIndices0">Examples</h5>
<details id="ch:findIndices0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndices (`elem` "aeiou") "Hello World!"
</strong>[1,4,7]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndices (\l -&gt; length l &gt; 3) ["a", "bcde", "fgh", "ijklmnop"]
</strong>[1,3]
</pre></details><a href="#g:17" id="g:17"><h2>Zipping and unzipping lists</h2></a><p class="src"><a id="v:zip" class="def">zip</a> :: [a] -&gt; [b] -&gt; [(a, b)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#zip" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code> takes two lists and returns a list of corresponding pairs.</p>
<p><code><a href="data-list.html#v:zip" title="Data.List">zip</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [] undefined
</strong>[]
&gt;&gt;&gt; <strong class="userinput">zip undefined []
</strong>*** Exception: Prelude.undefined
...
</pre>
<p><code><a href="data-list.html#v:zip" title="Data.List">zip</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:zip0">Examples</h5>
<details id="ch:zip0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1, 2, 3] ['a', 'b', 'c']
</strong>[(1,'a'),(2,'b'),(3,'c')]
</pre>
<p>If one input list is shorter than the other, excess elements of the longer list are discarded, even if one of the lists is infinite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1] ['a', 'b']
</strong>[(1,'a')]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1, 2] ['a']
</strong>[(1,'a')]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [] [1..]
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1..] []
</strong>[]
</pre></details><p class="src"><a id="v:zip3" class="def">zip3</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#zip3" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:zip3" title="Data.List">zip3</a></code> takes three lists and returns a list of triples, analogous to <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip4" class="def">zip4</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [(a, b, c, d)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zip4" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zip4" title="Data.List">zip4</a></code> function takes four lists and returns a list of quadruples, analogous to <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip5" class="def">zip5</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [(a, b, c, d, e)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zip5" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zip5" title="Data.List">zip5</a></code> function takes five lists and returns a list of five-tuples, analogous to <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip6" class="def">zip6</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [(a, b, c, d, e, f)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zip6" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zip6" title="Data.List">zip6</a></code> function takes six lists and returns a list of six-tuples, analogous to <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip7" class="def">zip7</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [(a, b, c, d, e, f, g)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zip7" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zip7" title="Data.List">zip7</a></code> function takes seven lists and returns a list of seven-tuples, analogous to <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#zipWith" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code> generalises <code><a href="data-list.html#v:zip" title="Data.List">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function.</p>
<pre>zipWith (,) xs ys == zip xs ys
zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]</pre>
<p><code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">let f = undefined
</strong>&gt;&gt;&gt; <strong class="userinput">zipWith f [] undefined
</strong>[]
</pre>
<p><code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:zipWith0">Examples</h5>
<details id="ch:zipWith0"><summary class="hide-when-js-enabled">Expand</summary><p><code class="inline-code"><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a> <a href="prelude.html#v:-43-" title="Prelude">(+)</a></code> can be applied to two lists to produce the list of corresponding sums:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith (+) [1, 2, 3] [4, 5, 6]
</strong>[5,7,9]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith (++) ["hello ", "foo"] ["world!", "bar"]
</strong>["hello world!","foobar"]
</pre></details><p class="src"><a id="v:zipWith3" class="def">zipWith3</a> :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#zipWith3" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(l,m,n))\)</span>. The <code><a href="data-list.html#v:zipWith3" title="Data.List">zipWith3</a></code> function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<pre>zipWith3 (,,) xs ys zs == zip3 xs ys zs
zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:zipWith30">Examples</h5>
<details id="ch:zipWith30"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith3 (\x y z -&gt; [x, y, z]) "123" "abc" "xyz"
</strong>["1ax","2by","3cz"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith3 (\x y z -&gt; (x * y) + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]
</strong>[11,18,27]
</pre></details><p class="src"><a id="v:zipWith4" class="def">zipWith4</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zipWith4" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zipWith4" title="Data.List">zipWith4</a></code> function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith5" class="def">zipWith5</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zipWith5" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zipWith5" title="Data.List">zipWith5</a></code> function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith6" class="def">zipWith6</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zipWith6" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zipWith6" title="Data.List">zipWith6</a></code> function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith7" class="def">zipWith7</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [h] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#zipWith7" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:zipWith7" title="Data.List">zipWith7</a></code> function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to <code><a href="data-list.html#v:zipWith" title="Data.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:unzip" class="def">unzip</a> :: [(a, b)] -&gt; ([a], [b]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#unzip" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code> transforms a list of pairs into a list of first components and a list of second components.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unzip0">Examples</h5>
<details id="ch:unzip0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip []
</strong>([],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip [(1, 'a'), (2, 'b')]
</strong>([1,2],"ab")
</pre></details><p class="src"><a id="v:unzip3" class="def">unzip3</a> :: [(a, b, c)] -&gt; ([a], [b], [c]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.List.html#unzip3" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unzip3" title="Data.List">unzip3</a></code> function takes a list of triples and returns three lists of the respective components, analogous to <code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unzip30">Examples</h5>
<details id="ch:unzip30"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip3 []
</strong>([],[],[])
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip3 [(1, 'a', True), (2, 'b', False)]
</strong>([1,2],"ab",[True,False])
</pre></details><p class="src"><a id="v:unzip4" class="def">unzip4</a> :: [(a, b, c, d)] -&gt; ([a], [b], [c], [d]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unzip4" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unzip4" title="Data.List">unzip4</a></code> function takes a list of quadruples and returns four lists, analogous to <code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code>.</p>
<p class="src"><a id="v:unzip5" class="def">unzip5</a> :: [(a, b, c, d, e)] -&gt; ([a], [b], [c], [d], [e]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unzip5" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unzip5" title="Data.List">unzip5</a></code> function takes a list of five-tuples and returns five lists, analogous to <code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code>.</p>
<p class="src"><a id="v:unzip6" class="def">unzip6</a> :: [(a, b, c, d, e, f)] -&gt; ([a], [b], [c], [d], [e], [f]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unzip6" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unzip6" title="Data.List">unzip6</a></code> function takes a list of six-tuples and returns six lists, analogous to <code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code>.</p>
<p class="src"><a id="v:unzip7" class="def">unzip7</a> :: [(a, b, c, d, e, f, g)] -&gt; ([a], [b], [c], [d], [e], [f], [g]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unzip7" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unzip7" title="Data.List">unzip7</a></code> function takes a list of seven-tuples and returns seven lists, analogous to <code><a href="data-list.html#v:unzip" title="Data.List">unzip</a></code>.</p>
<a href="#g:18" id="g:18"><h2>Special lists</h2></a><a href="#g:19" id="g:19"><h3>Functions on strings</h3></a><p class="src"><a id="v:lines" class="def">lines</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [<a href="data-string.html#t:String" title="Data.String">String</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#lines" class="link">Source</a> </p>
<p>Splits the argument into a list of <em>lines</em> stripped of their terminating <code class="inline-code">\n</code> characters. The <code class="inline-code">\n</code> terminator is optional in a final non-empty line of the argument string.</p>
<p>When the argument string is empty, or ends in a <code class="inline-code">\n</code> character, it can be recovered by passing the result of <code><a href="data-list.html#v:lines" title="Data.List">lines</a></code> to the <code><a href="data-list.html#v:unlines" title="Data.List">unlines</a></code> function. Otherwise, <code><a href="data-list.html#v:unlines" title="Data.List">unlines</a></code> appends the missing terminating <code class="inline-code">\n</code>. This makes <code class="inline-code">unlines . lines</code> <em>idempotent</em>:</p>
<pre>(unlines . lines) . (unlines . lines) = (unlines . lines)</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:lines0">Examples</h5>
<details id="ch:lines0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines ""           -- empty input contains no lines
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "\n"         -- single empty line
</strong>[""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one"        -- single unterminated line
</strong>["one"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\n"      -- single non-empty line
</strong>["one"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\n\n"    -- second line is empty
</strong>["one",""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\ntwo"   -- second line is unterminated
</strong>["one","two"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\ntwo\n" -- two non-empty lines
</strong>["one","two"]
</pre></details><p class="src"><a id="v:words" class="def">words</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [<a href="data-string.html#t:String" title="Data.String">String</a>] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#words" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:words" title="Data.List">words</a></code> breaks a string up into a list of words, which were delimited by white space (as defined by <code><a href="data-char.html#v:isSpace" title="Data.Char">isSpace</a></code>). This function trims any white spaces at the beginning and at the end.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:words0">Examples</h5>
<details id="ch:words0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">words "Lorem ipsum\ndolor"
</strong>["Lorem","ipsum","dolor"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">words " foo bar "
</strong>["foo","bar"]
</pre></details><p class="src"><a id="v:unlines" class="def">unlines</a> :: [<a href="data-string.html#t:String" title="Data.String">String</a>] -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unlines" class="link">Source</a> </p>
<p>Appends a <code class="inline-code">\n</code> character to each input string, then concatenates the results. Equivalent to <code class="inline-code">foldMap (s -&gt; s <a href="data-list.html#v:-43--43-" title="Data.List">++</a> "\n")</code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unlines0">Examples</h5>
<details id="ch:unlines0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unlines ["Hello", "World", "!"]
</strong>"Hello\nWorld\n!\n"
</pre>
<p>Note that <code class="inline-code"><a href="data-list.html#v:unlines" title="Data.List">unlines</a> <a href="data-function.html#v:." title="Data.Function">.</a> <a href="data-list.html#v:lines" title="Data.List">lines</a> <a href="data-eq.html#v:-47--61-" title="Data.Eq">/=</a> <a href="data-function.html#v:id" title="Data.Function">id</a></code> when the input is not <code class="inline-code">\n</code>-terminated:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unlines . lines $ "foo\nbar"
</strong>"foo\nbar\n"
</pre></details><p class="src"><a id="v:unwords" class="def">unwords</a> :: [<a href="data-string.html#t:String" title="Data.String">String</a>] -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unwords" class="link">Source</a> </p>
<p><code><a href="data-list.html#v:unwords" title="Data.List">unwords</a></code> joins words with separating spaces (U+0020 SPACE).</p>
<p><code><a href="data-list.html#v:unwords" title="Data.List">unwords</a></code> is neither left nor right inverse of <code><a href="data-list.html#v:words" title="Data.List">words</a></code>:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">words (unwords [" "])
</strong>[]
&gt;&gt;&gt; <strong class="userinput">unwords (words "foo\nbar")
</strong>"foo bar"
</pre>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unwords0">Examples</h5>
<details id="ch:unwords0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unwords ["Lorem", "ipsum", "dolor"]
</strong>"Lorem ipsum dolor"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unwords ["foo", "bar", "", "baz"]
</strong>"foo bar  baz"
</pre></details><a href="#g:20" id="g:20"><h3>"Set" operations</h3></a><p class="src"><a id="v:nub" class="def">nub</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#nub" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n^2)\)</span>. The <code><a href="data-list.html#v:nub" title="Data.List">nub</a></code> function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name <code><a href="data-list.html#v:nub" title="Data.List">nub</a></code> means `essence'.) It is a special case of <code><a href="data-list.html#v:nubBy" title="Data.List">nubBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p>If there exists <code class="inline-code">instance Ord a</code>, it's faster to use <code class="inline-code">nubOrd</code> from the <code class="inline-code">containers</code> package (<a href="https://hackage.haskell.org/package/containers/docs/Data-Containers-ListUtils.html#v:nubOrd">link to the latest online documentation</a>), which takes only <span class="mathjax">\(\mathcal{O}(n \log d)\)</span> time where <code class="inline-code">d</code> is the number of distinct elements in the list.</p>
<p>Another approach to speed up <code><a href="data-list.html#v:nub" title="Data.List">nub</a></code> is to use <code><a href="data-list.html#v:map" title="Data.List">map</a></code> <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:head" title="Data.List.NonEmpty">head</a></code> . <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:group" title="Data.List.NonEmpty">group</a></code> . <code><a href="data-list.html#v:sort" title="Data.List">sort</a></code>, which takes <span class="mathjax">\(\mathcal{O}(n \log n)\)</span> time, requires <code class="inline-code">instance Ord a</code> and doesn't preserve the order.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:nub0">Examples</h5>
<details id="ch:nub0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">nub [1,2,3,4,3,2,1,2,4,3,5]
</strong>[1,2,3,4,5]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">nub "hello, world!"
</strong>"helo, wrd!"
</pre></details><p class="src"><a id="v:delete" class="def">delete</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#delete" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="data-list.html#v:delete" title="Data.List">delete</a></code> <code class="inline-code">x</code> removes the first occurrence of <code class="inline-code">x</code> from its list argument.</p>
<p>It is a special case of <code><a href="data-list.html#v:deleteBy" title="Data.List">deleteBy</a></code>, which allows the programmer to supply their own equality test.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:delete0">Examples</h5>
<details id="ch:delete0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">delete 'a' "banana"
</strong>"bnana"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">delete "not" ["haskell", "is", "not", "awesome"]
</strong>["haskell","is","awesome"]
</pre></details><p class="src"><a id="v:-92--92-" class="def">(\\)</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <span class="fixity">infix 5</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#%5C%5C" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:-92--92-" title="Data.List">\\</a></code> function is list difference (non-associative). In the result of <code class="inline-code">xs</code> <code><a href="data-list.html#v:-92--92-" title="Data.List">\\</a></code> <code class="inline-code">ys</code>, the first occurrence of each element of <code class="inline-code">ys</code> in turn (if any) has been removed from <code class="inline-code">xs</code>. Thus <code class="inline-code">(xs ++ ys) \\ xs == ys</code>.</p>
<p>It is a special case of <code><a href="data-list.html#v:deleteFirstsBy" title="Data.List">deleteFirstsBy</a></code>, which allows the programmer to supply their own equality test.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:-92--92-0">Examples</h5>
<details id="ch:-92--92-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello World!" \\ "ell W"
</strong>"Hoorld!"
</pre>
<p>The second list must be finite, but the first may be infinite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 ([0..] \\ [2..4])
</strong>[0,1,5,6,7]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 ([0..] \\ [2..])
</strong>* Hangs forever *
</pre></details><p class="src"><a id="v:union" class="def">union</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#union" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:union" title="Data.List">union</a></code> function returns the list union of the two lists. It is a special case of <code><a href="data-list.html#v:unionBy" title="Data.List">unionBy</a></code>, which allows the programmer to supply their own equality test.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:union0">Examples</h5>
<details id="ch:union0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">"dog" `union` "cow"
</strong>"dogcw"
</pre>
<p>If equal elements are present in both lists, an element from the first list will be used. If the second list contains equal elements, only the first one will be retained:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">import Data.Semigroup(Arg(..))
</strong>&gt;&gt;&gt; <strong class="userinput">union [Arg () "dog"] [Arg () "cow"]
</strong>[Arg () "dog"]
&gt;&gt;&gt; <strong class="userinput">union [] [Arg () "dog", Arg () "cow"]
</strong>[Arg () "dog"]
</pre>
<p>However if the first list contains duplicates, so will the result:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"coot" `union` "duck"
</strong>"cootduk"
&gt;&gt;&gt; <strong class="userinput">"duck" `union` "coot"
</strong>"duckot"
</pre>
<p><code><a href="data-list.html#v:union" title="Data.List">union</a></code> is productive even if both arguments are infinite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[0, 2 ..] `union` [1, 3 ..]
</strong>[0,2,4,6,8,10,12..
</pre></details><p class="src"><a id="v:intersect" class="def">intersect</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#intersect" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:intersect" title="Data.List">intersect</a></code> function takes the list intersection of two lists. It is a special case of <code><a href="data-list.html#v:intersectBy" title="Data.List">intersectBy</a></code>, which allows the programmer to supply their own equality test.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:intersect0">Examples</h5>
<details id="ch:intersect0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">[1,2,3,4] `intersect` [2,4,6,8]
</strong>[2,4]
</pre>
<p>If equal elements are present in both lists, an element from the first list will be used, and all duplicates from the second list quashed:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">import Data.Semigroup
</strong>&gt;&gt;&gt; <strong class="userinput">intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
</strong>[Arg () "dog"]
</pre>
<p>However if the first list contains duplicates, so will the result.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"coot" `intersect` "heron"
</strong>"oo"
&gt;&gt;&gt; <strong class="userinput">"heron" `intersect` "coot"
</strong>"o"
</pre>
<p>If the second list is infinite, <code><a href="data-list.html#v:intersect" title="Data.List">intersect</a></code> either hangs or returns its first argument in full. Otherwise if the first list is infinite, <code><a href="data-list.html#v:intersect" title="Data.List">intersect</a></code> might be productive:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intersect [100..] [0..]
</strong>[100,101,102,103...
&gt;&gt;&gt; <strong class="userinput">intersect [0] [1..]
</strong>* Hangs forever *
&gt;&gt;&gt; <strong class="userinput">intersect [1..] [0]
</strong>* Hangs forever *
&gt;&gt;&gt; <strong class="userinput">intersect (cycle [1..3]) [2]
</strong>[2,2,2,2...
</pre></details><a href="#g:21" id="g:21"><h3>Ordered lists</h3></a><p class="src"><a id="v:sort" class="def">sort</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#sort" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:sort" title="Data.List">sort</a></code> function implements a stable sorting algorithm. It is a special case of <code><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<p>Elements are arranged from lowest to highest, keeping duplicates in the order they appeared in the input.</p>
<p>The argument must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:sort0">Examples</h5>
<details id="ch:sort0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">sort [1,6,4,3,2,5]
</strong>[1,2,3,4,5,6]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sort "haskell"
</strong>"aehklls"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">import Data.Semigroup(Arg(..))
</strong>&gt;&gt;&gt; <strong class="userinput">sort [Arg ":)" 0, Arg ":D" 0, Arg ":)" 1, Arg ":3" 0, Arg ":D" 1]
</strong>[Arg ":)" 0,Arg ":)" 1,Arg ":3" 0,Arg ":D" 0,Arg ":D" 1]
</pre></details><p class="src"><a id="v:sortOn" class="def">sortOn</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#sortOn" class="link">Source</a> </p>
<p>Sort a list by comparing the results of a key function applied to each element. <code class="inline-code"><a href="data-list.html#v:sortOn" title="Data.List">sortOn</a> f</code> is equivalent to <code class="inline-code"><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a> (<a href="data-ord.html#v:comparing" title="Data.Ord">comparing</a> f)</code>, but has the performance advantage of only evaluating <code class="inline-code">f</code> once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>.</p>
<p>Elements are arranged from lowest to highest, keeping duplicates in the order they appeared in the input.</p>
<p>The argument must be finite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:sortOn0">Examples</h5>
<details id="ch:sortOn0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
</strong>[(1,"Hello"),(2,"world"),(4,"!")]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortOn length ["jim", "creed", "pam", "michael", "dwight", "kevin"]
</strong>["jim","pam","creed","kevin","dwight","michael"]
</pre></details><h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:sortOn1">Performance notes</h5>
<details id="ch:sortOn1"><summary class="hide-when-js-enabled">Expand</summary><p>This function minimises the projections performed, by materialising the projections in an intermediate list.</p>
<p>For trivial projections, you should prefer using <code><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a></code> with <code><a href="data-ord.html#v:comparing" title="Data.Ord">comparing</a></code>, for example:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortBy (comparing fst) [(3, 1), (2, 2), (1, 3)]
</strong>[(1,3),(2,2),(3,1)]
</pre>
<p>Or, for the exact same API as <code><a href="data-list.html#v:sortOn" title="Data.List">sortOn</a></code>, you can use `sortBy . comparing`:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">(sortBy . comparing) fst [(3, 1), (2, 2), (1, 3)]
</strong>[(1,3),(2,2),(3,1)]
</pre></details><p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:insert" class="def">insert</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#insert" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:insert" title="Data.List">insert</a></code> function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of <code><a href="data-list.html#v:insertBy" title="Data.List">insertBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:insert0">Examples</h5>
<details id="ch:insert0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">insert (-1) [1, 2, 3]
</strong>[-1,1,2,3]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">insert 'd' "abcefg"
</strong>"abcdefg"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">insert 4 [1, 2, 3, 5, 6, 7]
</strong>[1,2,3,4,5,6,7]
</pre></details><a href="#g:22" id="g:22"><h2>Generalized functions</h2></a><a href="#g:23" id="g:23"><h3>The "<code class="inline-code">By</code>" operations</h3></a><p>By convention, overloaded functions have a non-overloaded counterpart whose name is suffixed with `<code class="inline-code">By</code>'.</p>
<p>It is often convenient to use these functions together with <code><a href="data-function.html#v:on" title="Data.Function">on</a></code>, for instance <code class="inline-code"><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a> (<a href="prelude.html#v:compare" title="Prelude">compare</a>
 <a href="data-function.html#v:on" title="Data.Function">`on`</a> <a href="prelude.html#v:fst" title="Prelude">fst</a>)</code>.</p>
<a href="#g:24" id="g:24"><h4>User-supplied equality (replacing an <code class="inline-code">Eq</code> context)</h4></a><p>The predicate is assumed to define an equivalence.</p>
<p class="src"><a id="v:nubBy" class="def">nubBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#nubBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:nubBy" title="Data.List">nubBy</a></code> function behaves just like <code><a href="data-list.html#v:nub" title="Data.List">nub</a></code>, except it uses a user-supplied equality predicate instead of the overloaded <code><a href="data-eq.html#v:-61--61-" title="Data.Eq">(==)</a></code> function.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:nubBy0">Examples</h5>
<details id="ch:nubBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
</strong>[1,2,6]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">nubBy (/=) [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
</strong>[2,2,2]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">nubBy (&gt;) [1, 2, 3, 2, 1, 5, 4, 5, 3, 2]
</strong>[1,2,3,5,5]
</pre></details><p class="src"><a id="v:deleteBy" class="def">deleteBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#deleteBy" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:deleteBy" title="Data.List">deleteBy</a></code> function behaves like <code><a href="data-list.html#v:delete" title="Data.List">delete</a></code>, but takes a user-supplied equality predicate.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:deleteBy0">Examples</h5>
<details id="ch:deleteBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">deleteBy (&lt;=) 4 [1..10]
</strong>[1,2,3,5,6,7,8,9,10]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">deleteBy (/=) 5 [5, 5, 4, 3, 5, 2]
</strong>[5,5,3,5,2]
</pre></details><p class="src"><a id="v:deleteFirstsBy" class="def">deleteFirstsBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#deleteFirstsBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:deleteFirstsBy" title="Data.List">deleteFirstsBy</a></code> function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed. This is the non-overloaded version of <code><a href="data-list.html#v:-92--92-" title="Data.List">(\\)</a></code>.</p>
<pre>(\\) == deleteFirstsBy (==)</pre>
<p>The second list must be finite, but the first may be infinite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:deleteFirstsBy0">Examples</h5>
<details id="ch:deleteFirstsBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">deleteFirstsBy (&gt;) [1..10] [3, 4, 5]
</strong>[4,5,6,7,8,9,10]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">deleteFirstsBy (/=) [1..10] [1, 3, 5]
</strong>[4,5,6,7,8,9,10]
</pre></details><p class="src"><a id="v:unionBy" class="def">unionBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#unionBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:unionBy" title="Data.List">unionBy</a></code> function is the non-overloaded version of <code><a href="data-list.html#v:union" title="Data.List">union</a></code>. Both arguments may be infinite.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:unionBy0">Examples</h5>
<details id="ch:unionBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">unionBy (&gt;) [3, 4, 5] [1, 2, 3, 4, 5, 6]
</strong>[3,4,5,4,5,6]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">import Data.Semigroup (Arg(..))
</strong>&gt;&gt;&gt; <strong class="userinput">unionBy (/=) [Arg () "Saul"] [Arg () "Kim"]
</strong>[Arg () "Saul", Arg () "Kim"]
</pre></details><p class="src"><a id="v:intersectBy" class="def">intersectBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#intersectBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:intersectBy" title="Data.List">intersectBy</a></code> function is the non-overloaded version of <code><a href="data-list.html#v:intersect" title="Data.List">intersect</a></code>. It is productive for infinite arguments only if the first one is a subset of the second.</p>
<p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#groupBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:groupBy" title="Data.List">groupBy</a></code> function is the non-overloaded version of <code><a href="data-list.html#v:group" title="Data.List">group</a></code>.</p>
<p>When a supplied relation is not transitive, it is important to remember that equality is checked against the first element in the group, not against the nearest neighbour:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">groupBy (\a b -&gt; b - a &lt; 5) [0..19]
</strong>[[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
</pre>
<p>It's often preferable to use <code class="inline-code">Data.List.NonEmpty.</code><code><a href="data-list-nonempty.html#v:groupBy" title="Data.List.NonEmpty">groupBy</a></code>, which provides type-level guarantees of non-emptiness of inner lists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:groupBy0">Examples</h5>
<details id="ch:groupBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">groupBy (/=) [1, 1, 1, 2, 3, 1, 4, 4, 5]
</strong>[[1],[1],[1,2,3],[1,4,4,5]]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">groupBy (&gt;) [1, 3, 5, 1, 4, 2, 6, 5, 4]
</strong>[[1],[3],[5,1,4,2],[6,5,4]]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">groupBy (const not) [True, False, True, False, False, False, True]
</strong>[[True,False],[True,False,False,False],[True]]
</pre></details><a href="#g:25" id="g:25"><h4>User-supplied comparison (replacing an <code class="inline-code">Ord</code> context)</h4></a><p>The function is assumed to define a total ordering.</p>
<p class="src"><a id="v:sortBy" class="def">sortBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#sortBy" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a></code> function is the non-overloaded version of <code><a href="data-list.html#v:sort" title="Data.List">sort</a></code>. The argument must be finite.</p>
<p>The supplied comparison relation is supposed to be reflexive and antisymmetric, otherwise, e. g., for <code class="inline-code">_ _ -&gt; GT</code>, the ordered list simply does not exist. The relation is also expected to be transitive: if it is not then <code><a href="data-list.html#v:sortBy" title="Data.List">sortBy</a></code> might fail to find an ordered permutation, even if it exists.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:sortBy0">Examples</h5>
<details id="ch:sortBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
</strong>[(1,"Hello"),(2,"world"),(4,"!")]
</pre></details><p class="src"><a id="v:insertBy" class="def">insertBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#insertBy" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The non-overloaded version of <code><a href="data-list.html#v:insert" title="Data.List">insert</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:insertBy0">Examples</h5>
<details id="ch:insertBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">insertBy (\x y -&gt; compare (length x) (length y)) [1, 2] [[1], [1, 2, 3], [1, 2, 3, 4]]
</strong>[[1],[1,2],[1,2,3],[1,2,3,4]]
</pre></details><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#maximumBy" class="link">Source</a> </p>
<p>The largest element of a non-empty structure with respect to the given comparison function. Structure order is used as a tie-breaker: if there are multiple largest elements, the rightmost of them is chosen.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:maximumBy0">Examples</h5>
<details id="ch:maximumBy0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
</strong>"Longest"
</pre>
<p>WARNING: This function is partial for possibly-empty structures like lists.</p></details><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: <a href="data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> t =&gt; (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.Foldable.html#minimumBy" class="link">Source</a> </p>
<p>The least element of a non-empty structure with respect to the given comparison function. Structure order is used as a tie-breaker: if there are multiple least elements, the leftmost of them is chosen.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:minimumBy0">Examples</h5>
<details id="ch:minimumBy0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
</strong>"!"
</pre>
<p>WARNING: This function is partial for possibly-empty structures like lists.</p></details><a href="#g:26" id="g:26"><h3>The "<code class="inline-code">generic</code>" operations</h3></a><p>The prefix `<code class="inline-code">generic</code>' indicates an overloaded function that is a generalized version of a <a href="prelude.html">Prelude</a> function.</p>
<p class="src"><a id="v:genericLength" class="def">genericLength</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> i =&gt; [a] -&gt; i <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericLength" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="data-list.html#v:genericLength" title="Data.List">genericLength</a></code> function is an overloaded version of <code><a href="ghc-list.html#v:length" title="GHC.List">length</a></code>. In particular, instead of returning an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>, it returns any type which is an instance of <code><a href="prelude.html#t:Num" title="Prelude">Num</a></code>. It is, however, less efficient than <code><a href="ghc-list.html#v:length" title="GHC.List">length</a></code>.</p>
<h5 class="subheading details-toggle-control details-toggle" data-details-id="ch:genericLength0">Examples</h5>
<details id="ch:genericLength0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen">&gt;&gt;&gt; <strong class="userinput">genericLength [1, 2, 3] :: Int
</strong>3
&gt;&gt;&gt; <strong class="userinput">genericLength [1, 2, 3] :: Float
</strong>3.0
</pre>
<p>Users should take care to pick a return type that is wide enough to contain the full length of the list. If the width is insufficient, the overflow behaviour will depend on the <code class="inline-code">(+)</code> implementation in the selected <code><a href="prelude.html#t:Num" title="Prelude">Num</a></code> instance. The following example overflows because the actual list length of 200 lies outside of the <code class="inline-code">Int8</code> range of <code class="inline-code">-128..127</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">genericLength [1..200] :: Int8
</strong>-56
</pre></details><p class="src"><a id="v:genericTake" class="def">genericTake</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericTake" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:genericTake" title="Data.List">genericTake</a></code> function is an overloaded version of <code><a href="data-list.html#v:take" title="Data.List">take</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of elements to take.</p>
<p class="src"><a id="v:genericDrop" class="def">genericDrop</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericDrop" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:genericDrop" title="Data.List">genericDrop</a></code> function is an overloaded version of <code><a href="data-list.html#v:drop" title="Data.List">drop</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of elements to drop.</p>
<p class="src"><a id="v:genericSplitAt" class="def">genericSplitAt</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericSplitAt" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:genericSplitAt" title="Data.List">genericSplitAt</a></code> function is an overloaded version of <code><a href="data-list.html#v:splitAt" title="Data.List">splitAt</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the position at which to split.</p>
<p class="src"><a id="v:genericIndex" class="def">genericIndex</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; [a] -&gt; i -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericIndex" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:genericIndex" title="Data.List">genericIndex</a></code> function is an overloaded version of <code><a href="data-list.html#v:-33--33-" title="Data.List">!!</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the index.</p>
<p class="src"><a id="v:genericReplicate" class="def">genericReplicate</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-internal-9.1201.0-3ad5/src/GHC.Internal.Data.OldList.html#genericReplicate" class="link">Source</a> </p>
<p>The <code><a href="data-list.html#v:genericReplicate" title="Data.List">genericReplicate</a></code> function is an overloaded version of <code><a href="data-list.html#v:replicate" title="Data.List">replicate</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of repetitions to make.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Data-List.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/Data-List.html</a>
  </p>
</div>
