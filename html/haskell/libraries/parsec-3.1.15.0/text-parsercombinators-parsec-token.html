<h1 class="caption">Text.ParserCombinators.Parsec.Token</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) Paolo Martini 2007</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the LICENSE file)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>derek.a.elkins@gmail.com</td>
</tr>
<tr>
<th>Stability</th>
<td>provisional</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="description">
<h4 class="caption">Description</h4>
<p>Parsec compatibility module</p>
</div>
<p class="src">type <a id="t:LanguageDef" class="def">LanguageDef</a> st = <a href="text-parsercombinators-parsec-token.html#t:GenLanguageDef" title="Text.ParserCombinators.Parsec.Token">GenLanguageDef</a> <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a> st <a href="../array-0.5.4.0/data-functor-identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/src/Text.Parsec.Token.html#LanguageDef" class="link">Source</a> </p>
<p class="src">data <a id="t:GenLanguageDef" class="def">GenLanguageDef</a> s u m <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/src/Text.Parsec.Token.html#GenLanguageDef" class="link">Source</a> </p>
<p>The <code>GenLanguageDef</code> type is a record that contains all parameterizable features of the <a href="text-parsec-token.html">Text.Parsec.Token</a> module. The module <a href="text-parsec-language.html">Text.Parsec.Language</a> contains some default definitions.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:LanguageDef" class="def">LanguageDef</a></td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><div class="subs fields">
<h4 class="caption">Fields</h4>
<ul>
<li>
<dfn class="src"><a id="v:commentStart" class="def">commentStart</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Describes the start of a block comment. Use the empty string if the language doesn't support block comments. For example "/*".</p>
</li>
<li>
<dfn class="src"><a id="v:commentEnd" class="def">commentEnd</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Describes the end of a block comment. Use the empty string if the language doesn't support block comments. For example "*/".</p>
</li>
<li>
<dfn class="src"><a id="v:commentLine" class="def">commentLine</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Describes the start of a line comment. Use the empty string if the language doesn't support line comments. For example "//".</p>
</li>
<li>
<dfn class="src"><a id="v:nestedComments" class="def">nestedComments</a> :: <a href="../array-0.5.4.0/data-bool.html#t:Bool" title="Data.Bool">Bool</a></dfn><p>Set to <code><a href="../array-0.5.4.0/data-bool.html#v:True" title="Data.Bool">True</a></code> if the language supports nested block comments.</p>
</li>
<li>
<dfn class="src"><a id="v:identStart" class="def">identStart</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a></dfn><p>This parser should accept any start characters of identifiers. For example <code>letter &lt;|&gt; char '_'</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:identLetter" class="def">identLetter</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a></dfn><p>This parser should accept any legal tail characters of identifiers. For example <code>alphaNum &lt;|&gt; char '_'</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:opStart" class="def">opStart</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a></dfn><p>This parser should accept any start characters of operators. For example <code>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</code></p>
</li>
<li>
<dfn class="src"><a id="v:opLetter" class="def">opLetter</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a></dfn><p>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the <code><a href="text-parsercombinators-parsec-token.html#v:reservedOp" title="Text.ParserCombinators.Parsec.Token">reservedOp</a></code> parser won't work correctly.</p>
</li>
<li>
<dfn class="src"><a id="v:reservedNames" class="def">reservedNames</a> :: [<a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a>]</dfn><p>The list of reserved identifiers.</p>
</li>
<li>
<dfn class="src"><a id="v:reservedOpNames" class="def">reservedOpNames</a> :: [<a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a>]</dfn><p>The list of reserved operators.</p>
</li>
<li>
<dfn class="src"><a id="v:caseSensitive" class="def">caseSensitive</a> :: <a href="../array-0.5.4.0/data-bool.html#t:Bool" title="Data.Bool">Bool</a></dfn><p>Set to <code><a href="../array-0.5.4.0/data-bool.html#v:True" title="Data.Bool">True</a></code> if the language is case sensitive.</p>
</li>
</ul>
</div></td></tr>
</table>
</div>
<p class="src">type <a id="t:TokenParser" class="def">TokenParser</a> st = <a href="text-parsercombinators-parsec-token.html#t:GenTokenParser" title="Text.ParserCombinators.Parsec.Token">GenTokenParser</a> <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a> st <a href="../array-0.5.4.0/data-functor-identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/src/Text.Parsec.Token.html#TokenParser" class="link">Source</a> </p>
<p class="src">data <a id="t:GenTokenParser" class="def">GenTokenParser</a> s u m <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/src/Text.Parsec.Token.html#GenTokenParser" class="link">Source</a> </p>
<p>The type of the record that holds lexical parsers that work on <code>s</code> streams with state <code>u</code> over a monad <code>m</code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a id="v:TokenParser" class="def">TokenParser</a></td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><div class="subs fields">
<h4 class="caption">Fields</h4>
<ul>
<li>
<dfn class="src"><a id="v:identifier" class="def">identifier</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the <code><a href="text-parsercombinators-parsec-token.html#t:LanguageDef" title="Text.ParserCombinators.Parsec.Token">LanguageDef</a></code> that is passed to <code><a href="text-parsercombinators-parsec-token.html#v:makeTokenParser" title="Text.ParserCombinators.Parsec.Token">makeTokenParser</a></code>. An <code>identifier</code> is treated as a single token using <code><a href="text-parsec.html#v:try" title="Text.Parsec">try</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:reserved" class="def">reserved</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m ()</dfn><p>The lexeme parser <code>reserved name</code> parses <code>symbol
 name</code>, but it also checks that the <code>name</code> is not a prefix of a valid identifier. A <code>reserved</code> word is treated as a single token using <code><a href="text-parsec.html#v:try" title="Text.Parsec">try</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:operator" class="def">operator</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the <code><a href="text-parsercombinators-parsec-token.html#t:LanguageDef" title="Text.ParserCombinators.Parsec.Token">LanguageDef</a></code> that is passed to <code><a href="text-parsercombinators-parsec-token.html#v:makeTokenParser" title="Text.ParserCombinators.Parsec.Token">makeTokenParser</a></code>. An <code>operator</code> is treated as a single token using <code><a href="text-parsec.html#v:try" title="Text.Parsec">try</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:reservedOp" class="def">reservedOp</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m ()</dfn><p>The lexeme parser <code>reservedOp name</code> parses <code>symbol
 name</code>, but it also checks that the <code>name</code> is not a prefix of a valid operator. A <code>reservedOp</code> is treated as a single token using <code><a href="text-parsec.html#v:try" title="Text.Parsec">try</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:charLiteral" class="def">charLiteral</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a></dfn><p>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</p>
</li>
<li>
<dfn class="src"><a id="v:stringLiteral" class="def">stringLiteral</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</p>
</li>
<li>
<dfn class="src"><a id="v:natural" class="def">natural</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a></dfn><p>This lexeme parser parses a natural number (a non-negative whole number). Returns the value of the number. The number can be specified in <code><a href="text-parsercombinators-parsec-token.html#v:decimal" title="Text.ParserCombinators.Parsec.Token">decimal</a></code>, <code><a href="text-parsercombinators-parsec-token.html#v:hexadecimal" title="Text.ParserCombinators.Parsec.Token">hexadecimal</a></code> or <code><a href="text-parsercombinators-parsec-token.html#v:octal" title="Text.ParserCombinators.Parsec.Token">octal</a></code>. The number is parsed according to the grammar rules in the Haskell report.</p>
</li>
<li>
<dfn class="src"><a id="v:integer" class="def">integer</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a></dfn><p>This lexeme parser parses an integer (a whole number). This parser is like <code><a href="text-parsercombinators-parsec-token.html#v:natural" title="Text.ParserCombinators.Parsec.Token">natural</a></code> except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in <code><a href="text-parsercombinators-parsec-token.html#v:decimal" title="Text.ParserCombinators.Parsec.Token">decimal</a></code>, <code><a href="text-parsercombinators-parsec-token.html#v:hexadecimal" title="Text.ParserCombinators.Parsec.Token">hexadecimal</a></code> or <code><a href="text-parsercombinators-parsec-token.html#v:octal" title="Text.ParserCombinators.Parsec.Token">octal</a></code>. The number is parsed according to the grammar rules in the Haskell report.</p>
</li>
<li>
<dfn class="src"><a id="v:float" class="def">float</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Double" title="Prelude">Double</a></dfn><p>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</p>
</li>
<li>
<dfn class="src"><a id="v:naturalOrFloat" class="def">naturalOrFloat</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m (<a href="../array-0.5.4.0/data-either.html#t:Either" title="Data.Either">Either</a> <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a> <a href="../array-0.5.4.0/prelude.html#t:Double" title="Prelude">Double</a>)</dfn><p>This lexeme parser parses either <code><a href="text-parsercombinators-parsec-token.html#v:natural" title="Text.ParserCombinators.Parsec.Token">natural</a></code> or a <code><a href="text-parsercombinators-parsec-token.html#v:float" title="Text.ParserCombinators.Parsec.Token">float</a></code>. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</p>
</li>
<li>
<dfn class="src"><a id="v:decimal" class="def">decimal</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a></dfn><p>Parses a non-negative whole number in the decimal system. Returns the value of the number.</p>
</li>
<li>
<dfn class="src"><a id="v:hexadecimal" class="def">hexadecimal</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a></dfn><p>Parses a non-negative whole number in the hexadecimal system. The number should be prefixed with "x" or "X". Returns the value of the number.</p>
</li>
<li>
<dfn class="src"><a id="v:octal" class="def">octal</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/prelude.html#t:Integer" title="Prelude">Integer</a></dfn><p>Parses a non-negative whole number in the octal system. The number should be prefixed with "o" or "O". Returns the value of the number.</p>
</li>
<li>
<dfn class="src"><a id="v:symbol" class="def">symbol</a> :: <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a> -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Lexeme parser <code>symbol s</code> parses <code><a href="text-parsec-char.html#v:string" title="Text.Parsec.Char">string</a></code> <code>s</code> and skips trailing white space.</p>
</li>
<li>
<dfn class="src"><a id="v:lexeme" class="def">lexeme</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p><code>lexeme p</code> first applies parser <code>p</code> and then the <code><a href="text-parsercombinators-parsec-token.html#v:whiteSpace" title="Text.ParserCombinators.Parsec.Token">whiteSpace</a></code> parser, returning the value of <code>p</code>. Every lexical token (lexeme) is defined using <code>lexeme</code>, this way every parse starts at a point without white space. Parsers that use <code>lexeme</code> are called <em>lexeme</em> parsers in this document.</p>
<p>The only point where the <code><a href="text-parsercombinators-parsec-token.html#v:whiteSpace" title="Text.ParserCombinators.Parsec.Token">whiteSpace</a></code> parser should be called explicitly is the start of the main parser in order to skip any leading white space.</p>
<pre>   mainParser  = do{ whiteSpace
                    ; ds &lt;- many (lexeme digit)
                    ; eof
                    ; return (sum ds)
                    }</pre>
</li>
<li>
<dfn class="src"><a id="v:whiteSpace" class="def">whiteSpace</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m ()</dfn><p>Parses any white space. White space consists of <em>zero</em> or more occurrences of a <code><a href="text-parsec-char.html#v:space" title="Text.Parsec.Char">space</a></code>, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the <code><a href="text-parsercombinators-parsec-token.html#t:LanguageDef" title="Text.ParserCombinators.Parsec.Token">LanguageDef</a></code> that is passed to <code><a href="text-parsercombinators-parsec-token.html#v:makeTokenParser" title="Text.ParserCombinators.Parsec.Token">makeTokenParser</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:parens" class="def">parens</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p>Lexeme parser <code>parens p</code> parses <code>p</code> enclosed in parenthesis, returning the value of <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:braces" class="def">braces</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p>Lexeme parser <code>braces p</code> parses <code>p</code> enclosed in braces ('{' and '}'), returning the value of <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:angles" class="def">angles</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p>Lexeme parser <code>angles p</code> parses <code>p</code> enclosed in angle brackets ('&lt;' and '&gt;'), returning the value of <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:brackets" class="def">brackets</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p>Lexeme parser <code>brackets p</code> parses <code>p</code> enclosed in brackets ('[' and ']'), returning the value of <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:squares" class="def">squares</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a</dfn><p>DEPRECATED: Use <code><a href="text-parsercombinators-parsec-token.html#v:brackets" title="Text.ParserCombinators.Parsec.Token">brackets</a></code>.</p>
</li>
<li>
<dfn class="src"><a id="v:semi" class="def">semi</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Lexeme parser |semi| parses the character ';' and skips any trailing white space. Returns the string ";".</p>
</li>
<li>
<dfn class="src"><a id="v:comma" class="def">comma</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Lexeme parser <code>comma</code> parses the character ',' and skips any trailing white space. Returns the string ",".</p>
</li>
<li>
<dfn class="src"><a id="v:colon" class="def">colon</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Lexeme parser <code>colon</code> parses the character ':' and skips any trailing white space. Returns the string ":".</p>
</li>
<li>
<dfn class="src"><a id="v:dot" class="def">dot</a> :: <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m <a href="../array-0.5.4.0/data-string.html#t:String" title="Data.String">String</a></dfn><p>Lexeme parser <code>dot</code> parses the character '.' and skips any trailing white space. Returns the string ".".</p>
</li>
<li>
<dfn class="src"><a id="v:semiSep" class="def">semiSep</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m [a]</dfn><p>Lexeme parser <code>semiSep p</code> parses <em>zero</em> or more occurrences of <code>p</code> separated by <code><a href="text-parsercombinators-parsec-token.html#v:semi" title="Text.ParserCombinators.Parsec.Token">semi</a></code>. Returns a list of values returned by <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:semiSep1" class="def">semiSep1</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m [a]</dfn><p>Lexeme parser <code>semiSep1 p</code> parses <em>one</em> or more occurrences of <code>p</code> separated by <code><a href="text-parsercombinators-parsec-token.html#v:semi" title="Text.ParserCombinators.Parsec.Token">semi</a></code>. Returns a list of values returned by <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:commaSep" class="def">commaSep</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m [a]</dfn><p>Lexeme parser <code>commaSep p</code> parses <em>zero</em> or more occurrences of <code>p</code> separated by <code><a href="text-parsercombinators-parsec-token.html#v:comma" title="Text.ParserCombinators.Parsec.Token">comma</a></code>. Returns a list of values returned by <code>p</code>.</p>
</li>
<li>
<dfn class="src"><a id="v:commaSep1" class="def">commaSep1</a> :: forall a. <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m a -&gt; <a href="text-parsec.html#t:ParsecT" title="Text.Parsec">ParsecT</a> s u m [a]</dfn><p>Lexeme parser <code>commaSep1 p</code> parses <em>one</em> or more occurrences of <code>p</code> separated by <code><a href="text-parsercombinators-parsec-token.html#v:comma" title="Text.ParserCombinators.Parsec.Token">comma</a></code>. Returns a list of values returned by <code>p</code>.</p>
</li>
</ul>
</div></td></tr>
</table>
</div>
<p class="src"><a id="v:makeTokenParser" class="def">makeTokenParser</a> :: <a href="text-parsec.html#t:Stream" title="Text.Parsec">Stream</a> s m <a href="../array-0.5.4.0/data-char.html#t:Char" title="Data.Char">Char</a> =&gt; <a href="text-parsercombinators-parsec-token.html#t:GenLanguageDef" title="Text.ParserCombinators.Parsec.Token">GenLanguageDef</a> s u m -&gt; <a href="text-parsercombinators-parsec-token.html#t:GenTokenParser" title="Text.ParserCombinators.Parsec.Token">GenTokenParser</a> s u m <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/src/Text.Parsec.Token.html#makeTokenParser" class="link">Source</a> </p>
<p>The expression <code>makeTokenParser language</code> creates a <code><a href="text-parsercombinators-parsec-token.html#t:GenTokenParser" title="Text.ParserCombinators.Parsec.Token">GenTokenParser</a></code> record that contains lexical parsers that are defined using the definitions in the <code>language</code> record.</p>
<p>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting <code><a href="text-parsercombinators-parsec-token.html#t:GenTokenParser" title="Text.ParserCombinators.Parsec.Token">GenTokenParser</a></code>.</p>
<pre> module Main where

 import Text.Parsec
 import qualified Text.Parsec.Token as P
 import Text.Parsec.Language (haskellDef)

 -- The parser
 ...

 expr  =   parens expr
       &lt;|&gt; identifier
       &lt;|&gt; ...


 -- The lexer
 lexer       = P.makeTokenParser haskellDef

 parens      = P.parens lexer
 braces      = P.braces lexer
 identifier  = P.identifier lexer
 reserved    = P.reserved lexer
 ...</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/Text-ParserCombinators-Parsec-Token.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/parsec-3.1.15.0/Text-ParserCombinators-Parsec-Token.html</a>
  </p>
</div>
