<h1 class="caption">Data.Text.Encoding</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) 2009 2010 2011 Bryan O'Sullivan<br>(c) 2009 Duncan Coutts<br>(c) 2008 2009 Tom Harper<br>(c) 2021 Andrew Lelechenko</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>bos@serpentine.com</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li>
<a href="#g:1">Decoding ByteStrings to Text</a><ul>
<li>
<a href="#g:total">Total Functions </a><ul>
<li><a href="#g:3">Controllable error handling</a></li>
<li><a href="#g:4">Stream oriented decoding</a></li>
<li><a href="#g:5">Incremental UTF-8 decoding</a></li>
</ul>
</li>
<li>
<a href="#g:6">Partial Functions</a><ul><li><a href="#g:7">Stream oriented decoding</a></li></ul>
</li>
</ul>
</li>
<li><a href="#g:8">Encoding Text to ByteStrings</a></li>
<li><a href="#g:9">Encoding Text using ByteString Builders</a></li>
<li><a href="#g:10">ByteString validation</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>Functions for converting <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code> values to and from <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, using several standard encodings.</p>
<p>To gain access to a much larger family of encodings, use the <a href="http://hackage.haskell.org/package/text-icu">text-icu package</a>.</p>
</div>
<a href="#g:1" id="g:1"><h2>Decoding ByteStrings to Text</h2></a><p>All of the single-parameter functions for decoding bytestrings encoded in one of the Unicode Transformation Formats (UTF) operate in a <em>strict</em> mode: each will throw an exception if given invalid input.</p>
<p>Each function has a variant, whose name is suffixed with -<code class="inline-code">With</code>, that gives greater control over the handling of decoding errors. For instance, <code><a href="data-text-encoding.html#v:decodeUtf8" title="Data.Text.Encoding">decodeUtf8</a></code> will throw an exception, but <code><a href="data-text-encoding.html#v:decodeUtf8With" title="Data.Text.Encoding">decodeUtf8With</a></code> allows the programmer to determine what to do on a decoding error.</p>
<a href="#g:total" id="g:total"><h3>Total Functions </h3></a><p>These functions facilitate total decoding and should be preferred over their partial counterparts.</p>
<p class="src"><a id="v:decodeLatin1" class="def">decodeLatin1</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeLatin1" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing Latin-1 (aka ISO-8859-1) encoded text.</p>
<p><code><a href="data-text-encoding.html#v:decodeLatin1" title="Data.Text.Encoding">decodeLatin1</a></code> is semantically equivalent to <code class="inline-code">Data.Text.pack . Data.ByteString.Char8.unpack</code></p>
<p>This is a total function. However, bear in mind that decoding Latin-1 (non-ASCII) characters to UTf-8 requires actual work and is not just buffer copying.</p>
<p class="src"><a id="v:decodeASCIIPrefix" class="def">decodeASCIIPrefix</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-text.html#t:Text" title="Data.Text">Text</a>, <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeASCIIPrefix" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing ASCII text.</p>
<p>This is a total function which returns a pair of the longest ASCII prefix as <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code>, and the remaining suffix as <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>.</p>
<p>Important note: the pair is lazy. This lets you check for errors by testing whether the second component is empty, without forcing the first component (which does a copy). To drop references to the input bytestring, force the prefix (using <code><a href="../base-4.21.0.0-8e62/ghc-exts.html#v:seq" title="GHC.Exts">seq</a></code> or <code class="inline-code">BangPatterns</code>) and drop references to the suffix.</p>
<h4>Properties</h4>
<ul>
<li>If <code class="inline-code">(prefix, suffix) = decodeAsciiPrefix s</code>, then <code class="inline-code"><a href="data-text-encoding.html#v:encodeUtf8" title="Data.Text.Encoding">encodeUtf8</a> prefix &lt;&gt; suffix = s</code>.</li>
<li>Either <code class="inline-code">suffix</code> is empty, or <code class="inline-code"><a href="b.html#v:head" title="B">head</a> suffix &gt; 127</code>.</li>
</ul>
<p><span class="version">Since: text-2.0.2</span></p>
<p class="src"><a id="v:decodeUtf8Lenient" class="def">decodeUtf8Lenient</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf8Lenient" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text.</p>
<p>Any invalid input bytes will be replaced with the Unicode replacement character U+FFFD.</p>
<p><span class="version">Since: text-2.0</span></p>
<p class="src"><a id="v:decodeUtf8-39-" class="def">decodeUtf8'</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-either.html#t:Either" title="Data.Either">Either</a> <a href="data-text-encoding-error.html#t:UnicodeException" title="Data.Text.Encoding.Error">UnicodeException</a> <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf8%27" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text.</p>
<p>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</p>
<p class="src"><a id="v:decodeASCII-39-" class="def">decodeASCII'</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeASCII%27" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing 7-bit ASCII encoded text.</p>
<p>This is a total function which returns either the <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> converted to a <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code> containing ASCII text, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p>
<p>Use <code><a href="data-text-encoding.html#v:decodeASCIIPrefix" title="Data.Text.Encoding">decodeASCIIPrefix</a></code> to retain the longest ASCII prefix for an invalid input instead of discarding it.</p>
<p><span class="version">Since: text-2.0.2</span></p>
<a href="#g:3" id="g:3"><h4>Controllable error handling</h4></a><p class="src"><a id="v:decodeUtf8With" class="def">decodeUtf8With</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf8With" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text.</p>
<p>Surrogate code points in replacement character returned by <code><a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a></code> will be automatically remapped to the replacement char <code class="inline-code">U+FFFD</code>.</p>
<p class="src"><a id="v:decodeUtf16LEWith" class="def">decodeUtf16LEWith</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf16LEWith" class="link">Source</a> </p>
<p>Decode text from little endian UTF-16 encoding.</p>
<p class="src"><a id="v:decodeUtf16BEWith" class="def">decodeUtf16BEWith</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf16BEWith" class="link">Source</a> </p>
<p>Decode text from big endian UTF-16 encoding.</p>
<p class="src"><a id="v:decodeUtf32LEWith" class="def">decodeUtf32LEWith</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf32LEWith" class="link">Source</a> </p>
<p>Decode text from little endian UTF-32 encoding.</p>
<p class="src"><a id="v:decodeUtf32BEWith" class="def">decodeUtf32BEWith</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf32BEWith" class="link">Source</a> </p>
<p>Decode text from big endian UTF-32 encoding.</p>
<a href="#g:4" id="g:4"><h4>Stream oriented decoding</h4></a><p>The <code><a href="data-text-encoding.html#v:streamDecodeUtf8" title="Data.Text.Encoding">streamDecodeUtf8</a></code> and <code><a href="data-text-encoding.html#v:streamDecodeUtf8With" title="Data.Text.Encoding">streamDecodeUtf8With</a></code> functions accept a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</p>
<ol>
<li value="1">The maximal prefix of <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code> that could be decoded from the given input.</li>
<li value="2">The suffix of the <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> that could not be decoded due to insufficient input.</li>
<li value="3">A function that accepts another <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>. That string will be assumed to directly follow the string that was passed as input to the original function, and it will in turn be decoded.</li>
</ol>
<p>To help understand the use of these functions, consider the Unicode string <code class="inline-code">"hi ☃"</code>. If encoded as UTF-8, this becomes <code class="inline-code">"hi
 \xe2\x98\x83"</code>; the final <code class="inline-code">'☃'</code> is encoded as 3 bytes.</p>
<p>Now suppose that we receive this encoded string as 3 packets that are split up on untidy boundaries: <code class="inline-code">["hi \xe2", "\x98",
 "\x83"]</code>. We cannot decode the entire Unicode string until we have received all three packets, but we would like to make progress as we receive each one.</p>
<pre>ghci&gt; let s0@(<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> _ _ f0) = <a href="data-text-encoding.html#v:streamDecodeUtf8" title="Data.Text.Encoding">streamDecodeUtf8</a> "hi \xe2"
ghci&gt; s0
<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> "hi " "\xe2" _
</pre>
<p>We use the continuation <code class="inline-code">f0</code> to decode our second packet.</p>
<pre>ghci&gt; let s1@(<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> _ _ f1) = f0 "\x98"
ghci&gt; s1
<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> "" "\xe2\x98"
</pre>
<p>We could not give <code class="inline-code">f0</code> enough input to decode anything, so it returned an empty string. Once we feed our second continuation <code class="inline-code">f1</code> the last byte of input, it will make progress.</p>
<pre>ghci&gt; let s2@(<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> _ _ f2) = f1 "\x83"
ghci&gt; s2
<a href="data-text-encoding.html#v:Some" title="Data.Text.Encoding">Some</a> "\x2603" "" _
</pre>
<p>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</p>
<p class="src"><a id="v:streamDecodeUtf8With" class="def">streamDecodeUtf8With</a> :: <a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#streamDecodeUtf8With" class="link">Source</a> </p>
<p>Decode, in a stream oriented way, a lazy <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text.</p>
<p><span class="version">Since: text-1.0.0.0</span></p>
<p class="src">data <a id="t:Decoding" class="def">Decoding</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#Decoding" class="link">Source</a> </p>
<p>A stream oriented decoding result.</p>
<p><span class="version">Since: text-1.0.0.0</span></p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a id="v:Some" class="def">Some</a> !<a href="data-text.html#t:Text" title="Data.Text">Text</a> !<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> (<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a>)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:Decoding">Instances</h5>
<details id="i:Decoding" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#line-313" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Decoding:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-text-encoding.html">Data.Text.Encoding</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a> -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a>] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
</div></details></td></tr>
</table></details>
</div>
<a href="#g:5" id="g:5"><h4>Incremental UTF-8 decoding</h4></a><p>The functions <code><a href="data-text-encoding.html#v:decodeUtf8Chunk" title="Data.Text.Encoding">decodeUtf8Chunk</a></code> and <code><a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a></code> provide more control for error-handling and streaming.</p>
<ul>
<li>Those functions return an UTF-8 prefix of the given <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> up to the next error. For example this lets you insert or delete arbitrary text, or do some stateful operations before resuming, such as keeping track of error locations. In contrast, the older stream-oriented interface only lets you substitute a single fixed <code><a href="../base-4.21.0.0-8e62/data-char.html#t:Char" title="Data.Char">Char</a></code> for each invalid byte in <code><a href="data-text-encoding-error.html#t:OnDecodeError" title="Data.Text.Encoding.Error">OnDecodeError</a></code>.</li>
<li>That prefix is encoded as a <code><a href="data-text-encoding.html#t:StrictBuilder" title="Data.Text.Encoding">StrictBuilder</a></code>, so you can accumulate chunks before doing the copying work to construct a <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code>, or you can output decoded fragments immediately as a lazy <code><a href="data-text-lazy.html#v:Text" title="Data.Text.Lazy">Text</a></code>.</li>
</ul>
<p>For even lower-level primitives, see <code><a href="data-text-encoding.html#v:validateUtf8Chunk" title="Data.Text.Encoding">validateUtf8Chunk</a></code> and <code><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a></code>.</p>
<p class="src"><a id="v:decodeUtf8Chunk" class="def">decodeUtf8Chunk</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a>, <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#decodeUtf8Chunk" class="link">Source</a> </p>
<p>Decode a chunk of UTF-8 text. To be continued with <code><a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a></code>.</p>
<p>See <code><a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a></code> for details on the result.</p>
<h4>Properties</h4>
<pre><a href="data-text-encoding.html#v:decodeUtf8Chunk" title="Data.Text.Encoding">decodeUtf8Chunk</a> = <a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a> <a href="data-text-encoding.html#v:startUtf8State" title="Data.Text.Encoding">startUtf8State</a>
</pre>
<p>Given:</p>
<pre><a href="data-text-encoding.html#v:decodeUtf8Chunk" title="Data.Text.Encoding">decodeUtf8Chunk</a> chunk = (builder, rest, ms)
</pre>
<p><code class="inline-code">builder</code> is a prefix and <code class="inline-code">rest</code> is a suffix of <code class="inline-code">chunk</code>.</p>
<pre><a href="data-text-encoding.html#v:encodeUtf8" title="Data.Text.Encoding">encodeUtf8</a> (<a href="data-text-encoding.html#v:strictBuilderToText" title="Data.Text.Encoding">strictBuilderToText</a> builder) <a href="../base-4.21.0.0-8e62/data-monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a> rest = chunk
</pre>
<p><span class="version">Since: text-2.0.2</span></p>
<p class="src"><a id="v:decodeUtf8More" class="def">decodeUtf8More</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a>, <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#decodeUtf8More" class="link">Source</a> </p>
<p>Decode another chunk in an ongoing UTF-8 stream.</p>
<p>Returns a triple:</p>
<ol>
<li value="1">A <code><a href="data-text-encoding.html#t:StrictBuilder" title="Data.Text.Encoding">StrictBuilder</a></code> for the decoded chunk of text. You can accumulate chunks with <code class="inline-code">(<a href="../base-4.21.0.0-8e62/data-monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a>)</code> or output them with <code><a href="sb.html#v:toText" title="SB">toText</a></code>.</li>
<li value="2">The undecoded remainder of the given chunk, for diagnosing errors and resuming (presumably after skipping some bytes).</li>
<li value="3">
<code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the new state, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if an invalid byte was encountered (it will be within the first 4 bytes of the undecoded remainder).</li>
</ol>
<h4>Properties</h4>
<p>Given:</p>
<pre>(pre, suf, ms) = <a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a> s chunk
</pre>
<ol>
<li value="1">
<p>If the output <code class="inline-code">pre</code> is nonempty (alternatively, if <code class="inline-code">length chunk &gt; length suf</code>)</p>
<pre>s2b pre `<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#v:append" title="Data.ByteString">append</a>` suf = p2b s `<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#v:append" title="Data.ByteString">append</a>` chunk
</pre>
<p>where</p>
<pre>s2b = <a href="data-text-encoding.html#v:encodeUtf8" title="Data.Text.Encoding">encodeUtf8</a> . <a href="data-text-encoding.html#v:toText" title="Data.Text.Encoding">toText</a>
p2b = <a href="data-text-internal-encoding.html#v:partUtf8ToByteString" title="Data.Text.Internal.Encoding">partUtf8ToByteString</a>
</pre>
</li>
<li value="2">
<p>If the output <code class="inline-code">pre</code> is empty (alternatively, if <code class="inline-code">length chunk = length suf</code>)</p>
<pre>suf = chunk</pre>
</li>
<li value="3">
<p>Decoding chunks separately is equivalent to decoding their concatenation.</p>
<p>Given:</p>
<pre>(pre1, suf1, Just s1) = <a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a> s chunk1
(pre2, suf2,     ms2) = <a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a> s1 chunk2
(pre3, suf3,     ms3) = <a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a> s (chunk1 `B.append` chunk2)
</pre>
<p>we have:</p>
<pre>s2b (pre1 <a href="../base-4.21.0.0-8e62/data-monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a> pre2) = s2b pre3
ms2 = ms3
</pre>
</li>
</ol>
<p class="src">data <a id="t:Utf8State" class="def">Utf8State</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#Utf8State" class="link">Source</a> </p>
<p>State of decoding a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> in UTF-8. Enables incremental decoding (<code><a href="data-text-encoding.html#v:validateUtf8Chunk" title="Data.Text.Encoding">validateUtf8Chunk</a></code>, <code><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a></code>, <code><a href="data-text-encoding.html#v:decodeUtf8Chunk" title="Data.Text.Encoding">decodeUtf8Chunk</a></code>, <code><a href="data-text-encoding.html#v:decodeUtf8More" title="Data.Text.Encoding">decodeUtf8More</a></code>).</p>
<p><span class="version">Since: text-2.0.2</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:Utf8State">Instances</h5>
<details id="i:Utf8State" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#line-106" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Utf8State:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-text-internal-encoding.html">Data.Text.Internal.Encoding</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a>] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#line-106" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Utf8State:Eq:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-text-internal-encoding.html">Data.Text.Internal.Encoding</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%3D%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/ghc-prim-0.13.0-4caa/src/GHC.Classes.html#%2F%3D" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src"><a id="v:startUtf8State" class="def">startUtf8State</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#startUtf8State" class="link">Source</a> </p>
<p>Initial <code><a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a></code>.</p>
<p><span class="version">Since: text-2.0.2</span></p>
<p class="src">type <a id="t:StrictBuilder" class="def">StrictBuilder</a> = <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.StrictBuilder.html#StrictBuilder" class="link">Source</a> </p>
<div class="warning"><p>Deprecated: Use StrictTextBuilder instead</p></div>
<p>A delayed representation of strict <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code>.</p>
<p><span class="version">Since: text-2.0.2</span></p>
<p class="src">data <a id="t:StrictTextBuilder" class="def">StrictTextBuilder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.StrictBuilder.html#StrictTextBuilder" class="link">Source</a> </p>
<p>A delayed representation of strict <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code>.</p>
<p><span class="version">Since: text-2.1.2</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:StrictTextBuilder">Instances</h5>
<details id="i:StrictTextBuilder" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.StrictBuilder.html#line-77" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:StrictTextBuilder:Monoid:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-text-internal-strictbuilder.html">Data.Text.Internal.StrictBuilder</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mempty">mempty</a> :: <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
<p class="src"><a href="#v:mappend">mappend</a> :: <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
<p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a>] -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.StrictBuilder.html#line-74" class="link">Source</a> </td>
<td class="doc"><p>Concatenation of <code><a href="data-text-encoding.html#t:StrictBuilder" title="Data.Text.Encoding">StrictBuilder</a></code> is right-biased: the right builder will be run first. This allows a builder to run tail-recursively when it was accumulated left-to-right.</p></td>
</tr>
<tr><td colspan="2"><details id="i:id:StrictTextBuilder:Semigroup:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="data-text-internal-strictbuilder.html">Data.Text.Internal.StrictBuilder</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
<p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
<p class="src"><a href="#v:stimes">stimes</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src"><a id="v:strictBuilderToText" class="def">strictBuilderToText</a> :: <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#strictBuilderToText" class="link">Source</a> </p>
<p>Use <code><a href="data-text-encoding.html#t:StrictBuilder" title="Data.Text.Encoding">StrictBuilder</a></code> to build <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code>.</p>
<p><span class="version">Since: text-2.0.2</span></p>
<p class="src"><a id="v:textToStrictBuilder" class="def">textToStrictBuilder</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="data-text-encoding.html#t:StrictTextBuilder" title="Data.Text.Encoding">StrictTextBuilder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#textToStrictBuilder" class="link">Source</a> </p>
<p>Copy <code><a href="data-text.html#t:Text" title="Data.Text">Text</a></code> in a <code><a href="data-text-encoding.html#t:StrictBuilder" title="Data.Text.Encoding">StrictBuilder</a></code></p>
<p><span class="version">Since: text-2.0.2</span></p>
<a href="#g:6" id="g:6"><h3>Partial Functions</h3></a><p>These functions are partial and should only be used with great caution (preferably not at all). See <a href="data-text-encoding.html#g:total">Data.Text.Encoding</a> for better solutions.</p>
<p class="src"><a id="v:decodeASCII" class="def">decodeASCII</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeASCII" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing 7-bit ASCII encoded text.</p>
<p>This is a partial function: it checks that input does not contain anything except ASCII and copies buffer or throws an error otherwise.</p>
<p class="src"><a id="v:decodeUtf8" class="def">decodeUtf8</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf8" class="link">Source</a> </p>
<p>Decode a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text that is known to be valid.</p>
<p>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:decodeUtf8-39-" title="Data.Text.Encoding">decodeUtf8'</a></code> or <code><a href="data-text-encoding.html#v:decodeUtf8With" title="Data.Text.Encoding">decodeUtf8With</a></code>.</p>
<p>This is a partial function: it checks that input is a well-formed UTF-8 sequence and copies buffer or throws an error otherwise.</p>
<p class="src"><a id="v:decodeUtf16LE" class="def">decodeUtf16LE</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf16LE" class="link">Source</a> </p>
<p>Decode text from little endian UTF-16 encoding.</p>
<p>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:decodeUtf16LEWith" title="Data.Text.Encoding">decodeUtf16LEWith</a></code>.</p>
<p class="src"><a id="v:decodeUtf16BE" class="def">decodeUtf16BE</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf16BE" class="link">Source</a> </p>
<p>Decode text from big endian UTF-16 encoding.</p>
<p>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:decodeUtf16BEWith" title="Data.Text.Encoding">decodeUtf16BEWith</a></code>.</p>
<p class="src"><a id="v:decodeUtf32LE" class="def">decodeUtf32LE</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf32LE" class="link">Source</a> </p>
<p>Decode text from little endian UTF-32 encoding.</p>
<p>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:decodeUtf32LEWith" title="Data.Text.Encoding">decodeUtf32LEWith</a></code>.</p>
<p class="src"><a id="v:decodeUtf32BE" class="def">decodeUtf32BE</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#decodeUtf32BE" class="link">Source</a> </p>
<p>Decode text from big endian UTF-32 encoding.</p>
<p>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:decodeUtf32BEWith" title="Data.Text.Encoding">decodeUtf32BEWith</a></code>.</p>
<a href="#g:7" id="g:7"><h4>Stream oriented decoding</h4></a><p class="src"><a id="v:streamDecodeUtf8" class="def">streamDecodeUtf8</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="data-text-encoding.html#t:Decoding" title="Data.Text.Encoding">Decoding</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#streamDecodeUtf8" class="link">Source</a> </p>
<p>Decode, in a stream oriented way, a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> containing UTF-8 encoded text that is known to be valid.</p>
<p>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use <code><a href="data-text-encoding.html#v:streamDecodeUtf8With" title="Data.Text.Encoding">streamDecodeUtf8With</a></code>.</p>
<p><span class="version">Since: text-1.0.0.0</span></p>
<a href="#g:8" id="g:8"><h2>Encoding Text to ByteStrings</h2></a><p class="src"><a id="v:encodeUtf8" class="def">encodeUtf8</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf8" class="link">Source</a> </p>
<p>Encode text using UTF-8 encoding.</p>
<p class="src"><a id="v:encodeUtf16LE" class="def">encodeUtf16LE</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf16LE" class="link">Source</a> </p>
<p>Encode text using little endian UTF-16 encoding.</p>
<p class="src"><a id="v:encodeUtf16BE" class="def">encodeUtf16BE</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf16BE" class="link">Source</a> </p>
<p>Encode text using big endian UTF-16 encoding.</p>
<p class="src"><a id="v:encodeUtf32LE" class="def">encodeUtf32LE</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf32LE" class="link">Source</a> </p>
<p>Encode text using little endian UTF-32 encoding.</p>
<p class="src"><a id="v:encodeUtf32BE" class="def">encodeUtf32BE</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf32BE" class="link">Source</a> </p>
<p>Encode text using big endian UTF-32 encoding.</p>
<a href="#g:9" id="g:9"><h2>Encoding Text using ByteString Builders</h2></a><p class="src"><a id="v:encodeUtf8Builder" class="def">encodeUtf8Builder</a> :: <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../binary-0.8.9.2-5d9d/data-binary-builder.html#t:Builder" title="Data.Binary.Builder">Builder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf8Builder" class="link">Source</a> </p>
<p>Encode text to a ByteString <code><a href="b.html#v:Builder" title="B">Builder</a></code> using UTF-8 encoding.</p>
<p><span class="version">Since: text-1.1.0.0</span></p>
<p class="src"><a id="v:encodeUtf8BuilderEscaped" class="def">encodeUtf8BuilderEscaped</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring-builder-prim.html#t:BoundedPrim" title="Data.ByteString.Builder.Prim">BoundedPrim</a> <a href="../base-4.21.0.0-8e62/data-word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="data-text.html#t:Text" title="Data.Text">Text</a> -&gt; <a href="../binary-0.8.9.2-5d9d/data-binary-builder.html#t:Builder" title="Data.Binary.Builder">Builder</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Encoding.html#encodeUtf8BuilderEscaped" class="link">Source</a> </p>
<p>Encode text using UTF-8 encoding and escape the ASCII characters using a <code><a href="bp.html#v:BoundedPrim" title="BP">BoundedPrim</a></code>.</p>
<p>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</p>
<p><span class="version">Since: text-1.1.0.0</span></p>
<a href="#g:10" id="g:10"><h2>ByteString validation</h2></a><p>These functions are for validating <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s as encoded text.</p>
<p class="src"><a id="v:validateUtf8Chunk" class="def">validateUtf8Chunk</a> :: <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a>, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#validateUtf8Chunk" class="link">Source</a> </p>
<p>Validate a <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> as UTF-8-encoded text. To be continued using <code><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a></code>.</p>
<p>See also <code><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a></code> for details on the result of this function.</p>
<pre><a href="data-text-encoding.html#v:validateUtf8Chunk" title="Data.Text.Encoding">validateUtf8Chunk</a> = <a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a> <a href="data-text-encoding.html#v:startUtf8State" title="Data.Text.Encoding">startUtf8State</a>
</pre>
<h4>Properties</h4>
<p>Given:</p>
<pre><a href="data-text-encoding.html#v:validateUtf8Chunk" title="Data.Text.Encoding">validateUtf8Chunk</a> chunk = (n, ms)
</pre>
<ul><li>
<p>The prefix is valid UTF-8. In particular, it should be accepted by this validation:</p>
<pre><a href="data-text-encoding.html#v:validateUtf8Chunk" title="Data.Text.Encoding">validateUtf8Chunk</a> (<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#v:take" title="Data.ByteString">take</a> n chunk) = (n, Just <a href="data-text-encoding.html#v:startUtf8State" title="Data.Text.Encoding">startUtf8State</a>)
</pre>
</li></ul>
<p class="src"><a id="v:validateUtf8More" class="def">validateUtf8More</a> :: <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a> -&gt; <a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a>, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-text-encoding.html#t:Utf8State" title="Data.Text.Encoding">Utf8State</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/src/Data.Text.Internal.Encoding.html#validateUtf8More" class="link">Source</a> </p>
<p>Validate another <code><a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#t:ByteString" title="Data.ByteString">ByteString</a></code> chunk in an ongoing stream of UTF-8-encoded text.</p>
<p>Returns a pair:</p>
<ol>
<li value="1">The first component <code class="inline-code">n</code> is the end position, relative to the current chunk, of the longest prefix of the accumulated bytestring which is valid UTF-8. <code class="inline-code">n</code> may be negative: that happens when an incomplete code point started in a previous chunk and is not completed by the current chunk (either that code point is still incomplete, or it is broken by an invalid byte).</li>
<li value="2">
<p>The second component <code class="inline-code">ms</code> indicates the following:</p>
<ul>
<li>if <code class="inline-code">ms = Nothing</code>, the remainder of the chunk contains an invalid byte, within four bytes from position <code class="inline-code">n</code>;</li>
<li>if <code class="inline-code">ms = Just s'</code>, you can carry on validating another chunk by calling <code><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a></code> with the new state <code class="inline-code">s'</code>.</li>
</ul>
</li>
</ol>
<h4>Properties</h4>
<p>Given:</p>
<pre><a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a> s chunk = (n, ms)
</pre>
<ul>
<li>
<p>If the chunk is invalid, it cannot be extended to be valid.</p>
<pre>ms = Nothing
==&gt; <a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a> s (chunk <a href="../base-4.21.0.0-8e62/data-monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a> more) = (n, Nothing)
</pre>
</li>
<li>
<p>Validating two chunks sequentially is the same as validating them together at once:</p>
<pre>ms = Just s'
==&gt; <a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a> s (chunk <a href="../base-4.21.0.0-8e62/data-monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a> more) = <a href="../base-4.21.0.0-8e62/data-bifunctor.html#v:first" title="Data.Bifunctor">first</a> (<a href="../bytestring-0.12.2.0-2f68/data-bytestring.html#v:length" title="Data.ByteString">length</a> chunk <a href="../base-4.21.0.0-8e62/prelude.html#v:-43-" title="Prelude">+</a>) (<a href="data-text-encoding.html#v:validateUtf8More" title="Data.Text.Encoding">validateUtf8More</a> s' more)
</pre>
</li>
</ul>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/Data-Text-Encoding.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/text-2.1.2-84f9/Data-Text-Encoding.html</a>
  </p>
</div>
