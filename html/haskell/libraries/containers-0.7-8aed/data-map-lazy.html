<h1 class="caption">Data.Map.Lazy</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) Daan Leijen 2002<br>(c) Andriy Palamarchuk 2008</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Map type</a></li>
<li>
<a href="#g:2">Construction</a><ul>
<li><a href="#g:3">From Unordered Lists</a></li>
<li><a href="#g:4">From Ascending Lists</a></li>
<li><a href="#g:5">From Descending Lists</a></li>
</ul>
</li>
<li><a href="#g:6">Insertion</a></li>
<li><a href="#g:7">Deletion/Update</a></li>
<li>
<a href="#g:8">Query</a><ul>
<li><a href="#g:9">Lookup</a></li>
<li><a href="#g:10">Size</a></li>
</ul>
</li>
<li>
<a href="#g:11">Combine</a><ul>
<li><a href="#g:12">Union</a></li>
<li><a href="#g:13">Difference</a></li>
<li><a href="#g:14">Intersection</a></li>
<li><a href="#g:15">Disjoint</a></li>
<li><a href="#g:16">Compose</a></li>
<li><a href="#g:17">General combining functions</a></li>
<li><a href="#g:18">Unsafe general combining function</a></li>
</ul>
</li>
<li>
<a href="#g:19">Traversal</a><ul><li><a href="#g:20">Map</a></li></ul>
</li>
<li>
<a href="#g:21">Folds</a><ul><li><a href="#g:22">Strict folds</a></li></ul>
</li>
<li>
<a href="#g:23">Conversion</a><ul>
<li><a href="#g:24">Lists</a></li>
<li><a href="#g:25">Ordered lists</a></li>
</ul>
</li>
<li><a href="#g:26">Filter</a></li>
<li><a href="#g:27">Submap</a></li>
<li><a href="#g:28">Indexed</a></li>
<li><a href="#g:29">Min/Max</a></li>
<li><a href="#g:30">Debugging</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<h2>Finite Maps (lazy interface)</h2>
<p>The <code class="inline-code"><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v</code> type represents a finite map (sometimes called a dictionary) from keys of type <code class="inline-code">k</code> to values of type <code class="inline-code">v</code>. A <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code> is strict in its keys but lazy in its values.</p>
<p>The functions in <a href="data-map-strict.html">Data.Map.Strict</a> are careful to force values before installing them in a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</p>
<p>When deciding if this is the correct data structure to use, consider:</p>
<ul>
<li>If you are using <code><a href="../base-4.21.0.0-8e62/prelude.html#v:Int" title="Prelude">Int</a></code> keys, you will get much better performance for most operations using <a href="data-intmap-lazy.html">Data.IntMap.Lazy</a>.</li>
<li>If you don't care about ordering, consider using <code class="inline-code">Data.HashMap.Lazy</code> from the <a href="https://hackage.haskell.org/package/unordered-containers">unordered-containers</a> package instead.</li>
</ul>
<p>For a walkthrough of the most commonly used functions see the <a href="https://haskell-containers.readthedocs.io/en/latest/map.html">maps introduction</a>.</p>
<p>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</p>
<pre>import qualified Data.Map.Lazy as Map</pre>
<p>Note that the implementation is generally <em>left-biased</em>. Functions that take two maps as arguments and combine them, such as <code><a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a></code> and <code><a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">intersection</a></code>, prefer the values in the first argument to those in the second.</p>
<h3>Detailed performance information</h3>
<p>The amortized running time is given for each operation, with <span class="mathjax">\(n\)</span> referring to the number of entries in the map.</p>
<p>Benchmarks comparing <a href="data-map-lazy.html">Data.Map.Lazy</a> with other dictionary implementations can be found at <a href="https://github.com/haskell-perf/dictionaries">https://github.com/haskell-perf/dictionaries</a>.</p>
<h3>Warning</h3>
<p>The size of a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code> must not exceed <code class="inline-code"><a href="../base-4.21.0.0-8e62/prelude.html#v:maxBound" title="Prelude">maxBound</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#v:Int" title="Prelude">Int</a></code>. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</p>
<h3>Implementation</h3>
<p>The implementation of <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code> is based on <em>size balanced</em> binary trees (or trees of <em>bounded balance</em>) as described by:</p>
<ul>
<li>Stephen Adams, "<em>Efficient sets: a balancing act</em>", Journal of Functional Programming 3(4):553-562, October 1993, <a href="http://www.swiss.ai.mit.edu/~adams/BB/">http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li>
<li>J. Nievergelt and E.M. Reingold, "<em>Binary search trees of bounded balance</em>", SIAM journal of computing 2(1), March 1973.</li>
</ul>
<p>Bounds for <code><a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a></code>, <code><a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">intersection</a></code>, and <code><a href="data-map-lazy.html#v:difference" title="Data.Map.Lazy">difference</a></code> are as given by</p>
<ul><li>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, "<em>Just Join for Parallel Ordered Sets</em>", <a href="https://arxiv.org/abs/1602.02120v3">https://arxiv.org/abs/1602.02120v3</a>.</li></ul>
</div>
<a href="#g:1" id="g:1"><h2>Map type</h2></a><p class="src">data <a id="t:Map" class="def">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#Map" class="link">Source</a> </p>
<p>A Map from keys <code class="inline-code">k</code> to values <code class="inline-code">a</code>.</p>
<p>The <code><a href="../base-4.21.0.0-8e62/prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code> operation for <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code> is <code><a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a></code>, which prefers values from the left operand. If <code class="inline-code">m1</code> maps a key <code class="inline-code">k</code> to a value <code class="inline-code">a1</code>, and <code class="inline-code">m2</code> maps the same key to a different value <code class="inline-code">a2</code>, then their union <code class="inline-code">m1 &lt;&gt; m2</code> maps <code class="inline-code">k</code> to <code class="inline-code">a1</code>.</p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:Map">Instances</h5>
<details id="i:Map" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-bifoldable.html#t:Bifoldable" title="Data.Bifoldable">Bifoldable</a> <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4342" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.6.3.1</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Bifoldable:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:bifold">bifold</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> m m -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifold" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldMap">bifoldMap</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldMap" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldr">bifoldr</a> :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldr" class="link">Source</a> </p>
<p class="src"><a href="#v:bifoldl">bifoldl</a> :: (c -&gt; a -&gt; c) -&gt; (c -&gt; b -&gt; c) -&gt; c -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b -&gt; c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Bifoldable.html#bifoldl" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Eq2" title="Data.Functor.Classes">Eq2</a> <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4240" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Eq2:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftEq2">liftEq2</a> :: (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (c -&gt; d -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a c -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> b d -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftEq2" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Ord2" title="Data.Functor.Classes">Ord2</a> <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4249" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Ord2:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftCompare2">liftCompare2</a> :: (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; (c -&gt; d -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a c -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> b d -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftCompare2" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Show2" title="Data.Functor.Classes">Show2</a> <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4258" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Show2:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftShowsPrec2">liftShowsPrec2</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([b] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowsPrec2" class="link">Source</a> </p>
<p class="src"><a href="#v:liftShowList2">liftShowList2</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([b] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowList2" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> k, <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> a) =&gt; <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-481" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.6.6</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Lift:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:lift">lift</a> :: <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> </p>
<p class="src"><a href="#v:liftTyped">liftTyped</a> :: forall (m :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>). <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../template-haskell-2.23.0.0-22c1/language-haskell-th-syntax.html#t:Code" title="Language.Haskell.TH.Syntax">Code</a> m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Eq1" title="Data.Functor.Classes">Eq1</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4245" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Eq1:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftEq">liftEq</a> :: (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftEq" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Ord1" title="Data.Functor.Classes">Ord1</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4254" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Ord1:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftCompare">liftCompare</a> :: (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftCompare" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> k) =&gt; <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Read1" title="Data.Functor.Classes">Read1</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4270" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Read1:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftReadsPrec">liftReadsPrec</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> a) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadList">liftReadList</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> a) -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadList" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadPrec">liftReadPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> a -&gt; <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] -&gt; <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftReadListPrec">liftReadListPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> a -&gt; <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [a] -&gt; <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftReadListPrec" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> k =&gt; <a href="../base-4.21.0.0-8e62/data-functor-classes.html#t:Show1" title="Data.Functor.Classes">Show1</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4266" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Show1:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:liftShowsPrec">liftShowsPrec</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:liftShowList">liftShowList</a> :: (<a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; ([a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a>) -&gt; [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/base-4.21.0.0-8e62/src/Data.Functor.Classes.html#liftShowList" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4280" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Functor:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4293" class="link">Source</a> </td>
<td class="doc"><p>Folds in order of increasing key.</p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Foldable:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fold">fold</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k m -&gt; m </p>
<p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m </p>
<p class="src"><a href="#v:foldMap-39-">foldMap'</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m </p>
<p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b </p>
<p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b </p>
<p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b </p>
<p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b </p>
<p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
<p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
<p class="src"><a href="#v:toList">toList</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [a] </p>
<p class="src"><a href="#v:null">null</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:length">length</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> </p>
<p class="src"><a href="#v:elem">elem</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:maximum">maximum</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
<p class="src"><a href="#v:minimum">minimum</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
<p class="src"><a href="#v:sum">sum</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
<p class="src"><a href="#v:product">product</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4288" class="link">Source</a> </td>
<td class="doc"><p>Traverses in order of increasing key.</p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Traversable:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:traverse">traverse</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b) </p>
<p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k (f a) -&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
<p class="src"><a href="#v:mapM">mapM</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b) </p>
<p class="src"><a href="#v:sequence">sequence</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k (m a) -&gt; m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../deepseq-1.5.1.0-18b1/control-deepseq.html#t:NFData" title="Control.DeepSeq">NFData</a> k, <a href="../deepseq-1.5.1.0-18b1/control-deepseq.html#t:NFData" title="Control.DeepSeq">NFData</a> a) =&gt; <a href="../deepseq-1.5.1.0-18b1/control-deepseq.html#t:NFData" title="Control.DeepSeq">NFData</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4362" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:NFData:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:rnf">rnf</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; () <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/deepseq-1.5.1.0-18b1/src/Control.DeepSeq.html#rnf" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-484" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Monoid:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:mempty">mempty</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:mappend">mappend</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:Semigroup" title="Prelude">Semigroup</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-489" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Semigroup:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="../base-4.21.0.0-8e62/data-list-nonempty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:stimes">stimes</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> k, <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> a, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-502" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Data:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:gfoldl">gfoldl</a> :: (forall d b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (d -&gt; b) -&gt; d -&gt; c b) -&gt; (forall g. g -&gt; c g) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; c (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
<p class="src"><a href="#v:gunfold">gunfold</a> :: (forall b r. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; c (b -&gt; r) -&gt; c r) -&gt; (forall r. r -&gt; c r) -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> -&gt; c (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
<p class="src"><a href="#v:toConstr">toConstr</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:Constr" title="Data.Data">Constr</a> </p>
<p class="src"><a href="#v:dataTypeOf">dataTypeOf</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-data.html#t:DataType" title="Data.Data">DataType</a> </p>
<p class="src"><a href="#v:dataCast1">dataCast1</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; c (t d)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a)) </p>
<p class="src"><a href="#v:dataCast2">dataCast2</a> :: <a href="../base-4.21.0.0-8e62/data-dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> t =&gt; (forall d e. (<a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d, <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> e) =&gt; c (t d e)) -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a)) </p>
<p class="src"><a href="#v:gmapT">gmapT</a> :: (forall b. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> b =&gt; b -&gt; b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a </p>
<p class="src"><a href="#v:gmapQl">gmapQl</a> :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; r </p>
<p class="src"><a href="#v:gmapQr">gmapQr</a> :: forall r r'. (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; r') -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; r </p>
<p class="src"><a href="#v:gmapQ">gmapQ</a> :: (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [u] </p>
<p class="src"><a href="#v:gmapQi">gmapQi</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; u) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; u </p>
<p class="src"><a href="#v:gmapM">gmapM</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
<p class="src"><a href="#v:gmapMp">gmapMp</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
<p class="src"><a href="#v:gmapMo">gmapMo</a> :: <a href="../base-4.21.0.0-8e62/control-monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; (forall d. <a href="../base-4.21.0.0-8e62/data-data.html#t:Data" title="Data.Data">Data</a> d =&gt; d -&gt; m d) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:IsList" title="GHC.Exts">IsList</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-3425" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.6.2</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:IsList:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs associated-types">
<h4 class="caption">Associated Types</h4>
<table>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v)</td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:if:D:R:ItemMap:Item:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) = (k, v)</div></details></td></tr>
</table>
</div> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fromList">fromList</a> :: [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:toList">toList</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; [<a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v)] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> k, <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> e) =&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:Read" title="Prelude">Read</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k e) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4369" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Read:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k e) </p>
<p class="src"><a href="#v:readList">readList</a> :: <a href="../base-4.21.0.0-8e62/prelude.html#t:ReadS" title="Prelude">ReadS</a> [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k e] </p>
<p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k e) </p>
<p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="../base-4.21.0.0-8e62/text-parsercombinators-readprec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k e] </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> k, <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> a) =&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:Show" title="Prelude">Show</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4387" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Show:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a] -&gt; <a href="../base-4.21.0.0-8e62/prelude.html#t:ShowS" title="Prelude">ShowS</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k, <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4225" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Eq:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> v) =&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-4232" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Ord:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:compare">compare</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ordering" title="Data.Ord">Ordering</a> </p>
<p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> </p>
<p class="src"><a href="#v:max">max</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
<p class="src"><a href="#v:min">min</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-3426" class="link">Source</a> </td>
<td class="doc empty"> </td>
</tr>
<tr><td colspan="2"><details id="i:id:Map:Item:22"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="src">type <a href="../base-4.21.0.0-8e62/ghc-exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v) = (k, v)</div></details></td></tr>
</table></details>
</div>
<a href="#g:2" id="g:2"><h2>Construction</h2></a><p class="src"><a id="v:empty" class="def">empty</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#empty" class="link">Source</a> </p>
<p><span class="mathjax">\(O(1)\)</span>. The empty map.</p>
<pre>empty      == fromList []
size empty == 0</pre>
<p class="src"><a id="v:singleton" class="def">singleton</a> :: k -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#singleton" class="link">Source</a> </p>
<p><span class="mathjax">\(O(1)\)</span>. A map with a single element.</p>
<pre>singleton 1 'a'        == fromList [(1, 'a')]
size (singleton 1 'a') == 1</pre>
<p class="src"><a id="v:fromSet" class="def">fromSet</a> :: (k -&gt; a) -&gt; <a href="data-set.html#t:Set" title="Data.Set">Set</a> k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromSet" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a set of keys and a function which for each key computes its value.</p>
<pre>fromSet (\k -&gt; replicate k 'a') (Data.Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
fromSet undefined Data.Set.empty == empty</pre>
<p class="src"><a id="v:fromArgSet" class="def">fromArgSet</a> :: <a href="data-set.html#t:Set" title="Data.Set">Set</a> (<a href="../base-4.21.0.0-8e62/data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> k a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromArgSet" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a set of elements contained inside <code><a href="../base-4.21.0.0-8e62/data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a></code>s.</p>
<pre>fromArgSet (Data.Set.fromList [Arg 3 "aaa", Arg 5 "aaaaa"]) == fromList [(5,"aaaaa"), (3,"aaa")]
fromArgSet Data.Set.empty == empty</pre>
<a href="#g:3" id="g:3"><h3>From Unordered Lists</h3></a><p class="src"><a id="v:fromList" class="def">fromList</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n \log n)\)</span>. Build a map from a list of key/value pairs. See also <code><a href="data-map-lazy.html#v:fromAscList" title="Data.Map.Lazy">fromAscList</a></code>. If the list contains more than one value for the same key, the last value for the key is retained.</p>
<p>If the keys of the list are ordered, a linear-time implementation is used.</p>
<pre>fromList [] == empty
fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]</pre>
<p class="src"><a id="v:fromListWith" class="def">fromListWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromListWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n \log n)\)</span>. Build a map from a list of key/value pairs with a combining function. See also <code><a href="data-map-lazy.html#v:fromAscListWith" title="Data.Map.Lazy">fromAscListWith</a></code>.</p>
<pre>fromListWith (++) [(5,"a"), (5,"b"), (3,"x"), (5,"c")] == fromList [(3, "x"), (5, "cba")]
fromListWith (++) [] == empty</pre>
<p>Note the reverse ordering of <code class="inline-code">"cba"</code> in the example.</p>
<p>The symmetric combining function <code class="inline-code">f</code> is applied in a left-fold over the list, as <code class="inline-code">f new old</code>.</p>
<h4>Performance</h4>
<p>You should ensure that the given <code class="inline-code">f</code> is fast with this order of arguments.</p>
<p>Symmetric functions may be slow in one order, and fast in another. For the common case of collecting values of matching keys in a list, as above:</p>
<p>The complexity of <code class="inline-code">(++) a b</code> is <span class="mathjax">\(O(a)\)</span>, so it is fast when given a short list as its first argument. Thus:</p>
<pre>fromListWith       (++)  (replicate 1000000 (3, "x"))   -- O(n),  fast
fromListWith (flip (++)) (replicate 1000000 (3, "x"))   -- O(n), extremely slow</pre>
<p>because they evaluate as, respectively:</p>
<pre>fromList [(3, "x" ++ ("x" ++ "xxxxx..xxxxx"))]   -- O(n)
fromList [(3, ("xxxxx..xxxxx" ++ "x") ++ "x")]   -- O(n)</pre>
<p>Thus, to get good performance with an operation like <code class="inline-code">(++)</code> while also preserving the same order as in the input list, reverse the input:</p>
<pre>fromListWith (++) (reverse [(5,"a"), (5,"b"), (5,"c")]) == fromList [(5, "abc")]</pre>
<p>and it is always fast to combine singleton-list values <code class="inline-code">[v]</code> with <code class="inline-code">fromListWith (++)</code>, as in:</p>
<pre>fromListWith (++) $ reverse $ map (\(k, v) -&gt; (k, [v])) someListOfTuples</pre>
<p class="src"><a id="v:fromListWithKey" class="def">fromListWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromListWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n \log n)\)</span>. Build a map from a list of key/value pairs with a combining function. See also <code><a href="data-map-lazy.html#v:fromAscListWithKey" title="Data.Map.Lazy">fromAscListWithKey</a></code>.</p>
<pre>let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
fromListWithKey f [] == empty</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<a href="#g:4" id="g:4"><h3>From Ascending Lists</h3></a><p class="src"><a id="v:fromAscList" class="def">fromAscList</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromAscList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from an ascending list in linear time. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True
valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p class="src"><a id="v:fromAscListWith" class="def">fromAscListWith</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromAscListWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from an ascending list in linear time with a combining function for equal keys. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True
valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p class="src"><a id="v:fromAscListWithKey" class="def">fromAscListWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromAscListWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from an ascending list in linear time with a combining function for equal keys. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True
valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:fromDistinctAscList" class="def">fromDistinctAscList</a> :: [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromDistinctAscList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from an ascending list of distinct elements in linear time. <em>The precondition is not checked.</em></p>
<pre>fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True
valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False</pre>
<a href="#g:5" id="g:5"><h3>From Descending Lists</h3></a><p class="src"><a id="v:fromDescList" class="def">fromDescList</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromDescList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a descending list in linear time. <em>The precondition (input list is descending) is not checked.</em></p>
<pre>fromDescList [(5,"a"), (3,"b")]          == fromList [(3, "b"), (5, "a")]
fromDescList [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "b")]
valid (fromDescList [(5,"a"), (5,"b"), (3,"b")]) == True
valid (fromDescList [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:fromDescListWith" class="def">fromDescListWith</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromDescListWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a descending list in linear time with a combining function for equal keys. <em>The precondition (input list is descending) is not checked.</em></p>
<pre>fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "ba")]
valid (fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")]) == True
valid (fromDescListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:fromDescListWithKey" class="def">fromDescListWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromDescListWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a descending list in linear time with a combining function for equal keys. <em>The precondition (input list is descending) is not checked.</em></p>
<pre>let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
valid (fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")]) == True
valid (fromDescListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:fromDistinctDescList" class="def">fromDistinctDescList</a> :: [(k, a)] -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#fromDistinctDescList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Build a map from a descending list of distinct elements in linear time. <em>The precondition is not checked.</em></p>
<pre>fromDistinctDescList [(5,"a"), (3,"b")] == fromList [(3, "b"), (5, "a")]
valid (fromDistinctDescList [(5,"a"), (3,"b")])          == True
valid (fromDistinctDescList [(5,"a"), (5,"b"), (3,"b")]) == False</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<a href="#g:6" id="g:6"><h2>Insertion</h2></a><p class="src"><a id="v:insert" class="def">insert</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#insert" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. <code><a href="data-map-lazy.html#v:insert" title="Data.Map.Lazy">insert</a></code> is equivalent to <code class="inline-code"><a href="data-map-lazy.html#v:insertWith" title="Data.Map.Lazy">insertWith</a> <a href="../base-4.21.0.0-8e62/data-function.html#v:const" title="Data.Function">const</a></code>.</p>
<pre>insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
insert 5 'x' empty                         == singleton 5 'x'</pre>
<p class="src"><a id="v:insertWith" class="def">insertWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#insertWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Insert with a function, combining new value and old value. <code class="inline-code"><a href="data-map-lazy.html#v:insertWith" title="Data.Map.Lazy">insertWith</a> f key value mp</code> will insert the pair (key, value) into <code class="inline-code">mp</code> if key does not exist in the map. If the key does exist, the function will insert the pair <code class="inline-code">(key, f new_value old_value)</code>.</p>
<pre>insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:insertWithKey" class="def">insertWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#insertWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Insert with a function, combining key, new value and old value. <code class="inline-code"><a href="data-map-lazy.html#v:insertWithKey" title="Data.Map.Lazy">insertWithKey</a> f key value mp</code> will insert the pair (key, value) into <code class="inline-code">mp</code> if key does not exist in the map. If the key does exist, the function will insert the pair <code class="inline-code">(key,f key new_value old_value)</code>. Note that the key passed to f is the same key passed to <code><a href="data-map-lazy.html#v:insertWithKey" title="Data.Map.Lazy">insertWithKey</a></code>.</p>
<pre>let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:insertLookupWithKey" class="def">insertLookupWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#insertLookupWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Combines insert operation with old value retrieval. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:insertLookupWithKey" title="Data.Map.Lazy">insertLookupWithKey</a> f k x map</code>) is a pair where the first element is equal to (<code class="inline-code"><a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k map</code>) and the second element equal to (<code class="inline-code"><a href="data-map-lazy.html#v:insertWithKey" title="Data.Map.Lazy">insertWithKey</a> f k x map</code>).</p>
<pre>let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")</pre>
<p>This is how to define <code class="inline-code">insertLookup</code> using <code class="inline-code">insertLookupWithKey</code>:</p>
<pre>let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<a href="#g:7" id="g:7"><h2>Deletion/Update</h2></a><p class="src"><a id="v:delete" class="def">delete</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#delete" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete a key and its value from the map. When the key is not a member of the map, the original map is returned.</p>
<pre>delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
delete 5 empty                         == empty</pre>
<p class="src"><a id="v:adjust" class="def">adjust</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#adjust" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update a value at a specific key with the result of the provided function. When the key is not a member of the map, the original map is returned.</p>
<pre>adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
adjust ("new " ++) 7 empty                         == empty</pre>
<p class="src"><a id="v:adjustWithKey" class="def">adjustWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#adjustWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Adjust a value at a specific key. When the key is not a member of the map, the original map is returned.</p>
<pre>let f key x = (show key) ++ ":new " ++ x
adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
adjustWithKey f 7 empty                         == empty</pre>
<p class="src"><a id="v:update" class="def">update</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#update" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:update" title="Data.Map.Lazy">update</a> f k map</code>) updates the value <code class="inline-code">x</code> at <code class="inline-code">k</code> (if it is in the map). If (<code class="inline-code">f x</code>) is <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the element is deleted. If it is (<code class="inline-code"><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a> y</code>), the key <code class="inline-code">k</code> is bound to the new value <code class="inline-code">y</code>.</p>
<pre>let f x = if x == "a" then Just "new a" else Nothing
update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:updateWithKey" class="def">updateWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:updateWithKey" title="Data.Map.Lazy">updateWithKey</a> f k map</code>) updates the value <code class="inline-code">x</code> at <code class="inline-code">k</code> (if it is in the map). If (<code class="inline-code">f k x</code>) is <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the element is deleted. If it is (<code class="inline-code"><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a> y</code>), the key <code class="inline-code">k</code> is bound to the new value <code class="inline-code">y</code>.</p>
<pre>let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:updateLookupWithKey" class="def">updateLookupWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateLookupWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Lookup and update. See also <code><a href="data-map-lazy.html#v:updateWithKey" title="Data.Map.Lazy">updateWithKey</a></code>. The function returns changed value, if it is updated. Returns the original key value if the map entry is deleted.</p>
<pre>let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])
updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")</pre>
<p class="src"><a id="v:alter" class="def">alter</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#alter" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:alter" title="Data.Map.Lazy">alter</a> f k map</code>) alters the value <code class="inline-code">x</code> at <code class="inline-code">k</code>, or absence thereof. <code><a href="data-map-lazy.html#v:alter" title="Data.Map.Lazy">alter</a></code> can be used to insert, delete, or update a value in a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>. In short : <code class="inline-code"><a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k (<a href="data-map-lazy.html#v:alter" title="Data.Map.Lazy">alter</a> f k m) = f (<a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k m)</code>.</p>
<pre>let f _ = Nothing
alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
alter f 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"

let f _ = Just "c"
alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "c")]
alter f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "c")]</pre>
<p>Note that <code class="inline-code"><a href="data-map-lazy.html#v:adjust" title="Data.Map.Lazy">adjust</a> = alter . fmap</code>.</p>
<p class="src"><a id="v:alterF" class="def">alterF</a> :: (<a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> f, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)) -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#alterF" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a> f k map</code>) alters the value <code class="inline-code">x</code> at <code class="inline-code">k</code>, or absence thereof. <code><a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a></code> can be used to inspect, insert, delete, or update a value in a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>. In short: <code class="inline-code"><a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k &lt;$&gt; <a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a> f k m = f
 (<a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k m)</code>.</p>
<p>Example:</p>
<pre>interactiveAlter :: Int -&gt; Map Int String -&gt; IO (Map Int String)
interactiveAlter k m = alterF f k m where
  f Nothing = do
     putStrLn $ show k ++
         " was not found in the map. Would you like to add it?"
     getUserResponse1 :: IO (Maybe String)
  f (Just old) = do
     putStrLn $ "The key is currently bound to " ++ show old ++
         ". Would you like to change or delete it?"
     getUserResponse2 :: IO (Maybe String)
</pre>
<p><code><a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a></code> is the most general operation for working with an individual key that may or may not be in a given map. When used with trivial functors like <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></code> and <code><a href="../base-4.21.0.0-8e62/data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a></code>, it is often slightly slower than more specialized combinators like <code><a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a></code> and <code><a href="data-map-lazy.html#v:insert" title="Data.Map.Lazy">insert</a></code>. However, when the functor is non-trivial and key comparison is not particularly cheap, it is the fastest way.</p>
<p>Note on rewrite rules:</p>
<p>This module includes GHC rewrite rules to optimize <code><a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a></code> for the <code><a href="../base-4.21.0.0-8e62/data-functor-const.html#t:Const" title="Data.Functor.Const">Const</a></code> and <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></code> functors. In general, these rules improve performance. The sole exception is that when using <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></code>, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the <code><a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></code> type.</p>
<p>Note: <code><a href="data-map-lazy.html#v:alterF" title="Data.Map.Lazy">alterF</a></code> is a flipped version of the <code class="inline-code">at</code> combinator from <code class="inline-code">Control.Lens.At</code>.</p>
<p><span class="version">Since: containers-0.5.8</span></p>
<a href="#g:8" id="g:8"><h2>Query</h2></a><a href="#g:9" id="g:9"><h3>Lookup</h3></a><p class="src"><a id="v:lookup" class="def">lookup</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookup" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Lookup the value at a key in the map.</p>
<p>The function will return the corresponding value as <code class="inline-code">(<a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a> value)</code>, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the key isn't in the map.</p>
<p>An example of using <code class="inline-code">lookup</code>:</p>
<pre>import Prelude hiding (lookup)
import Data.Map

employeeDept = fromList([("John","Sales"), ("Bob","IT")])
deptCountry = fromList([("IT","USA"), ("Sales","France")])
countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])

employeeCurrency :: String -&gt; Maybe String
employeeCurrency name = do
    dept &lt;- lookup name employeeDept
    country &lt;- lookup dept deptCountry
    lookup country countryCurrency

main = do
    putStrLn $ "John's currency: " ++ (show (employeeCurrency "John"))
    putStrLn $ "Pete's currency: " ++ (show (employeeCurrency "Pete"))</pre>
<p>The output of this program:</p>
<pre>  John's currency: Just "Euro"
  Pete's currency: Nothing</pre>
<p class="src"><a id="v:-33--63-" class="def">(!?)</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; k -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#%21%3F" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find the value at a key. Returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> when the element can not be found.</p>
<pre>fromList [(5, 'a'), (3, 'b')] !? 1 == Nothing</pre>
<pre>fromList [(5, 'a'), (3, 'b')] !? 5 == Just 'a'</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:-33-" class="def">(!)</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; k -&gt; a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#%21" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find the value at a key. Calls <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> when the element can not be found.</p>
<pre>fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
fromList [(5,'a'), (3,'b')] ! 5 == 'a'</pre>
<p class="src"><a id="v:findWithDefault" class="def">findWithDefault</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; a -&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#findWithDefault" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression <code class="inline-code">(<a href="data-map-lazy.html#v:findWithDefault" title="Data.Map.Lazy">findWithDefault</a> def k map)</code> returns the value at key <code class="inline-code">k</code> or returns default value <code class="inline-code">def</code> when the key is not in the map.</p>
<pre>findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'</pre>
<p class="src"><a id="v:member" class="def">member</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#member" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Is the key a member of the map? See also <code><a href="data-map-lazy.html#v:notMember" title="Data.Map.Lazy">notMember</a></code>.</p>
<pre>member 5 (fromList [(5,'a'), (3,'b')]) == True
member 1 (fromList [(5,'a'), (3,'b')]) == False</pre>
<p class="src"><a id="v:notMember" class="def">notMember</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#notMember" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Is the key not a member of the map? See also <code><a href="data-map-lazy.html#v:member" title="Data.Map.Lazy">member</a></code>.</p>
<pre>notMember 5 (fromList [(5,'a'), (3,'b')]) == False
notMember 1 (fromList [(5,'a'), (3,'b')]) == True</pre>
<p class="src"><a id="v:lookupLT" class="def">lookupLT</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupLT" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find largest key smaller than the given one and return the corresponding (key, value) pair.</p>
<pre>lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')</pre>
<p class="src"><a id="v:lookupGT" class="def">lookupGT</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupGT" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find smallest key greater than the given one and return the corresponding (key, value) pair.</p>
<pre>lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing</pre>
<p class="src"><a id="v:lookupLE" class="def">lookupLE</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupLE" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find largest key smaller or equal to the given one and return the corresponding (key, value) pair.</p>
<pre>lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')</pre>
<p class="src"><a id="v:lookupGE" class="def">lookupGE</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k v -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupGE" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Find smallest key greater or equal to the given one and return the corresponding (key, value) pair.</p>
<pre>lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing</pre>
<a href="#g:10" id="g:10"><h3>Size</h3></a><p class="src"><a id="v:null" class="def">null</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#null" class="link">Source</a> </p>
<p><span class="mathjax">\(O(1)\)</span>. Is the map empty?</p>
<pre>Data.Map.null (empty)           == True
Data.Map.null (singleton 1 'a') == False</pre>
<p class="src"><a id="v:size" class="def">size</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#size" class="link">Source</a> </p>
<p><span class="mathjax">\(O(1)\)</span>. The number of elements in the map.</p>
<pre>size empty                                   == 0
size (singleton 1 'a')                       == 1
size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3</pre>
<a href="#g:11" id="g:11"><h2>Combine</h2></a><a href="#g:12" id="g:12"><h3>Union</h3></a><p class="src"><a id="v:union" class="def">union</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#union" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a> t1 t2</code>) takes the left-biased union of <code class="inline-code">t1</code> and <code class="inline-code">t2</code>. It prefers <code class="inline-code">t1</code> when duplicate keys are encountered, i.e. (<code class="inline-code"><a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a> == <a href="data-map-lazy.html#v:unionWith" title="Data.Map.Lazy">unionWith</a> <a href="../base-4.21.0.0-8e62/data-function.html#v:const" title="Data.Function">const</a></code>).</p>
<pre>union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]</pre>
<p class="src"><a id="v:unionWith" class="def">unionWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#unionWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Union with a combining function.</p>
<pre>unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:unionWithKey" class="def">unionWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#unionWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Union with a combining function.</p>
<pre>let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:unions" class="def">unions</a> :: (<a href="../base-4.21.0.0-8e62/data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#unions" class="link">Source</a> </p>
<p>The union of a list of maps: (<code class="inline-code"><a href="data-map-lazy.html#v:unions" title="Data.Map.Lazy">unions</a> == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldl" title="Prelude">foldl</a> <a href="data-map-lazy.html#v:union" title="Data.Map.Lazy">union</a> <a href="data-map-lazy.html#v:empty" title="Data.Map.Lazy">empty</a></code>).</p>
<pre>unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
    == fromList [(3, "b"), (5, "a"), (7, "C")]
unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
    == fromList [(3, "B3"), (5, "A3"), (7, "C")]</pre>
<p class="src"><a id="v:unionsWith" class="def">unionsWith</a> :: (<a href="../base-4.21.0.0-8e62/data-foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; a -&gt; a) -&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#unionsWith" class="link">Source</a> </p>
<p>The union of a list of maps, with a combining operation: (<code class="inline-code"><a href="data-map-lazy.html#v:unionsWith" title="Data.Map.Lazy">unionsWith</a> f == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldl" title="Prelude">foldl</a> (<a href="data-map-lazy.html#v:unionWith" title="Data.Map.Lazy">unionWith</a> f) <a href="data-map-lazy.html#v:empty" title="Data.Map.Lazy">empty</a></code>).</p>
<pre>unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
    == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]</pre>
<a href="#g:13" id="g:13"><h3>Difference</h3></a><p class="src"><a id="v:difference" class="def">difference</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#difference" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Difference of two maps. Return elements of the first map not existing in the second map.</p>
<pre>difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"</pre>
<p class="src"><a id="v:-92--92-" class="def">(\\)</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#%5C%5C" class="link">Source</a> </p>
<p>Same as <code><a href="data-map-lazy.html#v:difference" title="Data.Map.Lazy">difference</a></code>.</p>
<p class="src"><a id="v:differenceWith" class="def">differenceWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#differenceWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n+m)\)</span>. Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the element is discarded (proper set difference). If it returns (<code class="inline-code"><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a> y</code>), the element is updated with a new value <code class="inline-code">y</code>.</p>
<pre>let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
    == singleton 3 "b:B"</pre>
<p class="src"><a id="v:differenceWithKey" class="def">differenceWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#differenceWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n+m)\)</span>. Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the element is discarded (proper set difference). If it returns (<code class="inline-code"><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a> y</code>), the element is updated with a new value <code class="inline-code">y</code>.</p>
<pre>let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
    == singleton 3 "3:b|B"</pre>
<a href="#g:14" id="g:14"><h3>Intersection</h3></a><p class="src"><a id="v:intersection" class="def">intersection</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#intersection" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Intersection of two maps. Return data in the first map for the keys existing in both maps. (<code class="inline-code"><a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">intersection</a> m1 m2 == <a href="data-map-lazy.html#v:intersectionWith" title="Data.Map.Lazy">intersectionWith</a> <a href="../base-4.21.0.0-8e62/data-function.html#v:const" title="Data.Function">const</a> m1 m2</code>).</p>
<pre>intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:intersectionWith" class="def">intersectionWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; b -&gt; c) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#intersectionWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Intersection with a combining function.</p>
<pre>intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"</pre>
<p class="src"><a id="v:intersectionWithKey" class="def">intersectionWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; c) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#intersectionWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Intersection with a combining function.</p>
<pre>let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"</pre>
<a href="#g:15" id="g:15"><h3>Disjoint</h3></a><p class="src"><a id="v:disjoint" class="def">disjoint</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#disjoint" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Check whether the key sets of two maps are disjoint (i.e., their <code><a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">intersection</a></code> is empty).</p>
<pre>disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
disjoint (fromList [])        (fromList [])                 == True</pre>
<pre>xs <a href="data-map-lazy.html#v:disjoint" title="Data.Map.Lazy">`disjoint`</a> ys = null (xs <a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">`intersection`</a> ys)
</pre>
<p><span class="version">Since: containers-0.6.2.1</span></p>
<a href="#g:16" id="g:16"><h3>Compose</h3></a><p class="src"><a id="v:compose" class="def">compose</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> b c -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> a c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#compose" class="link">Source</a> </p>
<p>Relate the keys of one map to the values of the other, by using the values of the former as keys for lookups in the latter.</p>
<p>Complexity: <span class="mathjax">\( O (n * \log(m)) \)</span>, where <span class="mathjax">\(m\)</span> is the size of the first argument</p>
<pre>compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]</pre>
<pre>(<a href="data-map-lazy.html#v:compose" title="Data.Map.Lazy">compose</a> bc ab <a href="data-map-lazy.html#v:-33--63-" title="Data.Map.Lazy">!?</a>) = (bc <a href="data-map-lazy.html#v:-33--63-" title="Data.Map.Lazy">!?</a>) &lt;=&lt; (ab <a href="data-map-lazy.html#v:-33--63-" title="Data.Map.Lazy">!?</a>)
</pre>
<p><strong>Note:</strong> Prior to v0.6.4, <a href="data-map-strict.html">Data.Map.Strict</a> exposed a version of <code><a href="data-map-lazy.html#v:compose" title="Data.Map.Lazy">compose</a></code> that forced the values of the output <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>. This version does not force these values.</p>
<p><span class="version">Since: containers-0.6.3.1</span></p>
<a href="#g:17" id="g:17"><h3>General combining functions</h3></a><p>See <a href="data-map-merge-lazy.html">Data.Map.Merge.Lazy</a></p>
<a href="#g:18" id="g:18"><h3>Unsafe general combining function</h3></a><p class="src"><a id="v:mergeWithKey" class="def">mergeWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> c) -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mergeWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n+m)\)</span>. An unsafe general combining function.</p>
<p>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer <code><a href="data-map-merge-lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> or <code><a href="data-map-merge-lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code>.</p>
<p>When <code><a href="data-map-lazy.html#v:mergeWithKey" title="Data.Map.Lazy">mergeWithKey</a></code> is given three arguments, it is inlined to the call site. You should therefore use <code><a href="data-map-lazy.html#v:mergeWithKey" title="Data.Map.Lazy">mergeWithKey</a></code> only to define custom combining functions. For example, you could define <code><a href="data-map-lazy.html#v:unionWithKey" title="Data.Map.Lazy">unionWithKey</a></code>, <code><a href="data-map-lazy.html#v:differenceWithKey" title="Data.Map.Lazy">differenceWithKey</a></code> and <code><a href="data-map-lazy.html#v:intersectionWithKey" title="Data.Map.Lazy">intersectionWithKey</a></code> as</p>
<pre>myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2</pre>
<p>When calling <code class="inline-code"><a href="data-map-lazy.html#v:mergeWithKey" title="Data.Map.Lazy">mergeWithKey</a> combine only1 only2</code>, a function combining two <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>s is created, such that</p>
<ul>
<li>if a key is present in both maps, it is passed with both corresponding values to the <code class="inline-code">combine</code> function. Depending on the result, the key is either present in the result with specified value, or is left out;</li>
<li>a nonempty subtree present only in the first map is passed to <code class="inline-code">only1</code> and the output is added to the result;</li>
<li>a nonempty subtree present only in the second map is passed to <code class="inline-code">only2</code> and the output is added to the result.</li>
</ul>
<p>The <code class="inline-code">only1</code> and <code class="inline-code">only2</code> methods <em>must return a map with a subset (possibly empty) of the keys of the given map</em>. The values can be modified arbitrarily. Most common variants of <code class="inline-code">only1</code> and <code class="inline-code">only2</code> are <code><a href="../base-4.21.0.0-8e62/data-function.html#v:id" title="Data.Function">id</a></code> and <code class="inline-code"><a href="../base-4.21.0.0-8e62/data-function.html#v:const" title="Data.Function">const</a> <a href="data-map-lazy.html#v:empty" title="Data.Map.Lazy">empty</a></code>, but for example <code class="inline-code"><a href="data-map-lazy.html#v:map" title="Data.Map.Lazy">map</a> f</code>, <code class="inline-code"><a href="data-map-lazy.html#v:filterWithKey" title="Data.Map.Lazy">filterWithKey</a> f</code>, or <code class="inline-code"><a href="data-map-lazy.html#v:mapMaybeWithKey" title="Data.Map.Lazy">mapMaybeWithKey</a> f</code> could be used for any <code class="inline-code">f</code>.</p>
<a href="#g:19" id="g:19"><h2>Traversal</h2></a><a href="#g:20" id="g:20"><h3>Map</h3></a><p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#map" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map a function over all values in the map.</p>
<pre>map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]</pre>
<p class="src"><a id="v:mapWithKey" class="def">mapWithKey</a> :: (k -&gt; a -&gt; b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map a function over all values in the map.</p>
<pre>let f key x = (show key) ++ ":" ++ x
mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]</pre>
<p class="src"><a id="v:traverseWithKey" class="def">traverseWithKey</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> t =&gt; (k -&gt; a -&gt; t b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; t (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#traverseWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. <code class="inline-code"><a href="data-map-lazy.html#v:traverseWithKey" title="Data.Map.Lazy">traverseWithKey</a> f m == <a href="data-map-lazy.html#v:fromList" title="Data.Map.Lazy">fromList</a> &lt;$&gt; <a href="../base-4.21.0.0-8e62/data-traversable.html#v:traverse" title="Data.Traversable">traverse</a> (\(k, v) -&gt; (,) k &lt;$&gt; f k v) (<a href="data-map-lazy.html#v:toList" title="Data.Map.Lazy">toList</a> m)</code> That is, behaves exactly like a regular <code><a href="../base-4.21.0.0-8e62/data-traversable.html#v:traverse" title="Data.Traversable">traverse</a></code> except that the traversing function also has access to the key associated with a value.</p>
<pre>traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing</pre>
<p class="src"><a id="v:traverseMaybeWithKey" class="def">traverseMaybeWithKey</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; a -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; f (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#traverseMaybeWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Traverse keys/values and collect the <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> results.</p>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:mapAccum" class="def">mapAccum</a> :: (a -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; (a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapAccum" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. The function <code><a href="data-map-lazy.html#v:mapAccum" title="Data.Map.Lazy">mapAccum</a></code> threads an accumulating argument through the map in ascending order of keys.</p>
<pre>let f a b = (a ++ b, b ++ "X")
mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])</pre>
<p class="src"><a id="v:mapAccumWithKey" class="def">mapAccumWithKey</a> :: (a -&gt; k -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; (a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapAccumWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. The function <code><a href="data-map-lazy.html#v:mapAccumWithKey" title="Data.Map.Lazy">mapAccumWithKey</a></code> threads an accumulating argument through the map in ascending order of keys.</p>
<pre>let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])</pre>
<p class="src"><a id="v:mapAccumRWithKey" class="def">mapAccumRWithKey</a> :: (a -&gt; k -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; (a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapAccumRWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. The function <code><a href="data-map-lazy.html#v:mapAccumRWithKey" title="Data.Map.Lazy">mapAccumRWithKey</a></code> threads an accumulating argument through the map in descending order of keys.</p>
<p class="src"><a id="v:mapKeys" class="def">mapKeys</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k2 =&gt; (k1 -&gt; k2) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k1 a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapKeys" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n \log n)\)</span>. <code class="inline-code"><a href="data-map-lazy.html#v:mapKeys" title="Data.Map.Lazy">mapKeys</a> f s</code> is the map obtained by applying <code class="inline-code">f</code> to each key of <code class="inline-code">s</code>.</p>
<p>The size of the result may be smaller if <code class="inline-code">f</code> maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</p>
<pre>mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"</pre>
<p class="src"><a id="v:mapKeysWith" class="def">mapKeysWith</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k2 =&gt; (a -&gt; a -&gt; a) -&gt; (k1 -&gt; k2) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k1 a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapKeysWith" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n \log n)\)</span>. <code class="inline-code"><a href="data-map-lazy.html#v:mapKeysWith" title="Data.Map.Lazy">mapKeysWith</a> c f s</code> is the map obtained by applying <code class="inline-code">f</code> to each key of <code class="inline-code">s</code>.</p>
<p>The size of the result may be smaller if <code class="inline-code">f</code> maps two or more distinct keys to the same new key. In this case the associated values will be combined using <code class="inline-code">c</code>. The value at the greater of the two original keys is used as the first argument to <code class="inline-code">c</code>.</p>
<pre>mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"</pre>
<p>Also see the performance note on <code><a href="data-map-lazy.html#v:fromListWith" title="Data.Map.Lazy">fromListWith</a></code>.</p>
<p class="src"><a id="v:mapKeysMonotonic" class="def">mapKeysMonotonic</a> :: (k1 -&gt; k2) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k1 a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapKeysMonotonic" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. <code class="inline-code"><a href="data-map-lazy.html#v:mapKeysMonotonic" title="Data.Map.Lazy">mapKeysMonotonic</a> f s == <a href="data-map-lazy.html#v:mapKeys" title="Data.Map.Lazy">mapKeys</a> f s</code>, but works only when <code class="inline-code">f</code> is strictly monotonic. That is, for any values <code class="inline-code">x</code> and <code class="inline-code">y</code>, if <code class="inline-code">x</code> &lt; <code class="inline-code">y</code> then <code class="inline-code">f x</code> &lt; <code class="inline-code">f y</code>. <em>The precondition is not checked.</em> Semi-formally, we have:</p>
<pre>and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
                    ==&gt; mapKeysMonotonic f s == mapKeys f s
    where ls = keys s</pre>
<p>This means that <code class="inline-code">f</code> maps distinct original keys to distinct resulting keys. This function has better performance than <code><a href="data-map-lazy.html#v:mapKeys" title="Data.Map.Lazy">mapKeys</a></code>.</p>
<pre>mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")])) == True
valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList [(5,"a"), (3,"b")])) == False</pre>
<a href="#g:21" id="g:21"><h2>Folds</h2></a><p class="src"><a id="v:foldr" class="def">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldr" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Fold the values in the map using the given right-associative binary operator, such that <code class="inline-code"><a href="data-map-lazy.html#v:foldr" title="Data.Map.Lazy">foldr</a> f z == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldr" title="Prelude">foldr</a> f z . <a href="data-map-lazy.html#v:elems" title="Data.Map.Lazy">elems</a></code>.</p>
<p>For example,</p>
<pre>elems map = foldr (:) [] map</pre>
<pre>let f a len = len + (length a)
foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4</pre>
<p class="src"><a id="v:foldl" class="def">foldl</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldl" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Fold the values in the map using the given left-associative binary operator, such that <code class="inline-code"><a href="data-map-lazy.html#v:foldl" title="Data.Map.Lazy">foldl</a> f z == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldl" title="Prelude">foldl</a> f z . <a href="data-map-lazy.html#v:elems" title="Data.Map.Lazy">elems</a></code>.</p>
<p>For example,</p>
<pre>elems = reverse . foldl (flip (:)) []</pre>
<pre>let f len a = len + (length a)
foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4</pre>
<p class="src"><a id="v:foldrWithKey" class="def">foldrWithKey</a> :: (k -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldrWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Fold the keys and values in the map using the given right-associative binary operator, such that <code class="inline-code"><a href="data-map-lazy.html#v:foldrWithKey" title="Data.Map.Lazy">foldrWithKey</a> f z == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldr" title="Prelude">foldr</a> (<a href="../base-4.21.0.0-8e62/data-tuple.html#v:uncurry" title="Data.Tuple">uncurry</a> f) z . <a href="data-map-lazy.html#v:toAscList" title="Data.Map.Lazy">toAscList</a></code>.</p>
<p>For example,</p>
<pre>keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map</pre>
<pre>let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"</pre>
<p class="src"><a id="v:foldlWithKey" class="def">foldlWithKey</a> :: (a -&gt; k -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldlWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Fold the keys and values in the map using the given left-associative binary operator, such that <code class="inline-code"><a href="data-map-lazy.html#v:foldlWithKey" title="Data.Map.Lazy">foldlWithKey</a> f z == <a href="../base-4.21.0.0-8e62/prelude.html#v:foldl" title="Prelude">foldl</a> (\z' (kx, x) -&gt; f z' kx x) z . <a href="data-map-lazy.html#v:toAscList" title="Data.Map.Lazy">toAscList</a></code>.</p>
<p>For example,</p>
<pre>keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []</pre>
<pre>let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"</pre>
<p class="src"><a id="v:foldMapWithKey" class="def">foldMapWithKey</a> :: <a href="../base-4.21.0.0-8e62/data-monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (k -&gt; a -&gt; m) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; m <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldMapWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Fold the keys and values in the map using the given monoid, such that</p>
<pre><a href="data-map-lazy.html#v:foldMapWithKey" title="Data.Map.Lazy">foldMapWithKey</a> f = <a href="../base-4.21.0.0-8e62/prelude.html#v:fold" title="Prelude">fold</a> . <a href="data-map-lazy.html#v:mapWithKey" title="Data.Map.Lazy">mapWithKey</a> f</pre>
<p>This can be an asymptotically faster than <code><a href="data-map-lazy.html#v:foldrWithKey" title="Data.Map.Lazy">foldrWithKey</a></code> or <code><a href="data-map-lazy.html#v:foldlWithKey" title="Data.Map.Lazy">foldlWithKey</a></code> for some monoids.</p>
<p><span class="version">Since: containers-0.5.4</span></p>
<a href="#g:22" id="g:22"><h3>Strict folds</h3></a><p class="src"><a id="v:foldr-39-" class="def">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldr%27" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. A strict version of <code><a href="data-map-lazy.html#v:foldr" title="Data.Map.Lazy">foldr</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldl%27" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. A strict version of <code><a href="data-map-lazy.html#v:foldl" title="Data.Map.Lazy">foldl</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a id="v:foldrWithKey-39-" class="def">foldrWithKey'</a> :: (k -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldrWithKey%27" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. A strict version of <code><a href="data-map-lazy.html#v:foldrWithKey" title="Data.Map.Lazy">foldrWithKey</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a id="v:foldlWithKey-39-" class="def">foldlWithKey'</a> :: (a -&gt; k -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#foldlWithKey%27" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. A strict version of <code><a href="data-map-lazy.html#v:foldlWithKey" title="Data.Map.Lazy">foldlWithKey</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<a href="#g:23" id="g:23"><h2>Conversion</h2></a><p class="src"><a id="v:elems" class="def">elems</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#elems" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Return all elements of the map in the ascending order of their keys. Subject to list fusion.</p>
<pre>elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
elems empty == []</pre>
<p class="src"><a id="v:keys" class="def">keys</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [k] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#keys" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Return all keys of the map in ascending order. Subject to list fusion.</p>
<pre>keys (fromList [(5,"a"), (3,"b")]) == [3,5]
keys empty == []</pre>
<p class="src"><a id="v:assocs" class="def">assocs</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#assocs" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. An alias for <code><a href="data-map-lazy.html#v:toAscList" title="Data.Map.Lazy">toAscList</a></code>. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</p>
<pre>assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
assocs empty == []</pre>
<p class="src"><a id="v:keysSet" class="def">keysSet</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-set.html#t:Set" title="Data.Set">Set</a> k <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#keysSet" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. The set of all keys of the map.</p>
<pre>keysSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [3,5]
keysSet empty == Data.Set.empty</pre>
<p class="src"><a id="v:argSet" class="def">argSet</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-set.html#t:Set" title="Data.Set">Set</a> (<a href="../base-4.21.0.0-8e62/data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#argSet" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. The set of all elements of the map contained in <code><a href="../base-4.21.0.0-8e62/data-semigroup.html#t:Arg" title="Data.Semigroup">Arg</a></code>s.</p>
<pre>argSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [Arg 3 "b",Arg 5 "a"]
argSet empty == Data.Set.empty</pre>
<a href="#g:24" id="g:24"><h3>Lists</h3></a><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#toList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Convert the map to a list of key/value pairs. Subject to list fusion.</p>
<pre>toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
toList empty == []</pre>
<a href="#g:25" id="g:25"><h3>Ordered lists</h3></a><p class="src"><a id="v:toAscList" class="def">toAscList</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#toAscList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Convert the map to a list of key/value pairs where the keys are in ascending order. Subject to list fusion.</p>
<pre>toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]</pre>
<p class="src"><a id="v:toDescList" class="def">toDescList</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#toDescList" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Convert the map to a list of key/value pairs where the keys are in descending order. Subject to list fusion.</p>
<pre>toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]</pre>
<a href="#g:26" id="g:26"><h2>Filter</h2></a><p class="src"><a id="v:filter" class="def">filter</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#filter" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Filter all values that satisfy the predicate.</p>
<pre>filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty</pre>
<p class="src"><a id="v:filterWithKey" class="def">filterWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#filterWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Filter all keys/values that satisfy the predicate.</p>
<pre>filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:restrictKeys" class="def">restrictKeys</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-set.html#t:Set" title="Data.Set">Set</a> k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#restrictKeys" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Restrict a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code> to only those keys found in a <code><a href="data-set.html#t:Set" title="Data.Set">Set</a></code>.</p>
<pre>m `restrictKeys` s = <a href="data-map-lazy.html#v:filterWithKey" title="Data.Map.Lazy">filterWithKey</a> (\k _ -&gt; k <a href="set.html#v:member" title="Set">`member`</a> s) m
m `restrictKeys` s = m <a href="data-map-lazy.html#v:intersection" title="Data.Map.Lazy">`intersection`</a> <a href="data-map-lazy.html#v:fromSet" title="Data.Map.Lazy">fromSet</a> (const ()) s
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:withoutKeys" class="def">withoutKeys</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-set.html#t:Set" title="Data.Set">Set</a> k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#withoutKeys" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Remove all keys in a <code><a href="data-set.html#t:Set" title="Data.Set">Set</a></code> from a <code><a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a></code>.</p>
<pre>m `withoutKeys` s = <a href="data-map-lazy.html#v:filterWithKey" title="Data.Map.Lazy">filterWithKey</a> (\k _ -&gt; k <a href="set.html#v:notMember" title="Set">`notMember`</a> s) m
m `withoutKeys` s = m <a href="data-map-lazy.html#v:difference" title="Data.Map.Lazy">`difference`</a> <a href="data-map-lazy.html#v:fromSet" title="Data.Map.Lazy">fromSet</a> (const ()) s
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:partition" class="def">partition</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#partition" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also <code><a href="data-map-lazy.html#v:split" title="Data.Map.Lazy">split</a></code>.</p>
<pre>partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])</pre>
<p class="src"><a id="v:partitionWithKey" class="def">partitionWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#partitionWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also <code><a href="data-map-lazy.html#v:split" title="Data.Map.Lazy">split</a></code>.</p>
<pre>partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])</pre>
<p class="src"><a id="v:takeWhileAntitone" class="def">takeWhileAntitone</a> :: (k -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#takeWhileAntitone" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Take while a predicate on the keys holds. The user is responsible for ensuring that for all keys <code class="inline-code">j</code> and <code class="inline-code">k</code> in the map, <code class="inline-code">j &lt; k ==&gt; p j &gt;= p k</code>. See note at <code><a href="data-map-lazy.html#v:spanAntitone" title="Data.Map.Lazy">spanAntitone</a></code>.</p>
<pre>takeWhileAntitone p = <a href="data-map-lazy.html#v:fromDistinctAscList" title="Data.Map.Lazy">fromDistinctAscList</a> . <a href="../base-4.21.0.0-8e62/data-list.html#v:takeWhile" title="Data.List">takeWhile</a> (p . fst) . <a href="data-map-lazy.html#v:toList" title="Data.Map.Lazy">toList</a>
takeWhileAntitone p = <a href="data-map-lazy.html#v:filterWithKey" title="Data.Map.Lazy">filterWithKey</a> (k _ -&gt; p k)
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:dropWhileAntitone" class="def">dropWhileAntitone</a> :: (k -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#dropWhileAntitone" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Drop while a predicate on the keys holds. The user is responsible for ensuring that for all keys <code class="inline-code">j</code> and <code class="inline-code">k</code> in the map, <code class="inline-code">j &lt; k ==&gt; p j &gt;= p k</code>. See note at <code><a href="data-map-lazy.html#v:spanAntitone" title="Data.Map.Lazy">spanAntitone</a></code>.</p>
<pre>dropWhileAntitone p = <a href="data-map-lazy.html#v:fromDistinctAscList" title="Data.Map.Lazy">fromDistinctAscList</a> . <a href="../base-4.21.0.0-8e62/data-list.html#v:dropWhile" title="Data.List">dropWhile</a> (p . fst) . <a href="data-map-lazy.html#v:toList" title="Data.Map.Lazy">toList</a>
dropWhileAntitone p = <a href="data-map-lazy.html#v:filterWithKey" title="Data.Map.Lazy">filterWithKey</a> (\k _ -&gt; not (p k))
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:spanAntitone" class="def">spanAntitone</a> :: (k -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#spanAntitone" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Divide a map at the point where a predicate on the keys stops holding. The user is responsible for ensuring that for all keys <code class="inline-code">j</code> and <code class="inline-code">k</code> in the map, <code class="inline-code">j &lt; k ==&gt; p j &gt;= p k</code>.</p>
<pre>spanAntitone p xs = (<a href="data-map-lazy.html#v:takeWhileAntitone" title="Data.Map.Lazy">takeWhileAntitone</a> p xs, <a href="data-map-lazy.html#v:dropWhileAntitone" title="Data.Map.Lazy">dropWhileAntitone</a> p xs)
spanAntitone p xs = partitionWithKey (\k _ -&gt; p k) xs
</pre>
<p>Note: if <code class="inline-code">p</code> is not actually antitone, then <code class="inline-code">spanAntitone</code> will split the map at some <em>unspecified</em> point where the predicate switches from holding to not holding (where the predicate is seen to hold before the first key and to fail after the last key).</p>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:mapMaybe" class="def">mapMaybe</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapMaybe" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map values and collect the <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> results.</p>
<pre>let f x = if x == "a" then Just "new a" else Nothing
mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"</pre>
<p class="src"><a id="v:mapMaybeWithKey" class="def">mapMaybeWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapMaybeWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map keys/values and collect the <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> results.</p>
<pre>let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"</pre>
<p class="src"><a id="v:mapEither" class="def">mapEither</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-either.html#t:Either" title="Data.Either">Either</a> b c) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapEither" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map values and separate the <code><a href="../base-4.21.0.0-8e62/data-either.html#v:Left" title="Data.Either">Left</a></code> and <code><a href="../base-4.21.0.0-8e62/data-either.html#v:Right" title="Data.Either">Right</a></code> results.</p>
<pre>let f a = if a &lt; "c" then Left a else Right a
mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])

mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])</pre>
<p class="src"><a id="v:mapEitherWithKey" class="def">mapEitherWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-either.html#t:Either" title="Data.Either">Either</a> b c) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mapEitherWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Map keys/values and separate the <code><a href="../base-4.21.0.0-8e62/data-either.html#v:Left" title="Data.Either">Left</a></code> and <code><a href="../base-4.21.0.0-8e62/data-either.html#v:Right" title="Data.Either">Right</a></code> results.</p>
<pre>let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])

mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])</pre>
<p class="src"><a id="v:split" class="def">split</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#split" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:split" title="Data.Map.Lazy">split</a> k map</code>) is a pair <code class="inline-code">(map1,map2)</code> where the keys in <code class="inline-code">map1</code> are smaller than <code class="inline-code">k</code> and the keys in <code class="inline-code">map2</code> larger than <code class="inline-code">k</code>. Any key equal to <code class="inline-code">k</code> is found in neither <code class="inline-code">map1</code> nor <code class="inline-code">map2</code>.</p>
<pre>split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)</pre>
<p class="src"><a id="v:splitLookup" class="def">splitLookup</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#splitLookup" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:splitLookup" title="Data.Map.Lazy">splitLookup</a> k map</code>) splits a map just like <code><a href="data-map-lazy.html#v:split" title="Data.Map.Lazy">split</a></code> but also returns <code class="inline-code"><a href="data-map-lazy.html#v:lookup" title="Data.Map.Lazy">lookup</a> k map</code>.</p>
<pre>splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)</pre>
<p class="src"><a id="v:splitRoot" class="def">splitRoot</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; [<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b] <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#splitRoot" class="link">Source</a> </p>
<p><span class="mathjax">\(O(1)\)</span>. Decompose a map into pieces based on the structure of the underlying tree. This function is useful for consuming a map in parallel.</p>
<p>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first submap less than all elements in the second, and so on).</p>
<p>Examples:</p>
<pre>splitRoot (fromList (zip [1..6] ['a'..])) ==
  [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d')],fromList [(5,'e'),(6,'f')]]</pre>
<pre>splitRoot empty == []</pre>
<p>Note that the current implementation does not return more than three submaps, but you should not depend on this behaviour because it can change in the future without notice.</p>
<p><span class="version">Since: containers-0.5.4</span></p>
<a href="#g:27" id="g:27"><h2>Submap</h2></a><p class="src"><a id="v:isSubmapOf" class="def">isSubmapOf</a> :: (<a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#isSubmapOf" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. This function is defined as (<code class="inline-code"><a href="data-map-lazy.html#v:isSubmapOf" title="Data.Map.Lazy">isSubmapOf</a> = <a href="data-map-lazy.html#v:isSubmapOfBy" title="Data.Map.Lazy">isSubmapOfBy</a> (==)</code>).</p>
<p class="src"><a id="v:isSubmapOfBy" class="def">isSubmapOfBy</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#isSubmapOfBy" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. The expression (<code class="inline-code"><a href="data-map-lazy.html#v:isSubmapOfBy" title="Data.Map.Lazy">isSubmapOfBy</a> f t1 t2</code>) returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> if all keys in <code class="inline-code">t1</code> are in tree <code class="inline-code">t2</code>, and when <code class="inline-code">f</code> returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> when applied to their respective values. For example, the following expressions are all <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code>:</p>
<pre>isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (&lt;=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])</pre>
<p>But the following are all <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:False" title="Data.Bool">False</a></code>:</p>
<pre>isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (&lt;)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])</pre>
<p>Note that <code class="inline-code">isSubmapOfBy (_ _ -&gt; True) m1 m2</code> tests whether all the keys in <code class="inline-code">m1</code> are also keys in <code class="inline-code">m2</code>.</p>
<p class="src"><a id="v:isProperSubmapOf" class="def">isProperSubmapOf</a> :: (<a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="../base-4.21.0.0-8e62/data-eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#isProperSubmapOf" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Is this a proper submap? (ie. a submap but not equal). Defined as (<code class="inline-code"><a href="data-map-lazy.html#v:isProperSubmapOf" title="Data.Map.Lazy">isProperSubmapOf</a> = <a href="data-map-lazy.html#v:isProperSubmapOfBy" title="Data.Map.Lazy">isProperSubmapOfBy</a> (==)</code>).</p>
<p class="src"><a id="v:isProperSubmapOfBy" class="def">isProperSubmapOfBy</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k b -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#isProperSubmapOfBy" class="link">Source</a> </p>
<p><span class="mathjax">\(O\bigl(m \log\bigl(\frac{n}{m}+1\bigr)\bigr), \; 0 &lt; m \leq n\)</span>. Is this a proper submap? (ie. a submap but not equal). The expression (<code class="inline-code"><a href="data-map-lazy.html#v:isProperSubmapOfBy" title="Data.Map.Lazy">isProperSubmapOfBy</a> f m1 m2</code>) returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> when <code class="inline-code">keys m1</code> and <code class="inline-code">keys m2</code> are not equal, all keys in <code class="inline-code">m1</code> are in <code class="inline-code">m2</code>, and when <code class="inline-code">f</code> returns <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code> when applied to their respective values. For example, the following expressions are all <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:True" title="Data.Bool">True</a></code>:</p>
<pre>isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])</pre>
<p>But the following are all <code><a href="../base-4.21.0.0-8e62/data-bool.html#v:False" title="Data.Bool">False</a></code>:</p>
<pre>isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])</pre>
<a href="#g:28" id="g:28"><h2>Indexed</h2></a><p class="src"><a id="v:lookupIndex" class="def">lookupIndex</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupIndex" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Lookup the <em>index</em> of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from <em>0</em> up to, but not including, the <code><a href="data-map-lazy.html#v:size" title="Data.Map.Lazy">size</a></code> of the map.</p>
<pre>isJust (lookupIndex 2 (fromList [(5,"a"), (3,"b")]))   == False
fromJust (lookupIndex 3 (fromList [(5,"a"), (3,"b")])) == 0
fromJust (lookupIndex 5 (fromList [(5,"a"), (3,"b")])) == 1
isJust (lookupIndex 6 (fromList [(5,"a"), (3,"b")]))   == False</pre>
<p class="src"><a id="v:findIndex" class="def">findIndex</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#findIndex" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Return the <em>index</em> of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from <em>0</em> up to, but not including, the <code><a href="data-map-lazy.html#v:size" title="Data.Map.Lazy">size</a></code> of the map. Calls <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> when the key is not a <code><a href="data-map-lazy.html#v:member" title="Data.Map.Lazy">member</a></code> of the map.</p>
<pre>findIndex 2 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
findIndex 3 (fromList [(5,"a"), (3,"b")]) == 0
findIndex 5 (fromList [(5,"a"), (3,"b")]) == 1
findIndex 6 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map</pre>
<p class="src"><a id="v:elemAt" class="def">elemAt</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#elemAt" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Retrieve an element by its <em>index</em>, i.e. by its zero-based index in the sequence sorted by keys. If the <em>index</em> is out of range (less than zero, greater or equal to <code><a href="data-map-lazy.html#v:size" title="Data.Map.Lazy">size</a></code> of the map), <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> is called.</p>
<pre>elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")
elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")
elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range</pre>
<p class="src"><a id="v:updateAt" class="def">updateAt</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateAt" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update the element at <em>index</em>, i.e. by its zero-based index in the sequence sorted by keys. If the <em>index</em> is out of range (less than zero, greater or equal to <code><a href="data-map-lazy.html#v:size" title="Data.Map.Lazy">size</a></code> of the map), <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> is called.</p>
<pre>updateAt (\ _ _ -&gt; Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]
updateAt (\ _ _ -&gt; Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]
updateAt (\ _ _ -&gt; Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\ _ _ -&gt; Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\_ _  -&gt; Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
updateAt (\_ _  -&gt; Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
updateAt (\_ _  -&gt; Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\_ _  -&gt; Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range</pre>
<p class="src"><a id="v:deleteAt" class="def">deleteAt</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#deleteAt" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete the element at <em>index</em>, i.e. by its zero-based index in the sequence sorted by keys. If the <em>index</em> is out of range (less than zero, greater or equal to <code><a href="data-map-lazy.html#v:size" title="Data.Map.Lazy">size</a></code> of the map), <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> is called.</p>
<pre>deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range
deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range</pre>
<p class="src"><a id="v:take" class="def">take</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#take" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Take a given number of entries in key order, beginning with the smallest keys.</p>
<pre>take n = <a href="data-map-lazy.html#v:fromDistinctAscList" title="Data.Map.Lazy">fromDistinctAscList</a> . <a href="../base-4.21.0.0-8e62/prelude.html#v:take" title="Prelude">take</a> n . <a href="data-map-lazy.html#v:toAscList" title="Data.Map.Lazy">toAscList</a>
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:drop" class="def">drop</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#drop" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Drop a given number of entries in key order, beginning with the smallest keys.</p>
<pre>drop n = <a href="data-map-lazy.html#v:fromDistinctAscList" title="Data.Map.Lazy">fromDistinctAscList</a> . <a href="../base-4.21.0.0-8e62/prelude.html#v:drop" title="Prelude">drop</a> n . <a href="data-map-lazy.html#v:toAscList" title="Data.Map.Lazy">toAscList</a>
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="../base-4.21.0.0-8e62/data-int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (<a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#splitAt" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Split a map at a particular index.</p>
<pre>splitAt !n !xs = (<a href="data-map-lazy.html#v:take" title="Data.Map.Lazy">take</a> n xs, <a href="data-map-lazy.html#v:drop" title="Data.Map.Lazy">drop</a> n xs)
</pre>
<p><span class="version">Since: containers-0.5.8</span></p>
<a href="#g:29" id="g:29"><h2>Min/Max</h2></a><p class="src"><a id="v:lookupMin" class="def">lookupMin</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupMin" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The minimal key of the map. Returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the map is empty.</p>
<pre>lookupMin (fromList [(5,"a"), (3,"b")]) == Just (3,"b")
lookupMin empty = Nothing</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:lookupMax" class="def">lookupMax</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#lookupMax" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The maximal key of the map. Returns <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the map is empty.</p>
<pre>lookupMax (fromList [(5,"a"), (3,"b")]) == Just (5,"a")
lookupMax empty = Nothing</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:findMin" class="def">findMin</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#findMin" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The minimal key of the map. Calls <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> if the map is empty.</p>
<pre>findMin (fromList [(5,"a"), (3,"b")]) == (3,"b")
findMin empty                            Error: empty map has no minimal element</pre>
<p class="src"><a id="v:findMax" class="def">findMax</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#findMax" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. The maximal key of the map. Calls <code><a href="../base-4.21.0.0-8e62/prelude.html#v:error" title="Prelude">error</a></code> if the map is empty.</p>
<pre>findMax (fromList [(5,"a"), (3,"b")]) == (5,"a")
findMax empty                            Error: empty map has no maximal element</pre>
<p class="src"><a id="v:deleteMin" class="def">deleteMin</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#deleteMin" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete the minimal key. Returns an empty map if the map is empty.</p>
<pre>deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(5,"a"), (7,"c")]
deleteMin empty == empty</pre>
<p class="src"><a id="v:deleteMax" class="def">deleteMax</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#deleteMax" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete the maximal key. Returns an empty map if the map is empty.</p>
<pre>deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
deleteMax empty == empty</pre>
<p class="src"><a id="v:deleteFindMin" class="def">deleteFindMin</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; ((k, a), <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#deleteFindMin" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete and find the minimal element.</p>
<pre>deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((3,"b"), fromList[(5,"a"), (10,"c")])
deleteFindMin empty                                      Error: can not return the minimal element of an empty map</pre>
<p class="src"><a id="v:deleteFindMax" class="def">deleteFindMax</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; ((k, a), <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#deleteFindMax" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Delete and find the maximal element.</p>
<pre>deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((10,"c"), fromList [(3,"b"), (5,"a")])
deleteFindMax empty                                      Error: can not return the maximal element of an empty map</pre>
<p class="src"><a id="v:updateMin" class="def">updateMin</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateMin" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update the value at the minimal key.</p>
<pre>updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:updateMax" class="def">updateMax</a> :: (a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateMax" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update the value at the maximal key.</p>
<pre>updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"</pre>
<p class="src"><a id="v:updateMinWithKey" class="def">updateMinWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateMinWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update the value at the minimal key.</p>
<pre>updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a id="v:updateMaxWithKey" class="def">updateMaxWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#updateMaxWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Update the value at the maximal key.</p>
<pre>updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"</pre>
<p class="src"><a id="v:minView" class="def">minView</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#minView" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Retrieves the value associated with minimal key of the map, and the map stripped of that element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if passed an empty map.</p>
<pre>minView (fromList [(5,"a"), (3,"b")]) == Just ("b", singleton 5 "a")
minView empty == Nothing</pre>
<p class="src"><a id="v:maxView" class="def">maxView</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#maxView" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Retrieves the value associated with maximal key of the map, and the map stripped of that element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if passed an empty map.</p>
<pre>maxView (fromList [(5,"a"), (3,"b")]) == Just ("a", singleton 3 "b")
maxView empty == Nothing</pre>
<p class="src"><a id="v:minViewWithKey" class="def">minViewWithKey</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ((k, a), <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#minViewWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if passed an empty map.</p>
<pre>minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
minViewWithKey empty == Nothing</pre>
<p class="src"><a id="v:maxViewWithKey" class="def">maxViewWithKey</a> :: <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ((k, a), <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#maxViewWithKey" class="link">Source</a> </p>
<p><span class="mathjax">\(O(\log n)\)</span>. Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or <code><a href="../base-4.21.0.0-8e62/data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if passed an empty map.</p>
<pre>maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
maxViewWithKey empty == Nothing</pre>
<a href="#g:30" id="g:30"><h2>Debugging</h2></a><p class="src"><a id="v:showTree" class="def">showTree</a> :: Whoops "showTree has moved to Data.Map.Internal.Debug.showTree." =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.DeprecatedShowTree.html#showTree" class="link">Source</a> </p>
<p>This function has moved to <code><a href="data-map-internal-debug.html#v:showTree" title="Data.Map.Internal.Debug">showTree</a></code>.</p>
<p class="src"><a id="v:showTreeWith" class="def">showTreeWith</a> :: Whoops "showTreeWith has moved to Data.Map.Internal.Debug.showTreeWith." =&gt; (k -&gt; a -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a>) -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.DeprecatedShowTree.html#showTreeWith" class="link">Source</a> </p>
<p>This function has moved to <code><a href="data-map-internal-debug.html#v:showTreeWith" title="Data.Map.Internal.Debug">showTreeWith</a></code>.</p>
<p class="src"><a id="v:valid" class="def">valid</a> :: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="data-map-lazy.html#t:Map" title="Data.Map.Lazy">Map</a> k a -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.Debug.html#valid" class="link">Source</a> </p>
<p><span class="mathjax">\(O(n)\)</span>. Test if the internal map structure is valid.</p>
<pre>valid (fromAscList [(3,"b"), (5,"a")]) == True
valid (fromAscList [(5,"a"), (3,"b")]) == False</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Lazy.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Lazy.html</a>
  </p>
</div>
