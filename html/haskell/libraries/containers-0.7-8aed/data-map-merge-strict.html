<h1 class="caption">Data.Map.Merge.Strict</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) David Feuer 2016</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Simple merge tactic types</a></li>
<li>
<a href="#g:2">General combining function</a><ul>
<li><a href="#g:3"><code class="inline-code">WhenMatched</code> tactics</a></li>
<li><a href="#g:4"><code class="inline-code">WhenMissing</code> tactics</a></li>
</ul>
</li>
<li><a href="#g:5">Applicative merge tactic types</a></li>
<li>
<a href="#g:6">Applicative general combining function</a><ul>
<li><a href="#g:7"><code class="inline-code">WhenMatched</code> tactics</a></li>
<li><a href="#g:8"><code class="inline-code">WhenMissing</code> tactics</a></li>
</ul>
</li>
<li><a href="#g:9">Covariant maps for tactics</a></li>
<li><a href="#g:10">Miscellaneous functions on tactics</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>This module defines an API for writing functions that merge two maps. The key functions are <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> and <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>. Each of these can be used with several different "merge tactics".</p>
<p>The <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> and <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use <code><a href="data-map-merge-strict.html#v:mapMissing" title="Data.Map.Merge.Strict">mapMissing</a></code> from this module then the results will be forced before they are inserted. If you use <code><a href="data-map-merge-lazy.html#v:mapMissing" title="Data.Map.Merge.Lazy">mapMissing</a></code> from <a href="data-map-merge-lazy.html">Data.Map.Merge.Lazy</a> then they will not.</p>
<h3>
<code><a href="data-map-merge-strict.html#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> inconsistency</h3>
<p>For historical reasons, the preserved values are /<em>not</em>/ forced. To force them, use <code><a href="data-map-merge-strict.html#v:preserveMissing-39-" title="Data.Map.Merge.Strict">preserveMissing'</a></code>.</p>
<h3>Efficiency note</h3>
<p>The <code><a href="../base-4.21.0.0-8e62/control-category.html#v:Category" title="Control.Category">Category</a></code>, <code><a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>, and <code><a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a></code> instances for <code><a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for <code><a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactics should not pose any major efficiency problems.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div>
<a href="#g:1" id="g:1"><h3>Simple merge tactic types</h3></a><p class="src">type <a id="t:SimpleWhenMissing" class="def">SimpleWhenMissing</a> = <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#SimpleWhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p>A tactic of type <code class="inline-code"> SimpleWhenMissing k x z </code> is an abstract representation of a function of type <code class="inline-code"> k -&gt; x -&gt; Maybe z </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src">type <a id="t:SimpleWhenMatched" class="def">SimpleWhenMatched</a> = <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#SimpleWhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p>A tactic of type <code class="inline-code"> SimpleWhenMatched k x y z </code> is an abstract representation of a function of type <code class="inline-code"> k -&gt; x -&gt; y -&gt; Maybe z </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:2" id="g:2"><h3>General combining function</h3></a><p class="src"><a id="v:merge" class="def">merge</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#merge" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="data-map-merge-strict.html#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a> k a c</td>
<td class="doc"><p>What to do with keys in <code class="inline-code">m1</code> but not <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict.html#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a> k b c</td>
<td class="doc"><p>What to do with keys in <code class="inline-code">m2</code> but not <code class="inline-code">m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict.html#t:SimpleWhenMatched" title="Data.Map.Merge.Strict">SimpleWhenMatched</a> k a b c</td>
<td class="doc"><p>What to do with keys in both <code class="inline-code">m1</code> and <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k a</td>
<td class="doc"><p>Map <code class="inline-code">m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k b</td>
<td class="doc"><p>Map <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k c</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>Merge two maps.</p>
<p><code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> takes two <code><a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics, a <code><a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-map-merge-lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> and <code><a href="data-map-merge-lazy.html#v:zipWithMaybeMatched" title="Data.Map.Merge.Lazy">zipWithMaybeMatched</a></code>.</p>
<p>Consider</p>
<pre>merge (mapMaybeMissing g1)
             (mapMaybeMissing g2)
             (zipWithMaybeMatched f)
             m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code class="inline-code">g1</code>, <code class="inline-code">g2</code>, or <code class="inline-code">f</code> as appropriate:</p>
<pre>maybes = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>This produces a <code><a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> for each key:</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code class="inline-code">Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-map-merge-lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-map-merge-strict.html#v:dropMissing" title="Data.Map.Merge.Strict">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-map-merge-strict.html#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> leaves all the entries alone.</li>
</ul>
<p>When <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> to define your custom combining functions.</p>
<p>Examples:</p>
<pre>unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)</pre>
<pre>intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)</pre>
<pre>differenceWith f = merge preserveMissing dropMissing (zipWithMatched f)</pre>
<pre>symmetricDifference = merge preserveMissing preserveMissing (zipWithMaybeMatched $ \ _ _ _ -&gt; Nothing)</pre>
<pre>mapEachPiece f g h = merge (mapMissing f) (mapMissing g) (zipWithMatched h)</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:3" id="g:3"><h4>
<code class="inline-code">WhenMatched</code> tactics</h4></a><p class="src"><a id="v:zipWithMaybeMatched" class="def">zipWithMaybeMatched</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y z. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#zipWithMaybeMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</p>
<pre>zipWithMaybeMatched :: (k -&gt; x -&gt; y -&gt; Maybe z)
                    -&gt; SimpleWhenMatched k x y z
</pre>
<p class="src"><a id="v:zipWithMatched" class="def">zipWithMatched</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y z. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; z) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#zipWithMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</p>
<pre>zipWithMatched :: (k -&gt; x -&gt; y -&gt; z)
               -&gt; SimpleWhenMatched k x y z
</pre>
<a href="#g:4" id="g:4"><h4>
<code class="inline-code">WhenMissing</code> tactics</h4></a><p class="src"><a id="v:mapMaybeMissing" class="def">mapMaybeMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#mapMaybeMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful <code><a href="data-map-merge-strict.html#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a></code> tactic, but others are usually more efficient.</p>
<pre>mapMaybeMissing :: (k -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing k x y
</pre>
<pre>mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</pre>
<p>but <code class="inline-code">mapMaybeMissing</code> uses fewer unnecessary <code><a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> operations.</p>
<p class="src"><a id="v:dropMissing" class="def">dropMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#dropMissing" class="link">Source</a> </p>
<p>Drop all the entries whose keys are missing from the other map.</p>
<pre>dropMissing :: SimpleWhenMissing k x y
</pre>
<pre>dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)</pre>
<p>but <code class="inline-code">dropMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:preserveMissing" class="def">preserveMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#preserveMissing" class="link">Source</a> </p>
<p>Preserve, unchanged, the entries whose keys are missing from the other map.</p>
<pre>preserveMissing :: SimpleWhenMissing k x x
</pre>
<pre>preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)</pre>
<p>but <code class="inline-code">preserveMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:preserveMissing-39-" class="def">preserveMissing'</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#preserveMissing%27" class="link">Source</a> </p>
<p>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</p>
<pre>preserveMissing' :: SimpleWhenMissing k x x
</pre>
<pre>preserveMissing' = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just $! x)</pre>
<p>but <code class="inline-code">preserveMissing'</code> is quite a bit faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:mapMissing" class="def">mapMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#mapMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map.</p>
<pre>mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing k x y
</pre>
<pre>mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</pre>
<p>but <code class="inline-code">mapMissing</code> is somewhat faster.</p>
<p class="src"><a id="v:filterMissing" class="def">filterMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x. <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#filterMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map.</p>
<pre>filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing k x x
</pre>
<pre>filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:5" id="g:5"><h3>Applicative merge tactic types</h3></a><p class="src">data <a id="t:WhenMissing" class="def">WhenMissing</a> (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#WhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> or <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>.</p>
<p>A tactic of type <code class="inline-code"> WhenMissing f k x z </code> is an abstract representation of a function of type <code class="inline-code"> k -&gt; x -&gt; f (Maybe z) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMissing">Instances</h5>
<details id="i:WhenMissing" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-category.html#t:Category" title="Control.Category">Category</a> (<a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2138" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a a </p>
<p class="src"><a href="#v:.">(.)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k b c -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a c </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2152" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code class="inline-code"> ReaderT k (ReaderT x (MaybeT f)) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x c </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> (<a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2133" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2165" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code class="inline-code"> ReaderT k (ReaderT x (MaybeT f)) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; (a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src">data <a id="t:WhenMatched" class="def">WhenMatched</a> (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) k x y z <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#WhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> or <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>.</p>
<p>A tactic of type <code class="inline-code"> WhenMatched f k x y z </code> is an abstract representation of a function of type <code class="inline-code"> k -&gt; x -&gt; y -&gt; f (Maybe z) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMatched">Instances</h5>
<details id="i:WhenMatched" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-category.html#t:Category" title="Control.Category">Category</a> (<a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2273" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a a </p>
<p class="src"><a href="#v:.">(.)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x b c -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a c </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2287" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code class="inline-code"> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y c </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> (<a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2268" class="link">Source</a> </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.21.0.0-8e62/control-monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#line-2300" class="link">Source</a> </td>
<td class="doc">
<p>Equivalent to <code class="inline-code"> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; (a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a </p>
</div></details></td></tr>
</table></details>
</div>
<a href="#g:6" id="g:6"><h3>Applicative general combining function</h3></a><p class="src"><a id="v:mergeA" class="def">mergeA</a> <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#mergeA" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: (<a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.21.0.0-8e62/data-ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a c</td>
<td class="doc"><p>What to do with keys in <code class="inline-code">m1</code> but not <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k b c</td>
<td class="doc"><p>What to do with keys in <code class="inline-code">m2</code> but not <code class="inline-code">m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k a b c</td>
<td class="doc"><p>What to do with keys in both <code class="inline-code">m1</code> and <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k a</td>
<td class="doc"><p>Map <code class="inline-code">m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k b</td>
<td class="doc"><p>Map <code class="inline-code">m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; f (<a href="data-map-strict.html#t:Map" title="Data.Map.Strict">Map</a> k c)</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>An applicative version of <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p><code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> takes two <code><a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics, a <code><a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-map-merge-lazy.html#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> and <code><a href="data-map-merge-lazy.html#v:zipWithMaybeAMatched" title="Data.Map.Merge.Lazy">zipWithMaybeAMatched</a></code>.</p>
<p>Consider</p>
<pre>mergeA (traverseMaybeMissing g1)
              (traverseMaybeMissing g2)
              (zipWithMaybeAMatched f)
              m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code class="inline-code">mergeA</code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code class="inline-code">g1</code>, <code class="inline-code">g2</code>, or <code class="inline-code">f</code> as appropriate:</p>
<pre>actions = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>Next, it will perform the actions in the <code class="inline-code">actions</code> list in order from left to right.</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code class="inline-code">Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-map-merge-lazy.html#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-map-merge-strict.html#v:dropMissing" title="Data.Map.Merge.Strict">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-map-merge-strict.html#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> leaves all the entries alone.</li>
<li>
<code><a href="data-map-merge-lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> does not use the <code><a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context.</li>
</ul>
<p>When <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> to define custom combining functions.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:7" id="g:7"><h4>
<code class="inline-code">WhenMatched</code> tactics</h4></a><p>The tactics described for <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> work for <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:zipWithMaybeAMatched" class="def">zipWithMaybeAMatched</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z)) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#zipWithMaybeAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</p>
<p>This is the fundamental <code><a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic.</p>
<p class="src"><a id="v:zipWithAMatched" class="def">zipWithAMatched</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f z) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#zipWithAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</p>
<a href="#g:8" id="g:8"><h4>
<code class="inline-code">WhenMissing</code> tactics</h4></a><p>The tactics described for <code><a href="data-map-merge-strict.html#v:merge" title="Data.Map.Merge.Strict">merge</a></code> work for <code><a href="data-map-merge-strict.html#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:traverseMaybeMissing" class="def">traverseMaybeMissing</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y)) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#traverseMaybeMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful <code><a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactic, but others are usually more efficient.</p>
<p class="src"><a id="v:traverseMissing" class="def">traverseMissing</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f y) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#traverseMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map.</p>
<p class="src"><a id="v:filterAMissing" class="def">filterAMissing</a> :: <a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f <a href="../base-4.21.0.0-8e62/data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#filterAMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map using some <code><a href="../base-4.21.0.0-8e62/control-applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> action.</p>
<pre>filterAMissing f = Merge.Lazy.traverseMaybeMissing $
  \k x -&gt; (\b -&gt; guard b *&gt; Just x) &lt;$&gt; f k x</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:9" id="g:9"><h3>Covariant maps for tactics</h3></a><p class="src"><a id="v:mapWhenMissing" class="def">mapWhenMissing</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) a b k x. <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#mapWhenMissing" class="link">Source</a> </p>
<p>Map covariantly over a <code class="inline-code"><a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x</code>.</p>
<p class="src"><a id="v:mapWhenMatched" class="def">mapWhenMatched</a> :: forall (f :: <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.21.0.0-8e62/data-kind.html#t:Type" title="Data.Kind">Type</a>) a b k x y. <a href="../base-4.21.0.0-8e62/control-monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Strict.Internal.html#mapWhenMatched" class="link">Source</a> </p>
<p>Map covariantly over a <code class="inline-code"><a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y</code>.</p>
<a href="#g:10" id="g:10"><h3>Miscellaneous functions on tactics</h3></a><p class="src"><a id="v:runWhenMatched" class="def">runWhenMatched</a> :: <a href="data-map-merge-strict.html#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z -&gt; k -&gt; x -&gt; y -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#runWhenMatched" class="link">Source</a> </p>
<p>Along with zipWithMaybeAMatched, witnesses the isomorphism between <code class="inline-code">WhenMatched f k x y z</code> and <code class="inline-code">k -&gt; x -&gt; y -&gt; f (Maybe z)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:runWhenMissing" class="def">runWhenMissing</a> :: <a href="data-map-merge-strict.html#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y -&gt; k -&gt; x -&gt; f (<a href="../base-4.21.0.0-8e62/data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/src/Data.Map.Internal.html#runWhenMissing" class="link">Source</a> </p>
<p>Along with traverseMaybeMissing, witnesses the isomorphism between <code class="inline-code">WhenMissing f k x y</code> and <code class="inline-code">k -&gt; x -&gt; f (Maybe y)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Merge-Strict.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.12.1/docs/libraries/containers-0.7-8aed/Data-Map-Merge-Strict.html</a>
  </p>
</div>
