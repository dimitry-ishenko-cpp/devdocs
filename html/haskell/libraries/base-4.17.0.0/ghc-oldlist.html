<h1 class="caption">GHC.OldList</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 2001</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file libraries/base/LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>stable</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Basic functions</a></li>
<li><a href="#g:2">List transformations</a></li>
<li>
<a href="#g:3">Reducing lists (folds)</a><ul><li><a href="#g:4">Special folds</a></li></ul>
</li>
<li>
<a href="#g:5">Building lists</a><ul>
<li><a href="#g:6">Scans</a></li>
<li><a href="#g:7">Accumulating maps</a></li>
<li><a href="#g:8">Infinite lists</a></li>
<li><a href="#g:9">Unfolding</a></li>
</ul>
</li>
<li>
<a href="#g:10">Sublists</a><ul>
<li><a href="#g:11">Extracting sublists</a></li>
<li><a href="#g:12">Predicates</a></li>
</ul>
</li>
<li>
<a href="#g:13">Searching lists</a><ul>
<li><a href="#g:14">Searching by equality</a></li>
<li><a href="#g:15">Searching with a predicate</a></li>
</ul>
</li>
<li><a href="#g:16">Indexing lists</a></li>
<li><a href="#g:17">Zipping and unzipping lists</a></li>
<li>
<a href="#g:18">Special lists</a><ul>
<li><a href="#g:19">Functions on strings</a></li>
<li><a href="#g:20">"Set" operations</a></li>
<li><a href="#g:21">Ordered lists</a></li>
</ul>
</li>
<li>
<a href="#g:22">Generalized functions</a><ul>
<li>
<a href="#g:23">The "<code>By</code>" operations</a><ul>
<li><a href="#g:24">User-supplied equality (replacing an <code>Eq</code> context)</a></li>
<li><a href="#g:25">User-supplied comparison (replacing an <code>Ord</code> context)</a></li>
</ul>
</li>
<li><a href="#g:26">The "<code>generic</code>" operations</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>This legacy module provides access to the list-specialised operations of <a href="data-list.html">Data.List</a>. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the <a href="https://wiki.haskell.org/Foldable_Traversable_In_Prelude">Foldable/Traversable-in-Prelude Proposal (FTP)</a>.</p>
<p>If the operations needed are available in <a href="ghc-list.html">GHC.List</a>, it's recommended to avoid importing this module and use <a href="ghc-list.html">GHC.List</a> instead for now.</p>
<p><span class="version">Since: base-4.8.0.0</span></p>
</div>
<a href="#g:1" id="g:1"><h2>Basic functions</h2></a><p class="src"><a id="v:-43--43-" class="def">(++)</a> :: [a] -&gt; [a] -&gt; [a] <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%2B%2B" class="link">Source</a> </p>
<p>Append two lists, i.e.,</p>
<pre>[x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
[x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</pre>
<p>If the first list is not finite, the result is the first list.</p>
<p>WARNING: This function takes linear time in the number of elements of the first list.</p>
<p class="src"><a id="v:head" class="def">head</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#head" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the first element of a list, which must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head [1, 2, 3]
</strong>1
&gt;&gt;&gt; <strong class="userinput">head [1..]
</strong>1
&gt;&gt;&gt; <strong class="userinput">head []
</strong>*** Exception: Prelude.head: empty list
</pre>
<p>WARNING: This function is partial. You can use case-matching, <code><a href="ghc-oldlist.html#v:uncons" title="GHC.OldList">uncons</a></code> or <code><a href="data-maybe.html#v:listToMaybe" title="Data.Maybe">listToMaybe</a></code> instead.</p>
<p class="src"><a id="v:last" class="def">last</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#last" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Extract the last element of a list, which must be finite and non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last [1, 2, 3]
</strong>3
&gt;&gt;&gt; <strong class="userinput">last [1..]
</strong>* Hangs forever *
&gt;&gt;&gt; <strong class="userinput">last []
</strong>*** Exception: Prelude.last: empty list
</pre>
<p>WARNING: This function is partial. You can use <code><a href="ghc-oldlist.html#v:reverse" title="GHC.OldList">reverse</a></code> with case-matching, <code><a href="ghc-oldlist.html#v:uncons" title="GHC.OldList">uncons</a></code> or <code><a href="data-maybe.html#v:listToMaybe" title="Data.Maybe">listToMaybe</a></code> instead.</p>
<p class="src"><a id="v:tail" class="def">tail</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#tail" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the elements after the head of a list, which must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tail [1, 2, 3]
</strong>[2,3]
&gt;&gt;&gt; <strong class="userinput">tail [1]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">tail []
</strong>*** Exception: Prelude.tail: empty list
</pre>
<p>WARNING: This function is partial. You can use case-matching or <code><a href="ghc-oldlist.html#v:uncons" title="GHC.OldList">uncons</a></code> instead.</p>
<p class="src"><a id="v:init" class="def">init</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#init" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Return all the elements of a list except the last one. The list must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">init [1, 2, 3]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">init [1]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">init []
</strong>*** Exception: Prelude.init: empty list
</pre>
<p>WARNING: This function is partial. You can use <code><a href="ghc-oldlist.html#v:reverse" title="GHC.OldList">reverse</a></code> with case-matching or <code><a href="ghc-oldlist.html#v:uncons" title="GHC.OldList">uncons</a></code> instead.</p>
<p class="src"><a id="v:uncons" class="def">uncons</a> :: [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#uncons" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Decompose a list into its head and tail.</p>
<ul>
<li>If the list is empty, returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li>
<li>If the list is non-empty, returns <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a> (x, xs)</code>, where <code>x</code> is the head of the list and <code>xs</code> its tail.</li>
</ul>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">uncons []
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">uncons [1]
</strong>Just (1,[])
&gt;&gt;&gt; <strong class="userinput">uncons [1, 2, 3]
</strong>Just (1,[2,3])
</pre>
<p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:singleton" class="def">singleton</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#singleton" class="link">Source</a> </p>
<p>Produce singleton list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">singleton True
</strong>[True]
</pre>
<p><span class="version">Since: base-4.15.0.0</span></p>
<p class="src"><a id="v:null" class="def">null</a> :: [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#null" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Test whether a list is empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">null []
</strong>True
&gt;&gt;&gt; <strong class="userinput">null [1]
</strong>False
&gt;&gt;&gt; <strong class="userinput">null [1..]
</strong>False
</pre>
<p class="src"><a id="v:length" class="def">length</a> :: [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#length" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a></code> returns the length of a finite list as an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>. It is an instance of the more general <code><a href="data-list.html#v:genericLength" title="Data.List">genericLength</a></code>, the result type of which may be any kind of number.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">length []
</strong>0
&gt;&gt;&gt; <strong class="userinput">length ['a', 'b', 'c']
</strong>3
&gt;&gt;&gt; <strong class="userinput">length [1..]
</strong>* Hangs forever *
</pre>
<a href="#g:2" id="g:2"><h2>List transformations</h2></a><p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#map" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:map" title="GHC.OldList">map</a></code> <code>f xs</code> is the list obtained by applying <code>f</code> to each element of <code>xs</code>, i.e.,</p>
<pre>map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
map f [x1, x2, ...] == [f x1, f x2, ...]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">map (+1) [1, 2, 3]
</strong>[2,3,4]
</pre>
<p class="src"><a id="v:reverse" class="def">reverse</a> :: [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#reverse" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:reverse" title="GHC.OldList">reverse</a></code> <code>xs</code> returns the elements of <code>xs</code> in reverse order. <code>xs</code> must be finite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">reverse [42]
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">reverse [2,5,7]
</strong>[7,5,2]
&gt;&gt;&gt; <strong class="userinput">reverse [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:intersperse" class="def">intersperse</a> :: a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#intersperse" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="ghc-oldlist.html#v:intersperse" title="GHC.OldList">intersperse</a></code> function takes an element and a list and `intersperses' that element between the elements of the list. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intersperse ',' "abcde"
</strong>"a,b,c,d,e"
</pre>
<p class="src"><a id="v:intercalate" class="def">intercalate</a> :: [a] -&gt; [[a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#intercalate" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:intercalate" title="GHC.OldList">intercalate</a></code> <code>xs xss</code> is equivalent to <code>(<a href="ghc-oldlist.html#v:concat" title="GHC.OldList">concat</a> (<a href="ghc-oldlist.html#v:intersperse" title="GHC.OldList">intersperse</a> xs xss))</code>. It inserts the list <code>xs</code> in between the lists in <code>xss</code> and concatenates the result.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">intercalate ", " ["Lorem", "ipsum", "dolor"]
</strong>"Lorem, ipsum, dolor"
</pre>
<p class="src"><a id="v:transpose" class="def">transpose</a> :: [[a]] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#transpose" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:transpose" title="GHC.OldList">transpose</a></code> function transposes the rows and columns of its argument. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">transpose [[1,2,3],[4,5,6]]
</strong>[[1,4],[2,5],[3,6]]
</pre>
<p>If some of the rows are shorter than the following rows, their elements are skipped:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">transpose [[10,11],[20],[],[30,31,32]]
</strong>[[10,20,30],[11,31],[32]]
</pre>
<p class="src"><a id="v:subsequences" class="def">subsequences</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#subsequences" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:subsequences" title="GHC.OldList">subsequences</a></code> function returns the list of all subsequences of the argument.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">subsequences "abc"
</strong>["","a","b","ab","c","ac","bc","abc"]
</pre>
<p class="src"><a id="v:permutations" class="def">permutations</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#permutations" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:permutations" title="GHC.OldList">permutations</a></code> function returns the list of all permutations of the argument.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">permutations "abc"
</strong>["abc","bac","cba","bca","cab","acb"]
</pre>
<a href="#g:3" id="g:3"><h2>Reducing lists (folds)</h2></a><p class="src"><a id="v:foldl" class="def">foldl</a> :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code>, applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</p>
<pre>foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn</pre>
<p>The list must be finite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl (+) 0 [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldl (+) 42 []
</strong>42
&gt;&gt;&gt; <strong class="userinput">foldl (-) 100 [1..4]
</strong>90
&gt;&gt;&gt; <strong class="userinput">foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>"dcbafoo"
&gt;&gt;&gt; <strong class="userinput">foldl (+) 0 [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl%27" class="link">Source</a> </p>
<p>A strict version of <code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code>.</p>
<p class="src"><a id="v:foldl1" class="def">foldl1</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl1" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:foldl1" title="GHC.OldList">foldl1</a></code> is a variant of <code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code> that has no starting value argument, and thus must be applied to non-empty lists. Note that unlike <code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code>, the accumulated value must be of the same type as the list elements.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldl1 (+) []
</strong>*** Exception: Prelude.foldl1: empty list
&gt;&gt;&gt; <strong class="userinput">foldl1 (-) [1..4]
</strong>-8
&gt;&gt;&gt; <strong class="userinput">foldl1 (&amp;&amp;) [True, False, True, True]
</strong>False
&gt;&gt;&gt; <strong class="userinput">foldl1 (||) [False, False, True, True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl1%27" class="link">Source</a> </p>
<p>A strict version of <code><a href="ghc-oldlist.html#v:foldl1" title="GHC.OldList">foldl1</a></code>.</p>
<p class="src"><a id="v:foldr" class="def">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#foldr" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code>, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</p>
<pre>foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</pre>
<p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldr1" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:foldr1" title="GHC.OldList">foldr1</a></code> is a variant of <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code> that has no starting value argument, and thus must be applied to non-empty lists. Note that unlike <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code>, the accumulated value must be of the same type as the list elements.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldr1 (+) []
</strong>*** Exception: Prelude.foldr1: empty list
&gt;&gt;&gt; <strong class="userinput">foldr1 (-) [1..4]
</strong>-2
&gt;&gt;&gt; <strong class="userinput">foldr1 (&amp;&amp;) [True, False, True, True]
</strong>False
&gt;&gt;&gt; <strong class="userinput">foldr1 (||) [False, False, True, True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">force $ foldr1 (+) [1..]
</strong>*** Exception: stack overflow
</pre>
<a href="#g:4" id="g:4"><h3>Special folds</h3></a><p class="src"><a id="v:concat" class="def">concat</a> :: [[a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#concat" class="link">Source</a> </p>
<p>Concatenate a list of lists.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concat []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">concat [[42]]
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">concat [[1,2,3], [4,5], [6], []]
</strong>[1,2,3,4,5,6]
</pre>
<p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (a -&gt; [b]) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#concatMap" class="link">Source</a> </p>
<p>Map a function returning a list over a list and concatenate the results. <code><a href="ghc-oldlist.html#v:concatMap" title="GHC.OldList">concatMap</a></code> can be seen as the composition of <code><a href="ghc-oldlist.html#v:concat" title="GHC.OldList">concat</a></code> and <code><a href="ghc-oldlist.html#v:map" title="GHC.OldList">map</a></code>.</p>
<pre>concatMap f xs == (concat . map f) xs</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concatMap (\i -&gt; [-i,i]) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">concatMap (\i -&gt; [-i,i]) [1,2,3]
</strong>[-1,1,-2,2,-3,3]
</pre>
<p class="src"><a id="v:and" class="def">and</a> :: [<a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#and" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:and" title="GHC.OldList">and</a></code> returns the conjunction of a Boolean list. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the list must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and []
</strong>True
&gt;&gt;&gt; <strong class="userinput">and [True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">and [False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">and [True, True, False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
</strong>False
&gt;&gt;&gt; <strong class="userinput">and (repeat True)
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:or" class="def">or</a> :: [<a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#or" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:or" title="GHC.OldList">or</a></code> returns the disjunction of a Boolean list. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or []
</strong>False
&gt;&gt;&gt; <strong class="userinput">or [True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">or [False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">or [True, True, False]
</strong>True
&gt;&gt;&gt; <strong class="userinput">or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
</strong>True
&gt;&gt;&gt; <strong class="userinput">or (repeat False)
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:any" class="def">any</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#any" class="link">Source</a> </p>
<p>Applied to a predicate and a list, <code><a href="ghc-oldlist.html#v:any" title="GHC.OldList">any</a></code> determines if any element of the list satisfies the predicate. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value for the predicate applied to an element at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) []
</strong>False
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2,3,4,5]
</strong>True
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1..]
</strong>True
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [0, -1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:all" class="def">all</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#all" class="link">Source</a> </p>
<p>Applied to a predicate and a list, <code><a href="ghc-oldlist.html#v:all" title="GHC.OldList">all</a></code> determines if all elements of the list satisfy the predicate. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the list must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value for the predicate applied to an element at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) []
</strong>True
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2,3,4,5]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1..]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:sum" class="def">sum</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#sum" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:sum" title="GHC.OldList">sum</a></code> function computes the sum of a finite list of numbers.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum []
</strong>0
&gt;&gt;&gt; <strong class="userinput">sum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">sum [1..10]
</strong>55
&gt;&gt;&gt; <strong class="userinput">sum [4.1, 2.0, 1.7]
</strong>7.8
&gt;&gt;&gt; <strong class="userinput">sum [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:product" class="def">product</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#product" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:product" title="GHC.OldList">product</a></code> function computes the product of a finite list of numbers.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product []
</strong>1
&gt;&gt;&gt; <strong class="userinput">product [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">product [1..10]
</strong>3628800
&gt;&gt;&gt; <strong class="userinput">product [4.1, 2.0, 1.7]
</strong>13.939999999999998
&gt;&gt;&gt; <strong class="userinput">product [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a>) =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#maximum" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:maximum" title="GHC.OldList">maximum</a></code> returns the maximum value from a list, which must be non-empty, finite, and of an ordered type. It is a special case of <code><a href="data-list.html#v:maximumBy" title="Data.List">maximumBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximum []
</strong>*** Exception: Prelude.maximum: empty list
&gt;&gt;&gt; <strong class="userinput">maximum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">maximum [55, -12, 7, 0, -89]
</strong>55
&gt;&gt;&gt; <strong class="userinput">maximum [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a>) =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#minimum" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:minimum" title="GHC.OldList">minimum</a></code> returns the minimum value from a list, which must be non-empty, finite, and of an ordered type. It is a special case of <code><a href="data-list.html#v:minimumBy" title="Data.List">minimumBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimum []
</strong>*** Exception: Prelude.minimum: empty list
&gt;&gt;&gt; <strong class="userinput">minimum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">minimum [55, -12, 7, 0, -89]
</strong>-89
&gt;&gt;&gt; <strong class="userinput">minimum [1..]
</strong>* Hangs forever *
</pre>
<a href="#g:5" id="g:5"><h2>Building lists</h2></a><a href="#g:6" id="g:6"><h3>Scans</h3></a><p class="src"><a id="v:scanl" class="def">scanl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:scanl" title="GHC.OldList">scanl</a></code> is similar to <code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code>, but returns a list of successive reduced values from the left:</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>last (scanl f z xs) == foldl f z xs</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (+) 0 [1..4]
</strong>[0,1,3,6,10]
&gt;&gt;&gt; <strong class="userinput">scanl (+) 42 []
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">scanl (-) 100 [1..4]
</strong>[100,99,97,94,90]
&gt;&gt;&gt; <strong class="userinput">scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["foo","afoo","bafoo","cbafoo","dcbafoo"]
&gt;&gt;&gt; <strong class="userinput">scanl (+) 0 [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl%27" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. A strict version of <code><a href="ghc-oldlist.html#v:scanl" title="GHC.OldList">scanl</a></code>.</p>
<p class="src"><a id="v:scanl1" class="def">scanl1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:scanl1" title="GHC.OldList">scanl1</a></code> is a variant of <code><a href="ghc-oldlist.html#v:scanl" title="GHC.OldList">scanl</a></code> that has no starting value argument:</p>
<pre>scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (+) [1..4]
</strong>[1,3,6,10]
&gt;&gt;&gt; <strong class="userinput">scanl1 (+) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">scanl1 (-) [1..4]
</strong>[1,-1,-4,-8]
&gt;&gt;&gt; <strong class="userinput">scanl1 (&amp;&amp;) [True, False, True, True]
</strong>[True,False,False,False]
&gt;&gt;&gt; <strong class="userinput">scanl1 (||) [False, False, True, True]
</strong>[False,False,True,True]
&gt;&gt;&gt; <strong class="userinput">scanl1 (+) [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:scanr" class="def">scanr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanr" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:scanr" title="GHC.OldList">scanr</a></code> is the right-to-left dual of <code><a href="ghc-oldlist.html#v:scanl" title="GHC.OldList">scanl</a></code>. Note that the order of parameters on the accumulating function are reversed compared to <code><a href="ghc-oldlist.html#v:scanl" title="GHC.OldList">scanl</a></code>. Also note that</p>
<pre>head (scanr f z xs) == foldr f z xs.</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (+) 0 [1..4]
</strong>[10,9,7,4,0]
&gt;&gt;&gt; <strong class="userinput">scanr (+) 42 []
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">scanr (-) 100 [1..4]
</strong>[98,-97,99,-96,100]
&gt;&gt;&gt; <strong class="userinput">scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
&gt;&gt;&gt; <strong class="userinput">force $ scanr (+) 0 [1..]
</strong>*** Exception: stack overflow
</pre>
<p class="src"><a id="v:scanr1" class="def">scanr1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanr1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:scanr1" title="GHC.OldList">scanr1</a></code> is a variant of <code><a href="ghc-oldlist.html#v:scanr" title="GHC.OldList">scanr</a></code> that has no starting value argument.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (+) [1..4]
</strong>[10,9,7,4]
&gt;&gt;&gt; <strong class="userinput">scanr1 (+) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">scanr1 (-) [1..4]
</strong>[-2,3,-1,4]
&gt;&gt;&gt; <strong class="userinput">scanr1 (&amp;&amp;) [True, False, True, True]
</strong>[False,False,True,True]
&gt;&gt;&gt; <strong class="userinput">scanr1 (||) [True, True, False, False]
</strong>[True,True,False,False]
&gt;&gt;&gt; <strong class="userinput">force $ scanr1 (+) [1..]
</strong>*** Exception: stack overflow
</pre>
<a href="#g:7" id="g:7"><h3>Accumulating maps</h3></a><p class="src"><a id="v:mapAccumL" class="def">mapAccumL</a> :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#mapAccumL" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:mapAccumL" title="GHC.OldList">mapAccumL</a></code> function behaves like a combination of <code><a href="ghc-oldlist.html#v:map" title="GHC.OldList">map</a></code> and <code><a href="ghc-oldlist.html#v:foldl" title="GHC.OldList">foldl</a></code>; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</p>
<p class="src"><a id="v:mapAccumR" class="def">mapAccumR</a> :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#mapAccumR" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:mapAccumR" title="GHC.OldList">mapAccumR</a></code> function behaves like a combination of <code><a href="ghc-oldlist.html#v:map" title="GHC.OldList">map</a></code> and <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code>; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</p>
<a href="#g:8" id="g:8"><h3>Infinite lists</h3></a><p class="src"><a id="v:iterate" class="def">iterate</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#iterate" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:iterate" title="GHC.OldList">iterate</a></code> <code>f x</code> returns an infinite list of repeated applications of <code>f</code> to <code>x</code>:</p>
<pre>iterate f x == [x, f x, f (f x), ...]</pre>
<p>Note that <code><a href="ghc-oldlist.html#v:iterate" title="GHC.OldList">iterate</a></code> is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See <code><a href="ghc-oldlist.html#v:iterate-39-" title="GHC.OldList">iterate'</a></code> for a strict variant of this function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate not True
</strong>[True,False,True,False...
&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate (+3) 42
</strong>[42,45,48,51,54,57,60,63...
</pre>
<p class="src"><a id="v:iterate-39-" class="def">iterate'</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#iterate%27" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:iterate-39-" title="GHC.OldList">iterate'</a></code> is the strict version of <code><a href="ghc-oldlist.html#v:iterate" title="GHC.OldList">iterate</a></code>.</p>
<p>It forces the result of each application of the function to weak head normal form (WHNF) before proceeding.</p>
<p class="src"><a id="v:repeat" class="def">repeat</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#repeat" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:repeat" title="GHC.OldList">repeat</a></code> <code>x</code> is an infinite list, with <code>x</code> the value of every element.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 20 $ repeat 17
</strong>[17,17,17,17,17,17,17,17,17...
</pre>
<p class="src"><a id="v:replicate" class="def">replicate</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#replicate" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:replicate" title="GHC.OldList">replicate</a></code> <code>n x</code> is a list of length <code>n</code> with <code>x</code> the value of every element. It is an instance of the more general <code><a href="data-list.html#v:genericReplicate" title="Data.List">genericReplicate</a></code>, in which <code>n</code> may be of any integral type.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">replicate 0 True
</strong>[]
&gt;&gt;&gt; <strong class="userinput">replicate (-1) True
</strong>[]
&gt;&gt;&gt; <strong class="userinput">replicate 4 True
</strong>[True,True,True,True]
</pre>
<p class="src"><a id="v:cycle" class="def">cycle</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#cycle" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:cycle" title="GHC.OldList">cycle</a></code> ties a finite list into a circular one, or equivalently, the infinite repetition of the original list. It is the identity on infinite lists.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">cycle []
</strong>*** Exception: Prelude.cycle: empty list
&gt;&gt;&gt; <strong class="userinput">take 20 $ cycle [42]
</strong>[42,42,42,42,42,42,42,42,42,42...
&gt;&gt;&gt; <strong class="userinput">take 20 $ cycle [2, 5, 7]
</strong>[2,5,7,2,5,7,2,5,7,2,5,7...
</pre>
<a href="#g:9" id="g:9"><h3>Unfolding</h3></a><p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (b -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unfoldr" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unfoldr" title="GHC.OldList">unfoldr</a></code> function is a `dual' to <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code>: while <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code> reduces a list to a summary value, <code><a href="ghc-oldlist.html#v:unfoldr" title="GHC.OldList">unfoldr</a></code> builds a list from a seed value. The function takes the element and returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if it is done producing the list or returns <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> <code>(a,b)</code>, in which case, <code>a</code> is a prepended to the list and <code>b</code> is used as the next element in a recursive call. For example,</p>
<pre>iterate f == unfoldr (\x -&gt; Just (x, f x))</pre>
<p>In some cases, <code><a href="ghc-oldlist.html#v:unfoldr" title="GHC.OldList">unfoldr</a></code> can undo a <code><a href="ghc-oldlist.html#v:foldr" title="GHC.OldList">foldr</a></code> operation:</p>
<pre>unfoldr f' (foldr f z xs) == xs</pre>
<p>if the following holds:</p>
<pre>f' (f x y) = Just (x,y)
f' z       = Nothing</pre>
<p>A simple use of unfoldr:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
</strong>[10,9,8,7,6,5,4,3,2,1]
</pre>
<a href="#g:10" id="g:10"><h2>Sublists</h2></a><a href="#g:11" id="g:11"><h3>Extracting sublists</h3></a><p class="src"><a id="v:take" class="def">take</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#take" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:take" title="GHC.OldList">take</a></code> <code>n</code>, applied to a list <code>xs</code>, returns the prefix of <code>xs</code> of length <code>n</code>, or <code>xs</code> itself if <code>n &gt;= <a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a> xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 "Hello World!"
</strong>"Hello"
&gt;&gt;&gt; <strong class="userinput">take 3 [1,2,3,4,5]
</strong>[1,2,3]
&gt;&gt;&gt; <strong class="userinput">take 3 [1,2]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">take 3 []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take (-1) [1,2]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take 0 [1,2]
</strong>[]
</pre>
<p>It is an instance of the more general <code><a href="data-list.html#v:genericTake" title="Data.List">genericTake</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:drop" class="def">drop</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#drop" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:drop" title="GHC.OldList">drop</a></code> <code>n xs</code> returns the suffix of <code>xs</code> after the first <code>n</code> elements, or <code>[]</code> if <code>n &gt;= <a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a> xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 6 "Hello World!"
</strong>"World!"
&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2,3,4,5]
</strong>[4,5]
&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">drop 3 []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">drop (-1) [1,2]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">drop 0 [1,2]
</strong>[1,2]
</pre>
<p>It is an instance of the more general <code><a href="data-list.html#v:genericDrop" title="Data.List">genericDrop</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#splitAt" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:splitAt" title="GHC.OldList">splitAt</a></code> <code>n xs</code> returns a tuple where first element is <code>xs</code> prefix of length <code>n</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 6 "Hello World!"
</strong>("Hello ","World!")
&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3,4,5]
</strong>([1,2,3],[4,5])
&gt;&gt;&gt; <strong class="userinput">splitAt 1 [1,2,3]
</strong>([1],[2,3])
&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">splitAt 4 [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">splitAt 0 [1,2,3]
</strong>([],[1,2,3])
&gt;&gt;&gt; <strong class="userinput">splitAt (-1) [1,2,3]
</strong>([],[1,2,3])
</pre>
<p>It is equivalent to <code>(<a href="ghc-oldlist.html#v:take" title="GHC.OldList">take</a> n xs, <a href="ghc-oldlist.html#v:drop" title="GHC.OldList">drop</a> n xs)</code> when <code>n</code> is not <code>_|_</code> (<code>splitAt _|_ xs = _|_</code>). <code><a href="ghc-oldlist.html#v:splitAt" title="GHC.OldList">splitAt</a></code> is an instance of the more general <code><a href="data-list.html#v:genericSplitAt" title="Data.List">genericSplitAt</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#takeWhile" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:takeWhile" title="GHC.OldList">takeWhile</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns the longest prefix (possibly empty) of <code>xs</code> of elements that satisfy <code>p</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 9) [1,2,3]
</strong>[1,2,3]
&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 0) [1,2,3]
</strong>[]
</pre>
<p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#dropWhile" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:dropWhile" title="GHC.OldList">dropWhile</a></code> <code>p xs</code> returns the suffix remaining after <code><a href="ghc-oldlist.html#v:takeWhile" title="GHC.OldList">takeWhile</a></code> <code>p xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
</strong>[3,4,5,1,2,3]
&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 9) [1,2,3]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 0) [1,2,3]
</strong>[1,2,3]
</pre>
<p class="src"><a id="v:dropWhileEnd" class="def">dropWhileEnd</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#dropWhileEnd" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:dropWhileEnd" title="GHC.OldList">dropWhileEnd</a></code> function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhileEnd isSpace "foo\n"
</strong>"foo"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhileEnd isSpace "foo bar"
</strong>"foo bar"
</pre>
<pre>dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined</pre>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:span" class="def">span</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#span" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:span" title="GHC.OldList">span</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of <code>xs</code> of elements that satisfy <code>p</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">span (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2],[3,4,1,2,3,4])
&gt;&gt;&gt; <strong class="userinput">span (&lt; 9) [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">span (&lt; 0) [1,2,3]
</strong>([],[1,2,3])
</pre>
<p><code><a href="ghc-oldlist.html#v:span" title="GHC.OldList">span</a></code> <code>p xs</code> is equivalent to <code>(<a href="ghc-oldlist.html#v:takeWhile" title="GHC.OldList">takeWhile</a> p xs, <a href="ghc-oldlist.html#v:dropWhile" title="GHC.OldList">dropWhile</a> p xs)</code></p>
<p class="src"><a id="v:break" class="def">break</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#break" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:break" title="GHC.OldList">break</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of <code>xs</code> of elements that <em>do not satisfy</em> <code>p</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">break (&gt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2,3],[4,1,2,3,4])
&gt;&gt;&gt; <strong class="userinput">break (&lt; 9) [1,2,3]
</strong>([],[1,2,3])
&gt;&gt;&gt; <strong class="userinput">break (&gt; 9) [1,2,3]
</strong>([1,2,3],[])
</pre>
<p><code><a href="ghc-oldlist.html#v:break" title="GHC.OldList">break</a></code> <code>p</code> is equivalent to <code><a href="ghc-oldlist.html#v:span" title="GHC.OldList">span</a> (<a href="data-bool.html#v:not" title="Data.Bool">not</a> . p)</code>.</p>
<p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#stripPrefix" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. The <code><a href="ghc-oldlist.html#v:stripPrefix" title="GHC.OldList">stripPrefix</a></code> function drops the given prefix from a list. It returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the list did not start with the prefix given, or <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a></code> the list after the prefix, if it does.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "foobar"
</strong>Just "bar"
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "foo"
</strong>Just ""
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "barfoo"
</strong>Nothing
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">stripPrefix "foo" "barfoobaz"
</strong>Nothing
</pre>
<p class="src"><a id="v:group" class="def">group</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#group" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:group" title="GHC.OldList">group</a></code> function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">group "Mississippi"
</strong>["M","i","ss","i","ss","i","pp","i"]
</pre>
<p>It is a special case of <code><a href="ghc-oldlist.html#v:groupBy" title="GHC.OldList">groupBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a id="v:inits" class="def">inits</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#inits" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:inits" title="GHC.OldList">inits</a></code> function returns all initial segments of the argument, shortest first. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">inits "abc"
</strong>["","a","ab","abc"]
</pre>
<p>Note that <code><a href="ghc-oldlist.html#v:inits" title="GHC.OldList">inits</a></code> has the following strictness property: <code>inits (xs ++ _|_) = inits xs ++ _|_</code></p>
<p>In particular, <code>inits _|_ = [] : _|_</code></p>
<p class="src"><a id="v:tails" class="def">tails</a> :: [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#tails" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="ghc-oldlist.html#v:tails" title="GHC.OldList">tails</a></code> function returns all final segments of the argument, longest first. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tails "abc"
</strong>["abc","bc","c",""]
</pre>
<p>Note that <code><a href="ghc-oldlist.html#v:tails" title="GHC.OldList">tails</a></code> has the following strictness property: <code>tails _|_ = _|_ : _|_</code></p>
<a href="#g:12" id="g:12"><h3>Predicates</h3></a><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#isPrefixOf" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. The <code><a href="ghc-oldlist.html#v:isPrefixOf" title="GHC.OldList">isPrefixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is a prefix of the second.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello" `isPrefixOf` "Hello World!"
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello" `isPrefixOf` "Wello Horld!"
</strong>False
</pre>
<p class="src"><a id="v:isSuffixOf" class="def">isSuffixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#isSuffixOf" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:isSuffixOf" title="GHC.OldList">isSuffixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is a suffix of the second. The second list must be finite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"ld!" `isSuffixOf` "Hello World!"
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"World" `isSuffixOf` "Hello World!"
</strong>False
</pre>
<p class="src"><a id="v:isInfixOf" class="def">isInfixOf</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#isInfixOf" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:isInfixOf" title="GHC.OldList">isInfixOf</a></code> function takes two lists and returns <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> iff the first list is contained, wholly and intact, anywhere within the second.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">isInfixOf "Haskell" "I really like Haskell."
</strong>True
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">isInfixOf "Ial" "I really like Haskell."
</strong>False
</pre>
<a href="#g:13" id="g:13"><h2>Searching lists</h2></a><a href="#g:14" id="g:14"><h3>Searching by equality</h3></a><p class="src"><a id="v:elem" class="def">elem</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#elem" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:elem" title="GHC.OldList">elem</a></code> is the list membership predicate, usually written in infix form, e.g., <code>x `elem` xs</code>. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from an element equal to <code>x</code> found at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` []
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2,3,4,5]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1..]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `elem` [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:notElem" class="def">notElem</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#notElem" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:notElem" title="GHC.OldList">notElem</a></code> is the negation of <code><a href="ghc-oldlist.html#v:elem" title="GHC.OldList">elem</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` []
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2,3,4,5]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1..]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:lookup" class="def">lookup</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [(a, b)] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#lookup" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:lookup" title="GHC.OldList">lookup</a></code> <code>key assocs</code> looks up a key in an association list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lookup 2 []
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first")]
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first"), (2, "second"), (3, "third")]
</strong>Just "second"
</pre>
<a href="#g:15" id="g:15"><h3>Searching with a predicate</h3></a><p class="src"><a id="v:find" class="def">find</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#find" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:find" title="GHC.OldList">find</a></code> function takes a predicate and a list and returns the first element in the list matching the predicate, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">find (&gt; 4) [1..]
</strong>Just 5
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">find (&lt; 0) [1..10]
</strong>Nothing
</pre>
<p class="src"><a id="v:filter" class="def">filter</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#filter" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:filter" title="GHC.OldList">filter</a></code>, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</p>
<pre>filter p xs = [ x | x &lt;- xs, p x]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">filter odd [1, 2, 3]
</strong>[1,3]
</pre>
<p class="src"><a id="v:partition" class="def">partition</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#partition" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:partition" title="GHC.OldList">partition</a></code> function takes a predicate and a list, and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</p>
<pre>partition p xs == (filter p xs, filter (not . p) xs)</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">partition (`elem` "aeiou") "Hello World!"
</strong>("eoo","Hll Wrld!")
</pre>
<a href="#g:16" id="g:16"><h2>Indexing lists</h2></a><p>These functions treat a list <code>xs</code> as a indexed collection, with indices ranging from 0 to <code><a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a> xs - 1</code>.</p>
<p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#%21%21" class="link">Source</a> </p>
<p>List index (subscript) operator, starting from 0. It is an instance of the more general <code><a href="data-list.html#v:genericIndex" title="Data.List">genericIndex</a></code>, which takes an index of any integral type.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 0
</strong>'a'
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 2
</strong>'c'
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 3
</strong>*** Exception: Prelude.!!: index too large
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! (-1)
</strong>*** Exception: Prelude.!!: negative index
</pre>
<p>WARNING: This function is partial. You can use &lt;<code>atMay</code> <a href="#">https://hackage.haskell.org/package/safe-0.3.19/docs/Safe.html#v:atMay&gt;</a> instead.</p>
<p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#elemIndex" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:elemIndex" title="GHC.OldList">elemIndex</a></code> function returns the index of the first element in the given list which is equal (by <code><a href="data-eq.html#v:-61--61-" title="Data.Eq">==</a></code>) to the query element, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndex 4 [0..]
</strong>Just 4
</pre>
<p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; [<a href="data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#elemIndices" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:elemIndices" title="GHC.OldList">elemIndices</a></code> function extends <code><a href="ghc-oldlist.html#v:elemIndex" title="GHC.OldList">elemIndex</a></code>, by returning the indices of all elements equal to the query element, in ascending order.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">elemIndices 'o' "Hello World"
</strong>[4,7]
</pre>
<p class="src"><a id="v:findIndex" class="def">findIndex</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#findIndex" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:findIndex" title="GHC.OldList">findIndex</a></code> function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if there is no such element.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndex isSpace "Hello World!"
</strong>Just 5
</pre>
<p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [<a href="data-int.html#t:Int" title="Data.Int">Int</a>] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#findIndices" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:findIndices" title="GHC.OldList">findIndices</a></code> function extends <code><a href="ghc-oldlist.html#v:findIndex" title="GHC.OldList">findIndex</a></code>, by returning the indices of all elements satisfying the predicate, in ascending order.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">findIndices (`elem` "aeiou") "Hello World!"
</strong>[1,4,7]
</pre>
<a href="#g:17" id="g:17"><h2>Zipping and unzipping lists</h2></a><p class="src"><a id="v:zip" class="def">zip</a> :: [a] -&gt; [b] -&gt; [(a, b)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zip" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code> takes two lists and returns a list of corresponding pairs.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1, 2] ['a', 'b']
</strong>[(1,'a'),(2,'b')]
</pre>
<p>If one input list is shorter than the other, excess elements of the longer list are discarded, even if one of the lists is infinite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1] ['a', 'b']
</strong>[(1,'a')]
&gt;&gt;&gt; <strong class="userinput">zip [1, 2] ['a']
</strong>[(1,'a')]
&gt;&gt;&gt; <strong class="userinput">zip [] [1..]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">zip [1..] []
</strong>[]
</pre>
<p><code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [] undefined
</strong>[]
&gt;&gt;&gt; <strong class="userinput">zip undefined []
</strong>*** Exception: Prelude.undefined
...
</pre>
<p><code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip3" class="def">zip3</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zip3" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:zip3" title="GHC.OldList">zip3</a></code> takes three lists and returns a list of triples, analogous to <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip4" class="def">zip4</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [(a, b, c, d)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zip4" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zip4" title="GHC.OldList">zip4</a></code> function takes four lists and returns a list of quadruples, analogous to <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip5" class="def">zip5</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [(a, b, c, d, e)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zip5" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zip5" title="GHC.OldList">zip5</a></code> function takes five lists and returns a list of five-tuples, analogous to <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip6" class="def">zip6</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [(a, b, c, d, e, f)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zip6" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zip6" title="GHC.OldList">zip6</a></code> function takes six lists and returns a list of six-tuples, analogous to <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip7" class="def">zip7</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [(a, b, c, d, e, f, g)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zip7" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zip7" title="GHC.OldList">zip7</a></code> function takes seven lists and returns a list of seven-tuples, analogous to <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zipWith" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code> generalises <code><a href="ghc-oldlist.html#v:zip" title="GHC.OldList">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function.</p>
<pre>zipWith (,) xs ys == zip xs ys
zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]</pre>
<p>For example, <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a> (+)</code> is applied to two lists to produce the list of corresponding sums:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith (+) [1, 2, 3] [4, 5, 6]
</strong>[5,7,9]
</pre>
<p><code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">let f = undefined
</strong>&gt;&gt;&gt; <strong class="userinput">zipWith f [] undefined
</strong>[]
</pre>
<p><code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith3" class="def">zipWith3</a> :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zipWith3" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zipWith3" title="GHC.OldList">zipWith3</a></code> function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<pre>zipWith3 (,,) xs ys zs == zip3 xs ys zs
zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]</pre>
<p class="src"><a id="v:zipWith4" class="def">zipWith4</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zipWith4" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zipWith4" title="GHC.OldList">zipWith4</a></code> function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith5" class="def">zipWith5</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zipWith5" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zipWith5" title="GHC.OldList">zipWith5</a></code> function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith6" class="def">zipWith6</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zipWith6" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zipWith6" title="GHC.OldList">zipWith6</a></code> function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith7" class="def">zipWith7</a> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [h] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#zipWith7" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:zipWith7" title="GHC.OldList">zipWith7</a></code> function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to <code><a href="ghc-oldlist.html#v:zipWith" title="GHC.OldList">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:unzip" class="def">unzip</a> :: [(a, b)] -&gt; ([a], [b]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#unzip" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code> transforms a list of pairs into a list of first components and a list of second components.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip []
</strong>([],[])
&gt;&gt;&gt; <strong class="userinput">unzip [(1, 'a'), (2, 'b')]
</strong>([1,2],"ab")
</pre>
<p class="src"><a id="v:unzip3" class="def">unzip3</a> :: [(a, b, c)] -&gt; ([a], [b], [c]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#unzip3" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unzip3" title="GHC.OldList">unzip3</a></code> function takes a list of triples and returns three lists, analogous to <code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip3 []
</strong>([],[],[])
&gt;&gt;&gt; <strong class="userinput">unzip3 [(1, 'a', True), (2, 'b', False)]
</strong>([1,2],"ab",[True,False])
</pre>
<p class="src"><a id="v:unzip4" class="def">unzip4</a> :: [(a, b, c, d)] -&gt; ([a], [b], [c], [d]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unzip4" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unzip4" title="GHC.OldList">unzip4</a></code> function takes a list of quadruples and returns four lists, analogous to <code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code>.</p>
<p class="src"><a id="v:unzip5" class="def">unzip5</a> :: [(a, b, c, d, e)] -&gt; ([a], [b], [c], [d], [e]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unzip5" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unzip5" title="GHC.OldList">unzip5</a></code> function takes a list of five-tuples and returns five lists, analogous to <code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code>.</p>
<p class="src"><a id="v:unzip6" class="def">unzip6</a> :: [(a, b, c, d, e, f)] -&gt; ([a], [b], [c], [d], [e], [f]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unzip6" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unzip6" title="GHC.OldList">unzip6</a></code> function takes a list of six-tuples and returns six lists, analogous to <code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code>.</p>
<p class="src"><a id="v:unzip7" class="def">unzip7</a> :: [(a, b, c, d, e, f, g)] -&gt; ([a], [b], [c], [d], [e], [f], [g]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unzip7" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unzip7" title="GHC.OldList">unzip7</a></code> function takes a list of seven-tuples and returns seven lists, analogous to <code><a href="ghc-oldlist.html#v:unzip" title="GHC.OldList">unzip</a></code>.</p>
<a href="#g:18" id="g:18"><h2>Special lists</h2></a><a href="#g:19" id="g:19"><h3>Functions on strings</h3></a><p class="src"><a id="v:lines" class="def">lines</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [<a href="data-string.html#t:String" title="Data.String">String</a>] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#lines" class="link">Source</a> </p>
<p>Splits the argument into a list of <em>lines</em> stripped of their terminating <code>n</code> characters. The <code>n</code> terminator is optional in a final non-empty line of the argument string.</p>
<p>For example:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines ""           -- empty input contains no lines
</strong>[]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "\n"         -- single empty line
</strong>[""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one"        -- single unterminated line
</strong>["one"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\n"      -- single non-empty line
</strong>["one"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\n\n"    -- second line is empty
</strong>["one",""]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\ntwo"   -- second line is unterminated
</strong>["one","two"]
</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lines "one\ntwo\n" -- two non-empty lines
</strong>["one","two"]
</pre>
<p>When the argument string is empty, or ends in a <code>n</code> character, it can be recovered by passing the result of <code><a href="ghc-oldlist.html#v:lines" title="GHC.OldList">lines</a></code> to the <code><a href="ghc-oldlist.html#v:unlines" title="GHC.OldList">unlines</a></code> function. Otherwise, <code><a href="ghc-oldlist.html#v:unlines" title="GHC.OldList">unlines</a></code> appends the missing terminating <code>n</code>. This makes <code>unlines . lines</code> <em>idempotent</em>:</p>
<pre>(unlines . lines) . (unlines . lines) = (unlines . lines)</pre>
<p class="src"><a id="v:words" class="def">words</a> :: <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; [<a href="data-string.html#t:String" title="Data.String">String</a>] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#words" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:words" title="GHC.OldList">words</a></code> breaks a string up into a list of words, which were delimited by white space.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">words "Lorem ipsum\ndolor"
</strong>["Lorem","ipsum","dolor"]
</pre>
<p class="src"><a id="v:unlines" class="def">unlines</a> :: [<a href="data-string.html#t:String" title="Data.String">String</a>] -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unlines" class="link">Source</a> </p>
<p>Appends a <code>n</code> character to each input string, then concatenates the results. Equivalent to <code>foldMap (s -&gt; s <a href="ghc-oldlist.html#v:-43--43-" title="GHC.OldList">++</a> "n")</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unlines ["Hello", "World", "!"]
</strong>"Hello\nWorld\n!\n"
</pre>
<h2>Note</h2>
<p><code><a href="ghc-oldlist.html#v:unlines" title="GHC.OldList">unlines</a> <a href="data-function.html#v:." title="Data.Function">.</a> <a href="ghc-oldlist.html#v:lines" title="GHC.OldList">lines</a> <a href="data-eq.html#v:-47--61-" title="Data.Eq">/=</a> <a href="data-function.html#v:id" title="Data.Function">id</a></code> when the input is not <code>n</code>-terminated:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unlines . lines $ "foo\nbar"
</strong>"foo\nbar\n"
</pre>
<p class="src"><a id="v:unwords" class="def">unwords</a> :: [<a href="data-string.html#t:String" title="Data.String">String</a>] -&gt; <a href="data-string.html#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unwords" class="link">Source</a> </p>
<p><code><a href="ghc-oldlist.html#v:unwords" title="GHC.OldList">unwords</a></code> is an inverse operation to <code><a href="ghc-oldlist.html#v:words" title="GHC.OldList">words</a></code>. It joins words with separating spaces.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unwords ["Lorem", "ipsum", "dolor"]
</strong>"Lorem ipsum dolor"
</pre>
<a href="#g:20" id="g:20"><h3>"Set" operations</h3></a><p class="src"><a id="v:nub" class="def">nub</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#nub" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n^2)\)</span>. The <code><a href="ghc-oldlist.html#v:nub" title="GHC.OldList">nub</a></code> function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name <code><a href="ghc-oldlist.html#v:nub" title="GHC.OldList">nub</a></code> means `essence'.) It is a special case of <code><a href="ghc-oldlist.html#v:nubBy" title="GHC.OldList">nubBy</a></code>, which allows the programmer to supply their own equality test.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">nub [1,2,3,4,3,2,1,2,4,3,5]
</strong>[1,2,3,4,5]
</pre>
<p class="src"><a id="v:delete" class="def">delete</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#delete" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-oldlist.html#v:delete" title="GHC.OldList">delete</a></code> <code>x</code> removes the first occurrence of <code>x</code> from its list argument. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">delete 'a' "banana"
</strong>"bnana"
</pre>
<p>It is a special case of <code><a href="ghc-oldlist.html#v:deleteBy" title="GHC.OldList">deleteBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a id="v:-92--92-" class="def">(\\)</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <span class="fixity">infix 5</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#%5C%5C" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:-92--92-" title="GHC.OldList">\\</a></code> function is list difference (non-associative). In the result of <code>xs</code> <code><a href="ghc-oldlist.html#v:-92--92-" title="GHC.OldList">\\</a></code> <code>ys</code>, the first occurrence of each element of <code>ys</code> in turn (if any) has been removed from <code>xs</code>. Thus</p>
<pre>(xs ++ ys) \\ xs == ys.</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"Hello World!" \\ "ell W"
</strong>"Hoorld!"
</pre>
<p>It is a special case of <code><a href="ghc-oldlist.html#v:deleteFirstsBy" title="GHC.OldList">deleteFirstsBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a id="v:union" class="def">union</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#union" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:union" title="GHC.OldList">union</a></code> function returns the list union of the two lists. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">"dog" `union` "cow"
</strong>"dogcw"
</pre>
<p>Duplicates, and elements of the first list, are removed from the the second list, but if the first list contains duplicates, so will the result. It is a special case of <code><a href="ghc-oldlist.html#v:unionBy" title="GHC.OldList">unionBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a id="v:intersect" class="def">intersect</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#intersect" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:intersect" title="GHC.OldList">intersect</a></code> function takes the list intersection of two lists. For example,</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[1,2,3,4] `intersect` [2,4,6,8]
</strong>[2,4]
</pre>
<p>If the first list contains duplicates, so will the result.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">[1,2,2,3,4] `intersect` [6,4,4,2]
</strong>[2,2,4]
</pre>
<p>It is a special case of <code><a href="ghc-oldlist.html#v:intersectBy" title="GHC.OldList">intersectBy</a></code>, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</p>
<a href="#g:21" id="g:21"><h3>Ordered lists</h3></a><p class="src"><a id="v:sort" class="def">sort</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#sort" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:sort" title="GHC.OldList">sort</a></code> function implements a stable sorting algorithm. It is a special case of <code><a href="ghc-oldlist.html#v:sortBy" title="GHC.OldList">sortBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<p>Elements are arranged from lowest to highest, keeping duplicates in the order they appeared in the input.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sort [1,6,4,3,2,5]
</strong>[1,2,3,4,5,6]
</pre>
<p class="src"><a id="v:sortOn" class="def">sortOn</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#sortOn" class="link">Source</a> </p>
<p>Sort a list by comparing the results of a key function applied to each element. <code>sortOn f</code> is equivalent to <code>sortBy (comparing f)</code>, but has the performance advantage of only evaluating <code>f</code> once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</p>
<p>Elements are arranged from lowest to highest, keeping duplicates in the order they appeared in the input.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
</strong>[(1,"Hello"),(2,"world"),(4,"!")]
</pre>
<p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:insert" class="def">insert</a> :: <a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#insert" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="ghc-oldlist.html#v:insert" title="GHC.OldList">insert</a></code> function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of <code><a href="ghc-oldlist.html#v:insertBy" title="GHC.OldList">insertBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">insert 4 [1,2,3,5,6,7]
</strong>[1,2,3,4,5,6,7]
</pre>
<a href="#g:22" id="g:22"><h2>Generalized functions</h2></a><a href="#g:23" id="g:23"><h3>The "<code>By</code>" operations</h3></a><p>By convention, overloaded functions have a non-overloaded counterpart whose name is suffixed with `<code>By</code>'.</p>
<p>It is often convenient to use these functions together with <code><a href="data-function.html#v:on" title="Data.Function">on</a></code>, for instance <code><a href="ghc-oldlist.html#v:sortBy" title="GHC.OldList">sortBy</a> (<a href="data-ord.html#v:compare" title="Data.Ord">compare</a>
 `on` <a href="data-tuple.html#v:fst" title="Data.Tuple">fst</a>)</code>.</p>
<a href="#g:24" id="g:24"><h4>User-supplied equality (replacing an <code>Eq</code> context)</h4></a><p>The predicate is assumed to define an equivalence.</p>
<p class="src"><a id="v:nubBy" class="def">nubBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#nubBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:nubBy" title="GHC.OldList">nubBy</a></code> function behaves just like <code><a href="ghc-oldlist.html#v:nub" title="GHC.OldList">nub</a></code>, except it uses a user-supplied equality predicate instead of the overloaded <code><a href="data-eq.html#v:-61--61-" title="Data.Eq">==</a></code> function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
</strong>[1,2,6]
</pre>
<p class="src"><a id="v:deleteBy" class="def">deleteBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#deleteBy" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="ghc-oldlist.html#v:deleteBy" title="GHC.OldList">deleteBy</a></code> function behaves like <code><a href="ghc-oldlist.html#v:delete" title="GHC.OldList">delete</a></code>, but takes a user-supplied equality predicate.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">deleteBy (&lt;=) 4 [1..10]
</strong>[1,2,3,5,6,7,8,9,10]
</pre>
<p class="src"><a id="v:deleteFirstsBy" class="def">deleteFirstsBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#deleteFirstsBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:deleteFirstsBy" title="GHC.OldList">deleteFirstsBy</a></code> function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</p>
<p class="src"><a id="v:unionBy" class="def">unionBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#unionBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:unionBy" title="GHC.OldList">unionBy</a></code> function is the non-overloaded version of <code><a href="ghc-oldlist.html#v:union" title="GHC.OldList">union</a></code>.</p>
<p class="src"><a id="v:intersectBy" class="def">intersectBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#intersectBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:intersectBy" title="GHC.OldList">intersectBy</a></code> function is the non-overloaded version of <code><a href="ghc-oldlist.html#v:intersect" title="GHC.OldList">intersect</a></code>.</p>
<p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#groupBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:groupBy" title="GHC.OldList">groupBy</a></code> function is the non-overloaded version of <code><a href="ghc-oldlist.html#v:group" title="GHC.OldList">group</a></code>.</p>
<a href="#g:25" id="g:25"><h4>User-supplied comparison (replacing an <code>Ord</code> context)</h4></a><p>The function is assumed to define a total ordering.</p>
<p class="src"><a id="v:sortBy" class="def">sortBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#sortBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:sortBy" title="GHC.OldList">sortBy</a></code> function is the non-overloaded version of <code><a href="ghc-oldlist.html#v:sort" title="GHC.OldList">sort</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
</strong>[(1,"Hello"),(2,"world"),(4,"!")]
</pre>
<p class="src"><a id="v:insertBy" class="def">insertBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#insertBy" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The non-overloaded version of <code><a href="ghc-oldlist.html#v:insert" title="GHC.OldList">insert</a></code>.</p>
<p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#maximumBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:maximumBy" title="GHC.OldList">maximumBy</a></code> function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</p>
<p>We can use this to find the longest entry of a list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
</strong>"Longest"
</pre>
<p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: (a -&gt; a -&gt; <a href="data-ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#minimumBy" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:minimumBy" title="GHC.OldList">minimumBy</a></code> function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</p>
<p>We can use this to find the shortest entry of a list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
</strong>"!"
</pre>
<a href="#g:26" id="g:26"><h3>The "<code>generic</code>" operations</h3></a><p>The prefix `<code>generic</code>' indicates an overloaded function that is a generalized version of a <a href="prelude.html">Prelude</a> function.</p>
<p class="src"><a id="v:genericLength" class="def">genericLength</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> i =&gt; [a] -&gt; i <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericLength" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. The <code><a href="ghc-oldlist.html#v:genericLength" title="GHC.OldList">genericLength</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a></code>. In particular, instead of returning an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>, it returns any type which is an instance of <code><a href="prelude.html#t:Num" title="Prelude">Num</a></code>. It is, however, less efficient than <code><a href="ghc-oldlist.html#v:length" title="GHC.OldList">length</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">genericLength [1, 2, 3] :: Int
</strong>3
&gt;&gt;&gt; <strong class="userinput">genericLength [1, 2, 3] :: Float
</strong>3.0
</pre>
<p>Users should take care to pick a return type that is wide enough to contain the full length of the list. If the width is insufficient, the overflow behaviour will depend on the <code>(+)</code> implementation in the selected <code><a href="prelude.html#t:Num" title="Prelude">Num</a></code> instance. The following example overflows because the actual list length of 200 lies outside of the <code>Int8</code> range of <code>-128..127</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">genericLength [1..200] :: Int8
</strong>-56
</pre>
<p class="src"><a id="v:genericTake" class="def">genericTake</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericTake" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:genericTake" title="GHC.OldList">genericTake</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:take" title="GHC.OldList">take</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of elements to take.</p>
<p class="src"><a id="v:genericDrop" class="def">genericDrop</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericDrop" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:genericDrop" title="GHC.OldList">genericDrop</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:drop" title="GHC.OldList">drop</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of elements to drop.</p>
<p class="src"><a id="v:genericSplitAt" class="def">genericSplitAt</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericSplitAt" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:genericSplitAt" title="GHC.OldList">genericSplitAt</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:splitAt" title="GHC.OldList">splitAt</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the position at which to split.</p>
<p class="src"><a id="v:genericIndex" class="def">genericIndex</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; [a] -&gt; i -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericIndex" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:genericIndex" title="GHC.OldList">genericIndex</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:-33--33-" title="GHC.OldList">!!</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the index.</p>
<p class="src"><a id="v:genericReplicate" class="def">genericReplicate</a> :: <a href="prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/Data.OldList.html#genericReplicate" class="link">Source</a> </p>
<p>The <code><a href="ghc-oldlist.html#v:genericReplicate" title="GHC.OldList">genericReplicate</a></code> function is an overloaded version of <code><a href="ghc-oldlist.html#v:replicate" title="GHC.OldList">replicate</a></code>, which accepts any <code><a href="prelude.html#t:Integral" title="Prelude">Integral</a></code> value as the number of repetitions to make.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/GHC-OldList.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/GHC-OldList.html</a>
  </p>
</div>
