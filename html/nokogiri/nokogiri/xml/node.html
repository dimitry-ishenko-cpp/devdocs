<h1 id="class-Nokogiri::XML::Node" class="class"> class Nokogiri::XML::Node </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="https://nokogiri.org/rdoc/Object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="pp/node.html">Nokogiri::XML::PP::Node</a>, <a class="include" href="searchable.html">Nokogiri::XML::Searchable</a>, <a class="include" href="../classresolver.html">Nokogiri::ClassResolver</a>
</dd>
</dl> <section class="description"> <p><a href="node.html"><code>Nokogiri::XML::Node</code></a> is the primary API you’ll use to interact with your <a href="document.html"><code>Document</code></a>.</p> <h2 id="class-Nokogiri::XML::Node-label-Attributes">Attributes </h2> <p>A <a href="node.html"><code>Nokogiri::XML::Node</code></a> may be treated similarly to a hash with regard to attributes. For example:</p> <pre class="ruby" data-language="ruby">node = Nokogiri::XML::DocumentFragment.parse("&lt;a href='#foo' id='link'&gt;link&lt;/a&gt;").at_css("a")
node.to_html # =&gt; "&lt;a href=\"#foo\" id=\"link\"&gt;link&lt;/a&gt;"
node['href'] # =&gt; "#foo"
node.keys # =&gt; ["href", "id"]
node.values # =&gt; ["#foo", "link"]
node['class'] = 'green' # =&gt; "green"
node.to_html # =&gt; "&lt;a href=\"#foo\" id=\"link\" class=\"green\"&gt;link&lt;/a&gt;"
</pre> <p>See the method group entitled <a href="node.html#class-Nokogiri::XML::Node-label-Working+With+Node+Attributes">Working With Node Attributes at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Navigation">Navigation </h2> <p><a href="node.html"><code>Nokogiri::XML::Node</code></a> also has methods that let you move around your tree:</p> <dl class="rdoc-list label-list"> <dt> <a href="node.html#method-i-parent"><code>#parent</code></a>, <a href="node.html#method-i-children"><code>#children</code></a>, <a href="node.html#method-i-next"><code>#next</code></a>, <a href="node.html#method-i-previous"><code>#previous</code></a> </dt> <dd> <p>Navigate up, down, or through siblings.</p> </dd> </dl> <p>See the method group entitled <a href="node.html#class-Nokogiri::XML::Node-label-Traversing+Document+Structure">Traversing Document Structure at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Serialization">Serialization </h2> <p>When printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:</p> <dl class="rdoc-list label-list"> <dt> <a href="node.html#method-i-content"><code>#content</code></a>, <a href="node.html#method-i-text"><code>#text</code></a>, <a href="node.html#method-i-inner_text"><code>#inner_text</code></a>, <a href="node.html#method-i-to_str"><code>#to_str</code></a> </dt> <dd> <p>These methods will all **emit plaintext**, meaning that entities will be replaced (e.g., +&amp;lt;+ will be replaced with +&lt;+), meaning that any sanitizing will likely be un-done in the output.</p> </dd> <dt> <a href="node.html#method-i-to_s"><code>#to_s</code></a>, <a href="node.html#method-i-to_xml"><code>#to_xml</code></a>, <a href="node.html#method-i-to_html"><code>#to_html</code></a>, <a href="node.html#method-i-inner_html"><code>#inner_html</code></a> </dt> <dd> <p>These methods will all **emit properly-escaped markup**, meaning that it’s suitable for consumption by browsers, parsers, etc.</p> </dd> </dl> <p>See the method group entitled <a href="node.html#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output">Serialization and Generating Output at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Searching">Searching </h2> <p>You may search this node’s subtree using methods like <a href="node.html#method-i-xpath"><code>#xpath</code></a> and <a href="node.html#method-i-css"><code>#css</code></a>.</p> <p>See the method group entitled <a href="node.html#class-Nokogiri::XML::Node-label-Searching+via+XPath+or+CSS+Queries">Searching via XPath or CSS Queries at <code>Node</code></a> for the full set of methods.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ATTRIBUTE_DECL">ATTRIBUTE_DECL </dt> <dd> <p>Attribute declaration type</p> </dd> <dt id="ATTRIBUTE_NODE">ATTRIBUTE_NODE </dt> <dd> <p>Attribute node type</p> </dd> <dt id="CDATA_SECTION_NODE">CDATA_SECTION_NODE </dt> <dd> <p><a href="cdata.html"><code>CDATA</code></a> node type, see <a href="node.html#method-i-cdata-3F"><code>Nokogiri::XML::Node#cdata?</code></a></p> </dd> <dt id="COMMENT_NODE">COMMENT_NODE </dt> <dd> <p><a href="comment.html"><code>Comment</code></a> node type, see <a href="node.html#method-i-comment-3F"><code>Nokogiri::XML::Node#comment?</code></a></p> </dd> <dt id="DOCB_DOCUMENT_NODE">DOCB_DOCUMENT_NODE </dt> <dd> <p>DOCB document node type</p> </dd> <dt id="DOCUMENT_FRAG_NODE">DOCUMENT_FRAG_NODE </dt> <dd> <p><a href="document.html"><code>Document</code></a> fragment node type</p> </dd> <dt id="DOCUMENT_NODE">DOCUMENT_NODE </dt> <dd> <p><a href="document.html"><code>Document</code></a> node type, see <a href="node.html#method-i-xml-3F"><code>Nokogiri::XML::Node#xml?</code></a></p> </dd> <dt id="DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE </dt> <dd> <p><a href="document.html"><code>Document</code></a> type node type</p> </dd> <dt id="DTD_NODE">DTD_NODE </dt> <dd> <p><a href="dtd.html"><code>DTD</code></a> node type</p> </dd> <dt id="ELEMENT_DECL">ELEMENT_DECL </dt> <dd> <p><a href="element.html"><code>Element</code></a> declaration type</p> </dd> <dt id="ELEMENT_NODE">ELEMENT_NODE </dt> <dd> <p><a href="element.html"><code>Element</code></a> node type, see <a href="node.html#method-i-element-3F"><code>Nokogiri::XML::Node#element?</code></a></p> </dd> <dt id="ENTITY_DECL">ENTITY_DECL </dt> <dd> <p>Entity declaration type</p> </dd> <dt id="ENTITY_NODE">ENTITY_NODE </dt> <dd> <p>Entity node type</p> </dd> <dt id="ENTITY_REF_NODE">ENTITY_REF_NODE </dt> <dd> <p>Entity reference node type</p> </dd> <dt id="HTML_DOCUMENT_NODE">HTML_DOCUMENT_NODE </dt> <dd> <p><a href="../html4.html"><code>HTML</code></a> document node type, see <a href="node.html#method-i-html-3F"><code>Nokogiri::XML::Node#html?</code></a></p> </dd> <dt id="IMPLIED_XPATH_CONTEXTS">IMPLIED_XPATH_CONTEXTS </dt>  <dt id="LOOKS_LIKE_XPATH">LOOKS_LIKE_XPATH </dt> <dd> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Regular expression used by <a href="searchable.html#method-i-search"><code>Searchable#search</code></a> to determine if a query string is <a href="../css.html"><code>CSS</code></a> or <a href="xpath.html"><code>XPath</code></a></p> </dd> <dt id="NAMESPACE_DECL">NAMESPACE_DECL </dt> <dd> <p><a href="namespace.html"><code>Namespace</code></a> declaration type</p> </dd> <dt id="NOTATION_NODE">NOTATION_NODE </dt> <dd> <p><a href="notation.html"><code>Notation</code></a> node type</p> </dd> <dt id="PI_NODE">PI_NODE </dt> <dd> <p>PI node type</p> </dd> <dt id="TEXT_NODE">TEXT_NODE </dt> <dd> <p><a href="text.html"><code>Text</code></a> node type, see <a href="node.html#method-i-text-3F"><code>Nokogiri::XML::Node#text?</code></a></p> </dd> <dt id="VALID_NAMESPACES">VALID_NAMESPACES </dt> <dd> <div class="mixin-from"> Included from <a href="../classresolver.html">Nokogiri::ClassResolver</a> </div> <p><a href="node.html#method-i-related_class"><code>related_class</code></a> restricts matching namespaces to those matching this set.</p> </dd> <dt id="XINCLUDE_END">XINCLUDE_END </dt> <dd> <p>XInclude end type</p> </dd> <dt id="XINCLUDE_START">XINCLUDE_START </dt> <dd> <p>XInclude start type</p> </dd> </dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(name, document) → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(name, document) { |node| ... } → Nokogiri::XML::Node </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 126
def initialize(name, document)
  # This is intentionally empty, and sets the method signature for subclasses.
end</pre> </div> <p>Create a new node with <code>name</code> that belongs to <code>document</code>.</p> <p>If you intend to add a node to a document tree, it’s likely that you will prefer one of the <a href="node.html"><code>Nokogiri::XML::Node</code></a> methods like <a href="node.html#method-i-add_child"><code>#add_child</code></a>, <a href="node.html#method-i-add_next_sibling"><code>#add_next_sibling</code></a>, <a href="node.html#method-i-replace"><code>#replace</code></a>, etc. which will both create an element (or subtree) and place it in the document tree.</p> <p>Another alternative, if you are concerned about performance, is Nokogiri::XML::Document#create_element which accepts additional arguments for contents or attributes but (like this method) avoids parsing markup.</p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>name</code> (String)</p> </li> <li> <p><code>document</code> (<a href="document.html"><code>Nokogiri::XML::Document</code></a>) The document to which the the returned node will belong.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Yields </dt> <dd> <p><a href="node.html"><code>Nokogiri::XML::Node</code></a></p> </dd> <dt>Returns </dt> <dd> <p><a href="node.html"><code>Nokogiri::XML::Node</code></a></p> </dd> </dl>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-name">&lt;=&gt;</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1256
def &lt;=&gt;(other)
  return nil unless other.is_a?(Nokogiri::XML::Node)
  return nil unless document == other.document

  compare(other)
end</pre> </div> <p>Compare two <a href="node.html"><code>Node</code></a> objects with respect to their <a href="document.html"><code>Document</code></a>. Nodes from different documents cannot be compared.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1246
def ==(other)
  return false unless other
  return false unless other.respond_to?(:pointer_id)

  pointer_id == other.pointer_id
end</pre> </div> <p>Test to see if this <a href="node.html"><code>Node</code></a> is equal to <code>other</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(visitor)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1240
def accept(visitor)
  visitor.visit(self)
end</pre> </div> <p>Accept a visitor. This method calls “visit” on <code>visitor</code> with self.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ancestors"> <span class="method-name">ancestors</span><span class="method-args">(selector = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ancestors-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1209
def ancestors(selector = nil)
  return NodeSet.new(document) unless respond_to?(:parent)
  return NodeSet.new(document) unless parent

  parents = [parent]

  while parents.last.respond_to?(:parent)
    break unless (ctx_parent = parents.last.parent)

    parents &lt;&lt; ctx_parent
  end

  return NodeSet.new(document, parents) unless selector

  root = parents.last
  search_results = root.search(selector)

  NodeSet.new(document, parents.find_all do |parent|
    search_results.include?(parent)
  end)
end</pre> </div> <p>Get a list of ancestor <a href="node.html"><code>Node</code></a> for this <a href="node.html"><code>Node</code></a>. If <code>selector</code> is given, the ancestors must match <code>selector</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-blank-3F"> <span class="method-callseq"> blank? → Boolean </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="blank-3F-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_blank_eh(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>true</code> if the node is an empty or whitespace-only text or cdata node, else <code>false</code>.</p> </dd> </dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">Nokogiri("&lt;root&gt;&lt;child/&gt;&lt;/root&gt;").root.child.blank? # =&gt; false
Nokogiri("&lt;root&gt;\t \n&lt;/root&gt;").root.child.blank? # =&gt; true
Nokogiri("&lt;root&gt;&lt;![CDATA[\t \n]]&gt;&lt;/root&gt;").root.child.blank? # =&gt; true
Nokogiri("&lt;root&gt;not-blank&lt;/root&gt;").root.child
  .tap { |n| n.content = "" }.blank # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cdata-3F"> <span class="method-name">cdata?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="cdata-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1130
def cdata?
  type == CDATA_SECTION_NODE
end</pre> </div> <p>Returns true if this is a <a href="cdata.html"><code>CDATA</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-clone"> <span class="method-name">clone</span><span class="method-args">(p1 = v1, p2 = v2)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-dup">dup</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-comment-3F"> <span class="method-name">comment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="comment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1125
def comment?
  type == COMMENT_NODE
end</pre> </div> <p>Returns true if this is a <a href="comment.html"><code>Comment</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-content"> <span class="method-callseq"> content() → String </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="content-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar *content;

  Noko_Node_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if (content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Contents of all the text nodes in this node’s subtree, concatenated together into a single String.</p> </dd> </dl> <p>⚠ Note that entities will <em>always</em> be expanded in the returned String.</p> <p>See related: <a href="node.html#method-i-inner_html"><code>#inner_html</code></a></p> <p><strong>Example</strong> of how entities are handled:</p> <p>Note that <code>&amp;lt;</code> becomes <code>&lt;</code> in the returned String.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML.fragment("&lt;child&gt;a &amp;lt; b&lt;/child&gt;")
doc.at_css("child").content
# =&gt; "a &lt; b"
</pre> <p><strong>Example</strong> of how a subtree is handled:</p> <p>Note that the <code>&lt;span&gt;</code> tags are omitted and only the text node contents are returned, concatenated into a single string.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML.fragment("&lt;child&gt;&lt;span&gt;first&lt;/span&gt; &lt;span&gt;second&lt;/span&gt;&lt;/child&gt;")
doc.at_css("child").content
# =&gt; "first second"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-inner_text">inner_text</a>, <a href="node.html#method-i-text">text</a>, <a href="node.html#method-i-to_str">to_str</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create_external_subset"> <span class="method-callseq"> create_external_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_external_subset-source"> <pre class="c" data-language="c">static VALUE
create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Noko_Node_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (doc-&gt;extSubset) {
    rb_raise(rb_eRuntimeError, "Document already has an external subset");
  }

  dtd = xmlNewDtd(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create an external subset</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create_internal_subset"> <span class="method-callseq"> create_internal_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_internal_subset-source"> <pre class="c" data-language="c">static VALUE
create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Noko_Node_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (xmlGetIntSubset(doc)) {
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");
  }

  dtd = xmlCreateIntSubset(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create the internal subset of a document.</p> <pre class="ruby" data-language="ruby">doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd"&gt;

doc.create_internal_subset("chapter", nil, "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter SYSTEM "chapter.dtd"&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-css_path"> <span class="method-name">css_path</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="css_path-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1200
def css_path
  path.split(%r{/}).filter_map do |part|
    part.empty? ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
  end.join(" &gt; ")
end</pre> </div> <p>Get the path to this node as a <a href="../css.html"><code>CSS</code></a> expression</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-decorate-21"> <span class="method-name">decorate!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="decorate-21-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 132
def decorate!
  document.decorate(self)
end</pre> </div> <p>Decorate this node with the decorators set up in this node’s <a href="document.html"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-description"> <span class="method-name">description</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="description-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1167
def description
  return nil if document.xml?

  Nokogiri::HTML4::ElementDescription[name]
end</pre> </div> <p>Fetch the <a href="../html4/elementdescription.html"><code>Nokogiri::HTML4::ElementDescription</code></a> for this node. Returns nil on <a href="../xml.html"><code>XML</code></a> documents and on unknown tags.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-document-3F"> <span class="method-name">document?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="document-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1145
def document?
  is_a?(XML::Document)
end</pre> </div> <p>Returns true if this is a <a href="document.html"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dup"> <span class="method-callseq"> dup → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth) → Nokogiri::XML::Node </span> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth, new_parent_doc) → Nokogiri::XML::Node </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="dup-source"> <pre class="c" data-language="c">static VALUE
duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE r_level, r_new_parent_doc;
  int level;
  int n_args;
  xmlDocPtr new_parent_doc;
  xmlNodePtr node, dup;

  Noko_Node_Get_Struct(self, xmlNode, node);

  n_args = rb_scan_args(argc, argv, "02", &amp;r_level, &amp;r_new_parent_doc);

  if (n_args &lt; 1) {
    r_level = INT2NUM((long)1);
  }
  level = (int)NUM2INT(r_level);

  if (n_args &lt; 2) {
    new_parent_doc = node-&gt;doc;
  } else {
    Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);
  }

  dup = xmlDocCopyNode(node, new_parent_doc, level);
  if (dup == NULL) { return Qnil; }

  noko_xml_document_pin_node(dup);

  return noko_xml_node_wrap(rb_obj_class(self), dup);
}</pre> </div> <p>Copy this node.</p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>depth</code> 0 is a shallow copy, 1 (the default) is a deep copy.</p> </li> <li> <p><code>new_parent_doc</code> The new node’s parent <a href="document.html"><code>Document</code></a>. Defaults to the this node’s document.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The new Nokgiri::XML::Node</p> </dd> </dl>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-clone">clone</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-elem-3F"> <span class="method-name">elem?</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-element-3F">element?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-element-3F"> <span class="method-name">element?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="element-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1181
def element?
  type == ELEMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="element.html"><code>Element</code></a> node</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-elem-3F">elem?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-element_children"> <span class="method-callseq"> element_children() → NodeSet </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="element_children-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Noko_Node_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = xmlNextElementSibling(child);
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The node’s child elements as a <a href="nodeset.html"><code>NodeSet</code></a>. Only children that are elements will be returned, which notably excludes <a href="text.html"><code>Text</code></a> nodes.</p> </dd> </dl> <p><strong>Example:</strong></p> <p>Note that <a href="node.html#method-i-children"><code>#children</code></a> returns the <a href="text.html"><code>Text</code></a> node “hello” while <a href="node.html#method-i-element_children"><code>#element_children</code></a> does not.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;").at_css("div")
div.element_children
# =&gt; [#&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]
div.children
# =&gt; [#&lt;Nokogiri::XML::Text:0x64 "hello"&gt;,
#     #&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-elements">elements</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-elements"> <span class="method-callseq"> elements() → NodeSet </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-element_children">element_children</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-encode_special_chars"> <span class="method-callseq"> encode_special_chars(string) → String </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="encode_special_chars-source"> <pre class="c" data-language="c">static VALUE
encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Noko_Node_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
              node-&gt;doc,
              (const xmlChar *)StringValueCStr(string)
            );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}</pre> </div> <p>Encode any special characters in <code>string</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-external_subset"> <span class="method-callseq"> external_subset() </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="external_subset-source"> <pre class="c" data-language="c">static VALUE
external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Noko_Node_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = doc-&gt;extSubset;

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the external subset</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-first_element_child"> <span class="method-callseq"> first_element_child() → Node </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="first_element_child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Noko_Node_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The first child <a href="node.html"><code>Node</code></a> that is an element.</p> </dd> </dl> <p><strong>Example:</strong></p> <p>Note that the “hello” child, which is a <a href="text.html"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;</code> element is returned.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;").at_css("div")
div.first_element_child
# =&gt; #(Element:0x3c { name = "span", children = [ #(Text "world")] })
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fragment"> <span class="method-name">fragment</span><span class="method-args">(tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="fragment-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1022
def fragment(tags)
  document.related_class("DocumentFragment").new(document, tags, self)
end</pre> </div> <p>Create a <a href="documentfragment.html"><code>DocumentFragment</code></a> containing <code>tags</code> that is relative to <em>this</em> context node.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fragment-3F"> <span class="method-name">fragment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="fragment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1160
def fragment?
  type == DOCUMENT_FRAG_NODE
end</pre> </div> <p>Returns true if this is a <a href="documentfragment.html"><code>DocumentFragment</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-html-3F"> <span class="method-name">html?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="html-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1140
def html?
  type == HTML_DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="../html4/document.html"><code>HTML4::Document</code></a> or <a href="../html5/document.html"><code>HTML5::Document</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inner_html"> <span class="method-name">inner_html</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1195
def inner_html(*args)
  children.map { |x| x.to_html(*args) }.join
end</pre> </div> <p>Get the <a href="node.html#method-i-inner_html"><code>inner_html</code></a> for this node’s <a href="node.html#method-i-children"><code>Node#children</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-inner_text"> <span class="method-name">inner_text</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-internal_subset"> <span class="method-callseq"> internal_subset() </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="internal_subset-source"> <pre class="c" data-language="c">static VALUE
internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Noko_Node_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = xmlGetIntSubset(doc);

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the internal subset</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(attribute) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="key-3F-source"> <pre class="c" data-language="c">static VALUE
key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  if (xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-has_attribute-3F">has_attribute?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lang"> <span class="method-callseq"> lang </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lang-source"> <pre class="c" data-language="c">static VALUE
get_lang(VALUE self_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;
  VALUE lang_rb ;

  Noko_Node_Get_Struct(self_rb, xmlNode, self);

  lang = xmlNodeGetLang(self);
  if (lang) {
    lang_rb = NOKOGIRI_STR_NEW2(lang);
    xmlFree(lang);
    return lang_rb ;
  }

  return Qnil ;
}</pre> </div> <p>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lang-3D"> <span class="method-callseq"> lang= </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lang-3D-source"> <pre class="c" data-language="c">static VALUE
set_lang(VALUE self_rb, VALUE lang_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;

  Noko_Node_Get_Struct(self_rb, xmlNode, self);
  lang = (xmlChar *)StringValueCStr(lang_rb);

  xmlNodeSetLang(self, lang);

  return Qnil ;
}</pre> </div> <p>Set the language of a node, i.e. the values of the xml:lang attribute.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-last_element_child"> <span class="method-callseq"> last_element_child() → Node </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="last_element_child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Noko_Node_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The last child <a href="node.html"><code>Node</code></a> that is an element.</p> </dd> </dl> <p><strong>Example:</strong></p> <p>Note that the “hello” child, which is a <a href="text.html"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;yes&lt;/span&gt;</code> element is returned.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;skip&lt;/div&gt;").at_css("div")
div.last_element_child
# =&gt; #(Element:0x3c { name = "span", children = [ #(Text "yes")] })
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-line"> <span class="method-callseq"> line() → Integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="line-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_line(VALUE rb_node)
{
  xmlNodePtr c_node;
  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  return LONG2NUM(xmlGetLineNo(c_node));
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The line number of this <a href="node.html"><code>Node</code></a>.</p> </dd> </dl>  <p><strong> ⚠ The CRuby and JRuby implementations differ in important ways! </strong></p> <p>Semantic differences:</p> <ul> <li> <p>The CRuby method reflects the node’s line number <em>in the parsed string</em></p> </li> <li> <p>The JRuby method reflects the node’s line number <em>in the final DOM structure</em> after corrections have been applied</p> </li> </ul> <p>Performance differences:</p> <ul> <li> <p>The CRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">O(1)</a> (constant time)</p> </li> <li> <p>The JRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time">O(n)</a> (linear time, where n is the number of nodes before/above the element in the DOM)</p> </li> </ul> <p>If you’d like to help improve the JRuby implementation, please review these issues and reach out to the maintainers:</p> <ul> <li> <p><a href="https://github.com/sparklemotion/nokogiri/issues/1223">github.com/sparklemotion/nokogiri/issues/1223</a></p> </li> <li> <p><a href="https://github.com/sparklemotion/nokogiri/pull/2177">github.com/sparklemotion/nokogiri/pull/2177</a></p> </li> <li> <p><a href="https://github.com/sparklemotion/nokogiri/issues/2380">github.com/sparklemotion/nokogiri/issues/2380</a></p> </li> </ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-line-3D"> <span class="method-callseq"> line=(num) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="line-3D-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_line_set(VALUE rb_node, VALUE rb_line_number)
{
  xmlNodePtr c_node;
  int line_number = NUM2INT(rb_line_number);

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  // libxml2 optionally uses xmlNode.psvi to store longer line numbers, but only for text nodes.
  // search for "psvi" in SAX2.c and tree.c to learn more.
  if (line_number &lt; 65535) {
    c_node-&gt;line = (short) line_number;
  } else {
    c_node-&gt;line = 65535;
    if (c_node-&gt;type == XML_TEXT_NODE) {
      c_node-&gt;psvi = (void *)(ptrdiff_t) line_number;
    }
  }

  return rb_line_number;
}</pre> </div> <p>Sets the line for this <a href="node.html"><code>Node</code></a>. num must be less than 65535.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-matches-3F"> <span class="method-name">matches?</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="matches-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1015
def matches?(selector)
  ancestors.last.search(selector).include?(self)
end</pre> </div> <p>Returns true if this <a href="node.html"><code>Node</code></a> matches <code>selector</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-name"> <span class="method-callseq"> name </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-node_name">node_name</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespace"> <span class="method-callseq"> namespace() → Namespace </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespace-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_namespace(VALUE rb_node)
{
  xmlNodePtr c_node ;
  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  if (c_node-&gt;ns) {
    return noko_xml_namespace_wrap(c_node-&gt;ns, c_node-&gt;doc);
  }

  return Qnil ;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The <a href="namespace.html"><code>Namespace</code></a> of the element or attribute node, or <code>nil</code> if there is no namespace.</p> </dd> </dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//first").namespace
# =&gt; nil
doc.at_xpath("//xmlns:second", "xmlns" =&gt; "http://example.com/child").namespace
# =&gt; #(Namespace:0x3c { href = "http://example.com/child" })
doc.at_xpath("//foo:third", "foo" =&gt; "http://example.com/foo").namespace
# =&gt; #(Namespace:0x50 { prefix = "foo", href = "http://example.com/foo" })
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespace_definitions"> <span class="method-callseq"> namespace_definitions() → Array&lt;Nokogiri::XML::Namespace&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespace_definitions-source"> <pre class="c" data-language="c">static VALUE
namespace_definitions(VALUE rb_node)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr c_node ;
  xmlNsPtr c_namespace;
  VALUE definitions = rb_ary_new();

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  c_namespace = c_node-&gt;nsDef;
  if (!c_namespace) {
    return definitions;
  }

  while (c_namespace != NULL) {
    rb_ary_push(definitions, noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc));
    c_namespace = c_namespace-&gt;next;
  }

  return definitions;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Namespaces that are defined directly on this node, as an Array of <a href="namespace.html"><code>Namespace</code></a> objects. The array will be empty if no namespaces are defined on this node.</p> </dd> </dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child" xmlns:unused="http://example.com/unused"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespace_definitions
# =&gt; []
doc.at_xpath("//xmlns:second", "xmlns" =&gt; "http://example.com/child").namespace_definitions
# =&gt; [#(Namespace:0x3c { href = "http://example.com/child" }),
#     #(Namespace:0x50 {
#       prefix = "unused",
#       href = "http://example.com/unused"
#       })]
doc.at_xpath("//foo:third", "foo" =&gt; "http://example.com/foo").namespace_definitions
# =&gt; [#(Namespace:0x64 { prefix = "foo", href = "http://example.com/foo" })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespace_scopes"> <span class="method-callseq"> namespace_scopes() → Array&lt;Nokogiri::XML::Namespace&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespace_scopes-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_namespace_scopes(VALUE rb_node)
{
  xmlNodePtr c_node ;
  xmlNsPtr *namespaces;
  VALUE scopes = rb_ary_new();
  int j;

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  namespaces = xmlGetNsList(c_node-&gt;doc, c_node);
  if (!namespaces) {
    return scopes;
  }

  for (j = 0 ; namespaces[j] != NULL ; ++j) {
    rb_ary_push(scopes, noko_xml_namespace_wrap(namespaces[j], c_node-&gt;doc));
  }

  xmlFree(namespaces);
  return scopes;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Array of all the Namespaces on this node and its ancestors.</p> </dd> </dl> <p>See also <a href="node.html#method-i-namespaces"><code>#namespaces</code></a></p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root" xmlns:bar="http://example.com/bar"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespace_scopes
# =&gt; [#(Namespace:0x3c { href = "http://example.com/root" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
doc.at_xpath("//child:second", "child" =&gt; "http://example.com/child").namespace_scopes
# =&gt; [#(Namespace:0x64 { href = "http://example.com/child" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
doc.at_xpath("//root:third", "root" =&gt; "http://example.com/root").namespace_scopes
# =&gt; [#(Namespace:0x78 { prefix = "foo", href = "http://example.com/foo" }),
#     #(Namespace:0x3c { href = "http://example.com/root" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespaced_key-3F"> <span class="method-callseq"> namespaced_key?(attribute, namespace) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespaced_key-3F-source"> <pre class="c" data-language="c">static VALUE
namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  if (xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
                   NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set with <code>namespace</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespaces"> <span class="method-callseq"> namespaces() → Hash&lt;String(Namespace#prefix) ⇒ String(Namespace#href)&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespaces-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1116
def namespaces
  namespace_scopes.each_with_object({}) do |ns, hash|
    prefix = ns.prefix
    key = prefix ? "xmlns:#{prefix}" : "xmlns"
    hash[key] = ns.href
  end
end</pre> </div> <p>Fetch all the namespaces on this node and its ancestors.</p> <p>Note that the keys in this hash <a href="../xml.html"><code>XML</code></a> attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix.</p> <p>The default namespace for this node will be included with key “xmlns”.</p> <p>See also <a href="node.html#method-i-namespace_scopes"><code>#namespace_scopes</code></a></p> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Hash containing all the namespaces on this node and its ancestors. The hash keys are the namespace prefix, and the hash value for each key is the namespace URI.</p> </dd> </dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root" xmlns:in_scope="http://example.com/in_scope"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespaces
# =&gt; {"xmlns"=&gt;"http://example.com/root",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
doc.at_xpath("//child:second", "child" =&gt; "http://example.com/child").namespaces
# =&gt; {"xmlns"=&gt;"http://example.com/child",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
doc.at_xpath("//root:third", "root" =&gt; "http://example.com/root").namespaces
# =&gt; {"xmlns:foo"=&gt;"http://example.com/foo",
#     "xmlns"=&gt;"http://example.com/root",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-native_content-3D"> <span class="method-callseq"> content= </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="native_content-3D-source"> <pre class="c" data-language="c">static VALUE
set_native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Noko_Node_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  while (NULL != child) {
    next = child-&gt;next ;
    xmlUnlinkNode(child) ;
    noko_xml_document_pin_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
  return content;
}</pre> </div> <p>Set the content for this <a href="node.html"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-next_element"> <span class="method-callseq"> next_element </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="next_element-source"> <pre class="c" data-language="c">static VALUE
next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Noko_Node_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre> </div> <p>Returns the next <a href="element.html"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-next_sibling"> <span class="method-callseq"> next_sibling </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="next_sibling-source"> <pre class="c" data-language="c">static VALUE
next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Noko_Node_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;next;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling) ;
}</pre> </div> <p>Returns the next sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-node_name"> <span class="method-callseq"> name </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="node_name-source"> <pre class="c" data-language="c">static VALUE
get_name(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  if (node-&gt;name) {
    return NOKOGIRI_STR_NEW2(node-&gt;name);
  }
  return Qnil;
}</pre> </div> <p>Returns the name for this <a href="node.html"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-name">name</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-node_name-3D"> <span class="method-name">node_name=</span><span class="method-args">(new_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="node_name-3D-source"> <pre class="c" data-language="c">static VALUE
set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar *)StringValueCStr(new_name));
  return new_name;
}</pre> </div> <p>Set the name for this <a href="node.html"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-name-3D">name=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-node_type"> <span class="method-callseq"> node_type </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="node_type-source"> <pre class="c" data-language="c">static VALUE
node_type(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  return INT2NUM(node-&gt;type);
}</pre> </div> <p>Get the type for this <a href="node.html"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-type">type</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parent"> <span class="method-callseq"> parent </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parent-source"> <pre class="c" data-language="c">static VALUE
get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Noko_Node_Get_Struct(self, xmlNode, node);

  parent = node-&gt;parent;
  if (!parent) { return Qnil; }

  return noko_xml_node_wrap(Qnil, parent) ;
}</pre> </div> <p>Get the parent <a href="node.html"><code>Node</code></a> for this <a href="node.html"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(string_or_io, options = nil) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1030
def parse(string_or_io, options = nil)
  ##
  # When the current node is unparented and not an element node, use the
  # document as the parsing context instead. Otherwise, the in-context
  # parser cannot find an element or a document node.
  # Document Fragments are also not usable by the in-context parser.
  if !element? &amp;&amp; !document? &amp;&amp; (!parent || parent.fragment?)
    return document.parse(string_or_io, options)
  end

  options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
  yield options if block_given?

  contents = if string_or_io.respond_to?(:read)
    string_or_io.read
  else
    string_or_io
  end

  return Nokogiri::XML::NodeSet.new(document) if contents.empty?

  # libxml2 does not obey the +recover+ option after encountering errors during +in_context+
  # parsing, and so this horrible hack is here to try to emulate recovery behavior.
  #
  # Unfortunately, this means we're no longer parsing "in context" and so namespaces that
  # would have been inherited from the context node won't be handled correctly. This hack was
  # written in 2010, and I regret it, because it's silently degrading functionality in a way
  # that's not easily prevented (or even detected).
  #
  # I think preferable behavior would be to either:
  #
  # a. add an error noting that we "fell back" and pointing the user to turning off the +recover+ option
  # b. don't recover, but raise a sensible exception
  #
  # For context and background: https://github.com/sparklemotion/nokogiri/issues/313
  # FIXME bug report: https://github.com/sparklemotion/nokogiri/issues/2092
  error_count = document.errors.length
  node_set = in_context(contents, options.to_i)
  if node_set.empty? &amp;&amp; (document.errors.length &gt; error_count)
    if options.recover?
      fragment = document.related_class("DocumentFragment").parse(contents)
      node_set = fragment.children
    else
      raise document.errors[error_count]
    end
  end
  node_set
end</pre> </div> <p>Parse <code>string_or_io</code> as a document fragment within the context of <strong>this</strong> node. Returns a <a href="nodeset.html"><code>XML::NodeSet</code></a> containing the nodes parsed from <code>string_or_io</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-path"> <span class="method-callseq"> path </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="path-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_path(VALUE rb_node)
{
  xmlNodePtr c_node;
  xmlChar *c_path ;
  VALUE rval;

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  c_path = xmlGetNodePath(c_node);
  if (c_path == NULL) {
    // see https://github.com/sparklemotion/nokogiri/issues/2250
    // this behavior is clearly undesirable, but is what libxml &lt;= 2.9.10 returned, and so we
    // do this for now to preserve the behavior across libxml2 versions.
    rval = NOKOGIRI_STR_NEW2("?");
  } else {
    rval = NOKOGIRI_STR_NEW2(c_path);
    xmlFree(c_path);
  }

  return rval ;
}</pre> </div> <p>Returns the path associated with this <a href="node.html"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pointer_id"> <span class="method-callseq"> pointer_id() → Integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pointer_id-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_pointer_id(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);

  return rb_uint2inum((uintptr_t)(node));
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>A unique id for this node based on the internal memory structures. This method is used by <a href="node.html#method-i-3D-3D"><code>#==</code></a> to determine node identity.</p> </dd> </dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-previous_element"> <span class="method-callseq"> previous_element </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="previous_element-source"> <pre class="c" data-language="c">static VALUE
previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Noko_Node_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  while (sibling &amp;&amp; sibling-&gt;type != XML_ELEMENT_NODE) {
    sibling = sibling-&gt;prev;
  }

  return sibling ? noko_xml_node_wrap(Qnil, sibling) : Qnil ;
}</pre> </div> <p>Returns the previous <a href="element.html"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-previous_sibling"> <span class="method-callseq"> previous_sibling </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="previous_sibling-source"> <pre class="c" data-language="c">static VALUE
previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Noko_Node_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre> </div> <p>Returns the previous sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-previous">previous</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-processing_instruction-3F"> <span class="method-name">processing_instruction?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="processing_instruction-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1150
def processing_instruction?
  type == PI_NODE
end</pre> </div> <p>Returns true if this is a <a href="processinginstruction.html"><code>ProcessingInstruction</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-read_only-3F"> <span class="method-name">read_only?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="read_only-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1175
def read_only?
  # According to gdome2, these are read-only node types
  [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
end</pre> </div> <p>Is this a read only node?</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-related_class"> <span class="method-callseq"> related_class(class_name) → Class </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="related_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/class_resolver.rb, line 46
def related_class(class_name)
  klass = nil
  inspecting = self.class

  while inspecting
    namespace_path = inspecting.name.split("::")[0..-2]
    inspecting = inspecting.superclass

    next unless VALID_NAMESPACES.include?(namespace_path.last)

    related_class_name = (namespace_path &lt;&lt; class_name).join("::")
    klass = begin
      Object.const_get(related_class_name)
    rescue NameError
      nil
    end
    break if klass
  end
  klass
end</pre> </div> <div class="mixin-from"> Included from <a href="../classresolver.html">Nokogiri::ClassResolver</a> </div> <p>Find a class constant within the</p> <p>Some examples:</p> <pre class="ruby" data-language="ruby">Nokogiri::XML::Document.new.related_class("DocumentFragment")
# =&gt; Nokogiri::XML::DocumentFragment
Nokogiri::HTML4::Document.new.related_class("DocumentFragment")
# =&gt; Nokogiri::HTML4::DocumentFragment
</pre> <p>Note this will also work for subclasses that follow the same convention, e.g.:</p> <pre class="ruby" data-language="ruby">Loofah::HTML::Document.new.related_class("DocumentFragment")
# =&gt; Loofah::HTML::DocumentFragment
</pre> <p>And even if it’s a subclass, this will iterate through the superclasses:</p> <pre class="ruby" data-language="ruby">class ThisIsATopLevelClass &lt; Nokogiri::HTML4::Builder ; end
ThisIsATopLevelClass.new.related_class("Document")
# =&gt; Nokogiri::HTML4::Document
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-text"> <span class="method-callseq"> text() → String </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-text-3F"> <span class="method-name">text?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="text-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1155
def text?
  type == TEXT_NODE
end</pre> </div> <p>Returns true if this is a <a href="text.html"><code>Text</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1190
def to_s
  document.xml? ? to_xml : to_html
end</pre> </div> <p>Turn this node in to a string. If the document is <a href="../html4.html"><code>HTML</code></a>, this method returns html. If the document is <a href="../xml.html"><code>XML</code></a>, this method returns <a href="../xml.html"><code>XML</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_str"> <span class="method-callseq"> to_str() → String </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-traverse"> <span class="method-name">traverse</span><span class="method-args">() { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="traverse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1233
def traverse(&amp;block)
  children.each { |j| j.traverse(&amp;block) }
  yield(self)
end</pre> </div> <p>Yields self and all children to <code>block</code> recursively.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-type"> <span class="method-callseq"> node_type </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-node_type">node_type</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unlink"> <span class="method-callseq"> unlink() → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unlink-source"> <pre class="c" data-language="c">static VALUE
unlink_node(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  noko_xml_document_pin_node(node);
  return self;
}</pre> </div> <p>Unlink this node from its current context.</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-xml-3F"> <span class="method-name">xml?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="xml-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1135
def xml?
  type == DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="document.html"><code>XML::Document</code></a> node</p>  </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-coerce"> <span class="method-name">coerce</span><span class="method-args">(data)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="coerce-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1473
      def coerce(data)
        case data
        when XML::NodeSet
          return data
        when XML::DocumentFragment
          return data.children
        when String
          return fragment(data).children
        when Document, XML::Attr
          # unacceptable
        when XML::Node
          return data
        end

        raise ArgumentError, &lt;&lt;~EOERR
          Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.
          (You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)
        EOERR
      end</pre> </div>  </div> </div> </section> </section> <section id="Manipulating+Document+Structure" class="documentation-section"> <header class="documentation-section-title"> <h2 id="Manipulating+Document+Structure"> Manipulating Document Structure </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Manipulating+Document+Structure-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 256
def &lt;&lt;(node_or_tags)
  add_child(node_or_tags)
  self
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node.html"><code>Node</code></a>.</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns <code>self</code>, to support chaining of calls (e.g., root &lt;&lt; child1 &lt;&lt; child2)</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_child"> <span class="method-name">add_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 148
def add_child(node_or_tags)
  node_or_tags = coerce(node_or_tags)
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
  else
    add_child_node_and_reparent_attrs(node_or_tags)
  end
  node_or_tags
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node.html"><code>Node</code></a>.</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node.html"><code>Node</code></a>), or <a href="nodeset.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment.html"><code>DocumentFragment</code></a>, <a href="nodeset.html"><code>NodeSet</code></a>, or String).</p> <p>Also see related method +&lt;&lt;+.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-add_namespace"> <span class="method-callseq"> add_namespace(prefix, href) → Nokogiri::XML::Namespace </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-add_namespace_definition">add_namespace_definition</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_namespace_definition"> <span class="method-callseq"> add_namespace_definition(prefix, href) → Nokogiri::XML::Namespace </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_namespace_definition-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_add_namespace_definition(VALUE rb_node, VALUE rb_prefix, VALUE rb_href)
{
  xmlNodePtr c_node, element;
  xmlNsPtr c_namespace;
  const xmlChar *c_prefix = (const xmlChar *)(NIL_P(rb_prefix) ? NULL : StringValueCStr(rb_prefix));

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);
  element = c_node ;

  c_namespace = xmlSearchNs(c_node-&gt;doc, c_node, c_prefix);

  if (!c_namespace) {
    if (c_node-&gt;type != XML_ELEMENT_NODE) {
      element = c_node-&gt;parent;
    }
    c_namespace = xmlNewNs(element, (const xmlChar *)StringValueCStr(rb_href), c_prefix);
  }

  if (!c_namespace) {
    return Qnil ;
  }

  if (NIL_P(rb_prefix) || c_node != element) {
    xmlSetNs(c_node, c_namespace);
  }

  return noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc);
}</pre> </div> <p>Adds a namespace definition to this node with <code>prefix</code> using <code>href</code> value, as if this node had included an attribute “xmlns:prefix=href”.</p> <p>A default namespace definition for this node can be added by passing <code>nil</code> for <code>prefix</code>.</p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>prefix</code> (String, <code>nil</code>) An <a href="https://www.w3.org/TR/xml-names/#ns-decl">XML Name</a></p> </li> <li> <p><code>href</code> (String) The <a href="https://www.w3.org/TR/xml-names/#sec-namespaces">URI reference</a></p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The new <a href="namespace.html"><code>Nokogiri::XML::Namespace</code></a></p> </dd> </dl> <p><strong>Example:</strong> adding a non-default namespace definition</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;store&gt;&lt;inventory&gt;&lt;/inventory&gt;&lt;/store&gt;")
inventory = doc.at_css("inventory")
inventory.add_namespace_definition("automobile", "http://alices-autos.com/")
inventory.add_namespace_definition("bicycle", "http://bobs-bikes.com/")
inventory.add_child("&lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;")
doc.to_xml
# =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +
#    "&lt;store&gt;\n" +
#    "  &lt;inventory xmlns:automobile=\"http://alices-autos.com/\" xmlns:bicycle=\"http://bobs-bikes.com/\"&gt;\n" +
#    "    &lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;\n" +
#    "  &lt;/inventory&gt;\n" +
#    "&lt;/store&gt;\n"
</pre> <p><strong>Example:</strong> adding a default namespace definition</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;store&gt;&lt;inventory&gt;&lt;tire&gt;Michelin model XGV, size 75R&lt;/tire&gt;&lt;/inventory&gt;&lt;/store&gt;")
doc.at_css("tire").add_namespace_definition(nil, "http://bobs-bikes.com/")
doc.to_xml
# =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +
#    "&lt;store&gt;\n" +
#    "  &lt;inventory&gt;\n" +
#    "    &lt;tire xmlns=\"http://bobs-bikes.com/\"&gt;Michelin model XGV, size 75R&lt;/tire&gt;\n" +
#    "  &lt;/inventory&gt;\n" +
#    "&lt;/store&gt;\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-add_namespace">add_namespace</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_next_sibling"> <span class="method-name">add_next_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_next_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 288
def add_next_sibling(node_or_tags)
  raise ArgumentError,
    "A document may not have multiple root nodes." if parent&amp;.document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling(:next, node_or_tags)
end</pre> </div> <p>Insert <code>node_or_tags</code> after this <a href="node.html"><code>Node</code></a> (as a sibling).</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node.html"><code>Node</code></a>), or <a href="nodeset.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment.html"><code>DocumentFragment</code></a>, <a href="nodeset.html"><code>NodeSet</code></a>, or String).</p> <p>Also see related method <code>after</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-next-3D">next=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_previous_sibling"> <span class="method-name">add_previous_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_previous_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 271
def add_previous_sibling(node_or_tags)
  raise ArgumentError,
    "A document may not have multiple root nodes." if parent&amp;.document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling(:previous, node_or_tags)
end</pre> </div> <p>Insert <code>node_or_tags</code> before this <a href="node.html"><code>Node</code></a> (as a sibling).</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node.html"><code>Node</code></a>), or <a href="nodeset.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment.html"><code>DocumentFragment</code></a>, <a href="nodeset.html"><code>NodeSet</code></a>, or String).</p> <p>Also see related method <code>before</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-previous-3D">previous=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-after"> <span class="method-name">after</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="after-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 318
def after(node_or_tags)
  add_next_sibling(node_or_tags)
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> after this node (as a sibling).</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a String containing markup.</p> <p>Returns <code>self</code>, to support chaining of calls.</p> <p>Also see related method <code>add_next_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-before"> <span class="method-name">before</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="before-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 304
def before(node_or_tags)
  add_previous_sibling(node_or_tags)
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> before this node (as a sibling).</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns <code>self</code>, to support chaining of calls.</p> <p>Also see related method <code>add_previous_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-children-3D"> <span class="method-name">children=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="children-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 349
def children=(node_or_tags)
  node_or_tags = coerce(node_or_tags)
  children.unlink
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
  else
    add_child_node_and_reparent_attrs(node_or_tags)
  end
end</pre> </div> <p>Set the content for this <a href="node.html"><code>Node</code></a> <code>node_or_tags</code></p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a String containing markup.</p> <p>Also see related method <code>inner_html=</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-content-3D"> <span class="method-name">content=</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="content-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 411
def content=(string)
  self.native_content = encode_special_chars(string.to_s)
end</pre> </div> <p>Set the Node’s content to a <a href="text.html"><code>Text</code></a> node containing <code>string</code>. The string gets <a href="../xml.html"><code>XML</code></a> escaped, not interpreted as markup.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-default_namespace-3D"> <span class="method-name">default_namespace=</span><span class="method-args">(url)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="default_namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 427
def default_namespace=(url)
  add_namespace_definition(nil, url)
end</pre> </div> <p>Adds a default namespace supplied as a string <code>url</code> href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed <a href="../xml.html"><code>XML</code></a>. A default namespace set with this method will now show up in <a href="node.html#method-i-attributes"><code>#attributes</code></a>, but when this node is serialized to <a href="../xml.html"><code>XML</code></a> an “xmlns” attribute will appear. See also <a href="node.html#method-i-namespace"><code>#namespace</code></a> and <a href="node.html#method-i-namespace-3D"><code>#namespace=</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-do_xinclude"> <span class="method-name">do_xinclude</span><span class="method-args">(options = XML::ParseOptions::DEFAULT_XML) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="do_xinclude-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 454
def do_xinclude(options = XML::ParseOptions::DEFAULT_XML)
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
  yield options if block_given?

  # call c extension
  process_xincludes(options.to_i)
end</pre> </div> <p>Do xinclude substitution on the subtree below node. If given a block, a <a href="parseoptions.html"><code>Nokogiri::XML::ParseOptions</code></a> object initialized from <code>options</code>, will be passed to it, allowing more convenient modification of the parser options.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inner_html-3D"> <span class="method-name">inner_html=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 338
def inner_html=(node_or_tags)
  self.children = node_or_tags
end</pre> </div> <p>Set the content for this <a href="node.html"><code>Node</code></a> to <code>node_or_tags</code>.</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a String containing markup.</p> <p>⚠ Please note that despite the name, this method will <strong>not</strong> always parse a String argument as <a href="../html4.html"><code>HTML</code></a>. A String argument will be parsed with the <code>DocumentFragment</code> parser related to this node’s document.</p> <p>For example, if the document is an <a href="../html4/document.html"><code>HTML4::Document</code></a> then the string will be parsed as <a href="../html4.html"><code>HTML4</code></a> using <a href="../html4/documentfragment.html"><code>HTML4::DocumentFragment</code></a>; but if the document is an <a href="document.html"><code>XML::Document</code></a> then it will parse the string as <a href="../xml.html"><code>XML</code></a> using <a href="documentfragment.html"><code>XML::DocumentFragment</code></a>.</p> <p>Also see related method <code>children=</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-name-3D"> <span class="method-callseq"> name=(new_name) </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-node_name-3D">node_name=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-namespace-3D"> <span class="method-name">namespace=</span><span class="method-args">(ns)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 437
def namespace=(ns)
  return set_namespace(ns) unless ns

  unless Nokogiri::XML::Namespace === ns
    raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
  end
  if ns.document != document
    raise ArgumentError, "namespace must be declared on the same document"
  end

  set_namespace(ns)
end</pre> </div> <p>Set the default namespace on this node (as would be defined with an “xmlns=” attribute in <a href="../xml.html"><code>XML</code></a> source), as a <a href="namespace.html"><code>Namespace</code></a> object <code>ns</code>. Note that a <a href="namespace.html"><code>Namespace</code></a> added this way will NOT be serialized as an xmlns attribute for this node. You probably want <a href="node.html#method-i-default_namespace-3D"><code>#default_namespace=</code></a> instead, or perhaps <a href="node.html#method-i-add_namespace_definition"><code>#add_namespace_definition</code></a> with a nil prefix argument.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-next"> <span class="method-callseq"> next_sibling </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-next_sibling">next_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-next-3D"> <span class="method-name">next=</span><span class="method-args">(node_or_tags)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-add_next_sibling">add_next_sibling</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parent-3D"> <span class="method-name">parent=</span><span class="method-args">(parent_node)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parent-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 417
def parent=(parent_node)
  parent_node.add_child(self)
end</pre> </div> <p>Set the parent <a href="node.html"><code>Node</code></a> for this <a href="node.html"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-prepend_child"> <span class="method-name">prepend_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="prepend_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 168
def prepend_child(node_or_tags)
  if (first = children.first)
    # Mimic the error add_child would raise.
    raise "Document already has a root node" if document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

    first.__send__(:add_sibling, :previous, node_or_tags)
  else
    add_child(node_or_tags)
  end
end</pre> </div> <p>Add <code>node_or_tags</code> as the first child of this <a href="node.html"><code>Node</code></a>.</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node.html"><code>Node</code></a>), or <a href="nodeset.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment.html"><code>DocumentFragment</code></a>, <a href="nodeset.html"><code>NodeSet</code></a>, or String).</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-previous"> <span class="method-callseq"> previous_sibling </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-previous_sibling">previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-previous-3D"> <span class="method-name">previous=</span><span class="method-args">(node_or_tags)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-add_previous_sibling">add_previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-unlink">unlink</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-replace"> <span class="method-name">replace</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="replace-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 369
def replace(node_or_tags)
  raise("Cannot replace a node with no parent") unless parent

  # We cannot replace a text node directly, otherwise libxml will return
  # an internal error at parser.c:13031, I don't know exactly why
  # libxml is trying to find a parent node that is an element or document
  # so I can't tell if this is bug in libxml or not. issue #775.
  if text?
    replacee = Nokogiri::XML::Node.new("dummy", document)
    add_previous_sibling_node(replacee)
    unlink
    return replacee.replace(node_or_tags)
  end

  node_or_tags = parent.coerce(node_or_tags)

  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_previous_sibling(n) }
    unlink
  else
    replace_node(node_or_tags)
  end
  node_or_tags
end</pre> </div> <p>Replace this <a href="node.html"><code>Node</code></a> with <code>node_or_tags</code>.</p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node.html"><code>Node</code></a>), or <a href="nodeset.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment.html"><code>DocumentFragment</code></a>, <a href="nodeset.html"><code>NodeSet</code></a>, or String).</p> <p>Also see related method <code>swap</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-swap"> <span class="method-name">swap</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="swap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 403
def swap(node_or_tags)
  replace(node_or_tags)
  self
end</pre> </div> <p>Swap this <a href="node.html"><code>Node</code></a> for <code>node_or_tags</code></p> <p><code>node_or_tags</code> can be a <a href="node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a String Containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>replace</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-wrap"> <span class="method-callseq"> wrap(markup) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> wrap(node) → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="wrap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 223
def wrap(node_or_tags)
  case node_or_tags
  when String
    context_node = parent || document
    new_parent = context_node.coerce(node_or_tags).first
    if new_parent.nil?
      raise "Failed to parse '#{node_or_tags}' in the context of a '#{context_node.name}' element"
    end
  when XML::Node
    new_parent = node_or_tags.dup
  else
    raise ArgumentError, "Requires a String or Node argument, and cannot accept a #{node_or_tags.class}"
  end

  if parent
    add_next_sibling(new_parent)
  else
    new_parent.unlink
  end
  new_parent.add_child(self)

  self
end</pre> </div> <p>Wrap this <a href="node.html"><code>Node</code></a> with the node parsed from <code>markup</code> or a dup of the <code>node</code>.</p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><strong>markup</strong> (String) Markup that is parsed and used as the wrapper. This node’s parent, if it exists, is used as the context node for parsing; otherwise the associated document is used. If the parsed fragment has multiple roots, the first root node is used as the wrapper.</p> </li> <li> <p><strong>node</strong> (<a href="node.html"><code>Nokogiri::XML::Node</code></a>) An element that is ‘#dup`ed and used as the wrapper.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code>, to support chaining.</p> </dd> </dl> <p>Also see <a href="nodeset.html#method-i-wrap"><code>NodeSet#wrap</code></a></p> <p><strong>Example</strong> with a <code>String</code> argument:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::HTML5(&lt;&lt;~HTML)
  &lt;html&gt;&lt;body&gt;
    &lt;a&gt;asdf&lt;/a&gt;
  &lt;/body&gt;&lt;/html&gt;
HTML
doc.at_css("a").wrap("&lt;div&gt;&lt;/div&gt;")
doc.to_html
# =&gt; &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
#      &lt;div&gt;&lt;a&gt;asdf&lt;/a&gt;&lt;/div&gt;
#    &lt;/body&gt;&lt;/html&gt;
</pre> <p><strong>Example</strong> with a <code>Node</code> argument:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::HTML5(&lt;&lt;~HTML)
  &lt;html&gt;&lt;body&gt;
    &lt;a&gt;asdf&lt;/a&gt;
  &lt;/body&gt;&lt;/html&gt;
HTML
doc.at_css("a").wrap(doc.create_element("div"))
doc.to_html
# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
#   &lt;div&gt;&lt;a&gt;asdf&lt;/a&gt;&lt;/div&gt;
# &lt;/body&gt;&lt;/html&gt;
</pre>  </div> </div> </section> </section> <section id="Searching+via+XPath+or+CSS+Queries" class="documentation-section"> <header class="documentation-section-title"> <h2 id="Searching+via+XPath+or+CSS+Queries"> Searching via XPath or CSS Queries </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Searching+via+XPath+or+CSS+Queries-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-25"> <span class="method-name">%</span><span class="method-args">(*args)</span> </div> </div> <div class="method-description"> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> </div> <div class="aliases"> Alias for: <a href="searchable.html#method-i-at">at</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-2F"> <span class="method-name">/</span><span class="method-args">(*args)</span> </div> </div> <div class="method-description"> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> </div> <div class="aliases"> Alias for: <a href="searchable.html#method-i-search">search</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3E"> <span class="method-callseq"> &gt;(selector) → NodeSet </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 196
def &gt;(selector) # rubocop:disable Naming/BinaryOperatorParameterName
  ns = (document.root&amp;.namespaces || {})
  xpath(CSS.xpath_for(selector, prefix: "./", ns: ns).first)
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this node’s immediate children using <a href="../css.html"><code>CSS</code></a> selector <code>selector</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-at"> <span class="method-callseq"> at(*paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="at-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 71
def at(*args)
  search(*args).first
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this object for <code>paths</code>, and return only the first result. <code>paths</code> must be one or more <a href="xpath.html"><code>XPath</code></a> or <a href="../css.html"><code>CSS</code></a> queries.</p> <p>See <a href="searchable.html#method-i-search"><code>Searchable#search</code></a> for more information.</p>  </div> <div class="aliases"> Also aliased as: <a href="searchable.html#method-i-25">%</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-at_css"> <span class="method-callseq"> at_css(*rules, [namespace-bindings, custom-pseudo-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="at_css-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 140
def at_css(*args)
  css(*args).first
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this object for <a href="../css.html"><code>CSS</code></a> <code>rules</code>, and return only the first match. <code>rules</code> must be one or more <a href="../css.html"><code>CSS</code></a> selectors.</p> <p>See <a href="searchable.html#method-i-css"><code>Searchable#css</code></a> for more information.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-at_xpath"> <span class="method-callseq"> at_xpath(*paths, [namespace-bindings, variable-bindings, custom-handler-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="at_xpath-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 188
def at_xpath(*args)
  xpath(*args).first
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this node for <a href="xpath.html"><code>XPath</code></a> <code>paths</code>, and return only the first match. <code>paths</code> must be one or more <a href="xpath.html"><code>XPath</code></a> queries.</p> <p>See <a href="searchable.html#method-i-xpath"><code>Searchable#xpath</code></a> for more information.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-css"> <span class="method-callseq"> css(*rules, [namespace-bindings, custom-pseudo-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="css-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 126
def css(*args)
  rules, handler, ns, _ = extract_params(args)

  css_internal(self, rules, handler, ns)
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this object for <a href="../css.html"><code>CSS</code></a> <code>rules</code>. <code>rules</code> must be one or more <a href="../css.html"><code>CSS</code></a> selectors. For example:</p> <pre class="ruby" data-language="ruby">node.css('title')
node.css('body h1.bold')
node.css('div + p.green', 'div#one')
</pre> <p>A hash of namespace bindings may be appended. For example:</p> <pre class="ruby" data-language="ruby">node.css('bike|tire', {'bike' =&gt; 'http://schwinn.com/'})
</pre> <p>💡 Custom <a href="../css.html"><code>CSS</code></a> pseudo classes may also be defined which are mapped to a custom <a href="xpath.html"><code>XPath</code></a> function. To define custom pseudo classes, create a class and implement the custom pseudo class you want defined. The first argument to the method will be the matching context <a href="nodeset.html"><code>NodeSet</code></a>. Any other arguments are ones that you pass in. For example:</p> <pre class="ruby" data-language="ruby">handler = Class.new {
  def regex(node_set, regex)
    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  end
}.new
node.css('title:regex("\w+")', handler)
</pre> <p>💡 Some <a href="xpath.html"><code>XPath</code></a> syntax is supported in <a href="../css.html"><code>CSS</code></a> queries. For example, to query for an attribute:</p> <pre class="ruby" data-language="ruby">node.css('img &gt; @href') # returns all +href+ attributes on an +img+ element
node.css('img / @href') # same

# ⚠ this returns +class+ attributes from all +div+ elements AND THEIR CHILDREN!
node.css('div @class')

node.css
</pre> <p>💡 Array-like syntax is supported in <a href="../css.html"><code>CSS</code></a> queries as an alternative to using +:nth-child()+.</p> <p>⚠ NOTE that indices are 1-based like <code>:nth-child</code> and not 0-based like Ruby Arrays. For example:</p> <pre class="ruby" data-language="ruby"># equivalent to 'li:nth-child(2)'
node.css('li[2]') # retrieve the second li element in a list
</pre> <p>⚠ NOTE that the <a href="../css.html"><code>CSS</code></a> query string is case-sensitive with regards to your document type. <a href="../html4.html"><code>HTML</code></a> tags will match only lowercase <a href="../css.html"><code>CSS</code></a> queries, so if you search for “H1” in an <a href="../html4.html"><code>HTML</code></a> document, you’ll never find anything. However, “H1” might be found in an <a href="../xml.html"><code>XML</code></a> document, where tags names are case-sensitive (e.g., “H1” is distinct from “h1”).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-search"> <span class="method-callseq"> search(*paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="search-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 51
def search(*args)
  paths, handler, ns, binds = extract_params(args)

  xpaths = paths.map(&amp;:to_s).map do |path|
    LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)
  end.flatten.uniq

  xpath(*(xpaths + [ns, handler, binds].compact))
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this object for <code>paths</code>. <code>paths</code> must be one or more <a href="xpath.html"><code>XPath</code></a> or <a href="../css.html"><code>CSS</code></a> queries:</p> <pre class="ruby" data-language="ruby">node.search("div.employee", ".//title")
</pre> <p>A hash of namespace bindings may be appended:</p> <pre class="ruby" data-language="ruby">node.search('.//bike:tire', {'bike' =&gt; 'http://schwinn.com/'})
node.search('bike|tire', {'bike' =&gt; 'http://schwinn.com/'})
</pre> <p>For <a href="xpath.html"><code>XPath</code></a> queries, a hash of variable bindings may also be appended to the namespace bindings. For example:</p> <pre class="ruby" data-language="ruby">node.search('.//address[@domestic=$value]', nil, {:value =&gt; 'Yes'})
</pre> <p>💡 Custom <a href="xpath.html"><code>XPath</code></a> functions and <a href="../css.html"><code>CSS</code></a> pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching <a href="nodeset.html"><code>NodeSet</code></a>. Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:</p> <pre class="ruby" data-language="ruby">handler = Class.new {
  def regex node_set, regex
    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  end
}.new
node.search('.//title[regex(., "\w+")]', 'div.employee:regex("[0-9]+")', handler)
</pre> <p>See <a href="searchable.html#method-i-xpath"><code>Searchable#xpath</code></a> and <a href="searchable.html#method-i-css"><code>Searchable#css</code></a> for further usage help.</p>  </div> <div class="aliases"> Also aliased as: <a href="searchable.html#method-i-2F">/</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-xpath"> <span class="method-callseq"> xpath(*paths, [namespace-bindings, variable-bindings, custom-handler-class]) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="xpath-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/searchable.rb, line 174
def xpath(*args)
  paths, handler, ns, binds = extract_params(args)

  xpath_internal(self, paths, handler, ns, binds)
end</pre> </div> <div class="mixin-from"> Included from <a href="searchable.html">Nokogiri::XML::Searchable</a> </div> <p>Search this node for <a href="xpath.html"><code>XPath</code></a> <code>paths</code>. <code>paths</code> must be one or more <a href="xpath.html"><code>XPath</code></a> queries.</p> <pre class="ruby" data-language="ruby">node.xpath('.//title')
</pre> <p>A hash of namespace bindings may be appended. For example:</p> <pre class="ruby" data-language="ruby">node.xpath('.//foo:name', {'foo' =&gt; 'http://example.org/'})
node.xpath('.//xmlns:name', node.root.namespaces)
</pre> <p>A hash of variable bindings may also be appended to the namespace bindings. For example:</p> <pre class="ruby" data-language="ruby">node.xpath('.//address[@domestic=$value]', nil, {:value =&gt; 'Yes'})
</pre> <p>💡 Custom <a href="xpath.html"><code>XPath</code></a> functions may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching <a href="nodeset.html"><code>NodeSet</code></a>. Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:</p> <pre class="ruby" data-language="ruby">handler = Class.new {
  def regex(node_set, regex)
    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  end
}.new
node.xpath('.//title[regex(., "\w+")]', handler)
</pre>  </div> </div> </section> </section> <section id="Serialization+and+Generating+Output" class="documentation-section"> <header class="documentation-section-title"> <h2 id="Serialization+and+Generating+Output"> Serialization and Generating Output </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Serialization+and+Generating+Output-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-canonicalize"> <span class="method-name">canonicalize</span><span class="method-args">(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="canonicalize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1398
def canonicalize(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)
  c14n_root = self
  document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
    tn = node.is_a?(XML::Node) ? node : parent
    tn == c14n_root || tn.ancestors.include?(c14n_root)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-callseq"> deconstruct_keys(array_of_names) → Hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1459
def deconstruct_keys(keys)
  requested_keys = DECONSTRUCT_KEYS &amp; keys
  {}.tap do |values|
    requested_keys.each do |key|
      method = DECONSTRUCT_METHODS[key] || key
      values[key] = send(method)
    end
  end
end</pre> </div> <p>Returns a hash describing the <a href="node.html"><code>Node</code></a>, to use in pattern matching.</p> <p>Valid keys and their values:</p> <ul> <li> <p><code>name</code> → (String) The name of this node, or “text” if it is a <a href="text.html"><code>Text</code></a> node.</p> </li> <li> <p><code>namespace</code> → (<a href="namespace.html"><code>Namespace</code></a>, nil) The namespace of this node, or nil if there is no namespace.</p> </li> <li> <p><code>attributes</code> → (Array&lt;Attr&gt;) The attributes of this node.</p> </li> <li> <p><code>children</code> → (Array&lt;Node&gt;) The children of this node. 💡 Note this includes text nodes.</p> </li> <li> <p><code>elements</code> → (Array&lt;Node&gt;) The child elements of this node. 💡 Note this does not include text nodes.</p> </li> <li> <p><code>content</code> → (String) The contents of all the text nodes in this node’s subtree. See <a href="node.html#method-i-content"><code>#content</code></a>.</p> </li> <li> <p><code>inner_html</code> → (String) The inner markup for the children of this node. See <a href="node.html#method-i-inner_html"><code>#inner_html</code></a>.</p> </li> </ul> <p>⚡ This is an experimental feature, available since v1.14.0</p> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML.parse(&lt;&lt;~XML)
  &lt;?xml version="1.0"?&gt;
  &lt;parent xmlns="http://nokogiri.org/ns/default" xmlns:noko="http://nokogiri.org/ns/noko"&gt;
    &lt;child1 foo="abc" noko:bar="def"&gt;First&lt;/child1&gt;
    &lt;noko:child2 foo="qwe" noko:bar="rty"&gt;Second&lt;/noko:child2&gt;
  &lt;/parent&gt;
XML

doc.root.deconstruct_keys([:name, :namespace])
# =&gt; {:name=&gt;"parent",
#     :namespace=&gt;
#      #(Namespace:0x35c { href = "http://nokogiri.org/ns/default" })}

doc.root.deconstruct_keys([:inner_html, :content])
# =&gt; {:content=&gt;"\n" + "  First\n" + "  Second\n",
#     :inner_html=&gt;
#      "\n" +
#      "  &lt;child1 foo=\"abc\" noko:bar=\"def\"&gt;First&lt;/child1&gt;\n" +
#      "  &lt;noko:child2 foo=\"qwe\" noko:bar=\"rty\"&gt;Second&lt;/noko:child2&gt;\n"}

doc.root.elements.first.deconstruct_keys([:attributes])
# =&gt; {:attributes=&gt;
#      [#(Attr:0x370 { name = "foo", value = "abc" }),
#       #(Attr:0x384 {
#         name = "bar",
#         namespace = #(Namespace:0x398 {
#           prefix = "noko",
#           href = "http://nokogiri.org/ns/noko"
#           }),
#         value = "def"
#         })]}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-serialize"> <span class="method-name">serialize</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="serialize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1280
def serialize(*args, &amp;block)
  options = if args.first.is_a?(Hash)
    args.shift
  else
    {
      encoding: args[0],
      save_with: args[1],
    }
  end

  options[:encoding] ||= document.encoding
  encoding = Encoding.find(options[:encoding] || "UTF-8")

  io = StringIO.new(String.new(encoding: encoding))

  write_to(io, options, &amp;block)
  io.string
end</pre> </div> <p>Serialize <a href="node.html"><code>Node</code></a> using <code>options</code>. Save options can also be set using a block.</p> <p>See also <a href="node/saveoptions.html"><code>Nokogiri::XML::Node::SaveOptions</code></a> and <a href="node.html#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output">Serialization and Generating Output at <code>Node</code></a>.</p> <p>These two statements are equivalent:</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8', :save_with =&gt; FORMAT | AS_XML)
</pre> <p>or</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8') do |config|
  config.format.as_xml
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_html"> <span class="method-name">to_html</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1306
def to_html(options = {})
  to_format(SaveOptions::DEFAULT_HTML, options)
end</pre> </div> <p>Serialize this <a href="node.html"><code>Node</code></a> to <a href="../html4.html"><code>HTML</code></a></p> <pre class="ruby" data-language="ruby">doc.to_html
</pre> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code>. For formatted output, use <a href="node.html#method-i-to_xhtml"><code>Node#to_xhtml</code></a> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_xhtml"> <span class="method-name">to_xhtml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_xhtml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1327
def to_xhtml(options = {})
  to_format(SaveOptions::DEFAULT_XHTML, options)
end</pre> </div> <p>Serialize this <a href="node.html"><code>Node</code></a> to XHTML using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xhtml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1316
def to_xml(options = {})
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  serialize(options)
end</pre> </div> <p>Serialize this <a href="node.html"><code>Node</code></a> to <a href="../xml.html"><code>XML</code></a> using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_html_to"> <span class="method-name">write_html_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_html_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1375
def write_html_to(io, options = {})
  write_format_to(SaveOptions::DEFAULT_HTML, io, options)
end</pre> </div> <p>Write <a href="node.html"><code>Node</code></a> as <a href="../html4.html"><code>HTML</code></a> to <code>io</code> with <code>options</code></p> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_to"> <span class="method-name">write_to</span><span class="method-args">(io, *options) { |config| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1348
def write_to(io, *options)
  options = options.first.is_a?(Hash) ? options.shift : {}
  encoding = options[:encoding] || options[0]
  if Nokogiri.jruby?
    save_options = options[:save_with] || options[1]
    indent_times = options[:indent] || 0
  else
    save_options = options[:save_with] || options[1] || SaveOptions::FORMAT
    indent_times = options[:indent] || 2
  end
  indent_text = options[:indent_text] || " "

  # Any string times 0 returns an empty string. Therefore, use the same
  # string instead of generating a new empty string for every node with
  # zero indentation.
  indentation = indent_times.zero? ? "" : (indent_text * indent_times)

  config = SaveOptions.new(save_options.to_i)
  yield config if block_given?

  native_write_to(io, encoding, indentation, config.options)
end</pre> </div> <p>Write <a href="node.html"><code>Node</code></a> to <code>io</code> with <code>options</code>. <code>options</code> modify the output of this method. Valid options are:</p> <ul> <li> <p><code>:encoding</code> for changing the encoding</p> </li> <li> <p><code>:indent_text</code> the indentation text, defaults to one space</p> </li> <li> <p><code>:indent</code> the number of <code>:indent_text</code> to use, defaults to 2</p> </li> <li> <p><code>:save_with</code> a combination of <a href="node/saveoptions.html"><code>SaveOptions</code></a> constants.</p> </li> </ul> <p>To save with UTF-8 indented twice:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :encoding =&gt; 'UTF-8', :indent =&gt; 2)
</pre> <p>To save indented with two dashes:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :indent_text =&gt; '-', :indent =&gt; 2)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_xhtml_to"> <span class="method-name">write_xhtml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_xhtml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1383
def write_xhtml_to(io, options = {})
  write_format_to(SaveOptions::DEFAULT_XHTML, io, options)
end</pre> </div> <p>Write <a href="node.html"><code>Node</code></a> as XHTML to <code>io</code> with <code>options</code></p> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_xml_to"> <span class="method-name">write_xml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_xml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1393
def write_xml_to(io, options = {})
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  write_to(io, options)
end</pre> </div> <p>Write <a href="node.html"><code>Node</code></a> as <a href="../xml.html"><code>XML</code></a> to <code>io</code> with <code>options</code></p> <pre class="ruby" data-language="ruby">doc.write_xml_to io, :encoding =&gt; 'UTF-8'
</pre> <p>See <a href="node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of options</p>  </div> </div> </section> </section> <section id="Traversing+Document+Structure" class="documentation-section"> <header class="documentation-section-title"> <h2 id="Traversing+Document+Structure"> Traversing Document Structure </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Traversing+Document+Structure-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-child"> <span class="method-callseq"> child() → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_child(VALUE self)
{
  xmlNodePtr node, child;
  Noko_Node_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>First of this node’s children, or <code>nil</code> if there are no children</p> </dd> </dl> <p>This is a convenience method and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.children.first
</pre> <p>See related: <a href="node.html#method-i-children"><code>#children</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-children"> <span class="method-callseq"> children() → Nokogiri::XML::NodeSet </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="children-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Noko_Node_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = child-&gt;next;
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child-&gt;next;
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><a href="nodeset.html"><code>Nokogiri::XML::NodeSet</code></a> containing this node’s children.</p> </dd> </dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-document"> <span class="method-callseq"> document() → Nokogiri::XML::Document </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="document-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_document(VALUE self)
{
  xmlNodePtr node;
  Noko_Node_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node-&gt;doc);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Parent <a href="document.html"><code>Nokogiri::XML::Document</code></a> for this node</p> </dd> </dl>  </div> </div> </section> </section> <section id="Working+With+Node+Attributes" class="documentation-section"> <header class="documentation-section-title"> <h2 id="Working+With+Node+Attributes"> Working With Node Attributes </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Working+With+Node+Attributes-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> [](name) → (String, nil) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 512
def [](name)
  get(name.to_s)
end</pre> </div> <p>Fetch an attribute from this node.</p> <p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes, use <a href="node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>(String, nil) value of the attribute <code>name</code>, or <code>nil</code> if no matching attribute exists</p> </dd> </dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child["size"] # =&gt; "large"
child["class"] # =&gt; "big wide tall"
</pre> <p><strong>Example:</strong> Namespaced attributes will not be returned.</p> <p>⚠ Note namespaced attributes may be accessed with <a href="node.html#method-i-attribute"><code>#attribute</code></a> or <a href="node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child width:size='broad'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child")["size"] # =&gt; nil
doc.at_css("child").attribute("size").value # =&gt; "broad"
doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
# =&gt; "broad"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-get_attribute">get_attribute</a>, <a href="node.html#method-i-attr">attr</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> []=(name, value) → value </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 550
def []=(name, value)
  set(name.to_s, value.to_s)
end</pre> </div> <p>Update the attribute <code>name</code> to <code>value</code>, or create the attribute if it does not exist.</p> <p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes for update, use <a href="node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>. To add a namespaced attribute, see the example below.</p> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>value</code></p> </dd> </dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child["size"] = "broad"
child.to_html
# =&gt; "&lt;child size=\"broad\"&gt;&lt;/child&gt;"
</pre> <p><strong>Example:</strong> Add a namespaced attribute.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child/&gt;
  &lt;/root&gt;
EOF
child = doc.at_css("child")
child["size"] = "broad"
ns = doc.root.namespace_definitions.find { |ns| ns.prefix == "width" }
child.attribute("size").namespace = ns
doc.to_html
# =&gt; "&lt;root xmlns:width=\"http://example.com/widths\"&gt;\n" +
#    "  &lt;child width:size=\"broad\"&gt;&lt;/child&gt;\n" +
#    "&lt;/root&gt;\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-set_attribute">set_attribute</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_class"> <span class="method-callseq"> add_class(names) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 715
def add_class(names)
  kwattr_add("class", names)
end</pre> </div> <p>Ensure <a href="../html4.html"><code>HTML</code></a> <a href="../css.html"><code>CSS</code></a> classes are present on <code>self</code>. Any <a href="../css.html"><code>CSS</code></a> classes in <code>names</code> that already exist in the “class” attribute are <em>not</em> added. Note that any existing duplicates in the “class” attribute are not removed. Compare with <a href="node.html#method-i-append_class"><code>#append_class</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_add("class", names)
</pre> <p>See related: <a href="node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node.html#method-i-classes"><code>#classes</code></a>, <a href="node.html#method-i-append_class"><code>#append_class</code></a>, <a href="node.html#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul><li> <p><code>names</code> (String, Array&lt;String&gt;)</p> <p><a href="../css.html"><code>CSS</code></a> class names to be added to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will not be added. Any class names not present will be added. If no “class” attribute exists, one is created.</p> </li></ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example:</strong> Ensure that the node has <a href="../css.html"><code>CSS</code></a> class “section”</p> <pre class="ruby" data-language="ruby">node                      # =&gt; &lt;div&gt;&lt;/div&gt;
node.add_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.add_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt; # duplicate not added
</pre> <p><strong>Example:</strong> Ensure that the node has <a href="../css.html"><code>CSS</code></a> classes “section” and “header”, via a String argument</p> <p>Note that the <a href="../css.html"><code>CSS</code></a> class “section” is not added because it is already present. Note also that the pre-existing duplicate <a href="../css.html"><code>CSS</code></a> class “section” is not removed.</p> <pre class="ruby" data-language="ruby">node                             # =&gt; &lt;div class="section section"&gt;&lt;/div&gt;
node.add_class("section header") # =&gt; &lt;div class="section section header"&gt;&lt;/div&gt;
</pre> <p><strong>Example:</strong> Ensure that the node has <a href="../css.html"><code>CSS</code></a> classes “section” and “header”, via an Array argument</p> <pre class="ruby" data-language="ruby">node                                  # =&gt; &lt;div&gt;&lt;/div&gt;
node.add_class(["section", "header"]) # =&gt; &lt;div class="section header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-append_class"> <span class="method-callseq"> append_class(names) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="append_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 759
def append_class(names)
  kwattr_append("class", names)
end</pre> </div> <p>Add <a href="../html4.html"><code>HTML</code></a> <a href="../css.html"><code>CSS</code></a> classes to <code>self</code>, regardless of duplication. Compare with <a href="node.html#method-i-add_class"><code>#add_class</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_append("class", names)
</pre> <p>See related: <a href="node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node.html#method-i-classes"><code>#classes</code></a>, <a href="node.html#method-i-add_class"><code>#add_class</code></a>, <a href="node.html#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul><li> <p><code>names</code> (String, Array&lt;String&gt;)</p> <p><a href="../css.html"><code>CSS</code></a> class names to be appended to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. All class names passed in will be appended to the “class” attribute even if they are already present in the attribute value. If no “class” attribute exists, one is created.</p> </li></ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example:</strong> Append “section” to the node’s <a href="../css.html"><code>CSS</code></a> “class” attribute</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div&gt;&lt;/div&gt;
node.append_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.append_class("section") # =&gt; &lt;div class="section section"&gt;&lt;/div&gt; # duplicate added!
</pre> <p><strong>Example:</strong> Append “section” and “header” to the noded’s <a href="../css.html"><code>CSS</code></a> “class” attribute, via a String argument</p> <p>Note that the <a href="../css.html"><code>CSS</code></a> class “section” is appended even though it is already present</p> <pre class="ruby" data-language="ruby">node                                # =&gt; &lt;div class="section section"&gt;&lt;/div&gt;
node.append_class("section header") # =&gt; &lt;div class="section section section header"&gt;&lt;/div&gt;
</pre> <p><strong>Example:</strong> Append “section” and “header” to the node’s <a href="../css.html"><code>CSS</code></a> “class” attribute, via an Array argument</p> <pre class="ruby" data-language="ruby">node                                     # =&gt; &lt;div&gt;&lt;/div&gt;
node.append_class(["section", "header"]) # =&gt; &lt;div class="section header"&gt;&lt;/div&gt;
node.append_class(["section", "header"]) # =&gt; &lt;div class="section header section header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-attr"> <span class="method-name">attr</span><span class="method-args">(name)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-attribute"> <span class="method-callseq"> attribute(name) → Nokogiri::XML::Attr </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="attribute-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Noko_Node_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Attribute (<a href="attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with name <code>name</code>.</p> </dd> </dl> <p>⚠ Note that attribute namespaces are ignored and only the simple (non-namespace-prefixed) name is used to find a matching attribute. In case of a simple name collision, only one of the matching attributes will be returned. In this case, you will need to use <a href="node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child.attribute("size") # =&gt; #&lt;Nokogiri::XML::Attr:0x550 name="size" value="large"&gt;
child.attribute("class") # =&gt; #&lt;Nokogiri::XML::Attr:0x564 name="class" value="big wide tall"&gt;
</pre> <p><strong>Example</strong> showing that namespaced attributes will not be returned:</p> <p>⚠ Note that only one of the two matching attributes is returned.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute("size")
# =&gt; #(Attr:0x550 {
#      name = "size",
#      namespace = #(Namespace:0x564 {
#        prefix = "width",
#        href = "http://example.com/widths"
#        }),
#      value = "broad"
#      })
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-attribute_nodes"> <span class="method-callseq"> attribute_nodes() → Array&lt;Nokogiri::XML::Attr&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="attribute_nodes-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute_nodes(VALUE rb_node)
{
  xmlNodePtr c_node;

  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

  return noko_xml_node_attrs(c_node);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Attributes (an Array of <a href="attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node.</p> </dd> </dl> <p>Note that this is the preferred alternative to <a href="node.html#method-i-attributes"><code>#attributes</code></a> when the simple (non-namespace-prefixed) attribute names may collide.</p> <p><strong>Example:</strong></p> <p>Contrast this with the colliding-name example from <a href="node.html#method-i-attributes"><code>#attributes</code></a>.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute_nodes
# =&gt; [#(Attr:0x550 {
#       name = "size",
#       namespace = #(Namespace:0x564 {
#         prefix = "width",
#         href = "http://example.com/widths"
#         }),
#       value = "broad"
#       }),
#     #(Attr:0x578 {
#       name = "size",
#       namespace = #(Namespace:0x58c {
#         prefix = "height",
#         href = "http://example.com/heights"
#         }),
#       value = "tall"
#       })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-attribute_with_ns"> <span class="method-callseq"> attribute_with_ns(name, namespace) → Nokogiri::XML::Attr </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="attribute_with_ns-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Noko_Node_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
                      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre> </div> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Attribute (<a href="attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with matching <code>name</code> and <code>namespace</code>.</p> </dd> </dl> <ul> <li> <p><code>name</code> (String): the simple (non-namespace-prefixed) name of the attribute</p> </li> <li> <p><code>namespace</code> (String): the URI of the attribute’s namespace</p> </li> </ul> <p>See related: <a href="node.html#method-i-attribute"><code>#attribute</code></a></p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute_with_ns("size", "http://example.com/widths")
# =&gt; #(Attr:0x550 {
#      name = "size",
#      namespace = #(Namespace:0x564 {
#        prefix = "width",
#        href = "http://example.com/widths"
#        }),
#      value = "broad"
#      })
doc.at_css("child").attribute_with_ns("size", "http://example.com/heights")
# =&gt; #(Attr:0x578 {
#      name = "size",
#      namespace = #(Namespace:0x58c {
#        prefix = "height",
#        href = "http://example.com/heights"
#        }),
#      value = "tall"
#      })
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-attributes"> <span class="method-callseq"> attributes() → Hash&lt;String ⇒ Nokogiri::XML::Attr&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="attributes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 609
def attributes
  attribute_nodes.each_with_object({}) do |node, hash|
    hash[node.node_name] = node
  end
end</pre> </div> <p>Fetch this node’s attributes.</p> <p>⚠ Because the keys do not include any namespace information for the attribute, in case of a simple name collision, not all attributes will be returned. In this case, you will need to use <a href="node.html#method-i-attribute_nodes"><code>#attribute_nodes</code></a>.</p> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>Hash containing attributes belonging to <code>self</code>. The hash keys are String attribute names (without the namespace), and the hash values are <a href="attr.html"><code>Nokogiri::XML::Attr</code></a>.</p> </dd> </dl> <p><strong>Example</strong> with no namespaces:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
doc.at_css("child").attributes
# =&gt; {"size"=&gt;#(Attr:0x550 { name = "size", value = "large" }),
#     "class"=&gt;#(Attr:0x564 { name = "class", value = "big wide tall" })}
</pre> <p><strong>Example</strong> with a namespace:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root xmlns:desc='http://example.com/sizes'&gt;&lt;child desc:size='large'/&gt;&lt;/root&gt;")
doc.at_css("child").attributes
# =&gt; {"size"=&gt;
#      #(Attr:0x550 {
#        name = "size",
#        namespace = #(Namespace:0x564 {
#          prefix = "desc",
#          href = "http://example.com/sizes"
#          }),
#        value = "large"
#        })}
</pre> <p><strong>Example</strong> with an attribute name collision:</p> <p>⚠ Note that only one of the attributes is returned in the Hash.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attributes
# =&gt; {"size"=&gt;
#      #(Attr:0x550 {
#        name = "size",
#        namespace = #(Namespace:0x564 {
#          prefix = "height",
#          href = "http://example.com/heights"
#          }),
#        value = "tall"
#        })}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-classes"> <span class="method-callseq"> classes() → Array&lt;String&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="classes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 669
def classes
  kwattr_values("class")
end</pre> </div> <p>Fetch <a href="../css.html"><code>CSS</code></a> class names of a <a href="node.html"><code>Node</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_values("class")
</pre> <p>See related: <a href="node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node.html#method-i-add_class"><code>#add_class</code></a>, <a href="node.html#method-i-append_class"><code>#append_class</code></a>, <a href="node.html#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>The <a href="../css.html"><code>CSS</code></a> classes (Array of String) present in the Node’s “class” attribute. If the attribute is empty or non-existent, the return value is an empty array.</p> </dd> </dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">node         # =&gt; &lt;div class="section title header"&gt;&lt;/div&gt;
node.classes # =&gt; ["section", "title", "header"]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(name)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-remove_attribute">remove_attribute</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |node_name, value| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 635
def each
  attribute_nodes.each do |node|
    yield [node.node_name, node.value]
  end
end</pre> </div> <p>Iterate over each attribute name and value pair for this <a href="node.html"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-get_attribute"> <span class="method-name">get_attribute</span><span class="method-args">(name)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-has_attribute-3F"> <span class="method-name">has_attribute?</span><span class="method-args">(p1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-key-3F">key?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-keys"> <span class="method-name">keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 629
def keys
  attribute_nodes.map(&amp;:node_name)
end</pre> </div> <p>Get the attribute names for this <a href="node.html"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-kwattr_add"> <span class="method-callseq"> kwattr_add(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_add-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 892
def kwattr_add(attribute_name, keywords)
  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = (current_kws + (keywords - current_kws)).join(" ")
  set_attribute(attribute_name, new_kws)
  self
end</pre> </div> <p>Ensure that values are present in a keyword attribute.</p> <p>Any values in <code>keywords</code> that already exist in the Node’s attribute values are <em>not</em> added. Note that any existing duplicates in the attribute values are not removed. Compare with <a href="node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../css.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node.html#method-i-add_class"><code>#add_class</code></a>, <a href="node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li> <li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any values already present will not be added. Any values not present will be added. If the named attribute does not exist, it is created.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” in its <code>rel</code> attribute.</p> <p>Note that duplicates are not added.</p> <pre class="ruby" data-language="ruby">node                               # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_add("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_add("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via a String argument.</p> <pre>Note that "nofollow" is not added because it is already present. Note also that the
pre-existing duplicate "nofollow" is not removed.

 node                                          # =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;
 node.kwattr_add("rel", "nofollow noreferrer") # =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;</pre> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via an Array argument.</p> <pre class="ruby" data-language="ruby">node                                               # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_add("rel", ["nofollow", "noreferrer"]) # =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-kwattr_append"> <span class="method-callseq"> kwattr_append(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_append-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 945
def kwattr_append(attribute_name, keywords)
  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = (current_kws + keywords).join(" ")
  set_attribute(attribute_name, new_kws)
  self
end</pre> </div> <p>Add keywords to a Node’s keyword attribute, regardless of duplication. Compare with <a href="node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../css.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node.html#method-i-append_class"><code>#append_class</code></a>, <a href="node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li> <li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. All values passed in will be appended to the named attribute even if they are already present in the attribute. If the named attribute does not exist, it is created.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example:</strong> Append “nofollow” to the <code>rel</code> attribute.</p> <p>Note that duplicates are added.</p> <pre class="ruby" data-language="ruby">node                                  # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow") # =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via a String argument.</p> <p>Note that “nofollow” is appended even though it is already present.</p> <pre class="ruby" data-language="ruby">node                                             # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow noreferrer") # =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via an Array argument.</p> <pre class="ruby" data-language="ruby">node                                                  # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_append("rel", ["nofollow", "noreferrer"]) # =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-kwattr_remove"> <span class="method-callseq"> kwattr_remove(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_remove-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 988
def kwattr_remove(attribute_name, keywords)
  if keywords.nil?
    remove_attribute(attribute_name)
    return self
  end

  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = current_kws - keywords
  if new_kws.empty?
    remove_attribute(attribute_name)
  else
    set_attribute(attribute_name, new_kws.join(" "))
  end
  self
end</pre> </div> <p>Remove keywords from a keyword attribute. Any matching keywords that exist in the named attribute are removed, including any multiple entries.</p> <p>If no keywords remain after this operation, or if <code>keywords</code> is <code>nil</code>, the attribute is deleted from the node.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../css.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node.html#method-i-remove_class"><code>#remove_class</code></a>, <a href="node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node.html#method-i-kwattr_append"><code>#kwattr_append</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul> <li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li> <li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be removed from the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any keywords present in the named attribute will be removed. If no keywords remain, or if <code>keywords</code> is nil, the attribute is deleted.</p> </li> </ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example:</strong></p> <p>Note that the <code>rel</code> attribute is deleted when empty.</p> <pre class="ruby" data-language="ruby">node                                    # =&gt; &lt;a rel="nofollow noreferrer"&gt;link&lt;/a&gt;
node.kwattr_remove("rel", "nofollow")   # =&gt; &lt;a rel="noreferrer"&gt;link&lt;/a&gt;
node.kwattr_remove("rel", "noreferrer") # =&gt; &lt;a&gt;link&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-kwattr_values"> <span class="method-callseq"> kwattr_values(attribute_name) → Array&lt;String&gt; </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 838
def kwattr_values(attribute_name)
  keywordify(get_attribute(attribute_name) || [])
end</pre> </div> <p>Fetch values from a keyword attribute of a <a href="node.html"><code>Node</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../css.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node.html#method-i-classes"><code>#classes</code></a>, <a href="node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul><li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be inspected.</p> </li></ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p>(Array&lt;String&gt;) The values present in the Node’s <code>attribute_name</code> attribute. If the attribute is empty or non-existent, the return value is an empty array.</p> </dd> </dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">node                      # =&gt; &lt;a rel="nofollow noopener external"&gt;link&lt;/a&gt;
node.kwattr_values("rel") # =&gt; ["nofollow", "noopener", "external"]
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-remove_attribute"> <span class="method-name">remove_attribute</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="remove_attribute-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 643
def remove_attribute(name)
  attr = attributes[name].remove if key?(name)
  clear_xpath_context if Nokogiri.jruby?
  attr
end</pre> </div> <p>Remove the attribute named <code>name</code></p>  </div> <div class="aliases"> Also aliased as: <a href="node.html#method-i-delete">delete</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-remove_class"> <span class="method-callseq"> remove_class(css_classes) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="remove_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 809
def remove_class(names = nil)
  kwattr_remove("class", names)
end</pre> </div> <p>Remove <a href="../html4.html"><code>HTML</code></a> <a href="../css.html"><code>CSS</code></a> classes from this node. Any <a href="../css.html"><code>CSS</code></a> class names in <code>css_classes</code> that exist in this node’s “class” attribute are removed, including any multiple entries.</p> <p>If no <a href="../css.html"><code>CSS</code></a> classes remain after this operation, or if <code>css_classes</code> is <code>nil</code>, the “class” attribute is deleted from the node.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_remove("class", css_classes)
</pre> <p>Also see <a href="node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a>, <a href="node.html#method-i-classes"><code>#classes</code></a>, <a href="node.html#method-i-add_class"><code>#add_class</code></a>, <a href="node.html#method-i-append_class"><code>#append_class</code></a></p> <dl class="rdoc-list label-list"> <dt>Parameters </dt>  </dl> <ul><li> <p><code>css_classes</code> (String, Array&lt;String&gt;)</p> <p><a href="../css.html"><code>CSS</code></a> class names to be removed from the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will be removed. If no <a href="../css.html"><code>CSS</code></a> classes remain, the “class” attribute is deleted.</p> </li></ul> <dl class="rdoc-list label-list"> <dt>Returns </dt> <dd> <p><code>self</code> (<a href="node.html"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p> </dd> </dl> <p><strong>Example</strong>: Deleting a <a href="../css.html"><code>CSS</code></a> class</p> <p>Note that all instances of the class “section” are removed from the “class” attribute.</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div class="section header section"&gt;&lt;/div&gt;
node.remove_class("section") # =&gt; &lt;div class="header"&gt;&lt;/div&gt;
</pre> <p><strong>Example</strong>: Deleting the only remaining <a href="../css.html"><code>CSS</code></a> class</p> <p>Note that the attribute is removed once there are no remaining classes.</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.remove_class("section") # =&gt; &lt;div&gt;&lt;/div&gt;
</pre> <p><strong>Example</strong>: Deleting multiple <a href="../css.html"><code>CSS</code></a> classes</p> <p>Note that the “class” attribute is deleted once it’s empty.</p> <pre class="ruby" data-language="ruby">node                                    # =&gt; &lt;div class="section header float"&gt;&lt;/div&gt;
node.remove_class(["section", "float"]) # =&gt; &lt;div class="header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-set_attribute"> <span class="method-callseq"> []=(name, value) → value </span> </div> </div>  <div class="aliases"> Alias for: <a href="node.html#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-value-3F"> <span class="method-name">value?</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="value-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 623
def value?(value)
  values.include?(value)
end</pre> </div> <p>Does this Node’s attributes include &lt;value&gt;</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 617
def values
  attribute_nodes.map(&amp;:value)
end</pre> </div> <p>Get the attribute values for this <a href="node.html"><code>Node</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,<br>Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,<br>Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.<br>
    <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html" class="_attribution-link">https://nokogiri.org/rdoc/Nokogiri/XML/Node.html</a>
  </p>
</div>
