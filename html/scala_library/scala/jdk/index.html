<h1>Package scala.jdk</h1>
<h2 id="signature">
<span class="modifier_kind"> <span class="kind">package</span></span> <span class="symbol"><span class="name">jdk</span></span>
</h2>

<div id="template"><div id="allMembers">
<div id="packages" class="package members">
<h2>Package Members</h2>
<h3 id="scala.jdk.javaapi">
<span class="modifier_kind"> <span class="kind">package </span></span><span class="symbol"><a href="javaapi/index.html" title=""><span class="name">javaapi</span></a></span>
</h3>
   </div>
<div id="types" class="types members">
<h2>Type Members</h2>
<h3 id="scala.jdk.Accumulator">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="accumulator.html" title="Accumulators are mutable sequences with two distinct features:"><span class="name">Accumulator</span></a><span class="tparams">[<span name="A">A</span>, <span name="CC">+CC<span class="tparams">[<span name="X">X</span>]</span> &lt;: <a href="../collection/mutable/seq.html" name="scala.collection.mutable.Seq" id="scala.collection.mutable.Seq" class="extype">collection.mutable.Seq</a>[<span name="scala.jdk.Accumulator.CC.X" class="extype">X</span>]</span>, <span name="C">+C &lt;: <a href="../collection/mutable/seq.html" name="scala.collection.mutable.Seq" id="scala.collection.mutable.Seq" class="extype">collection.mutable.Seq</a>[<span name="scala.jdk.Accumulator.A" class="extype">A</span>]</span>]</span><span class="result"> extends <a href="../collection/mutable/seq.html" name="scala.collection.mutable.Seq" id="scala.collection.mutable.Seq" class="extype">collection.mutable.Seq</a>[<span name="scala.jdk.Accumulator.A" class="extype">A</span>] with <a href="../collection/mutable/builder.html" name="scala.collection.mutable.Builder" id="scala.collection.mutable.Builder" class="extype">Builder</a>[<span name="scala.jdk.Accumulator.A" class="extype">A</span>, <span name="scala.jdk.Accumulator.C" class="extype">C</span>]</span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Accumulators are mutable sequences with two distinct features:</p>
<ul>
An accumulator can be appended efficiently to anotherThere are manually specialized Accumulators for <code>Int</code>, <code>Long</code> and <code>Double</code> that don't box the elements</ul>
<p>These two features make Accumulators a good candidate to collect the results of a parallel Java stream pipeline into a Scala collection. The <a href="../collection/convert/streamextensions%24streamhastoscala.html#toScala%5BC1%5D(factory:scala.collection.Factory%5BA,C1%5D)(implicitinfo:collection.convert.StreamExtensions.AccumulatorFactoryInfo%5BA,C1%5D):C1" name="scala.collection.convert.StreamExtensions.StreamHasToScala#toScala" id="scala.collection.convert.StreamExtensions.StreamHasToScala#toScala" class="extmbr">scala.collection.convert.StreamExtensions.StreamHasToScala.toScala</a> extension method on Java streams (available by importing <a href="streamconverters%24.html" name="scala.jdk.StreamConverters" id="scala.jdk.StreamConverters" class="extype"><code>scala.jdk.StreamConverters._</code></a>) is specialized for Accumulators: they are built in parallel, the parts are merged efficiently.</p>
<p>Building specialized Accumulators is handled transparently. As a user, using the <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a> object as a factory automatically creates an <a href="intaccumulator.html" name="scala.jdk.IntAccumulator" id="scala.jdk.IntAccumulator" class="extype">IntAccumulator</a>, <a href="longaccumulator.html" name="scala.jdk.LongAccumulator" id="scala.jdk.LongAccumulator" class="extype">LongAccumulator</a>, <a href="doubleaccumulator.html" name="scala.jdk.DoubleAccumulator" id="scala.jdk.DoubleAccumulator" class="extype">DoubleAccumulator</a> or <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a> depending on the element type.</p>
<p>Note: to run the example, start the Scala REPL with <code>scala -Yrepl-class-based</code> to avoid deadlocks, see <a href="https://github.com/scala/bug/issues/9076" target="_blank">https://github.com/scala/bug/issues/9076</a>.</p>
<pre data-language="scala">scala&gt; import scala.jdk.StreamConverters._
import scala.jdk.StreamConverters._

scala&gt; def isPrime(n: Int): Boolean = !(2 +: (3 to Math.sqrt(n).toInt by 2) exists (n % _ == 0))
isPrime: (n: Int)Boolean

scala&gt; val intAcc = (1 to 10000).asJavaParStream.filter(isPrime).toScala(scala.jdk.Accumulator)
intAcc: scala.jdk.IntAccumulator = IntAccumulator(1, 3, 5, 7, 11, 13, 17, 19, ...

scala&gt; val stringAcc = (1 to 100).asJavaParStream.mapToObj("&lt;&gt;" * _).toScala(Accumulator)
stringAcc: scala.jdk.AnyAccumulator[String] = AnyAccumulator(&lt;&gt;, &lt;&gt;&lt;&gt;, &lt;&gt;&lt;&gt;&lt;&gt;, ...</pre>
<p>There are two possibilities to process elements of a primitive Accumulator without boxing: specialized operations of the Accumulator, or the Stepper interface. The most common collection operations are overloaded or overridden in the primitive Accumulator classes, for example <a href="#" name="scala.jdk.IntAccumulator#map" id="scala.jdk.IntAccumulator#map" class="extmbr">IntAccumulator.map</a> or <a href="#" name="scala.jdk.IntAccumulator#exists" id="scala.jdk.IntAccumulator#exists" class="extmbr">IntAccumulator.exists</a>. Thanks to Scala's function specialization, <code>intAcc.exists(x =&gt; testOn(x))</code> does not incur boxing.</p>
<p>The <span name="Stepper" class="extype">Stepper</span> interface provides iterator-like <code>hasStep</code> and <code>nextStep</code> methods, and is specialized for <code>Int</code>, <code>Long</code> and <code>Double</code>. The <code>intAccumulator.stepper</code> method creates an <a href="../collection/intstepper.html" name="scala.collection.IntStepper" id="scala.collection.IntStepper" class="extype">scala.collection.IntStepper</a> that yields the elements of the accumulator without boxing.</p>
<p>Accumulators can hold more than <code>Int.MaxValue</code> elements. They have a <a href="accumulator.html#sizeLong:Long" name="scala.jdk.Accumulator#sizeLong" id="scala.jdk.Accumulator#sizeLong" class="extmbr">sizeLong</a> method that returns the size as a <code>Long</code>. Note that certain operations defined in <a href="../collection/seq.html" name="scala.collection.Seq" id="scala.collection.Seq" class="extype">scala.collection.Seq</a> are implemented using <a href="accumulator.html#length:Int" name="scala.jdk.Accumulator#length" id="scala.jdk.Accumulator#length" class="extmbr">length</a>, so they will not work correctly for large accumulators.</p>
<p>The <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a> class is a base class to share code between <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a> (for reference types) and the manual specializations <a href="intaccumulator.html" name="scala.jdk.IntAccumulator" id="scala.jdk.IntAccumulator" class="extype">IntAccumulator</a>, <a href="longaccumulator.html" name="scala.jdk.LongAccumulator" id="scala.jdk.LongAccumulator" class="extype">LongAccumulator</a> and <a href="doubleaccumulator.html" name="scala.jdk.DoubleAccumulator" id="scala.jdk.DoubleAccumulator" class="extype">DoubleAccumulator</a>. </p>
</div></div>
<h3 id="scala.jdk.AnyAccumulator">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class </span></span><span class="symbol"><a href="anyaccumulator.html" title="An Accumulator for arbitrary element types, see Accumulator."><span class="name">AnyAccumulator</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a>[<span name="scala.jdk.AnyAccumulator.A" class="extype">A</span>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>[<span name="scala.jdk.AnyAccumulator.A" class="extype">A</span>]] with <a href="../collection/mutable/seqops.html" name="scala.collection.mutable.SeqOps" id="scala.collection.mutable.SeqOps" class="extype">SeqOps</a>[<span name="scala.jdk.AnyAccumulator.A" class="extype">A</span>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>[<span name="scala.jdk.AnyAccumulator.A" class="extype">A</span>]] with <a href="../collection/iterablefactorydefaults.html" name="scala.collection.IterableFactoryDefaults" id="scala.collection.IterableFactoryDefaults" class="extype">IterableFactoryDefaults</a>[<span name="scala.jdk.AnyAccumulator.A" class="extype">A</span>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>] with <a href="../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <h3 id="scala.jdk.DoubleAccumulator">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class </span></span><span class="symbol"><a href="doubleaccumulator.html" title="A specialized Accumulator that holds Doubles without boxing, see Accumulator."><span class="name">DoubleAccumulator</span></a><span class="result"> extends <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a>[<a href="../double.html" name="scala.Double" id="scala.Double" class="extype">Double</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="doubleaccumulator.html" name="scala.jdk.DoubleAccumulator" id="scala.jdk.DoubleAccumulator" class="extype">DoubleAccumulator</a>] with <a href="../collection/mutable/seqops.html" name="scala.collection.mutable.SeqOps" id="scala.collection.mutable.SeqOps" class="extype">SeqOps</a>[<a href="../double.html" name="scala.Double" id="scala.Double" class="extype">Double</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="doubleaccumulator.html" name="scala.jdk.DoubleAccumulator" id="scala.jdk.DoubleAccumulator" class="extype">DoubleAccumulator</a>] with <a href="../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <h3 id="scala.jdk.IntAccumulator">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class </span></span><span class="symbol"><a href="intaccumulator.html" title="A specialized Accumulator that holds Ints without boxing, see Accumulator."><span class="name">IntAccumulator</span></a><span class="result"> extends <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a>[<a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="intaccumulator.html" name="scala.jdk.IntAccumulator" id="scala.jdk.IntAccumulator" class="extype">IntAccumulator</a>] with <a href="../collection/mutable/seqops.html" name="scala.collection.mutable.SeqOps" id="scala.collection.mutable.SeqOps" class="extype">SeqOps</a>[<a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="intaccumulator.html" name="scala.jdk.IntAccumulator" id="scala.jdk.IntAccumulator" class="extype">IntAccumulator</a>] with <a href="../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <h3 id="scala.jdk.LongAccumulator">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class </span></span><span class="symbol"><a href="longaccumulator.html" title="A specialized Accumulator that holds Longs without boxing, see Accumulator."><span class="name">LongAccumulator</span></a><span class="result"> extends <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a>[<a href="../long.html" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="longaccumulator.html" name="scala.jdk.LongAccumulator" id="scala.jdk.LongAccumulator" class="extype">LongAccumulator</a>] with <a href="../collection/mutable/seqops.html" name="scala.collection.mutable.SeqOps" id="scala.collection.mutable.SeqOps" class="extype">SeqOps</a>[<a href="../long.html" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>, <a href="longaccumulator.html" name="scala.jdk.LongAccumulator" id="scala.jdk.LongAccumulator" class="extype">LongAccumulator</a>] with <a href="../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <h3 id="scala.jdk.OptionShape">
<span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="optionshape.html" title="A type class implementing conversions from a generic Scala Option or Java Optional to a specialized Java variant (for Double, Int and Long)."><span class="name">OptionShape</span></a><span class="tparams">[<span name="A">A</span>, <span name="O">O</span>]</span><span class="result"> extends <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>A type class implementing conversions from a generic Scala <code>Option</code> or Java <code>Optional</code> to a specialized Java variant (for <code>Double</code>, <code>Int</code> and <code>Long</code>). </p></div>
<dl class="paramcmts block">
<dt class="tparam">A</dt>
<dd class="cmt"><p>the primitive type wrapped in an option</p></dd>
<dt class="tparam">O</dt>
<dd class="cmt"><p>the specialized Java <code>Optional</code> wrapping an element of type <code>A</code></p></dd>
</dl>
<dl class="attributes block">
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../annotation/implicitnotfound.html" name="scala.annotation.implicitNotFound" id="scala.annotation.implicitNotFound" class="extype">implicitNotFound</a></span><span class="args">(<span><span class="defval">"No specialized Optional type exists for elements of type ${A}"</span></span>)</span> </dd>
</dl>
</div>
<h3 id="scala.jdk.Priority0FunctionExtensions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="priority0functionextensions.html" title=""><span class="name">Priority0FunctionExtensions</span></a><span class="result"> extends <a href="priority1functionextensions.html" name="scala.jdk.Priority1FunctionExtensions" id="scala.jdk.Priority1FunctionExtensions" class="extype">Priority1FunctionExtensions</a></span></span>
</h3>
   <h3 id="scala.jdk.Priority1FunctionExtensions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="priority1functionextensions.html" title=""><span class="name">Priority1FunctionExtensions</span></a><span class="result"> extends <a href="priority2functionextensions.html" name="scala.jdk.Priority2FunctionExtensions" id="scala.jdk.Priority2FunctionExtensions" class="extype">Priority2FunctionExtensions</a></span></span>
</h3>
   <h3 id="scala.jdk.Priority2FunctionExtensions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="priority2functionextensions.html" title=""><span class="name">Priority2FunctionExtensions</span></a><span class="result"> extends <a href="priority3functionextensions.html" name="scala.jdk.Priority3FunctionExtensions" id="scala.jdk.Priority3FunctionExtensions" class="extype">Priority3FunctionExtensions</a></span></span>
</h3>
   <h3 id="scala.jdk.Priority3FunctionExtensions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="priority3functionextensions.html" title=""><span class="name">Priority3FunctionExtensions</span></a><span class="result"> extends <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span>
</h3>
   </div>
<div class="values members">
<h2>Value Members</h2>
<h3 id="scala.jdk.Accumulator">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="accumulator%24.html" title="Contains factory methods to build Accumulators."><span class="name">Accumulator</span></a></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Contains factory methods to build Accumulators.</p>
<p>Note that the <code>Accumulator</code> object itself is not a factory, but it is implicitly convert to a factory according to the element type, see <a href="accumulator%24.html#toFactory%5BA,C%5D(sa:scala.jdk.Accumulator.type)(implicitcanAccumulate:scala.jdk.Accumulator.AccumulatorFactoryShape%5BA,C%5D):scala.collection.Factory%5BA,C%5D" name="scala.jdk.Accumulator#toFactory" id="scala.jdk.Accumulator#toFactory" class="extmbr">Accumulator.toFactory</a>.</p>
<p>This allows passing the <code>Accumulator</code> object as argument when a <a href="../collection/factory.html" name="scala.collection.Factory" id="scala.collection.Factory" class="extype">collection.Factory</a>, and the implicit <a href="accumulator%24%24accumulatorfactoryshape.html" name="scala.jdk.Accumulator.AccumulatorFactoryShape" id="scala.jdk.Accumulator.AccumulatorFactoryShape" class="extype">Accumulator.AccumulatorFactoryShape</a> instance is used to build a specialized Accumulator according to the element type:</p>
<pre data-language="scala">scala&gt; val intAcc = Accumulator(1,2,3)
intAcc: scala.collection.convert.IntAccumulator = IntAccumulator(1, 2, 3)

scala&gt; val anyAccc = Accumulator("K")
anyAccc: scala.collection.convert.AnyAccumulator[String] = AnyAccumulator(K)

scala&gt; val intAcc2 = List(1,2,3).to(Accumulator)
intAcc2: scala.jdk.IntAccumulator = IntAccumulator(1, 2, 3)

scala&gt; val anyAcc2 = List("K").to(Accumulator)
anyAcc2: scala.jdk.AnyAccumulator[String] = AnyAccumulator(K)</pre>
</div></div>
<h3 id="scala.jdk.AnyAccumulator">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="anyaccumulator%24.html" title=""><span class="name">AnyAccumulator</span></a><span class="result"> extends <a href="../collection/seqfactory.html" name="scala.collection.SeqFactory" id="scala.collection.SeqFactory" class="extype">SeqFactory</a>[<a href="anyaccumulator.html" name="scala.jdk.AnyAccumulator" id="scala.jdk.AnyAccumulator" class="extype">AnyAccumulator</a>]</span></span>
</h3>
   <h3 id="scala.jdk.CollectionConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="collectionconverters%24.html" title="This object provides extension methods that convert between Scala and Java collections."><span class="name">CollectionConverters</span></a><span class="result"> extends <a href="../collection/convert/asjavaextensions.html" name="scala.collection.convert.AsJavaExtensions" id="scala.collection.convert.AsJavaExtensions" class="extype">AsJavaExtensions</a> with <a href="../collection/convert/asscalaextensions.html" name="scala.collection.convert.AsScalaExtensions" id="scala.collection.convert.AsScalaExtensions" class="extype">AsScalaExtensions</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods that convert between Scala and Java collections.</p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/collectionconverters%24.html" name="scala.jdk.javaapi.CollectionConverters" id="scala.jdk.javaapi.CollectionConverters" class="extype">javaapi.CollectionConverters</a> instead.</p>
<p>Note: to create <span name="java.util.stream.Stream" class="extype">Java Streams</span> that operate on Scala collections (sequentially or in parallel), use <a href="streamconverters%24.html" name="scala.jdk.StreamConverters" id="scala.jdk.StreamConverters" class="extype">StreamConverters</a>.</p>
<pre data-language="scala">import scala.jdk.CollectionConverters._
val s: java.util.Set[String] = Set("one", "two").asJava</pre>
<p>The conversions return adapters for the corresponding API, i.e., the collections are wrapped, not converted. Changes to the original collection are reflected in the view, and vice versa:</p>
<pre data-language="scala">scala&gt; import scala.jdk.CollectionConverters._

scala&gt; val s = collection.mutable.Set("one")
s: scala.collection.mutable.Set[String] = HashSet(one)

scala&gt; val js = s.asJava
js: java.util.Set[String] = [one]

scala&gt; js.add("two")

scala&gt; s
res2: scala.collection.mutable.Set[String] = HashSet(two, one)</pre>
<p>The following conversions are supported via <code>asScala</code> and <code>asJava</code>:</p>
<pre data-language="scala">scala.collection.Iterable       &lt;=&gt; java.lang.Iterable
scala.collection.Iterator       &lt;=&gt; java.util.Iterator
scala.collection.mutable.Buffer &lt;=&gt; java.util.List
scala.collection.mutable.Set    &lt;=&gt; java.util.Set
scala.collection.mutable.Map    &lt;=&gt; java.util.Map
scala.collection.concurrent.Map &lt;=&gt; java.util.concurrent.ConcurrentMap</pre>
<p>The following conversions are supported via <code>asScala</code> and through specially-named extension methods to convert to Java collections, as shown:</p>
<pre data-language="scala">scala.collection.Iterable    &lt;=&gt; java.util.Collection   (via asJavaCollection)
scala.collection.Iterator    &lt;=&gt; java.util.Enumeration  (via asJavaEnumeration)
scala.collection.mutable.Map &lt;=&gt; java.util.Dictionary   (via asJavaDictionary)</pre>
<p>In addition, the following one-way conversions are provided via <code>asJava</code>:</p>
<pre data-language="scala">scala.collection.Seq         =&gt; java.util.List
scala.collection.mutable.Seq =&gt; java.util.List
scala.collection.Set         =&gt; java.util.Set
scala.collection.Map         =&gt; java.util.Map</pre>
<p>The following one way conversion is provided via <code>asScala</code>:</p>
<pre data-language="scala">java.util.Properties =&gt; scala.collection.mutable.Map</pre>
<p>In all cases, converting from a source type to a target type and back again will return the original source object. For example:</p>
<pre data-language="scala">import scala.jdk.CollectionConverters._

val source = new scala.collection.mutable.ListBuffer[Int]
val target: java.util.List[Int] = source.asJava
val other: scala.collection.mutable.Buffer[Int] = target.asScala
assert(source eq other)</pre>
</div></div>
<h3 id="scala.jdk.DoubleAccumulator">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="doubleaccumulator%24.html" title=""><span class="name">DoubleAccumulator</span></a><span class="result"> extends <a href="../collection/specificiterablefactory.html" name="scala.collection.SpecificIterableFactory" id="scala.collection.SpecificIterableFactory" class="extype">SpecificIterableFactory</a>[<a href="../double.html" name="scala.Double" id="scala.Double" class="extype">Double</a>, <a href="doubleaccumulator.html" name="scala.jdk.DoubleAccumulator" id="scala.jdk.DoubleAccumulator" class="extype">DoubleAccumulator</a>] with <span name="java.io.Serializable" class="extype">java.io.Serializable</span></span></span>
</h3>
   <h3 id="scala.jdk.DurationConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="durationconverters%24.html" title="This object provides extension methods that convert between Scala and Java duration types."><span class="name">DurationConverters</span></a></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods that convert between Scala and Java duration types.</p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/durationconverters%24.html" name="scala.jdk.javaapi.DurationConverters" id="scala.jdk.javaapi.DurationConverters" class="extype">javaapi.DurationConverters</a> instead. </p>
</div></div>
<h3 id="scala.jdk.FunctionConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="functionconverters%24.html" title="This object provides extension methods that convert between Scala and Java function types."><span class="name">FunctionConverters</span></a><span class="result"> extends <a href="priority0functionextensions.html" name="scala.jdk.Priority0FunctionExtensions" id="scala.jdk.Priority0FunctionExtensions" class="extype">Priority0FunctionExtensions</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods that convert between Scala and Java function types.</p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/functionconverters%24.html" name="scala.jdk.javaapi.FunctionConverters" id="scala.jdk.javaapi.FunctionConverters" class="extype">javaapi.FunctionConverters</a> instead.</p>
<p>Using the <code>.asJava</code> extension method on a Scala function produces the most specific possible Java function type:</p>
<pre data-language="scala">scala&gt; import scala.jdk.FunctionConverters._
scala&gt; val f = (x: Int) =&gt; x + 1

scala&gt; val jf1 = f.asJava
jf1: java.util.function.IntUnaryOperator = ...</pre>
<p>More generic Java function types can be created using the corresponding <code>asJavaXYZ</code> extension method:</p>
<pre data-language="scala">scala&gt; val jf2 = f.asJavaFunction
jf2: java.util.function.Function[Int,Int] = ...

scala&gt; val jf3 = f.asJavaUnaryOperator
jf3: java.util.function.UnaryOperator[Int] = ...</pre>
<p>Converting a Java function to Scala is done using the <code>asScala</code> extension method:</p>
<pre data-language="scala">scala&gt; List(1,2,3).map(jf2.asScala)
res1: List[Int] = List(2, 3, 4)</pre>
</div></div>
<h3 id="scala.jdk.FunctionWrappers">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="functionwrappers%24.html" title=""><span class="name">FunctionWrappers</span></a></span>
</h3>
   <h3 id="scala.jdk.FutureConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="futureconverters%24.html" title="This object provides extension methods that convert between Scala Future and Java CompletionStage"><span class="name">FutureConverters</span></a></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods that convert between Scala <span name="Future" class="extype">Future</span> and Java <span name="CompletionStage" class="extype">CompletionStage</span></p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/futureconverters%24.html" name="scala.jdk.javaapi.FutureConverters" id="scala.jdk.javaapi.FutureConverters" class="extype">javaapi.FutureConverters</a> instead.</p>
<p>Note that the bridge is implemented at the read-only side of asynchronous handles, namely <span name="Future" class="extype">Future</span> (instead of <a href="../concurrent/promise.html" name="scala.concurrent.Promise" id="scala.concurrent.Promise" class="extype">scala.concurrent.Promise</a>) and <span name="CompletionStage" class="extype">CompletionStage</span> (instead of <span name="java.util.concurrent.CompletableFuture" class="extype">java.util.concurrent.CompletableFuture</span>). This is intentional, as the semantics of bridging the write-handles would be prone to race conditions; if both ends (<code>CompletableFuture</code> and <code>Promise</code>) are completed independently at the same time, they may contain different values afterwards. For this reason, <code>toCompletableFuture</code> is not supported on the created <code>CompletionStage</code>s. </p>
</div></div>
<h3 id="scala.jdk.IntAccumulator">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="intaccumulator%24.html" title=""><span class="name">IntAccumulator</span></a><span class="result"> extends <a href="../collection/specificiterablefactory.html" name="scala.collection.SpecificIterableFactory" id="scala.collection.SpecificIterableFactory" class="extype">SpecificIterableFactory</a>[<a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a>, <a href="intaccumulator.html" name="scala.jdk.IntAccumulator" id="scala.jdk.IntAccumulator" class="extype">IntAccumulator</a>] with <span name="java.io.Serializable" class="extype">java.io.Serializable</span></span></span>
</h3>
   <h3 id="scala.jdk.LongAccumulator">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="longaccumulator%24.html" title=""><span class="name">LongAccumulator</span></a><span class="result"> extends <a href="../collection/specificiterablefactory.html" name="scala.collection.SpecificIterableFactory" id="scala.collection.SpecificIterableFactory" class="extype">SpecificIterableFactory</a>[<a href="../long.html" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="longaccumulator.html" name="scala.jdk.LongAccumulator" id="scala.jdk.LongAccumulator" class="extype">LongAccumulator</a>] with <span name="java.io.Serializable" class="extype">java.io.Serializable</span></span></span>
</h3>
   <h3 id="scala.jdk.OptionConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="optionconverters%24.html" title="This object provides extension methods that convert between Scala Option and Java Optional types."><span class="name">OptionConverters</span></a></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods that convert between Scala <code>Option</code> and Java <code>Optional</code> types.</p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/optionconverters%24.html" name="scala.jdk.javaapi.OptionConverters" id="scala.jdk.javaapi.OptionConverters" class="extype">javaapi.OptionConverters</a> instead.</p>
<p>Scala <code>Option</code> is extended with a <code>toJava</code> method that creates a corresponding <code>Optional</code>, and a <code>toJavaPrimitive</code> method that creates a specialized variant (e.g., <code>OptionalInt</code>) if applicable.</p>
<p>Java <code>Optional</code> is extended with a <code>toScala</code> method and a <code>toJavaPrimitive</code> method.</p>
<p>Finally, specialized <code>Optional</code> types are extended with <code>toScala</code> and <code>toJavaGeneric</code> methods.</p>
<p>Example usage:</p>
<pre data-language="scala">import scala.jdk.OptionConverters._
val a = Option("example").toJava      // Creates java.util.Optional[String] containing "example"
val b = (None: Option[String]).toJava // Creates an empty java.util.Optional[String]
val c = a.toScala                     // Back to Option("example")
val d = b.toScala                     // Back to None typed as Option[String]
val e = Option(2.7).toJava            // java.util.Optional[Double] containing boxed 2.7
val f = Option(2.7).toJavaPrimitive   // java.util.OptionalDouble containing 2.7 (not boxed)
val g = f.toScala                     // Back to Option(2.7)
val h = f.toJavaGeneric               // Same as e
val i = e.toJavaPrimitive             // Same as f</pre>
</div></div>
<h3 id="scala.jdk.OptionShape">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="optionshape%24.html" title=""><span class="name">OptionShape</span></a></span>
</h3>
   <h3 id="scala.jdk.StreamConverters">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="streamconverters%24.html" title="This object provides extension methods to create Java Streams that operate on Scala collections (sequentially or in parallel)."><span class="name">StreamConverters</span></a><span class="result"> extends <a href="../collection/convert/streamextensions.html" name="scala.collection.convert.StreamExtensions" id="scala.collection.convert.StreamExtensions" class="extype">StreamExtensions</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>This object provides extension methods to create <span name="java.util.stream.Stream" class="extype">Java Streams</span> that operate on Scala collections (sequentially or in parallel). For more information on Java streams, consult the documentation (<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a>).</p>
<p>When writing Java code, use the explicit conversion methods defined in <a href="javaapi/streamconverters%24.html" name="scala.jdk.javaapi.StreamConverters" id="scala.jdk.javaapi.StreamConverters" class="extype">javaapi.StreamConverters</a> instead.</p>
<p>The methods <code>asJavaSeqStream</code> and <code>asJavaParStream</code> convert a collection to a Java Stream:</p>
<pre data-language="scala">scala&gt; import scala.jdk.StreamConverters._

scala&gt; val s = (1 to 10).toList.asJavaSeqStream
s: java.util.stream.IntStream = java.util.stream.IntPipeline$Head@7b1e5e55

scala&gt; s.map(_ * 2).filter(_ &gt; 5).toScala(List)
res1: List[Int] = List(6, 8, 10, 12, 14, 16, 18, 20)</pre>
<p>Note: using parallel streams in the Scala REPL causes deadlocks, see <a href="https://github.com/scala/bug/issues/9076" target="_blank">https://github.com/scala/bug/issues/9076</a>. As a workaround, use <code>scala -Yrepl-class-based</code>.</p>
<pre data-language="scala">scala&gt; def isPrime(n: Int): Boolean = !(2 +: (3 to Math.sqrt(n).toInt by 2) exists (n % _ == 0))
isPrime: (n: Int)Boolean

scala&gt; (10000 to 1000000).asJavaParStream.filter(isPrime).toScala(Vector)
res6: scala.collection.immutable.Vector[Int] = Vector(10007, 10009, 10037, 10039, ...</pre>
<p>A Java <a href="../index.html#Stream%5B+A%5D=scala.collection.immutable.Stream%5BA%5D" name="scala.Stream" id="scala.Stream" class="extmbr">Stream</a> provides operations on a sequence of elements. Streams are created from <span name="java.util.Spliterator" class="extype">Spliterators</span>, which are similar to Iterators with the additional capability to partition off some of their elements. This partitioning, if supported by the Spliterator, is used for parallelizing Stream operations.</p>
<p>Scala collections have a method <a href="#" name="scala.collection.IterableOnce#stepper" id="scala.collection.IterableOnce#stepper" class="extmbr"><code>stepper</code></a> that returns a <a href="../collection/stepper.html" name="scala.collection.Stepper" id="scala.collection.Stepper" class="extype">scala.collection.Stepper</a> for the collection, which in turn can be converted to a Spliterator for creating a Java Stream.</p>
<p>The <code>asJavaSeqStream </code> extension method is available on any Scala collection. The <code>asJavaParStream</code> extension method can only be invoked on collections where the return type of the <a href="#" name="scala.collection.IterableOnce#stepper" id="scala.collection.IterableOnce#stepper" class="extmbr"><code>stepper</code></a> method is marked with the <a href="../collection/stepper%24%24efficientsplit.html" name="scala.collection.Stepper.EfficientSplit" id="scala.collection.Stepper.EfficientSplit" class="extype">scala.collection.Stepper.EfficientSplit</a> marker trait. This trait is added to steppers that support partitioning, and therefore efficient parallel processing.</p>
<p>The following extension methods are available:</p>
<table thead="THead(List(Tr(List(Th(List(P(List(Txt( Collection Type )),null,null)),doctbl-left), Th(List(P(List(Txt( Extension Methods )),null,null)),doctbl-left)))))" tbody="TBody(List(Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(IterableOnce))), Txt( )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaSeqStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(IndexedSeq))), Txt(, Arrays, ), Code(List(Txt(BitSet))), Txt(, ), Code(List(Txt(Accumulator))), Txt(, ), Code(List(Txt(HashMap))), Txt(, ), Code(List(Txt(HashSet))), Txt(, ), Code(List(Txt(Range))), Txt(, ), Code(List(Txt(TreeMap))), Txt(, ), Code(List(Txt(TreeSet))), Txt(, ), Code(List(Txt(Vector))), Txt(, Strings )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaParStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(Map))), Txt( )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaSeqKeyStream))), Txt(, ), Code(List(Txt(asJavaSeqValueStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(HashMap))), Txt(, ), Code(List(Txt(TreeMap))), Txt( )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaParKeyStream))), Txt(, ), Code(List(Txt(asJavaParValueStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(Stepper))), Txt( )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaSeqStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( ), Code(List(Txt(Stepper with EfficientSplit))), Txt( )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaParStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( Strings )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(asJavaSeqStream))), Txt(, ), Code(List(Txt(asJavaParStream))), Txt(, ), Code(List(Txt(asJavaSeqCharStream))), Txt(, ), Code(List(Txt(asJavaParCharStream))), Txt(, ), Code(List(Txt(asJavaSeqCodePointStream))), Txt(, ), Code(List(Txt(asJavaParCodePointStream))), Txt( )),null,null)),doctbl-left))), Tr(List(Td(List(P(List(Txt( Java streams )),null,null)),doctbl-left), Td(List(P(List(Txt( ), Code(List(Txt(toScala))), Txt(, ), Code(List(Txt(asJavaPrimitiveStream))), Txt( )),null,null)),doctbl-left)))))" class="doctbl">
<thead><tr>
<th class="doctbl-left"><p> Collection Type </p></th>
<th class="doctbl-left"><p> Extension Methods </p></th>
</tr></thead>
<tbody>
<tr>
<td class="doctbl-left"><p> <code>IterableOnce</code> </p></td>
<td class="doctbl-left"><p> <code>asJavaSeqStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> <code>IndexedSeq</code>, Arrays, <code>BitSet</code>, <code>Accumulator</code>, <code>HashMap</code>, <code>HashSet</code>, <code>Range</code>, <code>TreeMap</code>, <code>TreeSet</code>, <code>Vector</code>, Strings </p></td>
<td class="doctbl-left"><p> <code>asJavaParStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> <code>Map</code> </p></td>
<td class="doctbl-left"><p> <code>asJavaSeqKeyStream</code>, <code>asJavaSeqValueStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> <code>HashMap</code>, <code>TreeMap</code> </p></td>
<td class="doctbl-left"><p> <code>asJavaParKeyStream</code>, <code>asJavaParValueStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> <code>Stepper</code> </p></td>
<td class="doctbl-left"><p> <code>asJavaSeqStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> <code>Stepper with EfficientSplit</code> </p></td>
<td class="doctbl-left"><p> <code>asJavaParStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> Strings </p></td>
<td class="doctbl-left"><p> <code>asJavaSeqStream</code>, <code>asJavaParStream</code>, <code>asJavaSeqCharStream</code>, <code>asJavaParCharStream</code>, <code>asJavaSeqCodePointStream</code>, <code>asJavaParCodePointStream</code> </p></td>
</tr>
<tr>
<td class="doctbl-left"><p> Java streams </p></td>
<td class="doctbl-left"><p> <code>toScala</code>, <code>asJavaPrimitiveStream</code> </p></td>
</tr>
</tbody>
</table>
<p>The <code>asJavaPrimitiveStream</code> method converts a <code>Stream[Int]</code> to an <code>IntStream</code>. It is the dual of the <code>boxed</code> method defined on primitive streams (e.g., <code>IntStream.boxed</code> is a <code>Stream[Integer]</code>).</p>
<p>The <code>toScala</code> extension methods on Java streams collects the result of a stream pipeline into a Scala collection, for example <code>stream.toScala(List)</code>, <code>stream.toScala(Vector)</code>. Note that transformation operations on streams are lazy (also called "intermediate"), terminal operations such as <code>forEach</code>, <code>count</code> or <code>toScala</code> trigger the evaluation.</p>
<p>Collecting a parallel stream to a collection can be performed in parallel. This is beneficial if the target collection supports efficient merging of the segments that are built in parallel. To support this use case, the Scala standard library provides the <a href="accumulator.html" name="scala.jdk.Accumulator" id="scala.jdk.Accumulator" class="extype">Accumulator</a> collection. This collection supports efficient parallel construction, and it has specialized subtypes for <code>Int</code>, <code>Long</code> and <code>Double</code> so that primitive Java streams can be collected to a Scala collection without boxing the elements. </p>
</div></div>
</div>
</div></div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala/jdk/index.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala/jdk/index.html</a>
  </p>
</div>
