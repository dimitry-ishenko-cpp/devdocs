<h1>Object scala.language</h1>

<h2 id="signature">
<span class="modifier_kind"> <span class="kind">object</span></span> <span class="symbol"><span class="name">language</span></span>
</h2>
<div id="comment" class="fullcommenttop">
<div class="comment cmt">
<p> The <code>scala.language</code> object controls the language features available to the programmer, as proposed in the <a href="https://docs.google.com/document/d/1nlkvpoIRkx7at1qJEZafJwthZ3GeIklTFhqmXMvTX9Q/edit" target="_blank"><b>SIP-18 document</b></a>.</p>
<p> Each of these features has to be explicitly imported into the current scope to become available:</p>
<pre data-language="scala">import language.postfixOps // or language._
List(1, 2, 3) reverse</pre>
<p> The language features are:</p>
<ul>
<li>
<a href="#dynamics:languageFeature.dynamics" name="scala.language#dynamics" id="scala.language#dynamics" class="extmbr"><code>dynamics</code></a> enables defining calls rewriting using the <a href="dynamic.html" name="scala.Dynamic" id="scala.Dynamic" class="extype"><code>Dynamic</code></a> trait</li>
<li>
<a href="#existentials:languageFeature.existentials" name="scala.language#existentials" id="scala.language#existentials" class="extmbr"><code>existentials</code></a> enables writing existential types</li>
<li>
<a href="#higherKinds:languageFeature.higherKinds" name="scala.language#higherKinds" id="scala.language#higherKinds" class="extmbr"><code>higherKinds</code></a> enables writing higher-kinded types</li>
<li>
<a href="#implicitConversions:languageFeature.implicitConversions" name="scala.language#implicitConversions" id="scala.language#implicitConversions" class="extmbr"><code>implicitConversions</code></a> enables defining implicit methods and members</li>
<li>
<a href="#postfixOps:languageFeature.postfixOps" name="scala.language#postfixOps" id="scala.language#postfixOps" class="extmbr"><code>postfixOps</code></a> enables postfix operators (not recommended)</li>
<li>
<a href="#reflectiveCalls:languageFeature.reflectiveCalls" name="scala.language#reflectiveCalls" id="scala.language#reflectiveCalls" class="extmbr"><code>reflectiveCalls</code></a> enables using structural types</li>
<li>
<a href="language%24%24experimental%24.html" name="scala.language.experimental" id="scala.language.experimental" class="extype"><code>experimental</code></a> contains newer features that have not yet been tested in production </li>
</ul>
</div>
<dl class="attributes block">
<dt>Source</dt>
<dd><a href="https://github.com/scala/scala/tree/v2.13.0/src/library/scala/language.scala#L38" target="_blank">language.scala</a></dd>
<dt>Linear Supertypes</dt>
<dd>
<a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>

</div>
<div id="template"><div id="allMembers"><div class="values members">
<h2>Value Members</h2>
<h3 id="!=">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Test two objects for inequality. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if !(this == that), false otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a href="int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>x.hashCode</code> except for boxed numeric types and <code>null</code>. For numerics, it returns a hash value which is consistent with value equality: if two value type instances compare as true, then ## will produce the same hash value for each of them. For <code>null</code> returns a hashcode where <code>null.hashCode</code> throws a <code>NullPointerException</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a hash value consistent with ==</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="==">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>The expression <code>x == that</code> is equivalent to <code>if (x eq null) that eq null else x.equals(that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="asInstanceOf">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Cast the receiver object to be of type <code>T0</code>.</p>
<p> Note that the success of a cast at runtime is modulo Scala's erasure semantics. Therefore the expression <code>1.asInstanceOf[String]</code> will throw a <code>ClassCastException</code> at runtime, while the expression <code>List(1).asInstanceOf[List[String]]</code> will not. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the requested type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the receiver object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="index.html#ClassCastException=ClassCastException" name="scala.ClassCastException" id="scala.ClassCastException" class="extmbr"><code>ClassCastException</code></a> if the receiver object is not an instance of the erasure of type <code>T0</code>.</p></span></dd>
</dl>
</div>
<h3 id="clone">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Create a copy of the receiver object.</p>
<p> The default implementation of the <code>clone</code> method is platform dependent. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a copy of the receiver object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Attributes</dt>
<dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="dynamics">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">dynamics</span><span class="result">: <a href="languagefeature%24%24dynamics.html" name="scala.languageFeature.dynamics" id="scala.languageFeature.dynamics" class="extype">dynamics</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Only where this feature is enabled, can direct or indirect subclasses of trait scala.Dynamic be defined. If <code>dynamics</code> is not enabled, a definition of a class, trait, or object that has <code>Dynamic</code> as a base trait is rejected by the compiler.</p>
<p> Selections of dynamic members of existing subclasses of trait <code>Dynamic</code> are unaffected; they can be used anywhere.</p>
<p> <b>Why introduce the feature?</b> To enable flexible DSLs and convenient interfacing with dynamic languages.</p>
<p> <b>Why control it?</b> Dynamic member selection can undermine static checkability of programs. Furthermore, dynamic member selection often relies on reflection, which is not available on all platforms. </p>
</div></div>
<h3 id="eq">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether the argument (<code>that</code>) is a reference to the receiver object (<code>this</code>).</p>
<p> The <code>eq</code> method implements an <a href="http://en.wikipedia.org/wiki/Equivalence_relation" target="_blank">equivalence relation</a> on non-null instances of <code>AnyRef</code>, and has three additional properties:</p>
<ul>
It is consistent: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, multiple invocations of <code>x.eq(y)</code> consistently returns <code>true</code> or consistently returns <code>false</code>.For any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(null)</code> and <code>null.eq(x)</code> returns <code>false</code>.
<code>null.eq(null)</code> returns <code>true</code>.</ul>
<p> When overriding the <code>equals</code> or <code>hashCode</code> methods, it is important to ensure that their behavior is consistent with reference equality. Therefore, if two objects are references to each other (<code>o1 eq o2</code>), they should be equal to each other (<code>o1 == o2</code>) and they should hash to the same value (<code>o1.hashCode == o2.hashCode</code>). </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div>
<h3 id="equals">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>The equality method for reference types. Default implementation delegates to <code>eq</code>.</p>
<p> See also <code>equals</code> in <a href="any.html" name="scala.Any" id="scala.Any" class="extype">scala.Any</a>. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="existentials">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">existentials</span><span class="result">: <a href="languagefeature%24%24existentials.html" name="scala.languageFeature.existentials" id="scala.languageFeature.existentials" class="extype">existentials</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Where this feature is enabled, existential types that cannot be expressed as wildcard types can be written and are allowed in inferred types of values or return types of methods. If <code>existentials</code> is not enabled, those cases will trigger a warning from the compiler.</p>
<p> Existential types with wildcard type syntax such as <code>List[_]</code>, or <code>Map[String, _]</code> are not affected.</p>
<p> <b>Why keep the feature?</b> Existential types are needed to make sense of Java’s wildcard types and raw types and the erased types of run-time values.</p>
<p> <b>Why control it?</b> Having complex existential types in a code base usually makes application code very brittle, with a tendency to produce type errors with obscure error messages. Therefore, going overboard with existential types is generally perceived not to be a good idea. Also, complicated existential types might be no longer supported in a future simplification of the language. </p>
</div></div>
<h3 id="finalize">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Called by the garbage collector on the receiver object when there are no more references to the object.</p>
<p> The details of when and if the <code>finalize</code> method is invoked, as well as the interaction between <code>finalize</code> and non-local returns and exceptions, are all platform dependent. </p>
</div>
<dl class="attributes block">
<dt>Attributes</dt>
<dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="getClass">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Returns the runtime class representation of the object. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a class object corresponding to the runtime type of the receiver.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl>
</div>
<h3 id="hashCode">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>The hashCode method for reference types. See hashCode in <a href="any.html" name="scala.Any" id="scala.Any" class="extype">scala.Any</a>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the hash code value for this object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl>
</div>
<h3 id="higherKinds">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">higherKinds</span><span class="result">: <a href="languagefeature%24%24higherkinds.html" name="scala.languageFeature.higherKinds" id="scala.languageFeature.higherKinds" class="extype">higherKinds</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Where this feature is enabled, higher-kinded types can be written. If <code>higherKinds</code> is not enabled, a higher-kinded type such as <code>F[A]</code> will trigger a warning from the compiler.</p>
<p> <b>Why keep the feature?</b> Higher-kinded types enable the definition of very general abstractions such as functor, monad, or arrow. A significant set of advanced libraries relies on them. Higher-kinded types are also at the core of the scala-virtualized effort to produce high-performance parallel DSLs through staging.</p>
<p> <b>Why control it?</b> Higher kinded types in Scala lead to a Turing-complete type system, where compiler termination is no longer guaranteed. They tend to be useful mostly for type-level computation and for highly generic design patterns. The level of abstraction implied by these design patterns is often a barrier to understanding for newcomers to a Scala codebase. Some syntactic aspects of higher-kinded types are hard to understand for the uninitiated and type inference is less effective for them than for normal types. Because we are not completely happy with them yet, it is possible that some aspects of higher-kinded types will change in future versions of Scala. So an explicit enabling also serves as a warning that code involving higher-kinded types might have to be slightly revised in the future. </p>
</div></div>
<h3 id="implicitConversions">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">implicitConversions</span><span class="result">: <a href="languagefeature%24%24implicitconversions.html" name="scala.languageFeature.implicitConversions" id="scala.languageFeature.implicitConversions" class="extype">implicitConversions</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Where this feature is enabled, definitions of implicit conversions are allowed. If <code>implicitConversions</code> is not enabled, the definition of an implicit conversion will trigger a warning from the compiler.</p>
<p> An implicit conversion is an implicit value of unary function type <code>A =&gt; B</code>, or an implicit method that has in its first parameter section a single, non-implicit parameter. Examples:</p>
<pre data-language="scala">implicit def stringToInt(s: String): Int = s.length
implicit val conv = (s: String) =&gt; s.length
implicit def listToX(xs: List[T])(implicit f: T =&gt; X): X = ...</pre>
<p> Implicit classes and implicit values of other types are not governed by this language feature.</p>
<p> <b>Why keep the feature?</b> Implicit conversions are central to many aspects of Scala’s core libraries.</p>
<p> <b>Why control it?</b> Implicit conversions are known to cause many pitfalls if over-used. And there is a tendency to over-use them because they look very powerful and their effects seem to be easy to understand. Also, in most situations using implicit parameters leads to a better design than implicit conversions. </p>
</div></div>
<h3 id="isInstanceOf">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Test whether the dynamic type of the receiver object is <code>T0</code>.</p>
<p> Note that the result of the test is modulo Scala's erasure semantics. Therefore the expression <code>1.isInstanceOf[String]</code> will return <code>false</code>, while the expression <code>List(1).isInstanceOf[List[String]]</code> will return <code>true</code>. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the specified type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is an instance of erasure of type <code>T0</code>; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></dd>
</dl>
</div>
<h3 id="ne">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>!(this eq that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is not a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div>
<h3 id="notify">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Wakes up a single thread that is waiting on the receiver object's monitor. </p></div>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="notifyAll">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Wakes up all threads that are waiting on the receiver object's monitor. </p></div>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="postfixOps">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">postfixOps</span><span class="result">: <a href="languagefeature%24%24postfixops.html" name="scala.languageFeature.postfixOps" id="scala.languageFeature.postfixOps" class="extype">postfixOps</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Only where this feature is enabled, is postfix operator notation <code>(expr op)</code> permitted. If <code>postfixOps</code> is not enabled, an expression using postfix notation is rejected by the compiler.</p>
<p> <b>Why keep the feature?</b> Postfix notation is preserved for backward compatibility only. Historically, several DSLs written in Scala need the notation.</p>
<p> <b>Why control it?</b> Postfix operators interact poorly with semicolon inference. Most programmers avoid them for this reason alone. Postfix syntax is associated with an abuse of infix notation, <code>a op1 b op2 c op3</code>, that can be harder to read than ordinary method invocation with judicious use of parentheses. It is recommended not to enable this feature except for legacy code. </p>
</div></div>
<h3 id="reflectiveCalls">
<span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">lazy val </span></span><span class="symbol"><span class="name">reflectiveCalls</span><span class="result">: <a href="languagefeature%24%24reflectivecalls.html" name="scala.languageFeature.reflectiveCalls" id="scala.languageFeature.reflectiveCalls" class="extype">reflectiveCalls</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>Where this feature is enabled, accesses to members of structural types that need reflection are supported. If <code>reflectiveCalls</code> is not enabled, an expression requiring reflection will trigger a warning from the compiler.</p>
<p> A structural type is a type of the form <code>Parents { Decls }</code> where <code>Decls</code> contains declarations of new members that do not override any member in <code>Parents</code>. To access one of these members, a reflective call is needed.</p>
<p> <b>Why keep the feature?</b> Structural types provide great flexibility because they avoid the need to define inheritance hierarchies a priori. Besides, their definition falls out quite naturally from Scala’s concept of type refinement.</p>
<p> <b>Why control it?</b> Reflection is not available on all platforms. Popular tools such as ProGuard have problems dealing with it. Even where reflection is available, reflective dispatch can lead to surprising performance degradations. </p>
</div></div>
<h3 id="synchronized">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl></div>
<h3 id="toString">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a String representation of this object. The default representation is platform dependent. On the java platform it is the concatenation of the class name, "@", and the object's hashcode in hexadecimal. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a String representation of the object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd>
</dl></div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="long.html" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd>
</dl></div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="long.html" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@<a href="native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl></div>
<h3 id="scala.language.experimental">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="language%24%24experimental%24.html" title="The experimental object contains features that are known to have unstable API or behavior that may change in future releases."><span class="name">experimental</span></a></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>The experimental object contains features that are known to have unstable API or behavior that may change in future releases.</p>
<p> Experimental features <b>may undergo API changes</b> in future releases, so production code should not rely on them.</p>
<p> Programmers are encouraged to try out experimental features and <a href="https://github.com/scala/bug/issues" target="_blank">report any bugs or API inconsistencies</a> they encounter so they can be improved in future releases. </p>
</div></div>
</div></div></div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala/language$.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala/language$.html</a>
  </p>
</div>
