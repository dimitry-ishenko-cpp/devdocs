<h1 id="C-Interface">C Interface</h1>
<h3 id="Base.@ccall">
<code>Base.@ccall</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">@ccall library.function_name(argvalue1::argtype1, ...)::returntype
@ccall function_name(argvalue1::argtype1, ...)::returntype
@ccall $function_pointer(argvalue1::argtype1, ...)::returntype</pre>
<p>Call a function in a C-exported shared library, specified by <code>library.function_name</code>, where <code>library</code> is a string constant or literal. The library may be omitted, in which case the <code>function_name</code> is resolved in the current process. Alternatively, <code>@ccall</code> may also be used to call a function pointer <code>$function_pointer</code>, such as one returned by <code>dlsym</code>.</p>
<p>Each <code>argvalue</code> to <code>@ccall</code> is converted to the corresponding <code>argtype</code>, by automatic insertion of calls to <code>unsafe_convert(argtype, cconvert(argtype, argvalue))</code>. (See also the documentation for <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> and <a href="#Base.cconvert"><code>cconvert</code></a> for further details.) In most cases, this simply results in a call to <code>convert(argtype, argvalue)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">@ccall strlen(s::Cstring)::Csize_t</pre>
<p>This calls the C standard library function:</p>
<pre data-language="julia">size_t strlen(char *)</pre>
<p>with a Julia variable named <code>s</code>. See also <code>ccall</code>.</p>
<p>Varargs are supported with the following convention:</p>
<pre data-language="julia">@ccall printf("%s = %d"::Cstring ; "foo"::Cstring, foo::Cint)::Cint</pre>
<p>The semicolon is used to separate required arguments (of which there must be at least one) from variadic arguments.</p>
<p>Example using an external library:</p>
<pre data-language="julia"># C signature of g_uri_escape_string:
# char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);

const glib = "libglib-2.0"
@ccall glib.g_uri_escape_string(my_uri::Cstring, ":/"::Cstring, true::Cint)::Cstring</pre>
<p>The string literal could also be used directly before the function name, if desired <code>"libglib-2.0".g_uri_escape_string(...</code></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L666-L713">source</a></section><h3 id="ccall">
<code>ccall</code><span class="docstring-category">Keyword</span>
</h3>
<section><pre data-language="julia">ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)
ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)
ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)</pre>
<p>Call a function in a C-exported shared library, specified by the tuple <code>(function_name, library)</code>, where each component is either a string or symbol. Instead of specifying a library, one can also use a <code>function_name</code> symbol or string, which is resolved in the current process. Alternatively, <code>ccall</code> may also be used to call a function pointer <code>function_pointer</code>, such as one returned by <code>dlsym</code>.</p>
<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</p>
<p>Each <code>argvalue</code> to the <code>ccall</code> will be converted to the corresponding <code>argtype</code>, by automatic insertion of calls to <code>unsafe_convert(argtype, cconvert(argtype, argvalue))</code>. (See also the documentation for <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> and <a href="#Base.cconvert"><code>cconvert</code></a> for further details.) In most cases, this simply results in a call to <code>convert(argtype, argvalue)</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/docs/basedocs.jl#L1278-L1296">source</a></section><h3 id="Core.Intrinsics.cglobal">
<code>Core.Intrinsics.cglobal</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cglobal((symbol, library) [, type=Cvoid])</pre>
<p>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in <a href="#ccall"><code>ccall</code></a>. Returns a <code>Ptr{Type}</code>, defaulting to <code>Ptr{Cvoid}</code> if no <code>Type</code> argument is supplied. The values can be read or written by <a href="#Base.unsafe_load"><code>unsafe_load</code></a> or <a href="#Base.unsafe_store!"><code>unsafe_store!</code></a>, respectively.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L7-L16">source</a></section><h3 id="Base.@cfunction">
<code>Base.@cfunction</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">@cfunction(callable, ReturnType, (ArgumentTypes...,)) -&gt; Ptr{Cvoid}
@cfunction($callable, ReturnType, (ArgumentTypes...,)) -&gt; CFunction</pre>
<p>Generate a C-callable function pointer from the Julia function <code>callable</code> for the given type signature. To pass the return value to a <code>ccall</code>, use the argument type <code>Ptr{Cvoid}</code> in the signature.</p>
<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '<span>$</span>' in front of the function argument changes this to instead create a runtime closure over the local variable <code>callable</code> (this is not supported on all architectures).</p>
<p>See <a href="../../manual/calling-c-and-fortran-code/index.html#Calling-C-and-Fortran-Code">manual section on ccall and cfunction usage</a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; function foo(x::Int, y::Int)
           return x + y
       end

julia&gt; @cfunction(foo, Int, (Int, Int))
Ptr{Cvoid} @0x000000001b82fcd0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L38-L63">source</a></section><h3 id="Base.CFunction">
<code>Base.CFunction</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">CFunction struct</pre>
<p>Garbage-collection handle for the return value from <code>@cfunction</code> when the first argument is annotated with '<span>$</span>'. Like all <code>cfunction</code> handles, it should be passed to <code>ccall</code> as a <code>Ptr{Cvoid}</code>, and will be converted automatically at the call site to the appropriate type.</p>
<p>See <a href="#Base.@cfunction"><code>@cfunction</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L19-L28">source</a></section><h3 id="Base.unsafe_convert">
<code>Base.unsafe_convert</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_convert(T, x)</pre>
<p>Convert <code>x</code> to a C argument of type <code>T</code> where the input <code>x</code> must be the return value of <code>cconvert(T, ...)</code>.</p>
<p>In cases where <a href="../base/index.html#Base.convert"><code>convert</code></a> would need to take a Julia object and turn it into a <code>Ptr</code>, this function should be used to define and perform that conversion.</p>
<p>Be careful to ensure that a Julia reference to <code>x</code> exists as long as the result of this function will be used. Accordingly, the argument <code>x</code> to this function should never be an expression, only a variable name or field reference. For example, <code>x=a.b.c</code> is acceptable, but <code>x=[a,b,c]</code> is not.</p>
<p>The <code>unsafe</code> prefix on this function indicates that using the result of this function after the <code>x</code> argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</p>
<p>See also <a href="#Base.cconvert"><code>cconvert</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L34-L54">source</a></section><h3 id="Base.cconvert">
<code>Base.cconvert</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cconvert(T,x)</pre>
<p>Convert <code>x</code> to a value to be passed to C code as type <code>T</code>, typically by calling <code>convert(T, x)</code>.</p>
<p>In cases where <code>x</code> cannot be safely converted to <code>T</code>, unlike <a href="../base/index.html#Base.convert"><code>convert</code></a>, <code>cconvert</code> may return an object of a type different from <code>T</code>, which however is suitable for <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> to handle. The result of this function should be kept valid (for the GC) until the result of <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> is not needed anymore. This can be used to allocate memory that will be accessed by the <code>ccall</code>. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</p>
<p>Neither <code>convert</code> nor <code>cconvert</code> should take a Julia object and turn it into a <code>Ptr</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/essentials.jl#L522-L535">source</a></section><h3 id="Base.unsafe_load">
<code>Base.unsafe_load</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_load(p::Ptr{T}, i::Integer=1)
unsafe_load(p::Ptr{T}, order::Symbol)
unsafe_load(p::Ptr{T}, i::Integer, order::Symbol)</pre>
<p>Load a value of type <code>T</code> from the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1]</code>. Optionally, an atomic memory ordering can be provided.</p>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Like C, the programmer is responsible for ensuring that referenced memory is not freed or garbage collected while invoking this function. Incorrect usage may segfault your program or return garbage answers. Unlike C, dereferencing memory region allocated as different type may be valid provided that the types are compatible.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>The <code>order</code> argument is available as of Julia 1.10.</p></div>
</div>
<p>See also: <a href="../multi-threading/index.html#atomic"><code>atomic</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L99-L118">source</a></section><h3 id="Base.unsafe_store!">
<code>Base.unsafe_store!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_store!(p::Ptr{T}, x, i::Integer=1)
unsafe_store!(p::Ptr{T}, x, order::Symbol)
unsafe_store!(p::Ptr{T}, x, i::Integer, order::Symbol)</pre>
<p>Store a value of type <code>T</code> to the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1] = x</code>. Optionally, an atomic memory ordering can be provided.</p>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Like C, the programmer is responsible for ensuring that referenced memory is not freed or garbage collected while invoking this function. Incorrect usage may segfault your program. Unlike C, storing memory region allocated as different type may be valid provided that that the types are compatible.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>The <code>order</code> argument is available as of Julia 1.10.</p></div>
</div>
<p>See also: <a href="../multi-threading/index.html#atomic"><code>atomic</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L125-L144">source</a></section><h3 id="Base.unsafe_modify!">
<code>Base.unsafe_modify!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_modify!(p::Ptr{T}, op, x, [order::Symbol]) -&gt; Pair</pre>
<p>These atomically perform the operations to get and set a memory address after applying the function <code>op</code>. If supported by the hardware (for example, atomic increment), this may be optimized to the appropriate hardware instruction, otherwise its execution will be similar to:</p>
<pre data-language="julia">y = unsafe_load(p)
z = op(y, x)
unsafe_store!(p, z)
return y =&gt; z</pre>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Like C, the programmer is responsible for ensuring that referenced memory is not freed or garbage collected while invoking this function. Incorrect usage may segfault your program.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires at least Julia 1.10.</p></div>
</div>
<p>See also: <a href="../base/index.html#Base.modifyproperty!"><code>modifyproperty!</code></a>, <a href="../multi-threading/index.html#atomic"><code>atomic</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L152-L174">source</a></section><h3 id="Base.unsafe_replace!">
<code>Base.unsafe_replace!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_replace!(p::Ptr{T}, expected, desired,
               [success_order::Symbol[, fail_order::Symbol=success_order]]) -&gt; (; old, success::Bool)</pre>
<p>These atomically perform the operations to get and conditionally set a memory address to a given value. If supported by the hardware, this may be optimized to the appropriate hardware instruction, otherwise its execution will be similar to:</p>
<pre data-language="julia">y = unsafe_load(p, fail_order)
ok = y === expected
if ok
    unsafe_store!(p, desired, success_order)
end
return (; old = y, success = ok)</pre>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Like C, the programmer is responsible for ensuring that referenced memory is not freed or garbage collected while invoking this function. Incorrect usage may segfault your program.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires at least Julia 1.10.</p></div>
</div>
<p>See also: <a href="../base/index.html#Base.replaceproperty!"><code>replaceproperty!</code></a>, <a href="../multi-threading/index.html#atomic"><code>atomic</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L179-L203">source</a></section><h3 id="Base.unsafe_swap!">
<code>Base.unsafe_swap!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_swap!(p::Ptr{T}, x, [order::Symbol])</pre>
<p>These atomically perform the operations to simultaneously get and set a memory address. If supported by the hardware, this may be optimized to the appropriate hardware instruction, otherwise its execution will be similar to:</p>
<pre data-language="julia">y = unsafe_load(p)
unsafe_store!(p, x)
return y</pre>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Like C, the programmer is responsible for ensuring that referenced memory is not freed or garbage collected while invoking this function. Incorrect usage may segfault your program.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires at least Julia 1.10.</p></div>
</div>
<p>See also: <a href="../base/index.html#Base.swapproperty!"><code>swapproperty!</code></a>, <a href="../multi-threading/index.html#atomic"><code>atomic</code></a></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L213-L233">source</a></section><h3 id="Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T}, Ptr{T}, Any}} where T">
<code>Base.unsafe_copyto!</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)</pre>
<p>Copy <code>N</code> elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</p>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointers <code>dest</code> and <code>src</code> to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/array.jl#L275-L284">source</a></section><h3 id="Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T}, Any, Array{T}, Any, Any}} where T">
<code>Base.unsafe_copyto!</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">unsafe_copyto!(dest::Array, do, src::Array, so, N)</pre>
<p>Copy <code>N</code> elements from a source array to a destination, starting at the linear index <code>so</code> in the source and <code>do</code> in the destination (1-indexed).</p>
<p>The <code>unsafe</code> prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>
<div class="admonition is-warning">

<div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div>
</div>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/array.jl#L316-L327">source</a></section><h3 id="Base.copyto!">
<code>Base.copyto!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">copyto!(dest::AbstractMatrix, src::UniformScaling)</pre>
<p>Copies a <a href="../../stdlib/linearalgebra/index.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> onto a matrix.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</p></div>
</div></section><section><pre data-language="julia">copyto!(dest, do, src, so, N)</pre>
<p>Copy <code>N</code> elements from collection <code>src</code> starting at the linear index <code>so</code>, to array <code>dest</code> starting at the index <code>do</code>. Return <code>dest</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/array.jl#L356-L361">source</a></section><section><pre data-language="julia">copyto!(dest::AbstractArray, src) -&gt; dest</pre>
<p>Copy all elements from collection <code>src</code> to array <code>dest</code>, whose length must be greater than or equal to the length <code>n</code> of <code>src</code>. The first <code>n</code> elements of <code>dest</code> are overwritten, the other elements are left untouched.</p>
<p>See also <a href="../arrays/index.html#Base.copy!"><code>copy!</code></a>, <a href="../base/index.html#Base.copy"><code>copy</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = [1., 0., 3., 0., 5.];

julia&gt; y = zeros(7);

julia&gt; copyto!(y, x);

julia&gt; y
7-element Vector{Float64}:
 1.0
 0.0
 3.0
 0.0
 5.0
 0.0
 0.0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/abstractarray.jl#L1030-L1057">source</a></section><section><pre data-language="julia">copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest</pre>
<p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = zeros(5, 5);

julia&gt; B = [1 2; 3 4];

julia&gt; Ainds = CartesianIndices((2:3, 2:3));

julia&gt; Binds = CartesianIndices(B);

julia&gt; copyto!(A, Ainds, B, Binds)
5Ã—5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  1.0  2.0  0.0  0.0
 0.0  3.0  4.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/multidimensional.jl#L1147-L1171">source</a></section><h3 id="Base.pointer">
<code>Base.pointer</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">pointer(array [, index])</pre>
<p>Get the native address of an array or string, optionally at a given location <code>index</code>.</p>
<p>This function is "unsafe". Be careful to ensure that a Julia reference to <code>array</code> exists as long as this pointer will be used. The <a href="../base/index.html#Base.GC.@preserve"><code>GC.@preserve</code></a> macro should be used to protect the <code>array</code> argument from garbage collection within a given block of code.</p>
<p>Calling <a href="#Core.Ref"><code>Ref(array[, index])</code></a> is generally preferable to this function as it guarantees validity.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L172-L183">source</a></section><h3 id="Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}">
<code>Base.unsafe_wrap</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)</pre>
<p>Wrap a Julia <code>Array</code> object around the data at the address given by <code>pointer</code>, without making a copy. The pointer element type <code>T</code> determines the array element type. <code>dims</code> is either an integer (for a 1d array) or a tuple of the array dimensions. <code>own</code> optionally specifies whether Julia should take ownership of the memory, calling <code>free</code> on the pointer when the array is no longer referenced.</p>
<p>This function is labeled "unsafe" because it will crash if <code>pointer</code> is not a valid memory address to data of the requested length. Unlike <a href="#Base.unsafe_load"><code>unsafe_load</code></a> and <a href="#Base.unsafe_store!"><code>unsafe_store!</code></a>, the programmer is responsible also for ensuring that the underlying data is not accessed through two arrays of different element type, similar to the strict aliasing rule in C.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L70-L84">source</a></section><h3 id="Base.pointer_from_objref">
<code>Base.pointer_from_objref</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">pointer_from_objref(x)</pre>
<p>Get the memory address of a Julia object as a <code>Ptr</code>. The existence of the resulting <code>Ptr</code> will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the <code>Ptr</code> will be used.</p>
<p>This function may not be called on immutable objects, since they do not have stable memory addresses.</p>
<p>See also <a href="#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L255-L266">source</a></section><h3 id="Base.unsafe_pointer_to_objref">
<code>Base.unsafe_pointer_to_objref</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_pointer_to_objref(p::Ptr)</pre>
<p>Convert a <code>Ptr</code> to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered "unsafe" and should be used with care.</p>
<p>See also <a href="#Base.pointer_from_objref"><code>pointer_from_objref</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L244-L252">source</a></section><h3 id="Base.disable_sigint">
<code>Base.disable_sigint</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">disable_sigint(f::Function)</pre>
<p>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using <code>do</code> block syntax as follows:</p>
<pre data-language="julia">disable_sigint() do
    # interrupt-unsafe code
    ...
end</pre>
<p>This is not needed on worker threads (<code>Threads.threadid() != 1</code>) since the <code>InterruptException</code> will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L454-L470">source</a></section><h3 id="Base.reenable_sigint">
<code>Base.reenable_sigint</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">reenable_sigint(f::Function)</pre>
<p>Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of <a href="#Base.disable_sigint"><code>disable_sigint</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L479-L484">source</a></section><h3 id="Base.exit_on_sigint">
<code>Base.exit_on_sigint</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">exit_on_sigint(on::Bool)</pre>
<p>Set <code>exit_on_sigint</code> flag of the julia runtime. If <code>false</code>, Ctrl-C (SIGINT) is capturable as <a href="../base/index.html#Core.InterruptException"><code>InterruptException</code></a> in <code>try</code> block. This is the default behavior in REPL, any code run via <code>-e</code> and <code>-E</code> and in Julia script run with <code>-i</code> option.</p>
<p>If <code>true</code>, <code>InterruptException</code> is not thrown by Ctrl-C. Running code upon such event requires <a href="../base/index.html#Base.atexit"><code>atexit</code></a>. This is the default behavior in Julia script run without <code>-i</code> option.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>Function <code>exit_on_sigint</code> requires at least Julia 1.5.</p></div>
</div>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L493-L507">source</a></section><h3 id="Base.systemerror">
<code>Base.systemerror</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">systemerror(sysfunc[, errno::Cint=Libc.errno()])
systemerror(sysfunc, iftrue::Bool)</pre>
<p>Raises a <code>SystemError</code> for <code>errno</code> with the descriptive string <code>sysfunc</code> if <code>iftrue</code> is <code>true</code></p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/error.jl#L169-L174">source</a></section><h3 id="Base.windowserror">
<code>Base.windowserror</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])
windowserror(sysfunc, iftrue::Bool)</pre>
<p>Like <a href="#Base.systemerror"><code>systemerror</code></a>, but for Windows API functions that use <a href="../libc/index.html#Base.Libc.GetLastError"><code>GetLastError</code></a> to return an error code instead of setting <a href="../libc/index.html#Base.Libc.errno"><code>errno</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/error.jl#L183-L189">source</a></section><h3 id="Core.Ptr">
<code>Core.Ptr</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Ptr{T}</pre>
<p>A memory address referring to data of type <code>T</code>. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/pointer.jl#L3-L8">source</a></section><h3 id="Core.Ref">
<code>Core.Ref</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Ref{T}</pre>
<p>An object that safely references data of type <code>T</code>. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the <code>Ref</code> itself is referenced.</p>
<p>In Julia, <code>Ref</code> objects are dereferenced (loaded or stored) with <code>[]</code>.</p>
<p>Creation of a <code>Ref</code> to a value <code>x</code> of type <code>T</code> is usually written <code>Ref(x)</code>. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written <code>Ref(a, i)</code> for creating a reference to the <code>i</code>-th element of <code>a</code>.</p>
<p><code>Ref{T}()</code> creates a reference to a value of type <code>T</code> without initialization. For a bitstype <code>T</code>, the value will be whatever currently resides in the memory allocated. For a non-bitstype <code>T</code>, the reference will be undefined and attempting to dereference it will result in an error, "UndefRefError: access to undefined reference".</p>
<p>To check if a <code>Ref</code> is an undefined reference, use <a href="#Base.isassigned-Tuple{Base.RefValue}"><code>isassigned(ref::RefValue)</code></a>. For example, <code>isassigned(Ref{T}())</code> is <code>false</code> if <code>T</code> is not a bitstype. If <code>T</code> is a bitstype, <code>isassigned(Ref{T}())</code> will always be true.</p>
<p>When passed as a <code>ccall</code> argument (either as a <code>Ptr</code> or <code>Ref</code> type), a <code>Ref</code> object will be converted to a native pointer to the data it references. For most <code>T</code>, or when converted to a <code>Ptr{Cvoid}</code>, this is a pointer to the object data. When <code>T</code> is an <code>isbits</code> type, this value may be safely mutated, otherwise mutation is strictly undefined behavior.</p>
<p>As a special case, setting <code>T = Any</code> will instead cause the creation of a pointer to the reference itself when converted to a <code>Ptr{Any}</code> (a <code>jl_value_t const* const*</code> if T is immutable, else a <code>jl_value_t *const *</code>). When converted to a <code>Ptr{Cvoid}</code>, it will still return a pointer to the data region as for any other <code>T</code>.</p>
<p>A <code>C_NULL</code> instance of <code>Ptr</code> can be passed to a <code>ccall</code> <code>Ref</code> argument to initialize it.</p>
<p><strong>Use in broadcasting</strong></p>
<p><code>Ref</code> is sometimes used in broadcasting in order to treat the referenced values as a scalar.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Ref(5)
Base.RefValue{Int64}(5)

julia&gt; isa.(Ref([1,2,3]), [Array, Dict, Int]) # Treat reference values as scalar during broadcasting
3-element BitVector:
 1
 0
 0

julia&gt; Ref{Function}()  # Undefined reference to a non-bitstype, Function
Base.RefValue{Function}(#undef)

julia&gt; try
           Ref{Function}()[] # Dereferencing an undefined reference will result in an error
       catch e
           println(e)
       end
UndefRefError()

julia&gt; Ref{Int64}()[]; # A reference to a bitstype refers to an undetermined value if not given

julia&gt; isassigned(Ref{Int64}()) # A reference to a bitstype is always assigned
true

julia&gt; Ref{Int64}(0)[] == 0 # Explicitly give a value for a bitstype reference
true</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/refpointer.jl#L3-L72">source</a></section><h3 id="Base.isassigned-Tuple{Base.RefValue}">
<code>Base.isassigned</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">isassigned(ref::RefValue) -&gt; Bool</pre>
<p>Test whether the given <a href="#Core.Ref"><code>Ref</code></a> is associated with a value. This is always true for a <a href="#Core.Ref"><code>Ref</code></a> of a bitstype object. Return <code>false</code> if the reference is undefined.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ref = Ref{Function}()
Base.RefValue{Function}(#undef)

julia&gt; isassigned(ref)
false

julia&gt; ref[] = (foobar(x) = x)
foobar (generic function with 1 method)

julia&gt; isassigned(ref)
true

julia&gt; isassigned(Ref{Int}())
true</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/refvalue.jl#L11-L35">source</a></section><h3 id="Base.Cchar">
<code>Base.Cchar</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cchar</pre>
<p>Equivalent to the native <code>char</code> c-type.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L86-L90">source</a></section><h3 id="Base.Cuchar">
<code>Base.Cuchar</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cuchar</pre>
<p>Equivalent to the native <code>unsigned char</code> c-type (<a href="../numbers/index.html#Core.UInt8"><code>UInt8</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L6-L10">source</a></section><h3 id="Base.Cshort">
<code>Base.Cshort</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cshort</pre>
<p>Equivalent to the native <code>signed short</code> c-type (<a href="../numbers/index.html#Core.Int16"><code>Int16</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L14-L18">source</a></section><h3 id="Base.Cstring">
<code>Base.Cstring</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cstring</pre>
<p>A C-style string composed of the native character type <a href="#Base.Cchar"><code>Cchar</code></a>s. <code>Cstring</code>s are NUL-terminated. For C-style strings composed of the native wide character type, see <a href="#Base.Cwstring"><code>Cwstring</code></a>. For more information about string interoperability with C, see the <a href="../../manual/calling-c-and-fortran-code/index.html#man-bits-types">manual</a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L138-L147">source</a></section><h3 id="Base.Cushort">
<code>Base.Cushort</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cushort</pre>
<p>Equivalent to the native <code>unsigned short</code> c-type (<a href="../numbers/index.html#Core.UInt16"><code>UInt16</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L22-L26">source</a></section><h3 id="Base.Cint">
<code>Base.Cint</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cint</pre>
<p>Equivalent to the native <code>signed int</code> c-type (<a href="../numbers/index.html#Core.Int32"><code>Int32</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L30-L34">source</a></section><h3 id="Base.Cuint">
<code>Base.Cuint</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cuint</pre>
<p>Equivalent to the native <code>unsigned int</code> c-type (<a href="../numbers/index.html#Core.UInt32"><code>UInt32</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L38-L42">source</a></section><h3 id="Base.Clong">
<code>Base.Clong</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Clong</pre>
<p>Equivalent to the native <code>signed long</code> c-type.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L104-L108">source</a></section><h3 id="Base.Culong">
<code>Base.Culong</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Culong</pre>
<p>Equivalent to the native <code>unsigned long</code> c-type.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L111-L115">source</a></section><h3 id="Base.Clonglong">
<code>Base.Clonglong</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Clonglong</pre>
<p>Equivalent to the native <code>signed long long</code> c-type (<a href="../numbers/index.html#Core.Int64"><code>Int64</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L86-L90">source</a></section><h3 id="Base.Culonglong">
<code>Base.Culonglong</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Culonglong</pre>
<p>Equivalent to the native <code>unsigned long long</code> c-type (<a href="../numbers/index.html#Core.UInt64"><code>UInt64</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L94-L98">source</a></section><h3 id="Base.Cintmax_t">
<code>Base.Cintmax_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cintmax_t</pre>
<p>Equivalent to the native <code>intmax_t</code> c-type (<a href="../numbers/index.html#Core.Int64"><code>Int64</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L70-L74">source</a></section><h3 id="Base.Cuintmax_t">
<code>Base.Cuintmax_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cuintmax_t</pre>
<p>Equivalent to the native <code>uintmax_t</code> c-type (<a href="../numbers/index.html#Core.UInt64"><code>UInt64</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L78-L82">source</a></section><h3 id="Base.Csize_t">
<code>Base.Csize_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Csize_t</pre>
<p>Equivalent to the native <code>size_t</code> c-type (<code>UInt</code>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L54-L58">source</a></section><h3 id="Base.Cssize_t">
<code>Base.Cssize_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cssize_t</pre>
<p>Equivalent to the native <code>ssize_t</code> c-type.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L62-L66">source</a></section><h3 id="Base.Cptrdiff_t">
<code>Base.Cptrdiff_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cptrdiff_t</pre>
<p>Equivalent to the native <code>ptrdiff_t</code> c-type (<code>Int</code>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L46-L50">source</a></section><h3 id="Base.Cwchar_t">
<code>Base.Cwchar_t</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cwchar_t</pre>
<p>Equivalent to the native <code>wchar_t</code> c-type (<a href="../numbers/index.html#Core.Int32"><code>Int32</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L118-L122">source</a></section><h3 id="Base.Cwstring">
<code>Base.Cwstring</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cwstring</pre>
<p>A C-style string composed of the native wide character type <a href="#Base.Cwchar_t"><code>Cwchar_t</code></a>s. <code>Cwstring</code>s are NUL-terminated. For C-style strings composed of the native character type, see <a href="#Base.Cstring"><code>Cstring</code></a>. For more information about string interoperability with C, see the <a href="../../manual/calling-c-and-fortran-code/index.html#man-bits-types">manual</a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/c.jl#L125-L135">source</a></section><h3 id="Base.Cfloat">
<code>Base.Cfloat</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cfloat</pre>
<p>Equivalent to the native <code>float</code> c-type (<a href="../numbers/index.html#Core.Float32"><code>Float32</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L102-L106">source</a></section><h3 id="Base.Cdouble">
<code>Base.Cdouble</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Cdouble</pre>
<p>Equivalent to the native <code>double</code> c-type (<a href="../numbers/index.html#Core.Float64"><code>Float64</code></a>).</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/ctypes.jl#L110-L114">source</a></section><h1 id="LLVM-Interface">
<a class="docs-heading-anchor" href="#LLVM-Interface">LLVM Interface</a>
</h1>
<h3 id="Core.Intrinsics.llvmcall">
<code>Core.Intrinsics.llvmcall</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">llvmcall(fun_ir::String, returntype, Tuple{argtype1, ...}, argvalue1, ...)
llvmcall((mod_ir::String, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)
llvmcall((mod_bc::Vector{UInt8}, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)</pre>
<p>Call the LLVM code provided in the first argument. There are several ways to specify this first argument:</p>
<ul>
<li>as a literal string, representing function-level IR (similar to an LLVM <code>define</code> block), with arguments are available as consecutive unnamed SSA variables (%0, %1, etc.);</li>
<li>as a 2-element tuple, containing a string of module IR and a string representing the name of the entry-point function to call;</li>
<li>as a 2-element tuple, but with the module provided as an <code>Vector{UInt8}</code> with bitcode.</li>
</ul>
<p>Note that contrary to <code>ccall</code>, the argument types must be specified as a tuple type, and not a tuple of types. All types, as well as the LLVM code, should be specified as literals, and not as variables or expressions (it may be necessary to use <code>@eval</code> to generate these literals).</p>
<p>See <code>test/llvmcall.jl</code> for usage examples.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/base/docs/basedocs.jl#L1299-L1319">source</a></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2023 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.10/base/c/" class="_attribution-link">https://docs.julialang.org/en/v1.10/base/c/</a>
  </p>
</div>
