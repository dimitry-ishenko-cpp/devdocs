<h1 id="Sorting-and-Related-Functions">Sorting and Related Functions</h1>
<p>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in ascending order:</p>
<pre data-language="julia">julia&gt; sort([2,3,1])
3-element Vector{Int64}:
 1
 2
 3</pre>
<p>You can sort in reverse order as well:</p>
<pre data-language="julia">julia&gt; sort([2,3,1], rev=true)
3-element Vector{Int64}:
 3
 2
 1</pre>
<p><code>sort</code> constructs a sorted copy leaving its input unchanged. Use the "bang" version of the sort function to mutate an existing array:</p>
<pre data-language="julia">julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Vector{Int64}:
 1
 2
 3</pre>
<p>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</p>
<pre data-language="julia">julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</pre>
<p>Arrays can be sorted according to an arbitrary transformation of their values:</p>
<pre data-language="julia">julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</pre>
<p>Or in reverse order by a transformation:</p>
<pre data-language="julia">julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</pre>
<p>If needed, the sorting algorithm can be chosen:</p>
<pre data-language="julia">julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</pre>
<p>All the sorting and order related functions rely on a "less than" relation defining a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak order</a> on the values to be manipulated. The <code>isless</code> function is invoked by default, but the relation can be specified via the <code>lt</code> keyword, a function that takes two array elements and returns <code>true</code> if and only if the first argument is "less than" the second. See <a href="#Base.sort!"><code>sort!</code></a> and <a href="#Alternate-Orderings">Alternate Orderings</a> for more information.</p>
<h2 id="Sorting-Functions">
<a class="docs-heading-anchor" href="#Sorting-Functions">Sorting Functions</a>
</h2>
<h3 id="Base.sort!">
<code>Base.sort!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort the vector <code>v</code> in place. A stable algorithm is used by default: the ordering of elements that compare equal is preserved. A specific algorithm can be selected via the <code>alg</code> keyword (see <a href="#Sorting-Algorithms">Sorting Algorithms</a> for available algorithms).</p>
<p>Elements are first transformed with the function <code>by</code> and then compared according to either the function <code>lt</code> or the ordering <code>order</code>. Finally, the resulting order is reversed if <code>rev=true</code> (this preserves forward stability: elements that compare equal are not reversed). The current implementation applies the <code>by</code> transformation before each comparison rather than once per element.</p>
<p>Passing an <code>lt</code> other than <code>isless</code> along with an <code>order</code> other than <a href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> or <a href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> is not permitted, otherwise all options are independent and can be used together in all possible combinations. Note that <code>order</code> can also include a "by" transformation, in which case it is applied after that defined with the <code>by</code> keyword. For more information on <code>order</code> values see the documentation on <a href="#Alternate-Orderings">Alternate Orderings</a>.</p>
<p>Relations between two elements are defined as follows (with "less" and "greater" exchanged when <code>rev=true</code>):</p>
<ul>
<li>
<code>x</code> is less than <code>y</code> if <code>lt(by(x), by(y))</code> (or <code>Base.Order.lt(order, by(x), by(y))</code>) yields true.</li>
<li>
<code>x</code> is greater than <code>y</code> if <code>y</code> is less than <code>x</code>.</li>
<li>
<code>x</code> and <code>y</code> are equivalent if neither is less than the other ("incomparable" is sometimes used as a synonym for "equivalent").</li>
</ul>
<p>The result of <code>sort!</code> is sorted in the sense that every element is greater than or equivalent to the previous one.</p>
<p>The <code>lt</code> function must define a strict weak order, that is, it must be</p>
<ul>
<li>irreflexive: <code>lt(x, x)</code> always yields <code>false</code>,</li>
<li>asymmetric: if <code>lt(x, y)</code> yields <code>true</code> then <code>lt(y, x)</code> yields <code>false</code>,</li>
<li>transitive: <code>lt(x, y) &amp;&amp; lt(y, z)</code> implies <code>lt(x, z)</code>,</li>
<li>transitive in equivalence: <code>!lt(x, y) &amp;&amp; !lt(y, x)</code> and <code>!lt(y, z) &amp;&amp; !lt(z, y)</code> together imply <code>!lt(x, z) &amp;&amp; !lt(z, x)</code>. In words: if <code>x</code> and <code>y</code> are equivalent and <code>y</code> and <code>z</code> are equivalent then <code>x</code> and <code>z</code> must be equivalent.</li>
</ul>
<p>For example <code>&lt;</code> is a valid <code>lt</code> function for <code>Int</code> values but <code>≤</code> is not: it violates irreflexivity. For <code>Float64</code> values even <code>&lt;</code> is invalid as it violates the fourth condition: <code>1.0</code> and <code>NaN</code> are equivalent and so are <code>NaN</code> and <code>2.0</code> but <code>1.0</code> and <code>2.0</code> are not equivalent.</p>
<p>See also <a href="#Base.sort"><code>sort</code></a>, <a href="#Base.sortperm"><code>sortperm</code></a>, <a href="#Base.sortslices"><code>sortslices</code></a>, <a href="#Base.Sort.partialsort!"><code>partialsort!</code></a>, <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, <a href="#Base.issorted"><code>issorted</code></a>, <a href="#Base.Sort.searchsorted"><code>searchsorted</code></a>, <a href="#Base.Sort.insorted"><code>insorted</code></a>, <a href="#Base.Order.ord"><code>Base.Order.ord</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2]; sort!(v); v
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v = [3, 1, 2]; sort!(v, rev = true); v
3-element Vector{Int64}:
 3
 2
 1

julia&gt; v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -&gt; x[1]); v
3-element Vector{Tuple{Int64, String}}:
 (1, "c")
 (2, "b")
 (3, "a")

julia&gt; v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -&gt; x[2]); v
3-element Vector{Tuple{Int64, String}}:
 (3, "a")
 (2, "b")
 (1, "c")

julia&gt; sort(0:3, by=x-&gt;x-2, order=Base.Order.By(abs)) # same as sort(0:3, by=abs(x-&gt;x-2))
4-element Vector{Int64}:
 2
 1
 3
 0

julia&gt; sort([2, NaN, 1, NaN, 3]) # correct sort with default lt=isless
5-element Vector{Float64}:
   1.0
   2.0
   3.0
 NaN
 NaN

julia&gt; sort([2, NaN, 1, NaN, 3], lt=&lt;) # wrong sort due to invalid lt. This behavior is undefined.
5-element Vector{Float64}:
   2.0
 NaN
   1.0
 NaN
   3.0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1585-L1686">source</a></section><section><pre data-language="julia">sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort the multidimensional array <code>A</code> along dimension <code>dims</code>. See the one-dimensional version of <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p>
<p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort!(A, dims = 1); A
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort!(A, dims = 2); A
2×2 Matrix{Int64}:
 1  2
 3  4</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L2059-L2088">source</a></section><h3 id="Base.sort">
<code>Base.sort</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Variant of <a href="#Base.sort!"><code>sort!</code></a> that returns a sorted copy of <code>v</code> leaving <code>v</code> itself unmodified.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2];

julia&gt; sort(v)
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v
3-element Vector{Int64}:
 3
 1
 2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1698-L1719">source</a></section><section><pre data-language="julia">sort(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort a multidimensional array <code>A</code> along the given dimension. See <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p>
<p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort(A, dims = 1)
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort(A, dims = 2)
2×2 Matrix{Int64}:
 3  4
 1  2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1987-L2013">source</a></section><h3 id="Base.sortperm">
<code>Base.sortperm</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortperm(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, [dims::Integer])</pre>
<p>Return a permutation vector or array <code>I</code> that puts <code>A[I]</code> in sorted order along the given dimension. If <code>A</code> has more than one dimension, then the <code>dims</code> keyword argument must be specified. The order is specified using the same keywords as <a href="#Base.sort!"><code>sort!</code></a>. The permutation is guaranteed to be stable even if the sorting algorithm is unstable: the indices of equal elements will appear in ascending order.</p>
<p>See also <a href="#Base.Sort.sortperm!"><code>sortperm!</code></a>, <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, <a href="../arrays/index.html#Base.invperm"><code>invperm</code></a>, <a href="../collections/index.html#Base.indexin"><code>indexin</code></a>. To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>The method accepting <code>dims</code> requires at least Julia 1.9.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2];

julia&gt; p = sortperm(v)
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; A = [8 7; 5 6]
2×2 Matrix{Int64}:
 8  7
 5  6

julia&gt; sortperm(A, dims = 1)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; sortperm(A, dims = 2)
2×2 Matrix{Int64}:
 3  1
 2  4</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1821-L1867">source</a></section><h3 id="Base.Sort.InsertionSort">
<code>Base.Sort.InsertionSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">InsertionSort</pre>
<p>Use the insertion sort algorithm.</p>
<p>Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output vector.</p>
<p>Characteristics:</p>
<ul><li>
<em>stable</em>: preserves the ordering of elements that compare equal</li></ul>
<p>(e.g. "a" and "A" in a sort of letters that ignores case).</p>
<ul>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>quadratic performance</em> in the number of elements to be sorted:</li>
</ul>
<p>it is well-suited to small collections but should not be used for large ones.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L799-L813">source</a></section><h3 id="Base.Sort.MergeSort">
<code>Base.Sort.MergeSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">MergeSort</pre>
<p>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>stable</em>: preserves the ordering of elements that compare equal (e.g. "a" and "A" in a sort of letters that ignores case).</li>
<li>
<em>not in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em> sort strategy.</li>
<li>
<em>good performance</em> for large collections but typically not quite as fast as <a href="#Base.Sort.QuickSort"><code>QuickSort</code></a>.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L2278-L2295">source</a></section><h3 id="Base.Sort.QuickSort">
<code>Base.Sort.QuickSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">QuickSort</pre>
<p>Indicate that a sorting function should use the quick sort algorithm, which is <em>not</em> stable.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>not stable</em>: does not preserve the ordering of elements that compare equal (e.g. "a" and "A" in a sort of letters that ignores case).</li>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li>
<li>
<em>good performance</em> for large collections.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L2262-L2275">source</a></section><h3 id="Base.Sort.PartialQuickSort">
<code>Base.Sort.PartialQuickSort</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">PartialQuickSort{T &lt;: Union{Integer,OrdinalRange}}</pre>
<p>Indicate that a sorting function should use the partial quick sort algorithm. <code>PartialQuickSort(k)</code> is like <code>QuickSort</code>, but is only required to find and sort the elements that would end up in <code>v[k]</code> were <code>v</code> fully sorted.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>not stable</em>: does not preserve the ordering of elements that compare equal (e.g. "a" and "A" in a sort of letters that ignores case).</li>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li>
</ul>
<p>Note that <code>PartialQuickSort(k)</code> does not necessarily sort the whole array. For example,</p>
<pre data-language="julia">julia&gt; x = rand(100);

julia&gt; k = 50:100;

julia&gt; s1 = sort(x; alg=QuickSort);

julia&gt; s2 = sort(x; alg=PartialQuickSort(k));

julia&gt; map(issorted, (s1, s2))
(true, false)

julia&gt; map(x-&gt;issorted(x[k]), (s1, s2))
(true, true)

julia&gt; s1[k] == s2[k]
true</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L2223-L2257">source</a></section><h3 id="Base.Sort.sortperm!">
<code>Base.Sort.sortperm!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortperm!(ix, A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, [dims::Integer])</pre>
<p>Like <a href="#Base.sortperm"><code>sortperm</code></a>, but accepts a preallocated index vector or array <code>ix</code> with the same <code>axes</code> as <code>A</code>. <code>ix</code> is initialized to contain the values <code>LinearIndices(A)</code>.</p>
<div class="admonition is-warning">

<div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div>
</div>
<div class="admonition is-compat">

<div class="admonition-body"><p>The method accepting <code>dims</code> requires at least Julia 1.9.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2]; p = zeros(Int, 3);

julia&gt; sortperm!(p, v); p
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; A = [8 7; 5 6]; p = zeros(Int,2, 2);

julia&gt; sortperm!(p, A; dims=1); p
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; sortperm!(p, A; dims=2); p
2×2 Matrix{Int64}:
 3  1
 2  4</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1899-L1938">source</a></section><h3 id="Base.sortslices">
<code>Base.sortslices</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort slices of an array <code>A</code>. The required keyword argument <code>dims</code> must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.</p>
<p>E.g., if <code>A</code> is a matrix, <code>dims=1</code> will sort rows, <code>dims=2</code> will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</p>
<p>For the remaining keyword arguments, see the documentation of <a href="#Base.sort!"><code>sort!</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Matrix{Int64}:
 -1   6  4
  7   3  5
  9  -2  8

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Matrix{Int64}:
  3   5  7
 -1  -4  6
 -2   8  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  5   3  7
 -4  -1  6
  8  -2  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Matrix{Int64}:
 7   5   3
 6  -4  -1
 9   8  -2</pre>
<p><strong>Higher dimensions</strong></p>
<p><code>sortslices</code> extends naturally to higher dimensions. E.g., if <code>A</code> is a a 2x2x2 array, <code>sortslices(A, dims=3)</code> will sort slices within the 3rd dimension, passing the 2x2 slices <code>A[:, :, 1]</code> and <code>A[:, :, 2]</code> to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the <code>by</code> or <code>lt</code> keyword argument to specify such an order.</p>
<p>If <code>dims</code> is a tuple, the order of the dimensions in <code>dims</code> is relevant and specifies the linear order of the slices. E.g., if <code>A</code> is three dimensional and <code>dims</code> is <code>(1, 2)</code>, the orderings of the first two dimensions are re-arranged such that the slices (of the remaining third dimension) are sorted. If <code>dims</code> is <code>(2, 1)</code> instead, the same slices will be taken, but the result order will be row-major instead.</p>
<p><strong>Higher dimensional examples</strong></p>
<pre data-language="julia">julia&gt; A = [4 3; 2 1 ;;; 'A' 'B'; 'C' 'D']
2×2×2 Array{Any, 3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 'A'  'B'
 'C'  'D'

julia&gt; sortslices(A, dims=(1,2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 'D'  'B'
 'C'  'A'

julia&gt; sortslices(A, dims=(2,1))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 'D'  'C'
 'B'  'A'

julia&gt; sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x-&gt;x[1,1])
1×1×5 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/multidimensional.jl#L1812-L1928">source</a></section><h2 id="Order-Related-Functions">
<a class="docs-heading-anchor" href="#Order-Related-Functions">Order-Related Functions</a>
</h2>
<h3 id="Base.issorted">
<code>Base.issorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">issorted(v, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Test whether a collection is in sorted order. The keywords modify what order is considered sorted, as described in the <a href="#Base.sort!"><code>sort!</code></a> documentation.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; issorted([1, 2, 3])
true

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[1])
true

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[2])
false

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[2], rev=true)
true

julia&gt; issorted([1, 2, -2, 3], by=abs)
true</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L64-L87">source</a></section><h3 id="Base.Sort.searchsorted">
<code>Base.Sort.searchsorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsorted(v, x; by=identity, lt=isless, rev=false)</pre>
<p>Return the range of indices in <code>v</code> where values are equivalent to <code>x</code>, or an empty range located at the insertion point if <code>v</code> does not contain values equivalent to <code>x</code>. The vector <code>v</code> must be sorted according to the order defined by the keywords. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p>
<p>The range is generally found using binary search, but there are optimized implementations for some inputs.</p>
<p>See also: <a href="#Base.Sort.searchsortedfirst"><code>searchsortedfirst</code></a>, <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.Sort.insorted"><code>insorted</code></a>, <a href="#"><code>findall</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 4) # single match
3:3

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches
4:5

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3:2

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7:6

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1:0

julia&gt; searchsorted([1=&gt;"one", 2=&gt;"two", 2=&gt;"two", 4=&gt;"four"], 2=&gt;"two", by=first) # compare the keys of the pairs
2:3</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L308-L343">source</a></section><h3 id="Base.Sort.searchsortedfirst">
<code>Base.Sort.searchsortedfirst</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsortedfirst(v, x; by=identity, lt=isless, rev=false)</pre>
<p>Return the index of the first value in <code>v</code> that is not ordered before <code>x</code>. If all values in <code>v</code> are ordered before <code>x</code>, return <code>lastindex(v) + 1</code>.</p>
<p>The vector <code>v</code> must be sorted according to the order defined by the keywords. <code>insert!</code>ing <code>x</code> at the returned index will maintain the sorted order. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning and use of the keywords. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p>
<p>The index is generally found using binary search, but there are optimized implementations for some inputs.</p>
<p>See also: <a href="#Base.Sort.searchsortedlast"><code>searchsortedlast</code></a>, <a href="#Base.Sort.searchsorted"><code>searchsorted</code></a>, <a href="#"><code>findfirst</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches
4

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1

julia&gt; searchsortedfirst([1=&gt;"one", 2=&gt;"two", 4=&gt;"four"], 3=&gt;"three", by=first) # compare the keys of the pairs
3</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L345-L382">source</a></section><h3 id="Base.Sort.searchsortedlast">
<code>Base.Sort.searchsortedlast</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsortedlast(v, x; by=identity, lt=isless, rev=false)</pre>
<p>Return the index of the last value in <code>v</code> that is not ordered after <code>x</code>. If all values in <code>v</code> are ordered after <code>x</code>, return <code>firstindex(v) - 1</code>.</p>
<p>The vector <code>v</code> must be sorted according to the order defined by the keywords. <code>insert!</code>ing <code>x</code> immediately after the returned index will maintain the sorted order. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning and use of the keywords. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p>
<p>The index is generally found using binary search, but there are optimized implementations for some inputs</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches
5

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
2

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
6

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
0

julia&gt; searchsortedlast([1=&gt;"one", 2=&gt;"two", 4=&gt;"four"], 3=&gt;"three", by=first) # compare the keys of the pairs
2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L384-L419">source</a></section><h3 id="Base.Sort.insorted">
<code>Base.Sort.insorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">insorted(x, v; by=identity, lt=isless, rev=false) -&gt; Bool</pre>
<p>Determine whether a vector <code>v</code> contains any value equivalent to <code>x</code>. The vector <code>v</code> must be sorted according to the order defined by the keywords. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p>
<p>The check is generally done using binary search, but there are optimized implementations for some inputs.</p>
<p>See also <a href="../collections/index.html#Base.in"><code>in</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; insorted(4, [1, 2, 4, 5, 5, 7]) # single match
true

julia&gt; insorted(5, [1, 2, 4, 5, 5, 7]) # multiple matches
true

julia&gt; insorted(3, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(9, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(0, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(2=&gt;"TWO", [1=&gt;"one", 2=&gt;"two", 4=&gt;"four"], by=first) # compare the keys of the pairs
true</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p><code>insorted</code> was added in Julia 1.6.</p></div>
</div>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L421-L458">source</a></section><h3 id="Base.Sort.partialsort!">
<code>Base.Sort.partialsort!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsort!(v, k; by=identity, lt=isless, rev=false)</pre>
<p>Partially sort the vector <code>v</code> in place so that the value at index <code>k</code> (or range of adjacent values if <code>k</code> is a range) occurs at the position where it would appear if the array were fully sorted. If <code>k</code> is a single index, that value is returned; if <code>k</code> is a range, an array of values at those indices is returned. Note that <code>partialsort!</code> may not fully sort the input array.</p>
<p>For the keyword arguments, see the documentation of <a href="#Base.sort!"><code>sort!</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4)
4

julia&gt; a
5-element Vector{Int64}:
 1
 2
 3
 4
 4

julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4, rev=true)
2

julia&gt; a
5-element Vector{Int64}:
 4
 4
 3
 2
 1</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L108-L160">source</a></section><h3 id="Base.Sort.partialsort">
<code>Base.Sort.partialsort</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsort(v, k, by=identity, lt=isless, rev=false)</pre>
<p>Variant of <a href="#Base.Sort.partialsort!"><code>partialsort!</code></a> that copies <code>v</code> before partially sorting it, thereby returning the same thing as <code>partialsort!</code> but leaving <code>v</code> unmodified.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L165-L170">source</a></section><h3 id="Base.Sort.partialsortperm">
<code>Base.Sort.partialsortperm</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsortperm(v, k; by=identity, lt=isless, rev=false)</pre>
<p>Return a partial permutation <code>I</code> of the vector <code>v</code>, so that <code>v[I]</code> returns values of a fully sorted version of <code>v</code> at index <code>k</code>. If <code>k</code> is a range, a vector of indices is returned; if <code>k</code> is an integer, a single index is returned. The order is specified using the same keywords as <code>sort!</code>. The permutation is stable: the indices of equal elements will appear in ascending order.</p>
<p>This function is equivalent to, but more efficient than, calling <code>sortperm(...)[k]</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2, 1];

julia&gt; v[partialsortperm(v, 1)]
1

julia&gt; p = partialsortperm(v, 1:3)
3-element view(::Vector{Int64}, 1:3) with eltype Int64:
 2
 4
 3

julia&gt; v[p]
3-element Vector{Int64}:
 1
 1
 2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1724-L1754">source</a></section><h3 id="Base.Sort.partialsortperm!">
<code>Base.Sort.partialsortperm!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsortperm!(ix, v, k; by=identity, lt=isless, rev=false)</pre>
<p>Like <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, but accepts a preallocated index vector <code>ix</code> the same size as <code>v</code>, which is used to store (a permutation of) the indices of <code>v</code>.</p>
<p><code>ix</code> is initialized to contain the indices of <code>v</code>.</p>
<p>(Typically, the indices of <code>v</code> will be <code>1:length(v)</code>, although if <code>v</code> has an alternative array type with non-one-based indices, such as an <code>OffsetArray</code>, <code>ix</code> must share those same indices)</p>
<p>Upon return, <code>ix</code> is guaranteed to have the indices <code>k</code> in their sorted positions, such that</p>
<pre data-language="julia">partialsortperm!(ix, v, k);
v[ix[k]] == partialsort(v, k)</pre>
<p>The return value is the <code>k</code>th element of <code>ix</code> if <code>k</code> is an integer, or view into <code>ix</code> if <code>k</code> is a range.</p>
<div class="admonition is-warning">

<div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2, 1];

julia&gt; ix = Vector{Int}(undef, 4);

julia&gt; partialsortperm!(ix, v, 1)
2

julia&gt; ix = [1:4;];

julia&gt; partialsortperm!(ix, v, 2:3)
2-element view(::Vector{Int64}, 2:3) with eltype Int64:
 4
 3</pre>

<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/sort.jl#L1758-L1797">source</a></section><h2 id="Sorting-Algorithms">
<a class="docs-heading-anchor" href="#Sorting-Algorithms">Sorting Algorithms</a>
</h2>
<p>There are currently four sorting algorithms publicly available in base Julia:</p>
<ul>
<li><a href="#Base.Sort.InsertionSort"><code>InsertionSort</code></a></li>
<li><a href="#Base.Sort.QuickSort"><code>QuickSort</code></a></li>
<li><a href="#Base.Sort.PartialQuickSort"><code>PartialQuickSort(k)</code></a></li>
<li><a href="#Base.Sort.MergeSort"><code>MergeSort</code></a></li>
</ul>
<p>By default, the <code>sort</code> family of functions uses stable sorting algorithms that are fast on most inputs. The exact algorithm choice is an implementation detail to allow for future performance improvements. Currently, a hybrid of <code>RadixSort</code>, <code>ScratchQuickSort</code>, <code>InsertionSort</code>, and <code>CountingSort</code> is used based on input type, size, and composition. Implementation details are subject to change but currently available in the extended help of <code>??Base.DEFAULT_STABLE</code> and the docstrings of internal sorting algorithms listed there.</p>
<p>You can explicitly specify your preferred algorithm with the <code>alg</code> keyword (e.g. <code>sort!(v, alg=PartialQuickSort(10:20))</code>) or reconfigure the default sorting algorithm for custom types by adding a specialized method to the <code>Base.Sort.defalg</code> function. For example, <a href="https://github.com/JuliaStrings/InlineStrings.jl/blob/v1.3.2/src/InlineStrings.jl#L903">InlineStrings.jl</a> defines the following method:</p>
<pre data-language="julia">Base.Sort.defalg(::AbstractArray{&lt;:Union{SmallInlineStrings, Missing}}) = InlineStringSort</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p>The default sorting algorithm (returned by <code>Base.Sort.defalg</code>) is guaranteed to be stable since Julia 1.9. Previous versions had unstable edge cases when sorting numeric arrays.</p></div>
</div>
<h2 id="Alternate-Orderings">
<a class="docs-heading-anchor" href="#Alternate-Orderings">Alternate Orderings</a>
</h2>
<p>By default, <code>sort</code>, <code>searchsorted</code>, and related functions use <a href="../base/index.html#Base.isless"><code>isless</code></a> to compare two elements in order to determine which should come first. The <a href="#Base.Order.Ordering"><code>Base.Order.Ordering</code></a> abstract type provides a mechanism for defining alternate orderings on the same set of elements: when calling a sorting function like <code>sort!</code>, an instance of <code>Ordering</code> can be provided with the keyword argument <code>order</code>.</p>
<p>Instances of <code>Ordering</code> define an order through the <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> function, which works as a generalization of <code>isless</code>. This function's behavior on custom <code>Ordering</code>s must satisfy all the conditions of a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak order</a>. See <a href="#Base.sort!"><code>sort!</code></a> for details and examples of valid and invalid <code>lt</code> functions.</p>
<h3 id="Base.Order.Ordering">
<code>Base.Order.Ordering</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Base.Order.Ordering</pre>
<p>Abstract type which represents a strict weak order on some set of elements. See <a href="#Base.sort!"><code>sort!</code></a> for more.</p>
<p>Use <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> to compare two elements according to the ordering.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L21-L28">source</a></section><h3 id="Base.Order.lt">
<code>Base.Order.lt</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">lt(o::Ordering, a, b) -&gt; Bool</pre>
<p>Test whether <code>a</code> is less than <code>b</code> according to the ordering <code>o</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L113-L117">source</a></section><h3 id="Base.Order.ord">
<code>Base.Order.ord</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ord(lt, by, rev::Union{Bool, Nothing}, order::Ordering=Forward)</pre>
<p>Construct an <a href="#Base.Order.Ordering"><code>Ordering</code></a> object from the same arguments used by <a href="#Base.sort!"><code>sort!</code></a>. Elements are first transformed by the function <code>by</code> (which may be <a href="../base/index.html#Base.identity"><code>identity</code></a>) and are then compared according to either the function <code>lt</code> or an existing ordering <code>order</code>. <code>lt</code> should be <a href="../base/index.html#Base.isless"><code>isless</code></a> or a function that obeys the same rules as the <code>lt</code> parameter of <a href="#Base.sort!"><code>sort!</code></a>. Finally, the resulting order is reversed if <code>rev=true</code>.</p>
<p>Passing an <code>lt</code> other than <code>isless</code> along with an <code>order</code> other than <a href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> or <a href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> is not permitted, otherwise all options are independent and can be used together in all possible combinations.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L139-L154">source</a></section><h3 id="Base.Order.Forward">
<code>Base.Order.Forward</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">Base.Order.Forward</pre>
<p>Default ordering according to <a href="../base/index.html#Base.isless"><code>isless</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L60-L64">source</a></section><h3 id="Base.Order.ReverseOrdering">
<code>Base.Order.ReverseOrdering</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">ReverseOrdering(fwd::Ordering=Forward)</pre>
<p>A wrapper which reverses an ordering.</p>
<p>For a given <code>Ordering</code> <code>o</code>, the following holds for all <code>a</code>, <code>b</code>:</p>
<pre data-language="julia">lt(ReverseOrdering(o), a, b) == lt(o, b, a)</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L33-L41">source</a></section><h3 id="Base.Order.Reverse">
<code>Base.Order.Reverse</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">Base.Order.Reverse</pre>
<p>Reverse ordering according to <a href="../base/index.html#Base.isless"><code>isless</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L67-L71">source</a></section><h3 id="Base.Order.By">
<code>Base.Order.By</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">By(by, order::Ordering=Forward)</pre>
<p><code>Ordering</code> which applies <code>order</code> to elements after they have been transformed by the function <code>by</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L74-L79">source</a></section><h3 id="Base.Order.Lt">
<code>Base.Order.Lt</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Lt(lt)</pre>
<p><code>Ordering</code> that calls <code>lt(a, b)</code> to compare elements. <code>lt</code> must obey the same rules as the <code>lt</code> parameter of <a href="#Base.sort!"><code>sort!</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L88-L93">source</a></section><h3 id="Base.Order.Perm">
<code>Base.Order.Perm</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Perm(order::Ordering, data::AbstractVector)</pre>
<p><code>Ordering</code> on the indices of <code>data</code> where <code>i</code> is less than <code>j</code> if <code>data[i]</code> is less than <code>data[j]</code> according to <code>order</code>. In the case that <code>data[i]</code> and <code>data[j]</code> are equal, <code>i</code> and <code>j</code> are compared by numeric value.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/5e9a32e7af2837e677e60543d4a15faa8d3a7297/base/ordering.jl#L98-L104">source</a></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2024 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.11/base/sort/" class="_attribution-link">https://docs.julialang.org/en/v1.11/base/sort/</a>
  </p>
</div>
