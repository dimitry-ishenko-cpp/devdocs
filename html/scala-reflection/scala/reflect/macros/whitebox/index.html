<h1>Package scala.reflect.macros.whitebox</h1>
<h2 id="signature">
<span class="modifier_kind"> <span class="kind">package</span></span> <span class="symbol"><span class="name">whitebox</span></span>
</h2>

<div id="template"><div id="allMembers"><div id="types" class="types members">
<h2>Type Members</h2>
<h3 id="scala.reflect.macros.whitebox.Context">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="context.html" title="EXPERIMENTAL"><span class="name">Context</span></a><span class="result"> extends <a href="../blackbox/context.html" name="scala.reflect.macros.blackbox.Context" id="scala.reflect.macros.blackbox.Context" class="extype">blackbox.Context</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> The whitebox Scala macros context.</p>
<p> See <a href="../index.html" name="scala.reflect.macros" id="scala.reflect.macros" class="extype">the overview page</a> for a description of how macros work. This documentation entry provides information on the API available to macro writers.</p>
<p> A macro context wraps a compiler universe exposed in <code>universe</code> and having type <a href="../universe.html" name="scala.reflect.macros.Universe" id="scala.reflect.macros.Universe" class="extype">scala.reflect.macros.Universe</a>. This type is a refinement over the generic reflection API provided in <a href="../../api/universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a>. The extended Universe provides mutability for reflection artifacts (e.g. macros can change types of compiler trees, add annotation to symbols representing definitions, etc) and exposes some internal compiler functionality such as <code>Symbol.deSkolemize</code> or <code>Tree.attachments</code>.</p>
<p> Another fundamental part of a macro context is <code>macroApplication</code>, which provides access to the tree undergoing macro expansion. Parts of this tree can be found in arguments of the corresponding macro implementations and in <code>prefix</code>, but <code>macroApplication</code> gives the full picture.</p>
<p> Other than that, macro contexts provide facilities for typechecking, exploring the compiler's symbol table and enclosing trees and compilation units, evaluating trees, logging warnings/errors and much more. Refer to the documentation of top-level traits in this package to learn the details.</p>
<p> If a macro def refers to a macro impl that uses <code>whitebox.Context</code>, then this macro def becomes a whitebox macro, gaining the ability to refine the type of its expansion beyond its official return type, which enables a number of important use cases. Blackbox macros, i.e. the ones defined with <code>blackbox.Context</code>, can't do that, so they are less powerful. However blackbox macros are also going to enjoy better support than whitebox macros, so choose wisely. See the <a href="http://docs.scala-lang.org/overviews/macros/overview.html" target="_blank">Macros Guide</a> for more information. </p>
</div>
<dl class="attributes block">
<dt>See also</dt>
<dd><span class="cmt"><p><code>scala.reflect.macros.blackbox.Context</code></p></span></dd>
</dl>
</div>
</div></div></div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala-reflect/scala/reflect/macros/whitebox/index.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala-reflect/scala/reflect/macros/whitebox/index.html</a>
  </p>
</div>
