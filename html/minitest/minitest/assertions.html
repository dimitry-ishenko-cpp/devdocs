<h1 id="module-Minitest::Assertions" class="module"> module Minitest::Assertions </h1> <section class="description"> <p><a href="../minitest.html"><code>Minitest</code></a> <a href="assertions.html"><code>Assertions</code></a>. All assertion methods accept a <code>msg</code> which is printed if the assertion fails.</p> <p>Protocol: Nearly everything here boils up to <code>assert</code>, which expects to be able to increment an instance accessor named <code>assertions</code>. This is not provided by <a href="assertions.html"><code>Assertions</code></a> and must be provided by the thing including <a href="assertions.html"><code>Assertions</code></a>. See Minitest::Runnable for an example.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-diff"> <span class="method-name">diff</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="diff-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 29
def self.diff
  return @diff if defined? @diff

  @diff = if (RbConfig::CONFIG["host_os"] =~ /mswin|mingw/ &amp;&amp;
              system("diff.exe", __FILE__, __FILE__)) then
            "diff.exe -u"
          elsif system("gdiff", __FILE__, __FILE__)
            "gdiff -u" # solaris and kin suck
          elsif system("diff", __FILE__, __FILE__)
            "diff -u"
          else
            nil
          end
end</pre> </div> <p>Returns the diff command to use in <a href="assertions.html#method-i-diff"><code>diff</code></a>. Tries to intelligently figure out what diff to use.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-diff-3D"> <span class="method-name">diff=</span><span class="method-args">(o)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="diff-3D-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 47
def self.diff= o
  @diff = o
end</pre> </div> <p>Set the diff command to use in <a href="assertions.html#method-i-diff"><code>diff</code></a>.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert"> <span class="method-name">assert</span><span class="method-args">(test, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 178
def assert test, msg = nil
  self.assertions += 1
  unless test then
    msg ||= "Expected #{mu_pp test} to be truthy."
    msg = msg.call if Proc === msg
    raise Minitest::Assertion, msg
  end
  true
end</pre> </div> <p>Fails unless <code>test</code> is truthy.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_empty"> <span class="method-name">assert_empty</span><span class="method-args">(obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_empty-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 195
def assert_empty obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to be empty" }
  assert_respond_to obj, :empty?
  assert obj.empty?, msg
end</pre> </div> <p>Fails unless <code>obj</code> is empty.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_equal"> <span class="method-name">assert_equal</span><span class="method-args">(exp, act, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_equal-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 216
def assert_equal exp, act, msg = nil
  msg = message(msg, E) { diff exp, act }
  result = assert exp == act, msg

  if nil == exp then
    if Minitest::VERSION =~ /^6/ then
      refute_nil exp, "Use assert_nil if expecting nil."
    else
      where = Minitest.filter_backtrace(caller).first
      where = where.split(/:in /, 2).first # clean up noise

      warn "DEPRECATED: Use assert_nil if expecting nil from #{where}. This will fail in Minitest 6."
    end
  end

  result
end</pre> </div> <p>Fails unless <code>exp == act</code> printing the difference between the two, if possible.</p> <p>If there is no visible difference but the assertion fails, you should suspect that your == is buggy, or your inspect output is missing crucial details. For nicer structural diffing, set <a href="test.html#method-c-make_my_diffs_pretty-21"><code>Minitest::Test.make_my_diffs_pretty!</code></a></p> <p>For floats use assert_in_delta.</p> <p>See also: <a href="assertions.html#method-c-diff"><code>Minitest::Assertions.diff</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_in_delta"> <span class="method-name">assert_in_delta</span><span class="method-args">(exp, act, delta = 0.001, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_in_delta-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 240
def assert_in_delta exp, act, delta = 0.001, msg = nil
  n = (exp - act).abs
  msg = message(msg) {
    "Expected |#{exp} - #{act}| (#{n}) to be &lt;= #{delta}"
  }
  assert delta &gt;= n, msg
end</pre> </div> <p>For comparing Floats. Fails unless <code>exp</code> and <code>act</code> are within <code>delta</code> of each other.</p> <pre class="ruby" data-language="ruby">assert_in_delta Math::PI, (22.0 / 7.0), 0.01
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_in_epsilon"> <span class="method-name">assert_in_epsilon</span><span class="method-args">(exp, act, epsilon = 0.001, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_in_epsilon-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 252
def assert_in_epsilon exp, act, epsilon = 0.001, msg = nil
  assert_in_delta exp, act, [exp.abs, act.abs].min * epsilon, msg
end</pre> </div> <p>For comparing Floats. Fails unless <code>exp</code> and <code>act</code> have a relative error less than <code>epsilon</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_includes"> <span class="method-name">assert_includes</span><span class="method-args">(collection, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_includes-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 259
def assert_includes collection, obj, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(collection)} to include #{mu_pp(obj)}"
  }
  assert_respond_to collection, :include?
  assert collection.include?(obj), msg
end</pre> </div> <p>Fails unless <code>collection</code> includes <code>obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_instance_of"> <span class="method-name">assert_instance_of</span><span class="method-args">(cls, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_instance_of-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 270
def assert_instance_of cls, obj, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(obj)} to be an instance of #{cls}, not #{obj.class}"
  }

  assert obj.instance_of?(cls), msg
end</pre> </div> <p>Fails unless <code>obj</code> is an instance of <code>cls</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_kind_of"> <span class="method-name">assert_kind_of</span><span class="method-args">(cls, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_kind_of-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 281
def assert_kind_of cls, obj, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(obj)} to be a kind of #{cls}, not #{obj.class}" }

  assert obj.kind_of?(cls), msg
end</pre> </div> <p>Fails unless <code>obj</code> is a kind of <code>cls</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_match"> <span class="method-name">assert_match</span><span class="method-args">(matcher, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_match-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 291
def assert_match matcher, obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp matcher} to match #{mu_pp obj}" }
  assert_respond_to matcher, :"=~"
  matcher = Regexp.new Regexp.escape matcher if String === matcher
  assert matcher =~ obj, msg

  Regexp.last_match
end</pre> </div> <p>Fails unless <code>matcher</code> <code>=~</code> <code>obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_mock"> <span class="method-name">assert_mock</span><span class="method-args">(mock)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_mock-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/mock.rb, line 248
def assert_mock mock
  assert mock.verify
end</pre> </div> <p>Assert that the mock verifies correctly.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_nil"> <span class="method-name">assert_nil</span><span class="method-args">(obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_nil-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 303
def assert_nil obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to be nil" }
  assert obj.nil?, msg
end</pre> </div> <p>Fails unless <code>obj</code> is nil</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_operator"> <span class="method-name">assert_operator</span><span class="method-args">(o1, op, o2 = UNDEFINED, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_operator-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 313
def assert_operator o1, op, o2 = UNDEFINED, msg = nil
  return assert_predicate o1, op, msg if UNDEFINED == o2
  msg = message(msg) { "Expected #{mu_pp(o1)} to be #{op} #{mu_pp(o2)}" }
  assert o1.__send__(op, o2), msg
end</pre> </div> <p>For testing with binary operators. Eg:</p> <pre class="ruby" data-language="ruby">assert_operator 5, :&lt;=, 4
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_output"> <span class="method-name">assert_output</span><span class="method-args">(stdout = nil, stderr = nil) { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_output-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 331
def assert_output stdout = nil, stderr = nil
  flunk "assert_output requires a block to capture output." unless
    block_given?

  out, err = capture_io do
    yield
  end

  err_msg = Regexp === stderr ? :assert_match : :assert_equal if stderr
  out_msg = Regexp === stdout ? :assert_match : :assert_equal if stdout

  y = send err_msg, stderr, err, "In stderr" if err_msg
  x = send out_msg, stdout, out, "In stdout" if out_msg

  (!stdout || x) &amp;&amp; (!stderr || y)
rescue Assertion
  raise
rescue =&gt; e
  raise UnexpectedError, e
end</pre> </div> <p>Fails if stdout or stderr do not output the expected results. Pass in nil if you don’t care about that streams output. Pass in “” if you require it to be silent. Pass in a regexp if you want to pattern match.</p> <pre class="ruby" data-language="ruby">assert_output(/hey/) { method_with_output }
</pre> <p>NOTE: this uses <a href="assertions.html#method-i-capture_io"><code>capture_io</code></a>, not <a href="assertions.html#method-i-capture_subprocess_io"><code>capture_subprocess_io</code></a>.</p> <p>See also: <a href="assertions.html#method-i-assert_silent"><code>assert_silent</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_path_exists"> <span class="method-name">assert_path_exists</span><span class="method-args">(path, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_path_exists-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 355
def assert_path_exists path, msg = nil
  msg = message(msg) { "Expected path '#{path}' to exist" }
  assert File.exist?(path), msg
end</pre> </div> <p>Fails unless <code>path</code> exists.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_pattern"> <span class="method-name">assert_pattern</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_pattern-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 374
def assert_pattern
  raise NotImplementedError, "only available in Ruby 3.0+" unless RUBY_VERSION &gt;= "3.0"
  flunk "assert_pattern requires a block to capture errors." unless block_given?

  begin # TODO: remove after ruby 2.6 dropped
    yield
    pass
  rescue NoMatchingPatternError =&gt; e
    flunk e.message
  end
end</pre> </div> <p>For testing with pattern matching (only supported with Ruby 3.0 and later)</p> <pre class="ruby" data-language="ruby"># pass
assert_pattern { [1,2,3] =&gt; [Integer, Integer, Integer] }

# fail "length mismatch (given 3, expected 1)"
assert_pattern { [1,2,3] =&gt; [Integer] }
</pre> <p>The bare <code>=&gt;</code> pattern will raise a NoMatchingPatternError on failure, which would normally be counted as a test error. This assertion rescues NoMatchingPatternError and generates a test failure. Any other exception will be raised as normal and generate a test error.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_predicate"> <span class="method-name">assert_predicate</span><span class="method-args">(o1, op, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_predicate-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 395
def assert_predicate o1, op, msg = nil
  msg = message(msg) { "Expected #{mu_pp(o1)} to be #{op}" }
  assert o1.__send__(op), msg
end</pre> </div> <p>For testing with predicates. Eg:</p> <pre class="ruby" data-language="ruby">assert_predicate str, :empty?
</pre> <p>This is really meant for specs and is front-ended by <a href="assertions.html#method-i-assert_operator"><code>assert_operator</code></a>:</p> <pre class="ruby" data-language="ruby">str.must_be :empty?
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_raises"> <span class="method-name">assert_raises</span><span class="method-args">(*exp) { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_raises-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 422
def assert_raises *exp
  flunk "assert_raises requires a block to capture errors." unless
    block_given?

  msg = "#{exp.pop}.\n" if String === exp.last
  exp &lt;&lt; StandardError if exp.empty?

  begin
    yield
  rescue *exp =&gt; e
    pass # count assertion
    return e
  rescue Minitest::Assertion # incl Skip &amp; UnexpectedError
    # don't count assertion
    raise
  rescue SignalException, SystemExit
    raise
  rescue Exception =&gt; e
    flunk proc {
      exception_details(e, "#{msg}#{mu_pp(exp)} exception expected, not")
    }
  end

  exp = exp.first if exp.size == 1

  flunk "#{msg}#{mu_pp(exp)} expected but nothing was raised."
end</pre> </div> <p>Fails unless the block raises one of <code>exp</code>. Returns the exception matched so you can check the message, attributes, etc.</p> <p><code>exp</code> takes an optional message on the end to help explain failures and defaults to StandardError if no exception class is passed. Eg:</p> <pre class="ruby" data-language="ruby">assert_raises(CustomError) { method_with_custom_error }
</pre> <p>With custom error message:</p> <pre class="ruby" data-language="ruby">assert_raises(CustomError, 'This should have raised CustomError') { method_with_custom_error }
</pre> <p>Using the returned object:</p> <pre class="ruby" data-language="ruby">error = assert_raises(CustomError) do
  raise CustomError, 'This is really bad'
end

assert_equal 'This is really bad', error.message
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_respond_to"> <span class="method-name">assert_respond_to</span><span class="method-args">(obj, meth, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_respond_to-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 453
def assert_respond_to obj, meth, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(obj)} (#{obj.class}) to respond to ##{meth}"
  }
  assert obj.respond_to?(meth), msg
end</pre> </div> <p>Fails unless <code>obj</code> responds to <code>meth</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_same"> <span class="method-name">assert_same</span><span class="method-args">(exp, act, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_same-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 463
def assert_same exp, act, msg = nil
  msg = message(msg) {
    data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]
    "Expected %s (oid=%d) to be the same as %s (oid=%d)" % data
  }
  assert exp.equal?(act), msg
end</pre> </div> <p>Fails unless <code>exp</code> and <code>act</code> are equal?</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_send"> <span class="method-name">assert_send</span><span class="method-args">(send_ary, m = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_send-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 476
def assert_send send_ary, m = nil
  where = Minitest.filter_backtrace(caller).first
  where = where.split(/:in /, 2).first # clean up noise
  warn "DEPRECATED: assert_send. From #{where}"

  recv, msg, *args = send_ary
  m = message(m) {
    "Expected #{mu_pp(recv)}.#{msg}(*#{mu_pp(args)}) to return true" }
  assert recv.__send__(msg, *args), m
end</pre> </div> <p><code>send_ary</code> is a receiver, message and arguments.</p> <p>Fails unless the call returns a true value</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_silent"> <span class="method-name">assert_silent</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_silent-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 492
def assert_silent
  assert_output "", "" do
    yield
  end
end</pre> </div> <p>Fails if the block outputs anything to stderr or stdout.</p> <p>See also: <a href="assertions.html#method-i-assert_output"><code>assert_output</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_throws"> <span class="method-name">assert_throws</span><span class="method-args">(sym, msg = nil) { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_throws-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 501
def assert_throws sym, msg = nil
  default = "Expected #{mu_pp(sym)} to have been thrown"
  caught = true
  value = catch(sym) do
    begin
      yield
    rescue ThreadError =&gt; e       # wtf?!? 1.8 + threads == suck
      default += ", not \:#{e.message[/uncaught throw \`(\w+?)\'/, 1]}"
    rescue ArgumentError =&gt; e     # 1.9 exception
      raise e unless e.message.include?("uncaught throw")
      default += ", not #{e.message.split(/ /).last}"
    rescue NameError =&gt; e         # 1.8 exception
      raise e unless e.name == sym
      default += ", not #{e.name.inspect}"
    end
    caught = false
  end

  assert caught, message(msg) { default }
  value
rescue Assertion
  raise
rescue =&gt; e
  raise UnexpectedError, e
end</pre> </div> <p>Fails unless the block throws <code>sym</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-capture_io"> <span class="method-name">capture_io</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="capture_io-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 542
def capture_io
  _synchronize do
    begin
      captured_stdout, captured_stderr = StringIO.new, StringIO.new

      orig_stdout, orig_stderr = $stdout, $stderr
      $stdout, $stderr         = captured_stdout, captured_stderr

      yield

      return captured_stdout.string, captured_stderr.string
    ensure
      $stdout = orig_stdout
      $stderr = orig_stderr
    end
  end
end</pre> </div> <p>Captures $stdout and $stderr into strings:</p> <pre class="ruby" data-language="ruby">out, err = capture_io do
  puts "Some info"
  warn "You did a bad thing"
end

assert_match %r%info%, out
assert_match %r%bad%, err
</pre> <p>NOTE: For efficiency, this method uses StringIO and does not capture IO for subprocesses. Use <a href="assertions.html#method-i-capture_subprocess_io"><code>capture_subprocess_io</code></a> for that.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-capture_subprocess_io"> <span class="method-name">capture_subprocess_io</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="capture_subprocess_io-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 575
def capture_subprocess_io
  _synchronize do
    begin
      require "tempfile"

      captured_stdout, captured_stderr = Tempfile.new("out"), Tempfile.new("err")

      orig_stdout, orig_stderr = $stdout.dup, $stderr.dup
      $stdout.reopen captured_stdout
      $stderr.reopen captured_stderr

      yield

      $stdout.rewind
      $stderr.rewind

      return captured_stdout.read, captured_stderr.read
    ensure
      $stdout.reopen orig_stdout
      $stderr.reopen orig_stderr

      orig_stdout.close
      orig_stderr.close
      captured_stdout.close!
      captured_stderr.close!
    end
  end
end</pre> </div> <p>Captures $stdout and $stderr into strings, using Tempfile to ensure that subprocess IO is captured as well.</p> <pre class="ruby" data-language="ruby">out, err = capture_subprocess_io do
  system "echo Some info"
  system "echo You did a bad thing 1&gt;&amp;2"
end

assert_match %r%info%, out
assert_match %r%bad%, err
</pre> <p>NOTE: This method is approximately 10x slower than <a href="assertions.html#method-i-capture_io"><code>capture_io</code></a> so only use it when you need to test the output of a subprocess.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-diff"> <span class="method-name">diff</span><span class="method-args">(exp, act)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="diff-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 59
def diff exp, act
  result = nil

  expect, butwas = things_to_diff(exp, act)

  return "Expected: #{mu_pp exp}\n  Actual: #{mu_pp act}" unless
    expect

  Tempfile.open("expect") do |a|
    a.puts expect
    a.flush

    Tempfile.open("butwas") do |b|
      b.puts butwas
      b.flush

      result = `#{Minitest::Assertions.diff} #{a.path} #{b.path}`
      result.sub!(/^\-\-\- .+/, "--- expected")
      result.sub!(/^\+\+\+ .+/, "+++ actual")

      if result.empty? then
        klass = exp.class
        result = [
                  "No visible difference in the #{klass}#inspect output.\n",
                  "You should look at the implementation of #== on ",
                  "#{klass} or its members.\n",
                  expect,
                 ].join
      end
    end
  end

  result
end</pre> </div> <p>Returns a diff between <code>exp</code> and <code>act</code>. If there is no known diff command or if it doesn’t make sense to diff the output (single line, short output), then it simply returns a basic comparison between the two.</p> <p>See <code>things_to_diff</code> for more info.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-exception_details"> <span class="method-name">exception_details</span><span class="method-args">(e, msg)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="exception_details-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 607
def exception_details e, msg
  [
   "#{msg}",
   "Class: &lt;#{e.class}&gt;",
   "Message: &lt;#{e.message.inspect}&gt;",
   "---Backtrace---",
   "#{Minitest.filter_backtrace(e.backtrace).join("\n")}",
   "---------------",
  ].join "\n"
end</pre> </div> <p>Returns details for exception <code>e</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fail_after"> <span class="method-name">fail_after</span><span class="method-args">(y,m,d,msg)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="fail_after-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 623
def fail_after y,m,d,msg
  flunk msg if Time.now &gt; Time.local(y, m, d)
end</pre> </div> <p>Fails after a given date (in the local time zone). This allows you to put time-bombs in your tests if you need to keep something around until a later date lest you forget about it.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-flunk"> <span class="method-name">flunk</span><span class="method-args">(msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="flunk-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 630
def flunk msg = nil
  msg ||= "Epic Fail!"
  assert false, msg
end</pre> </div> <p>Fails with <code>msg</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-message"> <span class="method-name">message</span><span class="method-args">(msg = nil, ending = nil, &amp;default)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="message-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 638
def message msg = nil, ending = nil, &amp;default
  proc {
    msg = msg.call.chomp(".") if Proc === msg
    custom_message = "#{msg}.\n" unless msg.nil? or msg.to_s.empty?
    "#{custom_message}#{default.call}#{ending || "."}"
  }
end</pre> </div> <p>Returns a proc that will output <code>msg</code> along with the default message.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mu_pp"> <span class="method-name">mu_pp</span><span class="method-args">(obj)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mu_pp-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 129
def mu_pp obj
  s = obj.inspect

  if defined? Encoding then
    s = s.encode Encoding.default_external

    if String === obj &amp;&amp; (obj.encoding != Encoding.default_external ||
                          !obj.valid_encoding?) then
      enc = "# encoding: #{obj.encoding}"
      val = "#    valid: #{obj.valid_encoding?}"
      s = "#{enc}\n#{val}\n#{s}"
    end
  end

  s
end</pre> </div> <p>This returns a human-readable version of <code>obj</code>. By default inspect is called. You can override this to use pretty_inspect if you want.</p> <p>See <a href="test.html#method-c-make_my_diffs_pretty-21"><code>Minitest::Test.make_my_diffs_pretty!</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mu_pp_for_diff"> <span class="method-name">mu_pp_for_diff</span><span class="method-args">(obj)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mu_pp_for_diff-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 152
def mu_pp_for_diff obj
  str = mu_pp obj

  # both '\n' &amp; '\\n' (_after_ mu_pp (aka inspect))
  single = !!str.match(/(?&lt;!\\|^)\\n/)
  double = !!str.match(/(?&lt;=\\|^)\\n/)

  process =
    if single ^ double then
      if single then
        lambda { |s| s == "\\n"   ? "\n"    : s } # unescape
      else
        lambda { |s| s == "\\\\n" ? "\\n\n" : s } # unescape a bit, add nls
      end
    else
      :itself                                     # leave it alone
    end

  str.
    gsub(/\\?\\n/, &amp;process).
    gsub(/:0x[a-fA-F0-9]{4,}/m, ":0xXXXXXX") # anonymize hex values
end</pre> </div> <p>This returns a diff-able more human-readable version of <code>obj</code>. This differs from the regular <a href="assertions.html#method-i-mu_pp"><code>mu_pp</code></a> because it expands escaped newlines and makes hex-values (like object_ids) generic. This uses <a href="assertions.html#method-i-mu_pp"><code>mu_pp</code></a> to do the first pass and then cleans it up.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pass"> <span class="method-name">pass</span><span class="method-args">(_msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pass-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 649
def pass _msg = nil
  assert true
end</pre> </div> <p>used for counting assertions</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute"> <span class="method-name">refute</span><span class="method-args">(test, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 656
def refute test, msg = nil
  msg ||= message { "Expected #{mu_pp(test)} to not be truthy" }
  assert !test, msg
end</pre> </div> <p>Fails if <code>test</code> is truthy.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_empty"> <span class="method-name">refute_empty</span><span class="method-args">(obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_empty-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 664
def refute_empty obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to not be empty" }
  assert_respond_to obj, :empty?
  refute obj.empty?, msg
end</pre> </div> <p>Fails if <code>obj</code> is empty.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_equal"> <span class="method-name">refute_equal</span><span class="method-args">(exp, act, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_equal-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 675
def refute_equal exp, act, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(act)} to not be equal to #{mu_pp(exp)}"
  }
  refute exp == act, msg
end</pre> </div> <p>Fails if <code>exp == act</code>.</p> <p>For floats use refute_in_delta.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_in_delta"> <span class="method-name">refute_in_delta</span><span class="method-args">(exp, act, delta = 0.001, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_in_delta-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 687
def refute_in_delta exp, act, delta = 0.001, msg = nil
  n = (exp - act).abs
  msg = message(msg) {
    "Expected |#{exp} - #{act}| (#{n}) to not be &lt;= #{delta}"
  }
  refute delta &gt;= n, msg
end</pre> </div> <p>For comparing Floats. Fails if <code>exp</code> is within <code>delta</code> of <code>act</code>.</p> <pre class="ruby" data-language="ruby">refute_in_delta Math::PI, (22.0 / 7.0)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_in_epsilon"> <span class="method-name">refute_in_epsilon</span><span class="method-args">(a, b, epsilon = 0.001, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_in_epsilon-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 699
def refute_in_epsilon a, b, epsilon = 0.001, msg = nil
  refute_in_delta a, b, a * epsilon, msg
end</pre> </div> <p>For comparing Floats. Fails if <code>exp</code> and <code>act</code> have a relative error less than <code>epsilon</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_includes"> <span class="method-name">refute_includes</span><span class="method-args">(collection, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_includes-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 706
def refute_includes collection, obj, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(collection)} to not include #{mu_pp(obj)}"
  }
  assert_respond_to collection, :include?
  refute collection.include?(obj), msg
end</pre> </div> <p>Fails if <code>collection</code> includes <code>obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_instance_of"> <span class="method-name">refute_instance_of</span><span class="method-args">(cls, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_instance_of-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 717
def refute_instance_of cls, obj, msg = nil
  msg = message(msg) {
    "Expected #{mu_pp(obj)} to not be an instance of #{cls}"
  }
  refute obj.instance_of?(cls), msg
end</pre> </div> <p>Fails if <code>obj</code> is an instance of <code>cls</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_kind_of"> <span class="method-name">refute_kind_of</span><span class="method-args">(cls, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_kind_of-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 727
def refute_kind_of cls, obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to not be a kind of #{cls}" }
  refute obj.kind_of?(cls), msg
end</pre> </div> <p>Fails if <code>obj</code> is a kind of <code>cls</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_match"> <span class="method-name">refute_match</span><span class="method-args">(matcher, obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_match-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 735
def refute_match matcher, obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp matcher} to not match #{mu_pp obj}" }
  assert_respond_to matcher, :"=~"
  matcher = Regexp.new Regexp.escape matcher if String === matcher
  refute matcher =~ obj, msg
end</pre> </div> <p>Fails if <code>matcher</code> <code>=~</code> <code>obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_nil"> <span class="method-name">refute_nil</span><span class="method-args">(obj, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_nil-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 745
def refute_nil obj, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to not be nil" }
  refute obj.nil?, msg
end</pre> </div> <p>Fails if <code>obj</code> is nil.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_operator"> <span class="method-name">refute_operator</span><span class="method-args">(o1, op, o2 = UNDEFINED, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_operator-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 780
def refute_operator o1, op, o2 = UNDEFINED, msg = nil
  return refute_predicate o1, op, msg if UNDEFINED == o2
  msg = message(msg) { "Expected #{mu_pp(o1)} to not be #{op} #{mu_pp(o2)}" }
  refute o1.__send__(op, o2), msg
end</pre> </div> <p>Fails if <code>o1</code> is not <code>op</code> <code>o2</code>. Eg:</p> <pre class="ruby" data-language="ruby">refute_operator 1, :&gt;, 2 #=&gt; pass
refute_operator 1, :&lt;, 2 #=&gt; fail
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_path_exists"> <span class="method-name">refute_path_exists</span><span class="method-args">(path, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_path_exists-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 789
def refute_path_exists path, msg = nil
  msg = message(msg) { "Expected path '#{path}' to not exist" }
  refute File.exist?(path), msg
end</pre> </div> <p>Fails if <code>path</code> exists.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_pattern"> <span class="method-name">refute_pattern</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_pattern-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 762
def refute_pattern
  raise NotImplementedError, "only available in Ruby 3.0+" unless RUBY_VERSION &gt;= "3.0"
  flunk "refute_pattern requires a block to capture errors." unless block_given?

  begin
    yield
    flunk("NoMatchingPatternError expected, but nothing was raised.")
  rescue NoMatchingPatternError
    pass
  end
end</pre> </div> <p>For testing with pattern matching (only supported with Ruby 3.0 and later)</p> <pre class="ruby" data-language="ruby"># pass
refute_pattern { [1,2,3] =&gt; [String] }

# fail "NoMatchingPatternError expected, but nothing was raised."
refute_pattern { [1,2,3] =&gt; [Integer, Integer, Integer] }
</pre> <p>This assertion expects a NoMatchingPatternError exception, and will fail if none is raised. Any other exceptions will be raised as normal and generate a test error.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_predicate"> <span class="method-name">refute_predicate</span><span class="method-args">(o1, op, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_predicate-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 803
def refute_predicate o1, op, msg = nil
  msg = message(msg) { "Expected #{mu_pp(o1)} to not be #{op}" }
  refute o1.__send__(op), msg
end</pre> </div> <p>For testing with predicates.</p> <pre class="ruby" data-language="ruby">refute_predicate str, :empty?
</pre> <p>This is really meant for specs and is front-ended by <a href="assertions.html#method-i-refute_operator"><code>refute_operator</code></a>:</p> <pre class="ruby" data-language="ruby">str.wont_be :empty?
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_respond_to"> <span class="method-name">refute_respond_to</span><span class="method-args">(obj, meth, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_respond_to-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 811
def refute_respond_to obj, meth, msg = nil
  msg = message(msg) { "Expected #{mu_pp(obj)} to not respond to #{meth}" }

  refute obj.respond_to?(meth), msg
end</pre> </div> <p>Fails if <code>obj</code> responds to the message <code>meth</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-refute_same"> <span class="method-name">refute_same</span><span class="method-args">(exp, act, msg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="refute_same-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 820
def refute_same exp, act, msg = nil
  msg = message(msg) {
    data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]
    "Expected %s (oid=%d) to not be the same as %s (oid=%d)" % data
  }
  refute exp.equal?(act), msg
end</pre> </div> <p>Fails if <code>exp</code> is the same (by object identity) as <code>act</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-skip"> <span class="method-name">skip</span><span class="method-args">(msg = nil, bt = caller)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="skip-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 833
def skip msg = nil, bt = caller
  msg ||= "Skipped, no message given"
  @skip = true
  raise Minitest::Skip, msg, bt
end</pre> </div> <p>Skips the current run. If run in verbose-mode, the skipped run gets listed at the end of the run but doesn’t cause a failure exit code.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-skip_until"> <span class="method-name">skip_until</span><span class="method-args">(y,m,d,msg)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="skip_until-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 845
def skip_until y,m,d,msg
  skip msg if Time.now &lt; Time.local(y, m, d)
  where = caller.first.rpartition(':in').reject(&amp;:empty?).first
  warn "Stale skip_until %p at %s" % [msg, where]
end</pre> </div> <p>Skips the current run until a given date (in the local time zone). This allows you to put some fixes on hold until a later date, but still holds you accountable and prevents you from forgetting it.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-skipped-3F"> <span class="method-name">skipped?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="skipped-3F-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 854
def skipped?
  defined?(@skip) and @skip
end</pre> </div> <p>Was this testcase skipped? Meant for teardown.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-things_to_diff"> <span class="method-name">things_to_diff</span><span class="method-args">(exp, act)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="things_to_diff-source"> <pre class="ruby" data-language="ruby"># File lib/minitest/assertions.rb, line 104
def things_to_diff exp, act
  expect = mu_pp_for_diff exp
  butwas = mu_pp_for_diff act

  e1, e2 = expect.include?("\n"), expect.include?("\\n")
  b1, b2 = butwas.include?("\n"), butwas.include?("\\n")

  need_to_diff =
    (e1 ^ e2                  ||
     b1 ^ b2                  ||
     expect.size &gt; 30         ||
     butwas.size &gt; 30         ||
     expect == butwas)        &amp;&amp;
    Minitest::Assertions.diff

  need_to_diff &amp;&amp; [expect, butwas]
end</pre> </div> <p>Returns things to diff [expect, butwas], or [nil, nil] if nothing to diff.</p> <p>Criterion:</p> <ol>
<li> <p>Strings include newlines or escaped newlines, but not both.</p> </li>
<li> <p>or: String lengths are &gt; 30 characters.</p> </li>
<li> <p>or: Strings are equal to each other (but maybe different encodings?).</p> </li>
<li> <p>and: we found a diff executable.</p> </li>
</ol>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Ryan Davis, seattle.rb<br>Licensed under the MIT License.<br>
    <a href="https://docs.seattlerb.org/minitest/Minitest/Assertions.html" class="_attribution-link">https://docs.seattlerb.org/minitest/Minitest/Assertions.html</a>
  </p>
</div>
