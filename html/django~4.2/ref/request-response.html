<h1 id="request-and-response-objects">Request and response objects</h1>  <h2 id="quick-overview">Quick overview</h2> <p id="s-module-django.http">Django uses request and response objects to pass state through the system.</p> <p>When a page is requested, Django creates an <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object that contains metadata about the request. Then Django loads the appropriate view, passing the <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> as the first argument to the view function. Each view is responsible for returning an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object.</p> <p>This document explains the APIs for <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> and <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> objects, which are defined in the <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code>django.http</code></a> module.</p>   <h2 id="httprequest-objects">
<code>HttpRequest</code> objects</h2> <dl class="py class" id="s-httprequest-objects"> <dt class="sig sig-object py" id="django.http.HttpRequest">
<code>class HttpRequest</code> </dt> 
</dl>  <h3 id="httprequest-attributes">Attributes</h3> <p id="s-attributes">All attributes should be considered read-only, unless stated otherwise.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.scheme">
<code>HttpRequest.scheme</code> </dt> <dd>
<p>A string representing the scheme of the request (<code>http</code> or <code>https</code> usually).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.body">
<code>HttpRequest.body</code> </dt> <dd>
<p>The raw HTTP request body as a bytestring. This is useful for processing data in different ways than conventional HTML forms: binary images, XML payload etc. For processing conventional form data, use <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code>HttpRequest.POST</code></a>.</p> <p>You can also read from an <code>HttpRequest</code> using a file-like interface with <a class="reference internal" href="#django.http.HttpRequest.read" title="django.http.HttpRequest.read"><code>HttpRequest.read()</code></a> or <a class="reference internal" href="#django.http.HttpRequest.readline" title="django.http.HttpRequest.readline"><code>HttpRequest.readline()</code></a>. Accessing the <code>body</code> attribute <em>after</em> reading the request with either of these I/O stream methods will produce a <code>RawPostDataException</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.path">
<code>HttpRequest.path</code> </dt> <dd>
<p>A string representing the full path to the requested page, not including the scheme, domain, or query string.</p> <p>Example: <code>"/music/bands/the_beatles/"</code></p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.path_info">
<code>HttpRequest.path_info</code> </dt> <dd>
<p>Under some web server configurations, the portion of the URL after the host name is split up into a script prefix portion and a path info portion. The <code>path_info</code> attribute always contains the path info portion of the path, no matter what web server is being used. Using this instead of <a class="reference internal" href="#django.http.HttpRequest.path" title="django.http.HttpRequest.path"><code>path</code></a> can make your code easier to move between test and deployment servers.</p> <p>For example, if the <code>WSGIScriptAlias</code> for your application is set to <code>"/minfo"</code>, then <code>path</code> might be <code>"/minfo/music/bands/the_beatles/"</code> and <code>path_info</code> would be <code>"/music/bands/the_beatles/"</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.method">
<code>HttpRequest.method</code> </dt> <dd>
<p>A string representing the HTTP method used in the request. This is guaranteed to be uppercase. For example:</p> <pre data-language="python">if request.method == "GET":
    do_something()
elif request.method == "POST":
    do_something_else()
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.encoding">
<code>HttpRequest.encoding</code> </dt> <dd>
<p>A string representing the current encoding used to decode form submission data (or <code>None</code>, which means the <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> setting is used). You can write to this attribute to change the encoding used when accessing the form data. Any subsequent attribute accesses (such as reading from <a class="reference internal" href="#django.http.HttpRequest.GET" title="django.http.HttpRequest.GET"><code>GET</code></a> or <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code>POST</code></a>) will use the new <code>encoding</code> value. Useful if you know the form data is not in the <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> encoding.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.content_type">
<code>HttpRequest.content_type</code> </dt> <dd>
<p>A string representing the MIME type of the request, parsed from the <code>CONTENT_TYPE</code> header.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.content_params">
<code>HttpRequest.content_params</code> </dt> <dd>
<p>A dictionary of key/value parameters included in the <code>CONTENT_TYPE</code> header.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.GET">
<code>HttpRequest.GET</code> </dt> <dd>
<p>A dictionary-like object containing all given HTTP GET parameters. See the <a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.POST">
<code>HttpRequest.POST</code> </dt> <dd>
<p>A dictionary-like object containing all given HTTP POST parameters, providing that the request contains form data. See the <a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code>QueryDict</code></a> documentation below. If you need to access raw or non-form data posted in the request, access this through the <a class="reference internal" href="#django.http.HttpRequest.body" title="django.http.HttpRequest.body"><code>HttpRequest.body</code></a> attribute instead.</p> <p>It’s possible that a request can come in via POST with an empty <code>POST</code> dictionary – if, say, a form is requested via the POST HTTP method but does not include form data. Therefore, you shouldn’t use <code>if request.POST</code> to check for use of the POST method; instead, use <code>if request.method ==
"POST"</code> (see <a class="reference internal" href="#django.http.HttpRequest.method" title="django.http.HttpRequest.method"><code>HttpRequest.method</code></a>).</p> <p><code>POST</code> does <em>not</em> include file-upload information. See <a class="reference internal" href="#django.http.HttpRequest.FILES" title="django.http.HttpRequest.FILES"><code>FILES</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.COOKIES">
<code>HttpRequest.COOKIES</code> </dt> <dd>
<p>A dictionary containing all cookies. Keys and values are strings.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.FILES">
<code>HttpRequest.FILES</code> </dt> <dd>
<p>A dictionary-like object containing all uploaded files. Each key in <code>FILES</code> is the <code>name</code> from the <code>&lt;input type="file" name=""&gt;</code>. Each value in <code>FILES</code> is an <a class="reference internal" href="files/uploads.html#django.core.files.uploadedfile.UploadedFile" title="django.core.files.uploadedfile.UploadedFile"><code>UploadedFile</code></a>.</p> <p>See <a class="reference internal" href="../topics/files.html"><span class="doc">Managing files</span></a> for more information.</p> <p><code>FILES</code> will only contain data if the request method was POST and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype="multipart/form-data"</code>. Otherwise, <code>FILES</code> will be a blank dictionary-like object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.META">
<code>HttpRequest.META</code> </dt> <dd>
<p>A dictionary containing all available HTTP headers. Available headers depend on the client and server, but here are some examples:</p> <ul class="simple"> <li>
<code>CONTENT_LENGTH</code> – The length of the request body (as a string).</li> <li>
<code>CONTENT_TYPE</code> – The MIME type of the request body.</li> <li>
<code>HTTP_ACCEPT</code> – Acceptable content types for the response.</li> <li>
<code>HTTP_ACCEPT_ENCODING</code> – Acceptable encodings for the response.</li> <li>
<code>HTTP_ACCEPT_LANGUAGE</code> – Acceptable languages for the response.</li> <li>
<code>HTTP_HOST</code> – The HTTP Host header sent by the client.</li> <li>
<code>HTTP_REFERER</code> – The referring page, if any.</li> <li>
<code>HTTP_USER_AGENT</code> – The client’s user-agent string.</li> <li>
<code>QUERY_STRING</code> – The query string, as a single (unparsed) string.</li> <li>
<code>REMOTE_ADDR</code> – The IP address of the client.</li> <li>
<code>REMOTE_HOST</code> – The hostname of the client.</li> <li>
<code>REMOTE_USER</code> – The user authenticated by the web server, if any.</li> <li>
<code>REQUEST_METHOD</code> – A string such as <code>"GET"</code> or <code>"POST"</code>.</li> <li>
<code>SERVER_NAME</code> – The hostname of the server.</li> <li>
<code>SERVER_PORT</code> – The port of the server (as a string).</li> </ul> <p>With the exception of <code>CONTENT_LENGTH</code> and <code>CONTENT_TYPE</code>, as given above, any HTTP headers in the request are converted to <code>META</code> keys by converting all characters to uppercase, replacing any hyphens with underscores and adding an <code>HTTP_</code> prefix to the name. So, for example, a header called <code>X-Bender</code> would be mapped to the <code>META</code> key <code>HTTP_X_BENDER</code>.</p> <p>Note that <a class="reference internal" href="django-admin.html#django-admin-runserver"><code>runserver</code></a> strips all headers with underscores in the name, so you won’t see them in <code>META</code>. This prevents header-spoofing based on ambiguity between underscores and dashes both being normalizing to underscores in WSGI environment variables. It matches the behavior of web servers like Nginx and Apache 2.4+.</p> <p><a class="reference internal" href="#django.http.HttpRequest.headers" title="django.http.HttpRequest.headers"><code>HttpRequest.headers</code></a> is a simpler way to access all HTTP-prefixed headers, plus <code>CONTENT_LENGTH</code> and <code>CONTENT_TYPE</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.headers">
<code>HttpRequest.headers</code> </dt> <dd>
<p>A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus <code>Content-Length</code> and <code>Content-Type</code>) from the request.</p> <p>The name of each header is stylized with title-casing (e.g. <code>User-Agent</code>) when it’s displayed. You can access headers case-insensitively:</p> <pre data-language="pycon">&gt;&gt;&gt; request.headers
{'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6', ...}

&gt;&gt;&gt; "User-Agent" in request.headers
True
&gt;&gt;&gt; "user-agent" in request.headers
True

&gt;&gt;&gt; request.headers["User-Agent"]
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)
&gt;&gt;&gt; request.headers["user-agent"]
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)

&gt;&gt;&gt; request.headers.get("User-Agent")
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)
&gt;&gt;&gt; request.headers.get("user-agent")
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)
</pre> <p>For use in, for example, Django templates, headers can also be looked up using underscores in place of hyphens:</p> <pre data-language="markup">{{ request.headers.user_agent }}
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.resolver_match">
<code>HttpRequest.resolver_match</code> </dt> <dd>
<p>An instance of <a class="reference internal" href="urlresolvers.html#django.urls.ResolverMatch" title="django.urls.ResolverMatch"><code>ResolverMatch</code></a> representing the resolved URL. This attribute is only set after URL resolving took place, which means it’s available in all views but not in middleware which are executed before URL resolving takes place (you can use it in <a class="reference internal" href="../topics/http/middleware.html#process_view" title="process_view"><code>process_view()</code></a> though).</p> </dd>
</dl>   <h3 id="attributes-set-by-application-code">Attributes set by application code</h3> <p id="s-attributes-set-by-application-code">Django doesn’t set these attributes itself but makes use of them if set by your application.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.current_app">
<code>HttpRequest.current_app</code> </dt> <dd>
<p>The <a class="reference internal" href="templates/builtins.html#std-templatetag-url"><code>url</code></a> template tag will use its value as the <code>current_app</code> argument to <a class="reference internal" href="urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code>reverse()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.urlconf">
<code>HttpRequest.urlconf</code> </dt> <dd>
<p>This will be used as the root URLconf for the current request, overriding the <a class="reference internal" href="settings.html#std-setting-ROOT_URLCONF"><code>ROOT_URLCONF</code></a> setting. See <a class="reference internal" href="../topics/http/urls.html#how-django-processes-a-request"><span class="std std-ref">How Django processes a request</span></a> for details.</p> <p><code>urlconf</code> can be set to <code>None</code> to revert any changes made by previous middleware and return to using the <a class="reference internal" href="settings.html#std-setting-ROOT_URLCONF"><code>ROOT_URLCONF</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.exception_reporter_filter">
<code>HttpRequest.exception_reporter_filter</code> </dt> <dd>
<p>This will be used instead of <a class="reference internal" href="settings.html#std-setting-DEFAULT_EXCEPTION_REPORTER_FILTER"><code>DEFAULT_EXCEPTION_REPORTER_FILTER</code></a> for the current request. See <a class="reference internal" href="../howto/error-reporting.html#custom-error-reports"><span class="std std-ref">Custom error reports</span></a> for details.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.exception_reporter_class">
<code>HttpRequest.exception_reporter_class</code> </dt> <dd>
<p>This will be used instead of <a class="reference internal" href="settings.html#std-setting-DEFAULT_EXCEPTION_REPORTER"><code>DEFAULT_EXCEPTION_REPORTER</code></a> for the current request. See <a class="reference internal" href="../howto/error-reporting.html#custom-error-reports"><span class="std std-ref">Custom error reports</span></a> for details.</p> </dd>
</dl>   <h3 id="attributes-set-by-middleware">Attributes set by middleware</h3> <p id="s-attributes-set-by-middleware">Some of the middleware included in Django’s contrib apps set attributes on the request. If you don’t see the attribute on a request, be sure the appropriate middleware class is listed in <a class="reference internal" href="settings.html#std-setting-MIDDLEWARE"><code>MIDDLEWARE</code></a>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.session">
<code>HttpRequest.session</code> </dt> <dd>
<p>From the <a class="reference internal" href="middleware.html#django.contrib.sessions.middleware.SessionMiddleware" title="django.contrib.sessions.middleware.SessionMiddleware"><code>SessionMiddleware</code></a>: A readable and writable, dictionary-like object that represents the current session.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.site">
<code>HttpRequest.site</code> </dt> <dd>
<p>From the <a class="reference internal" href="middleware.html#django.contrib.sites.middleware.CurrentSiteMiddleware" title="django.contrib.sites.middleware.CurrentSiteMiddleware"><code>CurrentSiteMiddleware</code></a>: An instance of <a class="reference internal" href="contrib/sites.html#django.contrib.sites.models.Site" title="django.contrib.sites.models.Site"><code>Site</code></a> or <a class="reference internal" href="contrib/sites.html#django.contrib.sites.requests.RequestSite" title="django.contrib.sites.requests.RequestSite"><code>RequestSite</code></a> as returned by <a class="reference internal" href="contrib/sites.html#django.contrib.sites.shortcuts.get_current_site" title="django.contrib.sites.shortcuts.get_current_site"><code>get_current_site()</code></a> representing the current site.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpRequest.user">
<code>HttpRequest.user</code> </dt> <dd>
<p>From the <a class="reference internal" href="middleware.html#django.contrib.auth.middleware.AuthenticationMiddleware" title="django.contrib.auth.middleware.AuthenticationMiddleware"><code>AuthenticationMiddleware</code></a>: An instance of <a class="reference internal" href="settings.html#std-setting-AUTH_USER_MODEL"><code>AUTH_USER_MODEL</code></a> representing the currently logged-in user. If the user isn’t currently logged in, <code>user</code> will be set to an instance of <a class="reference internal" href="contrib/auth.html#django.contrib.auth.models.AnonymousUser" title="django.contrib.auth.models.AnonymousUser"><code>AnonymousUser</code></a>. You can tell them apart with <a class="reference internal" href="contrib/auth.html#django.contrib.auth.models.User.is_authenticated" title="django.contrib.auth.models.User.is_authenticated"><code>is_authenticated</code></a>, like so:</p> <pre data-language="python">if request.user.is_authenticated:
    ...  # Do something for logged-in users.
else:
    ...  # Do something for anonymous users.
</pre> </dd>
</dl>   <h3 id="methods">Methods</h3> <dl class="py method" id="s-methods"> <dt class="sig sig-object py" id="django.http.HttpRequest.get_host">
<code>HttpRequest.get_host()</code> </dt> <dd>
<p>Returns the originating host of the request using information from the <code>HTTP_X_FORWARDED_HOST</code> (if <a class="reference internal" href="settings.html#std-setting-USE_X_FORWARDED_HOST"><code>USE_X_FORWARDED_HOST</code></a> is enabled) and <code>HTTP_HOST</code> headers, in that order. If they don’t provide a value, the method uses a combination of <code>SERVER_NAME</code> and <code>SERVER_PORT</code> as detailed in <a class="pep reference external" href="https://peps.python.org/pep-3333/" id="index-0"><strong>PEP 3333</strong></a>.</p> <p>Example: <code>"127.0.0.1:8000"</code></p> <p>Raises <code>django.core.exceptions.DisallowedHost</code> if the host is not in <a class="reference internal" href="settings.html#std-setting-ALLOWED_HOSTS"><code>ALLOWED_HOSTS</code></a> or the domain name is invalid according to <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1034.html" id="index-1"><strong>RFC 1034</strong></a>/<a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1035.html" id="index-2"><strong>1035</strong></a>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>The <a class="reference internal" href="#django.http.HttpRequest.get_host" title="django.http.HttpRequest.get_host"><code>get_host()</code></a> method fails when the host is behind multiple proxies. One solution is to use middleware to rewrite the proxy headers, as in the following example:</p> <pre data-language="python">class MultipleProxyMiddleware:
    FORWARDED_FOR_FIELDS = [
        "HTTP_X_FORWARDED_FOR",
        "HTTP_X_FORWARDED_HOST",
        "HTTP_X_FORWARDED_SERVER",
    ]

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        """
        Rewrites the proxy headers so that only the most
        recent proxy is used.
        """
        for field in self.FORWARDED_FOR_FIELDS:
            if field in request.META:
                if "," in request.META[field]:
                    parts = request.META[field].split(",")
                    request.META[field] = parts[-1].strip()
        return self.get_response(request)
</pre> <p class="last">This middleware should be positioned before any other middleware that relies on the value of <a class="reference internal" href="#django.http.HttpRequest.get_host" title="django.http.HttpRequest.get_host"><code>get_host()</code></a> – for instance, <a class="reference internal" href="middleware.html#django.middleware.common.CommonMiddleware" title="django.middleware.common.CommonMiddleware"><code>CommonMiddleware</code></a> or <a class="reference internal" href="middleware.html#django.middleware.csrf.CsrfViewMiddleware" title="django.middleware.csrf.CsrfViewMiddleware"><code>CsrfViewMiddleware</code></a>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.get_port">
<code>HttpRequest.get_port()</code> </dt> <dd>
<p>Returns the originating port of the request using information from the <code>HTTP_X_FORWARDED_PORT</code> (if <a class="reference internal" href="settings.html#std-setting-USE_X_FORWARDED_PORT"><code>USE_X_FORWARDED_PORT</code></a> is enabled) and <code>SERVER_PORT</code> <code>META</code> variables, in that order.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.get_full_path">
<code>HttpRequest.get_full_path()</code> </dt> <dd>
<p>Returns the <code>path</code>, plus an appended query string, if applicable.</p> <p>Example: <code>"/music/bands/the_beatles/?print=true"</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.get_full_path_info">
<code>HttpRequest.get_full_path_info()</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.HttpRequest.get_full_path" title="django.http.HttpRequest.get_full_path"><code>get_full_path()</code></a>, but uses <a class="reference internal" href="#django.http.HttpRequest.path_info" title="django.http.HttpRequest.path_info"><code>path_info</code></a> instead of <a class="reference internal" href="#django.http.HttpRequest.path" title="django.http.HttpRequest.path"><code>path</code></a>.</p> <p>Example: <code>"/minfo/music/bands/the_beatles/?print=true"</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.build_absolute_uri">
<code>HttpRequest.build_absolute_uri(location=None)</code> </dt> <dd>
<p>Returns the absolute URI form of <code>location</code>. If no location is provided, the location will be set to <code>request.get_full_path()</code>.</p> <p>If the location is already an absolute URI, it will not be altered. Otherwise the absolute URI is built using the server variables available in this request. For example:</p> <pre data-language="python">&gt;&gt;&gt; request.build_absolute_uri()
'https://example.com/music/bands/the_beatles/?print=true'
&gt;&gt;&gt; request.build_absolute_uri('/bands/')
'https://example.com/bands/'
&gt;&gt;&gt; request.build_absolute_uri('https://example2.com/bands/')
'https://example2.com/bands/'
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Mixing HTTP and HTTPS on the same site is discouraged, therefore <a class="reference internal" href="#django.http.HttpRequest.build_absolute_uri" title="django.http.HttpRequest.build_absolute_uri"><code>build_absolute_uri()</code></a> will always generate an absolute URI with the same scheme the current request has. If you need to redirect users to HTTPS, it’s best to let your web server redirect all HTTP traffic to HTTPS.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.get_signed_cookie">
<code>HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)</code> </dt> <dd>
<p>Returns a cookie value for a signed cookie, or raises a <code>django.core.signing.BadSignature</code> exception if the signature is no longer valid. If you provide the <code>default</code> argument the exception will be suppressed and that default value will be returned instead.</p> <p>The optional <code>salt</code> argument can be used to provide extra protection against brute force attacks on your secret key. If supplied, the <code>max_age</code> argument will be checked against the signed timestamp attached to the cookie value to ensure the cookie is not older than <code>max_age</code> seconds.</p> <p>For example:</p> <pre data-language="pycon">&gt;&gt;&gt; request.get_signed_cookie("name")
'Tony'
&gt;&gt;&gt; request.get_signed_cookie("name", salt="name-salt")
'Tony' # assuming cookie was set using the same salt
&gt;&gt;&gt; request.get_signed_cookie("nonexistent-cookie")
KeyError: 'nonexistent-cookie'
&gt;&gt;&gt; request.get_signed_cookie("nonexistent-cookie", False)
False
&gt;&gt;&gt; request.get_signed_cookie("cookie-that-was-tampered-with")
BadSignature: ...
&gt;&gt;&gt; request.get_signed_cookie("name", max_age=60)
SignatureExpired: Signature age 1677.3839159 &gt; 60 seconds
&gt;&gt;&gt; request.get_signed_cookie("name", False, max_age=60)
False
</pre> <p>See <a class="reference internal" href="../topics/signing.html"><span class="doc">cryptographic signing</span></a> for more information.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.is_secure">
<code>HttpRequest.is_secure()</code> </dt> <dd>
<p>Returns <code>True</code> if the request is secure; that is, if it was made with HTTPS.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.accepts">
<code>HttpRequest.accepts(mime_type)</code> </dt> <dd>
<p>Returns <code>True</code> if the request <code>Accept</code> header matches the <code>mime_type</code> argument:</p> <pre data-language="pycon">&gt;&gt;&gt; request.accepts("text/html")
True
</pre> <p>Most browsers send <code>Accept: */*</code> by default, so this would return <code>True</code> for all content types. Setting an explicit <code>Accept</code> header in API requests can be useful for returning a different content type for those consumers only. See <a class="reference internal" href="../topics/class-based-views/generic-editing.html#content-negotiation-example"><span class="std std-ref">Content negotiation example</span></a> of using <code>accepts()</code> to return different content to API consumers.</p> <p>If a response varies depending on the content of the <code>Accept</code> header and you are using some form of caching like Django’s <a class="reference internal" href="middleware.html#module-django.middleware.cache" title="django.middleware.cache: Middleware for the site-wide cache."><code>cache middleware</code></a>, you should decorate the view with <a class="reference internal" href="../topics/http/decorators.html#django.views.decorators.vary.vary_on_headers" title="django.views.decorators.vary.vary_on_headers"><code>vary_on_headers('Accept')</code></a> so that the responses are properly cached.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.read">
<code>HttpRequest.read(size=None)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.readline">
<code>HttpRequest.readline()</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.readlines">
<code>HttpRequest.readlines()</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpRequest.__iter__">
<code>HttpRequest.__iter__()</code> </dt> <dd>
<p>Methods implementing a file-like interface for reading from an <code>HttpRequest</code> instance. This makes it possible to consume an incoming request in a streaming fashion. A common use-case would be to process a big XML payload with an iterative parser without constructing a whole XML tree in memory.</p> <p>Given this standard interface, an <code>HttpRequest</code> instance can be passed directly to an XML parser such as <a class="reference external" href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree" title="(in Python v3.11)"><code>ElementTree</code></a>:</p> <pre data-language="python">import xml.etree.ElementTree as ET

for element in ET.iterparse(request):
    process(element)
</pre> </dd>
</dl>    <h2 id="querydict-objects">
<code>QueryDict</code> objects</h2> <dl class="py class" id="s-querydict-objects"> <dt class="sig sig-object py" id="django.http.QueryDict">
<code>class QueryDict</code> </dt> 
</dl> <p>In an <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object, the <a class="reference internal" href="#django.http.HttpRequest.GET" title="django.http.HttpRequest.GET"><code>GET</code></a> and <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code>POST</code></a> attributes are instances of <code>django.http.QueryDict</code>, a dictionary-like class customized to deal with multiple values for the same key. This is necessary because some HTML form elements, notably <code>&lt;select multiple&gt;</code>, pass multiple values for the same key.</p> <p>The <code>QueryDict</code>s at <code>request.POST</code> and <code>request.GET</code> will be immutable when accessed in a normal request/response cycle. To get a mutable version you need to use <a class="reference internal" href="#django.http.QueryDict.copy" title="django.http.QueryDict.copy"><code>QueryDict.copy()</code></a>.</p>  <h3 id="id1">Methods</h3> <p id="s-id1"><a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code>QueryDict</code></a> implements all the standard dictionary methods because it’s a subclass of dictionary. Exceptions are outlined here:</p> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.__init__">
<code>QueryDict.__init__(query_string=None, mutable=False, encoding=None)</code> </dt> <dd>
<p>Instantiates a <code>QueryDict</code> object based on <code>query_string</code>.</p> <pre data-language="python">&gt;&gt;&gt; QueryDict('a=1&amp;a=2&amp;c=3')
&lt;QueryDict: {'a': ['1', '2'], 'c': ['3']}&gt;
</pre> <p>If <code>query_string</code> is not passed in, the resulting <code>QueryDict</code> will be empty (it will have no keys or values).</p> <p>Most <code>QueryDict</code>s you encounter, and in particular those at <code>request.POST</code> and <code>request.GET</code>, will be immutable. If you are instantiating one yourself, you can make it mutable by passing <code>mutable=True</code> to its <code>__init__()</code>.</p> <p>Strings for setting both keys and values will be converted from <code>encoding</code> to <code>str</code>. If <code>encoding</code> is not set, it defaults to <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.fromkeys">
<code>classmethod QueryDict.fromkeys(iterable, value='', mutable=False, encoding=None)</code> </dt> <dd>
<p>Creates a new <code>QueryDict</code> with keys from <code>iterable</code> and each value equal to <code>value</code>. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; QueryDict.fromkeys(["a", "a", "b"], value="val")
&lt;QueryDict: {'a': ['val', 'val'], 'b': ['val']}&gt;
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.__getitem__">
<code>QueryDict.__getitem__(key)</code> </dt> <dd>
<p>Returns the value for the given key. If the key has more than one value, it returns the last value. Raises <code>django.utils.datastructures.MultiValueDictKeyError</code> if the key does not exist. (This is a subclass of Python’s standard <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.11)"><code>KeyError</code></a>, so you can stick to catching <code>KeyError</code>.)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.__setitem__">
<code>QueryDict.__setitem__(key, value)</code> </dt> <dd>
<p>Sets the given key to <code>[value]</code> (a list whose single element is <code>value</code>). Note that this, as other dictionary functions that have side effects, can only be called on a mutable <code>QueryDict</code> (such as one that was created via <a class="reference internal" href="#django.http.QueryDict.copy" title="django.http.QueryDict.copy"><code>QueryDict.copy()</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.__contains__">
<code>QueryDict.__contains__(key)</code> </dt> <dd>
<p>Returns <code>True</code> if the given key is set. This lets you do, e.g., <code>if "foo"
in request.GET</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.get">
<code>QueryDict.get(key, default=None)</code> </dt> <dd>
<p>Uses the same logic as <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code>__getitem__()</code></a>, with a hook for returning a default value if the key doesn’t exist.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.setdefault">
<code>QueryDict.setdefault(key, default=None)</code> </dt> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" title="(in Python v3.11)"><code>dict.setdefault()</code></a>, except it uses <a class="reference internal" href="#django.http.QueryDict.__setitem__" title="django.http.QueryDict.__setitem__"><code>__setitem__()</code></a> internally.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.update">
<code>QueryDict.update(other_dict)</code> </dt> <dd>
<p>Takes either a <code>QueryDict</code> or a dictionary. Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.update" title="(in Python v3.11)"><code>dict.update()</code></a>, except it <em>appends</em> to the current dictionary items rather than replacing them. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1", mutable=True)
&gt;&gt;&gt; q.update({"a": "2"})
&gt;&gt;&gt; q.getlist("a")
['1', '2']
&gt;&gt;&gt; q["a"]  # returns the last
'2'
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.items">
<code>QueryDict.items()</code> </dt> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.items" title="(in Python v3.11)"><code>dict.items()</code></a>, except this uses the same last-value logic as <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code>__getitem__()</code></a> and returns an iterator object instead of a view object. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=2&amp;a=3")
&gt;&gt;&gt; list(q.items())
[('a', '3')]
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.values">
<code>QueryDict.values()</code> </dt> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.values" title="(in Python v3.11)"><code>dict.values()</code></a>, except this uses the same last-value logic as <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code>__getitem__()</code></a> and returns an iterator instead of a view object. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=2&amp;a=3")
&gt;&gt;&gt; list(q.values())
['3']
</pre> </dd>
</dl> <p>In addition, <code>QueryDict</code> has the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.copy">
<code>QueryDict.copy()</code> </dt> <dd>
<p>Returns a copy of the object using <a class="reference external" href="https://docs.python.org/3/library/copy.html#copy.deepcopy" title="(in Python v3.11)"><code>copy.deepcopy()</code></a>. This copy will be mutable even if the original was not.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.getlist">
<code>QueryDict.getlist(key, default=None)</code> </dt> <dd>
<p>Returns a list of the data with the requested key. Returns an empty list if the key doesn’t exist and <code>default</code> is <code>None</code>. It’s guaranteed to return a list unless the default value provided isn’t a list.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.setlist">
<code>QueryDict.setlist(key, list_)</code> </dt> <dd>
<p>Sets the given key to <code>list_</code> (unlike <a class="reference internal" href="#django.http.QueryDict.__setitem__" title="django.http.QueryDict.__setitem__"><code>__setitem__()</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.appendlist">
<code>QueryDict.appendlist(key, item)</code> </dt> <dd>
<p>Appends an item to the internal list associated with key.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.setlistdefault">
<code>QueryDict.setlistdefault(key, default_list=None)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.QueryDict.setdefault" title="django.http.QueryDict.setdefault"><code>setdefault()</code></a>, except it takes a list of values instead of a single value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.lists">
<code>QueryDict.lists()</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.QueryDict.items" title="django.http.QueryDict.items"><code>items()</code></a>, except it includes all values, as a list, for each member of the dictionary. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=2&amp;a=3")
&gt;&gt;&gt; q.lists()
[('a', ['1', '2', '3'])]
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.pop">
<code>QueryDict.pop(key)</code> </dt> <dd>
<p>Returns a list of values for the given key and removes them from the dictionary. Raises <code>KeyError</code> if the key does not exist. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=2&amp;a=3", mutable=True)
&gt;&gt;&gt; q.pop("a")
['1', '2', '3']
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.popitem">
<code>QueryDict.popitem()</code> </dt> <dd>
<p>Removes an arbitrary member of the dictionary (since there’s no concept of ordering), and returns a two value tuple containing the key and a list of all values for the key. Raises <code>KeyError</code> when called on an empty dictionary. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=2&amp;a=3", mutable=True)
&gt;&gt;&gt; q.popitem()
('a', ['1', '2', '3'])
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.dict">
<code>QueryDict.dict()</code> </dt> <dd>
<p>Returns a <code>dict</code> representation of <code>QueryDict</code>. For every (key, list) pair in <code>QueryDict</code>, <code>dict</code> will have (key, item), where item is one element of the list, using the same logic as <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code>QueryDict.__getitem__()</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=1&amp;a=3&amp;a=5")
&gt;&gt;&gt; q.dict()
{'a': '5'}
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.QueryDict.urlencode">
<code>QueryDict.urlencode(safe=None)</code> </dt> <dd>
<p>Returns a string of the data in query string format. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict("a=2&amp;b=3&amp;b=5")
&gt;&gt;&gt; q.urlencode()
'a=2&amp;b=3&amp;b=5'
</pre> <p>Use the <code>safe</code> parameter to pass characters which don’t require encoding. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = QueryDict(mutable=True)
&gt;&gt;&gt; q["next"] = "/a&amp;b/"
&gt;&gt;&gt; q.urlencode(safe="/")
'next=/a%26b/'
</pre> </dd>
</dl>    <h2 id="httpresponse-objects">
<code>HttpResponse</code> objects</h2> <dl class="py class" id="s-httpresponse-objects"> <dt class="sig sig-object py" id="django.http.HttpResponse">
<code>class HttpResponse</code> </dt> 
</dl> <p>In contrast to <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> objects, which are created automatically by Django, <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> objects are your responsibility. Each view you write is responsible for instantiating, populating, and returning an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>.</p> <p>The <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> class lives in the <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code>django.http</code></a> module.</p>  <h3 id="usage">Usage</h3>  <h4 id="passing-strings">Passing strings</h4> <p id="s-usage">Typical usage is to pass the contents of the page, as a string, bytestring, or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(in Python v3.11)"><code>memoryview</code></a>, to the <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> constructor:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.http import HttpResponse
&gt;&gt;&gt; response = HttpResponse("Here's the text of the web page.")
&gt;&gt;&gt; response = HttpResponse("Text only, please.", content_type="text/plain")
&gt;&gt;&gt; response = HttpResponse(b"Bytestrings are also accepted.")
&gt;&gt;&gt; response = HttpResponse(memoryview(b"Memoryview as well."))
</pre> <p>But if you want to add content incrementally, you can use <code>response</code> as a file-like object:</p> <pre data-language="pycon">&gt;&gt;&gt; response = HttpResponse()
&gt;&gt;&gt; response.write("&lt;p&gt;Here's the text of the web page.&lt;/p&gt;")
&gt;&gt;&gt; response.write("&lt;p&gt;Here's another paragraph.&lt;/p&gt;")
</pre>   <h4 id="passing-iterators">Passing iterators</h4> <p id="s-passing-iterators">Finally, you can pass <code>HttpResponse</code> an iterator rather than strings. <code>HttpResponse</code> will consume the iterator immediately, store its content as a string, and discard it. Objects with a <code>close()</code> method such as files and generators are immediately closed.</p> <p>If you need the response to be streamed from the iterator to the client, you must use the <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> class instead.</p>   <h4 id="id2">Setting header fields</h4> <p id="s-setting-header-fields">To set or remove a header field in your response, use <a class="reference internal" href="#django.http.HttpResponse.headers" title="django.http.HttpResponse.headers"><code>HttpResponse.headers</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; response = HttpResponse()
&gt;&gt;&gt; response.headers["Age"] = 120
&gt;&gt;&gt; del response.headers["Age"]
</pre> <p>You can also manipulate headers by treating your response like a dictionary:</p> <pre data-language="pycon">&gt;&gt;&gt; response = HttpResponse()
&gt;&gt;&gt; response["Age"] = 120
&gt;&gt;&gt; del response["Age"]
</pre> <p>This proxies to <code>HttpResponse.headers</code>, and is the original interface offered by <code>HttpResponse</code>.</p> <p>When using this interface, unlike a dictionary, <code>del</code> doesn’t raise <code>KeyError</code> if the header field doesn’t exist.</p> <p>You can also set headers on instantiation:</p> <pre data-language="pycon">&gt;&gt;&gt; response = HttpResponse(headers={"Age": 120})
</pre> <p>For setting the <code>Cache-Control</code> and <code>Vary</code> header fields, it is recommended to use the <a class="reference internal" href="utils.html#django.utils.cache.patch_cache_control" title="django.utils.cache.patch_cache_control"><code>patch_cache_control()</code></a> and <a class="reference internal" href="utils.html#django.utils.cache.patch_vary_headers" title="django.utils.cache.patch_vary_headers"><code>patch_vary_headers()</code></a> methods from <a class="reference internal" href="utils.html#module-django.utils.cache" title="django.utils.cache: Helper functions for controlling caching."><code>django.utils.cache</code></a>, since these fields can have multiple, comma-separated values. The “patch” methods ensure that other values, e.g. added by a middleware, are not removed.</p> <p>HTTP header fields cannot contain newlines. An attempt to set a header field containing a newline character (CR or LF) will raise <code>BadHeaderError</code></p>   <h4 id="telling-the-browser-to-treat-the-response-as-a-file-attachment">Telling the browser to treat the response as a file attachment</h4> <p id="s-telling-the-browser-to-treat-the-response-as-a-file-attachment">To tell the browser to treat the response as a file attachment, set the <code>Content-Type</code> and <code>Content-Disposition</code> headers. For example, this is how you might return a Microsoft Excel spreadsheet:</p> <pre data-language="pycon">&gt;&gt;&gt; response = HttpResponse(
...     my_data,
...     headers={
...         "Content-Type": "application/vnd.ms-excel",
...         "Content-Disposition": 'attachment; filename="foo.xls"',
...     },
... )
</pre> <p>There’s nothing Django-specific about the <code>Content-Disposition</code> header, but it’s easy to forget the syntax, so we’ve included it here.</p>    <h3 id="id3">Attributes</h3> <dl class="py attribute" id="s-id3"> <dt class="sig sig-object py" id="django.http.HttpResponse.content">
<code>HttpResponse.content</code> </dt> <dd>
<p>A bytestring representing the content, encoded from a string if necessary.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.headers">
<code>HttpResponse.headers</code> </dt> <dd>
<p>A case insensitive, dict-like object that provides an interface to all HTTP headers on the response. See <a class="reference internal" href="#setting-header-fields"><span class="std std-ref">Setting header fields</span></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.charset">
<code>HttpResponse.charset</code> </dt> <dd>
<p>A string denoting the charset in which the response will be encoded. If not given at <code>HttpResponse</code> instantiation time, it will be extracted from <code>content_type</code> and if that is unsuccessful, the <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> setting will be used.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.status_code">
<code>HttpResponse.status_code</code> </dt> <dd>
<p>The <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15" id="index-3"><strong>HTTP status code</strong></a> for the response.</p> <p>Unless <a class="reference internal" href="#django.http.HttpResponse.reason_phrase" title="django.http.HttpResponse.reason_phrase"><code>reason_phrase</code></a> is explicitly set, modifying the value of <code>status_code</code> outside the constructor will also modify the value of <code>reason_phrase</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.reason_phrase">
<code>HttpResponse.reason_phrase</code> </dt> <dd>
<p>The HTTP reason phrase for the response. It uses the <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15.1" id="index-4"><strong>HTTP standard’s</strong></a> default reason phrases.</p> <p>Unless explicitly set, <code>reason_phrase</code> is determined by the value of <a class="reference internal" href="#django.http.HttpResponse.status_code" title="django.http.HttpResponse.status_code"><code>status_code</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.streaming">
<code>HttpResponse.streaming</code> </dt> <dd>
<p>This is always <code>False</code>.</p> <p>This attribute exists so middleware can treat streaming responses differently from regular responses.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponse.closed">
<code>HttpResponse.closed</code> </dt> <dd>
<p><code>True</code> if the response has been closed.</p> </dd>
</dl>   <h3 id="id4">Methods</h3> <dl class="py method" id="s-id4"> <dt class="sig sig-object py" id="django.http.HttpResponse.__init__">
<code>HttpResponse.__init__(content=b'', content_type=None, status=200, reason=None, charset=None, headers=None)</code> </dt> <dd>
<p>Instantiates an <code>HttpResponse</code> object with the given page content, content type, and headers.</p> <p><code>content</code> is most commonly an iterator, bytestring, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(in Python v3.11)"><code>memoryview</code></a>, or string. Other types will be converted to a bytestring by encoding their string representation. Iterators should return strings or bytestrings and those will be joined together to form the content of the response.</p> <p><code>content_type</code> is the MIME type optionally completed by a character set encoding and is used to fill the HTTP <code>Content-Type</code> header. If not specified, it is formed by <code>'text/html'</code> and the <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> settings, by default: <code>"text/html; charset=utf-8"</code>.</p> <p><code>status</code> is the <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15" id="index-5"><strong>HTTP status code</strong></a> for the response. You can use Python’s <a class="reference external" href="https://docs.python.org/3/library/http.html#http.HTTPStatus" title="(in Python v3.11)"><code>http.HTTPStatus</code></a> for meaningful aliases, such as <code>HTTPStatus.NO_CONTENT</code>.</p> <p><code>reason</code> is the HTTP response phrase. If not provided, a default phrase will be used.</p> <p><code>charset</code> is the charset in which the response will be encoded. If not given it will be extracted from <code>content_type</code>, and if that is unsuccessful, the <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> setting will be used.</p> <p><code>headers</code> is a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><code>dict</code></a> of HTTP headers for the response.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.__setitem__">
<code>HttpResponse.__setitem__(header, value)</code> </dt> <dd>
<p>Sets the given header name to the given value. Both <code>header</code> and <code>value</code> should be strings.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.__delitem__">
<code>HttpResponse.__delitem__(header)</code> </dt> <dd>
<p>Deletes the header with the given name. Fails silently if the header doesn’t exist. Case-insensitive.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.__getitem__">
<code>HttpResponse.__getitem__(header)</code> </dt> <dd>
<p>Returns the value for the given header name. Case-insensitive.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.get">
<code>HttpResponse.get(header, alternate=None)</code> </dt> <dd>
<p>Returns the value for the given header, or an <code>alternate</code> if the header doesn’t exist.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.has_header">
<code>HttpResponse.has_header(header)</code> </dt> <dd>
<p>Returns <code>True</code> or <code>False</code> based on a case-insensitive check for a header with the given name.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.items">
<code>HttpResponse.items()</code> </dt> <dd>
<p>Acts like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.items" title="(in Python v3.11)"><code>dict.items()</code></a> for HTTP headers on the response.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.setdefault">
<code>HttpResponse.setdefault(header, value)</code> </dt> <dd>
<p>Sets a header unless it has already been set.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.set_cookie">
<code>HttpResponse.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)</code> </dt> <dd>
<p>Sets a cookie. The parameters are the same as in the <a class="reference external" href="https://docs.python.org/3/library/http.cookies.html#http.cookies.Morsel" title="(in Python v3.11)"><code>Morsel</code></a> cookie object in the Python standard library.</p> <ul> <li>
<p class="first"><code>max_age</code> should be a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.11)"><code>timedelta</code></a> object, an integer number of seconds, or <code>None</code> (default) if the cookie should last only as long as the client’s browser session. If <code>expires</code> is not specified, it will be calculated.</p> <div class="versionchanged"> <span class="title">Changed in Django 4.1:</span> <p>Support for <code>timedelta</code> objects was added.</p> </div> </li> <li>
<code>expires</code> should either be a string in the format <code>"Wdy, DD-Mon-YY HH:MM:SS GMT"</code> or a <code>datetime.datetime</code> object in UTC. If <code>expires</code> is a <code>datetime</code> object, the <code>max_age</code> will be calculated. </li> <li>Use <code>domain</code> if you want to set a cross-domain cookie. For example, <code>domain="example.com"</code> will set a cookie that is readable by the domains www.example.com, blog.example.com, etc. Otherwise, a cookie will only be readable by the domain that set it. </li> <li>Use <code>secure=True</code> if you want the cookie to be only sent to the server when a request is made with the <code>https</code> scheme. </li> <li>
<p class="first">Use <code>httponly=True</code> if you want to prevent client-side JavaScript from having access to the cookie.</p> <p><a class="reference external" href="https://owasp.org/www-community/HttpOnly">HttpOnly</a> is a flag included in a Set-Cookie HTTP response header. It’s part of the <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6265.html#section-4.1.2.6" id="index-6"><strong>RFC 6265</strong></a> standard for cookies and can be a useful way to mitigate the risk of a client-side script accessing the protected cookie data.</p> </li> <li>
<p class="first">Use <code>samesite='Strict'</code> or <code>samesite='Lax'</code> to tell the browser not to send this cookie when performing a cross-origin request. <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">SameSite</a> isn’t supported by all browsers, so it’s not a replacement for Django’s CSRF protection, but rather a defense in depth measure.</p> <p>Use <code>samesite='None'</code> (string) to explicitly state that this cookie is sent with all same-site and cross-site requests.</p> </li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6265.html#section-6.1" id="index-7"><strong>RFC 6265</strong></a> states that user agents should support cookies of at least 4096 bytes. For many browsers this is also the maximum size. Django will not raise an exception if there’s an attempt to store a cookie of more than 4096 bytes, but many browsers will not set the cookie correctly.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.set_signed_cookie">
<code>HttpResponse.set_signed_cookie(key, value, salt='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.HttpResponse.set_cookie" title="django.http.HttpResponse.set_cookie"><code>set_cookie()</code></a>, but <a class="reference internal" href="../topics/signing.html"><span class="doc">cryptographic signing</span></a> the cookie before setting it. Use in conjunction with <a class="reference internal" href="#django.http.HttpRequest.get_signed_cookie" title="django.http.HttpRequest.get_signed_cookie"><code>HttpRequest.get_signed_cookie()</code></a>. You can use the optional <code>salt</code> argument for added key strength, but you will need to remember to pass it to the corresponding <a class="reference internal" href="#django.http.HttpRequest.get_signed_cookie" title="django.http.HttpRequest.get_signed_cookie"><code>HttpRequest.get_signed_cookie()</code></a> call.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.delete_cookie">
<code>HttpResponse.delete_cookie(key, path='/', domain=None, samesite=None)</code> </dt> <dd>
<p>Deletes the cookie with the given key. Fails silently if the key doesn’t exist.</p> <p>Due to the way cookies work, <code>path</code> and <code>domain</code> should be the same values you used in <code>set_cookie()</code> – otherwise the cookie may not be deleted.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.close">
<code>HttpResponse.close()</code> </dt> <dd>
<p>This method is called at the end of the request directly by the WSGI server.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.write">
<code>HttpResponse.write(content)</code> </dt> <dd>
<p>This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a file-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.flush">
<code>HttpResponse.flush()</code> </dt> <dd>
<p>This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a file-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.tell">
<code>HttpResponse.tell()</code> </dt> <dd>
<p>This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a file-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.getvalue">
<code>HttpResponse.getvalue()</code> </dt> <dd>
<p>Returns the value of <a class="reference internal" href="#django.http.HttpResponse.content" title="django.http.HttpResponse.content"><code>HttpResponse.content</code></a>. This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a stream-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.readable">
<code>HttpResponse.readable()</code> </dt> <dd>
<p>Always <code>False</code>. This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a stream-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.seekable">
<code>HttpResponse.seekable()</code> </dt> <dd>
<p>Always <code>False</code>. This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a stream-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.writable">
<code>HttpResponse.writable()</code> </dt> <dd>
<p>Always <code>True</code>. This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a stream-like object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.http.HttpResponse.writelines">
<code>HttpResponse.writelines(lines)</code> </dt> <dd>
<p>Writes a list of lines to the response. Line separators are not added. This method makes an <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> instance a stream-like object.</p> </dd>
</dl>   <h3 id="ref-httpresponse-subclasses">
<code>HttpResponse</code> subclasses</h3> <p id="s-httpresponse-subclasses">Django includes a number of <code>HttpResponse</code> subclasses that handle different types of HTTP responses. Like <code>HttpResponse</code>, these subclasses live in <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code>django.http</code></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseRedirect">
<code>class HttpResponseRedirect</code> </dt> <dd>
<p>The first argument to the constructor is required – the path to redirect to. This can be a fully qualified URL (e.g. <code>'https://www.yahoo.com/search/'</code>), an absolute path with no domain (e.g. <code>'/search/'</code>), or even a relative path (e.g. <code>'search/'</code>). In that last case, the client browser will reconstruct the full URL itself according to the current path. See <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> for other optional constructor arguments. Note that this returns an HTTP status code 302.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.HttpResponseRedirect.url">
<code>url</code> </dt> <dd>
<p>This read-only attribute represents the URL the response will redirect to (equivalent to the <code>Location</code> response header).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponsePermanentRedirect">
<code>class HttpResponsePermanentRedirect</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.HttpResponseRedirect" title="django.http.HttpResponseRedirect"><code>HttpResponseRedirect</code></a>, but it returns a permanent redirect (HTTP status code 301) instead of a “found” redirect (status code 302).</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseNotModified">
<code>class HttpResponseNotModified</code> </dt> <dd>
<p>The constructor doesn’t take any arguments and no content should be added to this response. Use this to designate that a page hasn’t been modified since the user’s last request (status code 304).</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseBadRequest">
<code>class HttpResponseBadRequest</code> </dt> <dd>
<p>Acts just like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> but uses a 400 status code.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseNotFound">
<code>class HttpResponseNotFound</code> </dt> <dd>
<p>Acts just like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> but uses a 404 status code.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseForbidden">
<code>class HttpResponseForbidden</code> </dt> <dd>
<p>Acts just like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> but uses a 403 status code.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseNotAllowed">
<code>class HttpResponseNotAllowed</code> </dt> <dd>
<p>Like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>, but uses a 405 status code. The first argument to the constructor is required: a list of permitted methods (e.g. <code>['GET', 'POST']</code>).</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseGone">
<code>class HttpResponseGone</code> </dt> <dd>
<p>Acts just like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> but uses a 410 status code.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.http.HttpResponseServerError">
<code>class HttpResponseServerError</code> </dt> <dd>
<p>Acts just like <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> but uses a 500 status code.</p> </dd>
</dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If a custom subclass of <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> implements a <code>render</code> method, Django will treat it as emulating a <a class="reference internal" href="template-response.html#django.template.response.SimpleTemplateResponse" title="django.template.response.SimpleTemplateResponse"><code>SimpleTemplateResponse</code></a>, and the <code>render</code> method must itself return a valid response object.</p> </div>  <h4 id="custom-response-classes">Custom response classes</h4> <p id="s-custom-response-classes">If you find yourself needing a response class that Django doesn’t provide, you can create it with the help of <a class="reference external" href="https://docs.python.org/3/library/http.html#http.HTTPStatus" title="(in Python v3.11)"><code>http.HTTPStatus</code></a>. For example:</p> <pre data-language="pycon">from http import HTTPStatus
from django.http import HttpResponse

class HttpResponseNoContent(HttpResponse):
    status_code = HTTPStatus.NO_CONTENT
</pre>     <h2 id="jsonresponse-objects">
<code>JsonResponse</code> objects</h2> <dl class="py class" id="s-jsonresponse-objects"> <dt class="sig sig-object py" id="django.http.JsonResponse">
<code>class JsonResponse(data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None, **kwargs)</code> </dt> <dd>
<p>An <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> subclass that helps to create a JSON-encoded response. It inherits most behavior from its superclass with a couple differences:</p> <p>Its default <code>Content-Type</code> header is set to <em class="mimetype">application/json</em>.</p> <p>The first parameter, <code>data</code>, should be a <code>dict</code> instance. If the <code>safe</code> parameter is set to <code>False</code> (see below) it can be any JSON-serializable object.</p> <p>The <code>encoder</code>, which defaults to <a class="reference internal" href="../topics/serialization.html#django.core.serializers.json.DjangoJSONEncoder" title="django.core.serializers.json.DjangoJSONEncoder"><code>django.core.serializers.json.DjangoJSONEncoder</code></a>, will be used to serialize the data. See <a class="reference internal" href="../topics/serialization.html#serialization-formats-json"><span class="std std-ref">JSON serialization</span></a> for more details about this serializer.</p> <p>The <code>safe</code> boolean parameter defaults to <code>True</code>. If it’s set to <code>False</code>, any object can be passed for serialization (otherwise only <code>dict</code> instances are allowed). If <code>safe</code> is <code>True</code> and a non-<code>dict</code> object is passed as the first argument, a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><code>TypeError</code></a> will be raised.</p> <p>The <code>json_dumps_params</code> parameter is a dictionary of keyword arguments to pass to the <code>json.dumps()</code> call used to generate the response.</p> </dd>
</dl>  <h3 id="id5">Usage</h3> <p id="s-id5">Typical usage could look like:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.http import JsonResponse
&gt;&gt;&gt; response = JsonResponse({"foo": "bar"})
&gt;&gt;&gt; response.content
b'{"foo": "bar"}'
</pre>  <h4 id="serializing-non-dictionary-objects">Serializing non-dictionary objects</h4> <p id="s-serializing-non-dictionary-objects">In order to serialize objects other than <code>dict</code> you must set the <code>safe</code> parameter to <code>False</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; response = JsonResponse([1, 2, 3], safe=False)
</pre> <p>Without passing <code>safe=False</code>, a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><code>TypeError</code></a> will be raised.</p> <p>Note that an API based on <code>dict</code> objects is more extensible, flexible, and makes it easier to maintain forwards compatibility. Therefore, you should avoid using non-dict objects in JSON-encoded response.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Before the <a class="reference external" href="https://262.ecma-international.org/5.1/#sec-11.1.4">5th edition of ECMAScript</a> it was possible to poison the JavaScript <code>Array</code> constructor. For this reason, Django does not allow passing non-dict objects to the <a class="reference internal" href="#django.http.JsonResponse" title="django.http.JsonResponse"><code>JsonResponse</code></a> constructor by default. However, most modern browsers implement ECMAScript 5 which removes this attack vector. Therefore it is possible to disable this security precaution.</p> </div>   <h4 id="changing-the-default-json-encoder">Changing the default JSON encoder</h4> <p id="s-changing-the-default-json-encoder">If you need to use a different JSON encoder class you can pass the <code>encoder</code> parameter to the constructor method:</p> <pre data-language="pycon">&gt;&gt;&gt; response = JsonResponse(data, encoder=MyJSONEncoder)
</pre>     <h2 id="httpresponse-streaming">
<code>StreamingHttpResponse</code> objects</h2> <dl class="py class" id="s-streaminghttpresponse-objects"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse">
<code>class StreamingHttpResponse</code> </dt> 
</dl> <p>The <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> class is used to stream a response from Django to the browser.</p> <div class="admonition-advanced-usage admonition"> <p class="first admonition-title">Advanced usage</p> <p><a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> is somewhat advanced, in that it is important to know whether you’ll be serving your application synchronously under WSGI or asynchronously under ASGI, and adjust your usage appropriately.</p> <p class="last">Please read these notes with care.</p> </div> <p>An example usage of <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> under WSGI is streaming content when generating the response would take too long or uses too much memory. For instance, it’s useful for <a class="reference internal" href="../howto/outputting-csv.html#streaming-csv-files"><span class="std std-ref">generating large CSV files</span></a>.</p> <p>There are performance considerations when doing this, though. Django, under WSGI, is designed for short-lived requests. Streaming responses will tie a worker process for the entire duration of the response. This may result in poor performance.</p> <p>Generally speaking, you would perform expensive tasks outside of the request-response cycle, rather than resorting to a streamed response.</p> <p>When serving under ASGI, however, a <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> need not stop other requests from being served whilst waiting for I/O. This opens up the possibility of long-lived requests for streaming content and implementing patterns such as long-polling, and server-sent events.</p> <p>Even under ASGI note, <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> should only be used in situations where it is absolutely required that the whole content isn’t iterated before transferring the data to the client. Because the content can’t be accessed, many middleware can’t function normally. For example the <code>ETag</code> and <code>Content-Length</code> headers can’t be generated for streaming responses.</p> <p>The <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> is not a subclass of <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>, because it features a slightly different API. However, it is almost identical, with the following notable differences:</p> <ul> <li>It should be given an iterator that yields bytestrings as content. When serving under WSGI, this should be a sync iterator. When serving under ASGI, this is should an async iterator. </li> <li>
<p class="first">You cannot access its content, except by iterating the response object itself. This should only occur when the response is returned to the client: you should not iterate the response yourself.</p> <p>Under WSGI the response will be iterated synchronously. Under ASGI the response will be iterated asynchronously. (This is why the iterator type must match the protocol you’re using.)</p> <p>To avoid a crash, an incorrect iterator type will be mapped to the correct type during iteration, and a warning will be raised, but in order to do this the iterator must be fully-consumed, which defeats the purpose of using a <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> at all.</p> </li> <li>It has no <code>content</code> attribute. Instead, it has a <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code>streaming_content</code></a> attribute. This can be used in middleware to wrap the response iterable, but should not be consumed. </li> <li>You cannot use the file-like object <code>tell()</code> or <code>write()</code> methods. Doing so will raise an exception. </li> </ul> <p>The <a class="reference internal" href="#django.http.HttpResponseBase" title="django.http.HttpResponseBase"><code>HttpResponseBase</code></a> base class is common between <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> and <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a>.</p> <div class="versionchanged"> <span class="title">Changed in Django 4.2:</span> <p>Support for asynchronous iteration was added.</p> </div>  <h3 id="id6">Attributes</h3> <dl class="py attribute" id="s-id6"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse.streaming_content">
<code>StreamingHttpResponse.streaming_content</code> </dt> <dd>
<p>An iterator of the response content, bytestring encoded according to <a class="reference internal" href="#django.http.HttpResponse.charset" title="django.http.HttpResponse.charset"><code>HttpResponse.charset</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse.status_code">
<code>StreamingHttpResponse.status_code</code> </dt> <dd>
<p>The <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15" id="index-8"><strong>HTTP status code</strong></a> for the response.</p> <p>Unless <a class="reference internal" href="#django.http.StreamingHttpResponse.reason_phrase" title="django.http.StreamingHttpResponse.reason_phrase"><code>reason_phrase</code></a> is explicitly set, modifying the value of <code>status_code</code> outside the constructor will also modify the value of <code>reason_phrase</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse.reason_phrase">
<code>StreamingHttpResponse.reason_phrase</code> </dt> <dd>
<p>The HTTP reason phrase for the response. It uses the <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15.1" id="index-9"><strong>HTTP standard’s</strong></a> default reason phrases.</p> <p>Unless explicitly set, <code>reason_phrase</code> is determined by the value of <a class="reference internal" href="#django.http.StreamingHttpResponse.status_code" title="django.http.StreamingHttpResponse.status_code"><code>status_code</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse.streaming">
<code>StreamingHttpResponse.streaming</code> </dt> <dd>
<p>This is always <code>True</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.http.StreamingHttpResponse.is_async">
<code>StreamingHttpResponse.is_async</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.2.</span> </div> <p>Boolean indicating whether <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code>StreamingHttpResponse.streaming_content</code></a> is an asynchronous iterator or not.</p> <p>This is useful for middleware needing to wrap <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code>StreamingHttpResponse.streaming_content</code></a>.</p> </dd>
</dl>    <h2 id="fileresponse-objects">
<code>FileResponse</code> objects</h2> <dl class="py class" id="s-fileresponse-objects"> <dt class="sig sig-object py" id="django.http.FileResponse">
<code>class FileResponse(open_file, as_attachment=False, filename='', **kwargs)</code> </dt> <dd>
<p><a class="reference internal" href="#django.http.FileResponse" title="django.http.FileResponse"><code>FileResponse</code></a> is a subclass of <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> optimized for binary files. It uses <a class="pep reference external" href="https://peps.python.org/pep-3333/#optional-platform-specific-file-handling" id="index-10"><strong>wsgi.file_wrapper</strong></a> if provided by the wsgi server, otherwise it streams the file out in small chunks.</p> <p>If <code>as_attachment=True</code>, the <code>Content-Disposition</code> header is set to <code>attachment</code>, which asks the browser to offer the file to the user as a download. Otherwise, a <code>Content-Disposition</code> header with a value of <code>inline</code> (the browser default) will be set only if a filename is available.</p> <p>If <code>open_file</code> doesn’t have a name or if the name of <code>open_file</code> isn’t appropriate, provide a custom file name using the <code>filename</code> parameter. Note that if you pass a file-like object like <code>io.BytesIO</code>, it’s your task to <code>seek()</code> it before passing it to <code>FileResponse</code>.</p> <p>The <code>Content-Length</code> header is automatically set when it can be guessed from the content of <code>open_file</code>.</p> <p>The <code>Content-Type</code> header is automatically set when it can be guessed from the <code>filename</code>, or the name of <code>open_file</code>.</p> </dd>
</dl> <p><code>FileResponse</code> accepts any file-like object with binary content, for example a file open in binary mode like so:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.http import FileResponse
&gt;&gt;&gt; response = FileResponse(open("myfile.png", "rb"))
</pre> <p>The file will be closed automatically, so don’t open it with a context manager.</p> <div class="admonition-use-under-asgi admonition"> <p class="first admonition-title">Use under ASGI</p> <p>Python’s file API is synchronous. This means that the file must be fully consumed in order to be served under ASGI.</p> <p class="last">In order to stream a file asynchronously you need to use a third-party package that provides an asynchronous file API, such as <a class="reference external" href="https://github.com/Tinche/aiofiles">aiofiles</a>.</p> </div>  <h3 id="id7">Methods</h3> <dl class="py method" id="s-id7"> <dt class="sig sig-object py" id="django.http.FileResponse.set_headers">
<code>FileResponse.set_headers(open_file)</code> </dt> <dd>
<p>This method is automatically called during the response initialization and set various headers (<code>Content-Length</code>, <code>Content-Type</code>, and <code>Content-Disposition</code>) depending on <code>open_file</code>.</p> </dd>
</dl>    <h2 id="httpresponsebase-class">
<code>HttpResponseBase</code> class</h2> <dl class="py class" id="s-httpresponsebase-class"> <dt class="sig sig-object py" id="django.http.HttpResponseBase">
<code>class HttpResponseBase</code> </dt> 
</dl> <p>The <a class="reference internal" href="#django.http.HttpResponseBase" title="django.http.HttpResponseBase"><code>HttpResponseBase</code></a> class is common to all Django responses. It should not be used to create responses directly, but it can be useful for type-checking.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.2/ref/request-response/" class="_attribution-link">https://docs.djangoproject.com/en/4.2/ref/request-response/</a>
  </p>
</div>
