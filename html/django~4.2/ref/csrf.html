<h1 id="cross-site-request-forgery-protection">Cross Site Request Forgery protection</h1> <p id="s-module-django.middleware.csrf">The CSRF middleware and template tag provides easy-to-use protection against <a class="reference external" href="https://www.squarefree.com/securitytips/web-developers.html#CSRF">Cross Site Request Forgeries</a>. This type of attack occurs when a malicious website contains a link, a form button or some JavaScript that is intended to perform some action on your website, using the credentials of a logged-in user who visits the malicious site in their browser. A related type of attack, ‘login CSRF’, where an attacking site tricks a user’s browser into logging into a site with someone else’s credentials, is also covered.</p> <p>The first defense against CSRF attacks is to ensure that GET requests (and other ‘safe’ methods, as defined by <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1" id="index-0"><strong>RFC 9110#section-9.2.1</strong></a>) are side effect free. Requests via ‘unsafe’ methods, such as POST, PUT, and DELETE, can then be protected by the steps outlined in <a class="reference internal" href="../howto/csrf.html#using-csrf"><span class="std std-ref">How to use Django’s CSRF protection</span></a>.</p>  <h2 id="how-csrf-works">How it works</h2> <p id="s-how-it-works">The CSRF protection is based on the following things:</p> <ol class="arabic"> <li>
<p class="first">A CSRF cookie that is a random secret value, which other sites will not have access to.</p> <p><code>CsrfViewMiddleware</code> sends this cookie with the response whenever <code>django.middleware.csrf.get_token()</code> is called. It can also send it in other cases. For security reasons, the value of the secret is changed each time a user logs in.</p> </li> <li>
<p class="first">A hidden form field with the name ‘csrfmiddlewaretoken’, present in all outgoing POST forms.</p> <p>In order to protect against <a class="reference external" href="https://www.breachattack.com/">BREACH</a> attacks, the value of this field is not simply the secret. It is scrambled differently with each response using a mask. The mask is generated randomly on every call to <code>get_token()</code>, so the form field value is different each time.</p> <p>This part is done by the template tag.</p> </li> <li>
<p class="first">For all incoming requests that are not using HTTP GET, HEAD, OPTIONS or TRACE, a CSRF cookie must be present, and the ‘csrfmiddlewaretoken’ field must be present and correct. If it isn’t, the user will get a 403 error.</p> <p>When validating the ‘csrfmiddlewaretoken’ field value, only the secret, not the full token, is compared with the secret in the cookie value. This allows the use of ever-changing tokens. While each request may use its own token, the secret remains common to all.</p> <p>This check is done by <code>CsrfViewMiddleware</code>.</p> </li> <li>
<code>CsrfViewMiddleware</code> verifies the <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin">Origin header</a>, if provided by the browser, against the current host and the <a class="reference internal" href="settings.html#std-setting-CSRF_TRUSTED_ORIGINS"><code>CSRF_TRUSTED_ORIGINS</code></a> setting. This provides protection against cross-subdomain attacks. </li> <li>
<p class="first">In addition, for HTTPS requests, if the <code>Origin</code> header isn’t provided, <code>CsrfViewMiddleware</code> performs strict referer checking. This means that even if a subdomain can set or modify cookies on your domain, it can’t force a user to post to your application since that request won’t come from your own exact domain.</p> <p>This also addresses a man-in-the-middle attack that’s possible under HTTPS when using a session independent secret, due to the fact that HTTP <code>Set-Cookie</code> headers are (unfortunately) accepted by clients even when they are talking to a site under HTTPS. (Referer checking is not done for HTTP requests because the presence of the <code>Referer</code> header isn’t reliable enough under HTTP.)</p> <p>If the <a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_DOMAIN"><code>CSRF_COOKIE_DOMAIN</code></a> setting is set, the referer is compared against it. You can allow cross-subdomain requests by including a leading dot. For example, <code>CSRF_COOKIE_DOMAIN = '.example.com'</code> will allow POST requests from <code>www.example.com</code> and <code>api.example.com</code>. If the setting is not set, then the referer must match the HTTP <code>Host</code> header.</p> <p>Expanding the accepted referers beyond the current host or cookie domain can be done with the <a class="reference internal" href="settings.html#std-setting-CSRF_TRUSTED_ORIGINS"><code>CSRF_TRUSTED_ORIGINS</code></a> setting.</p> </li> </ol> <div class="versionchanged"> <span class="title">Changed in Django 4.1:</span> <p>In older versions, the CSRF cookie value was masked.</p> </div> <p>This ensures that only forms that have originated from trusted domains can be used to POST data back.</p> <p>It deliberately ignores GET requests (and other requests that are defined as ‘safe’ by <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1" id="index-1"><strong>RFC 9110#section-9.2.1</strong></a>). These requests ought never to have any potentially dangerous side effects, and so a CSRF attack with a GET request ought to be harmless. <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1" id="index-2"><strong>RFC 9110#section-9.2.1</strong></a> defines POST, PUT, and DELETE as ‘unsafe’, and all other methods are also assumed to be unsafe, for maximum protection.</p> <p>The CSRF protection cannot protect against man-in-the-middle attacks, so use <a class="reference internal" href="../topics/security.html#security-recommendation-ssl"><span class="std std-ref">HTTPS</span></a> with <a class="reference internal" href="middleware.html#http-strict-transport-security"><span class="std std-ref">HTTP Strict Transport Security</span></a>. It also assumes <a class="reference internal" href="../topics/security.html#host-headers-virtual-hosting"><span class="std std-ref">validation of the HOST header</span></a> and that there aren’t any <a class="reference internal" href="../topics/security.html#cross-site-scripting"><span class="std std-ref">cross-site scripting vulnerabilities</span></a> on your site (because XSS vulnerabilities already let an attacker do anything a CSRF vulnerability allows and much worse).</p> <div class="admonition-removing-the-referer-header admonition"> <p class="first admonition-title">Removing the <code>Referer</code> header</p> <p class="last">To avoid disclosing the referrer URL to third-party sites, you might want to <a class="reference external" href="https://www.w3.org/TR/referrer-policy/#referrer-policy-delivery">disable the referer</a> on your site’s <code>&lt;a&gt;</code> tags. For example, you might use the <code>&lt;meta name="referrer" content="no-referrer"&gt;</code> tag or include the <code>Referrer-Policy: no-referrer</code> header. Due to the CSRF protection’s strict referer checking on HTTPS requests, those techniques cause a CSRF failure on requests with ‘unsafe’ methods. Instead, use alternatives like <code>&lt;a rel="noreferrer" ...&gt;"</code> for links to third-party sites.</p> </div>   <h2 id="csrf-limitations">Limitations</h2> <p id="s-limitations">Subdomains within a site will be able to set cookies on the client for the whole domain. By setting the cookie and using a corresponding token, subdomains will be able to circumvent the CSRF protection. The only way to avoid this is to ensure that subdomains are controlled by trusted users (or, are at least unable to set cookies). Note that even without CSRF, there are other vulnerabilities, such as session fixation, that make giving subdomains to untrusted parties a bad idea, and these vulnerabilities cannot easily be fixed with current browsers.</p>   <h2 id="utilities">Utilities</h2> <p id="s-module-django.views.decorators.csrf">The examples below assume you are using function-based views. If you are working with class-based views, you can refer to <a class="reference internal" href="../topics/class-based-views/intro.html#id1"><span class="std std-ref">Decorating class-based views</span></a>.</p> <dl class="py function"> <dt class="sig sig-object py" id="django.views.decorators.csrf.csrf_exempt">
<code>csrf_exempt(view)</code> </dt> <dd>
<p>This decorator marks a view as being exempt from the protection ensured by the middleware. Example:</p> <pre data-language="python">from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt


@csrf_exempt
def my_view(request):
    return HttpResponse("Hello world")
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.views.decorators.csrf.csrf_protect">
<code>csrf_protect(view)</code> </dt> <dd>
<p>Decorator that provides the protection of <code>CsrfViewMiddleware</code> to a view.</p> <p>Usage:</p> <pre data-language="python">from django.shortcuts import render
from django.views.decorators.csrf import csrf_protect


@csrf_protect
def my_view(request):
    c = {}
    # ...
    return render(request, "a_template.html", c)
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.views.decorators.csrf.requires_csrf_token">
<code>requires_csrf_token(view)</code> </dt> <dd>
<p>Normally the <a class="reference internal" href="templates/builtins.html#std-templatetag-csrf_token"><code>csrf_token</code></a> template tag will not work if <code>CsrfViewMiddleware.process_view</code> or an equivalent like <code>csrf_protect</code> has not run. The view decorator <code>requires_csrf_token</code> can be used to ensure the template tag does work. This decorator works similarly to <code>csrf_protect</code>, but never rejects an incoming request.</p> <p>Example:</p> <pre data-language="python">from django.shortcuts import render
from django.views.decorators.csrf import requires_csrf_token


@requires_csrf_token
def my_view(request):
    c = {}
    # ...
    return render(request, "a_template.html", c)
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.views.decorators.csrf.ensure_csrf_cookie">
<code>ensure_csrf_cookie(view)</code> </dt> <dd>
<p>This decorator forces a view to send the CSRF cookie.</p> </dd>
</dl>   <h2 id="settings">Settings</h2> <p id="s-settings">A number of settings can be used to control Django’s CSRF behavior:</p> <ul class="simple"> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_AGE"><code>CSRF_COOKIE_AGE</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_DOMAIN"><code>CSRF_COOKIE_DOMAIN</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_HTTPONLY"><code>CSRF_COOKIE_HTTPONLY</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_NAME"><code>CSRF_COOKIE_NAME</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_PATH"><code>CSRF_COOKIE_PATH</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_SAMESITE"><code>CSRF_COOKIE_SAMESITE</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_COOKIE_SECURE"><code>CSRF_COOKIE_SECURE</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_FAILURE_VIEW"><code>CSRF_FAILURE_VIEW</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_HEADER_NAME"><code>CSRF_HEADER_NAME</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_TRUSTED_ORIGINS"><code>CSRF_TRUSTED_ORIGINS</code></a></li> <li><a class="reference internal" href="settings.html#std-setting-CSRF_USE_SESSIONS"><code>CSRF_USE_SESSIONS</code></a></li> </ul>   <h2 id="frequently-asked-questions">Frequently Asked Questions</h2>  <h3 id="is-posting-an-arbitrary-csrf-token-pair-cookie-and-post-data-a-vulnerability">Is posting an arbitrary CSRF token pair (cookie and POST data) a vulnerability?</h3> <p id="s-frequently-asked-questions">No, this is by design. Without a man-in-the-middle attack, there is no way for an attacker to send a CSRF token cookie to a victim’s browser, so a successful attack would need to obtain the victim’s browser’s cookie via XSS or similar, in which case an attacker usually doesn’t need CSRF attacks.</p> <p>Some security audit tools flag this as a problem but as mentioned before, an attacker cannot steal a user’s browser’s CSRF cookie. “Stealing” or modifying <em>your own</em> token using Firebug, Chrome dev tools, etc. isn’t a vulnerability.</p>   <h3 id="is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default">Is it a problem that Django’s CSRF protection isn’t linked to a session by default?</h3> <p id="s-is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default">No, this is by design. Not linking CSRF protection to a session allows using the protection on sites such as a <em>pastebin</em> that allow submissions from anonymous users which don’t have a session.</p> <p>If you wish to store the CSRF token in the user’s session, use the <a class="reference internal" href="settings.html#std-setting-CSRF_USE_SESSIONS"><code>CSRF_USE_SESSIONS</code></a> setting.</p>   <h3 id="why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in">Why might a user encounter a CSRF validation failure after logging in?</h3> <p id="s-why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in">For security reasons, CSRF tokens are rotated each time a user logs in. Any page with a form generated before a login will have an old, invalid CSRF token and need to be reloaded. This might happen if a user uses the back button after a login or if they log in a different browser tab.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.2/ref/csrf/" class="_attribution-link">https://docs.djangoproject.com/en/4.2/ref/csrf/</a>
  </p>
</div>
