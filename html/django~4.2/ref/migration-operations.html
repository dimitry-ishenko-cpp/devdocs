<h1 id="migration-operations">Migration Operations</h1> <p id="s-module-django.db.migrations.operations">Migration files are composed of one or more <code>Operation</code>s, objects that declaratively record what the migration should do to your database.</p> <p>Django also uses these <code>Operation</code> objects to work out what your models looked like historically, and to calculate what changes you’ve made to your models since the last migration so it can automatically write your migrations; that’s why they’re declarative, as it means Django can easily load them all into memory and run through them without touching the database to work out what your project should look like.</p> <p>There are also more specialized <code>Operation</code> objects which are for things like <a class="reference internal" href="../topics/migrations.html#data-migrations"><span class="std std-ref">data migrations</span></a> and for advanced manual database manipulation. You can also write your own <code>Operation</code> classes if you want to encapsulate a custom change you commonly make.</p> <p>If you need an empty migration file to write your own <code>Operation</code> objects into, use <code>python manage.py makemigrations --empty yourappname</code>, but be aware that manually adding schema-altering operations can confuse the migration autodetector and make resulting runs of <a class="reference internal" href="django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a> output incorrect code.</p> <p>All of the core Django operations are available from the <code>django.db.migrations.operations</code> module.</p> <p>For introductory material, see the <a class="reference internal" href="../topics/migrations.html"><span class="doc">migrations topic guide</span></a>.</p>  <h2 id="schema-operations">Schema Operations</h2>  <h3 id="createmodel"><code>CreateModel</code></h3> <dl class="py class" id="s-schema-operations"> <dt class="sig sig-object py" id="django.db.migrations.operations.CreateModel">
<code>class CreateModel(name, fields, options=None, bases=None, managers=None)</code> </dt> 
</dl> <p>Creates a new model in the project history and a corresponding table in the database to match it.</p> <p><code>name</code> is the model name, as would be written in the <code>models.py</code> file.</p> <p><code>fields</code> is a list of 2-tuples of <code>(field_name, field_instance)</code>. The field instance should be an unbound field (so just <code>models.CharField(...)</code>, rather than a field taken from another model).</p> <p><code>options</code> is an optional dictionary of values from the model’s <code>Meta</code> class.</p> <p><code>bases</code> is an optional list of other classes to have this model inherit from; it can contain both class objects as well as strings in the format <code>"appname.ModelName"</code> if you want to depend on another model (so you inherit from the historical version). If it’s not supplied, it defaults to inheriting from the standard <code>models.Model</code>.</p> <p><code>managers</code> takes a list of 2-tuples of <code>(manager_name, manager_instance)</code>. The first manager in the list will be the default manager for this model during migrations.</p>   <h3 id="deletemodel"><code>DeleteModel</code></h3> <dl class="py class" id="s-deletemodel"> <dt class="sig sig-object py" id="django.db.migrations.operations.DeleteModel">
<code>class DeleteModel(name)</code> </dt> 
</dl> <p>Deletes the model from the project history and its table from the database.</p>   <h3 id="renamemodel"><code>RenameModel</code></h3> <dl class="py class" id="s-renamemodel"> <dt class="sig sig-object py" id="django.db.migrations.operations.RenameModel">
<code>class RenameModel(old_name, new_name)</code> </dt> 
</dl> <p>Renames the model from an old name to a new one.</p> <p>You may have to manually add this if you change the model’s name and quite a few of its fields at once; to the autodetector, this will look like you deleted a model with the old name and added a new one with a different name, and the migration it creates will lose any data in the old table.</p>   <h3 id="altermodeltable"><code>AlterModelTable</code></h3> <dl class="py class" id="s-altermodeltable"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterModelTable">
<code>class AlterModelTable(name, table)</code> </dt> 
</dl> <p>Changes the model’s table name (the <a class="reference internal" href="models/options.html#django.db.models.Options.db_table" title="django.db.models.Options.db_table"><code>db_table</code></a> option on the <code>Meta</code> subclass).</p>   <h3 id="altermodeltablecomment"><code>AlterModelTableComment</code></h3> <div class="versionadded" id="s-altermodeltablecomment"> <span class="title">New in Django 4.2.</span> </div> <dl class="py class"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterModelTableComment">
<code>class AlterModelTableComment(name, table_comment)</code> </dt> 
</dl> <p>Changes the model’s table comment (the <a class="reference internal" href="models/options.html#django.db.models.Options.db_table_comment" title="django.db.models.Options.db_table_comment"><code>db_table_comment</code></a> option on the <code>Meta</code> subclass).</p>   <h3 id="alteruniquetogether"><code>AlterUniqueTogether</code></h3> <dl class="py class" id="s-alteruniquetogether"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterUniqueTogether">
<code>class AlterUniqueTogether(name, unique_together)</code> </dt> 
</dl> <p>Changes the model’s set of unique constraints (the <a class="reference internal" href="models/options.html#django.db.models.Options.unique_together" title="django.db.models.Options.unique_together"><code>unique_together</code></a> option on the <code>Meta</code> subclass).</p>   <h3 id="alterindextogether"><code>AlterIndexTogether</code></h3> <dl class="py class" id="s-alterindextogether"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterIndexTogether">
<code>class AlterIndexTogether(name, index_together)</code> </dt> 
</dl> <p>Changes the model’s set of custom indexes (the <code>index_together</code> option on the <code>Meta</code> subclass).</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>AlterIndexTogether</code> is officially supported only for pre-Django 4.2 migration files. For backward compatibility reasons, it’s still part of the public API, and there’s no plan to deprecate or remove it, but it should not be used for new migrations. Use <a class="reference internal" href="#django.db.migrations.operations.AddIndex" title="django.db.migrations.operations.AddIndex"><code>AddIndex</code></a> and <a class="reference internal" href="#django.db.migrations.operations.RemoveIndex" title="django.db.migrations.operations.RemoveIndex"><code>RemoveIndex</code></a> operations instead.</p> </div>   <h3 id="alterorderwithrespectto"><code>AlterOrderWithRespectTo</code></h3> <dl class="py class" id="s-alterorderwithrespectto"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterOrderWithRespectTo">
<code>class AlterOrderWithRespectTo(name, order_with_respect_to)</code> </dt> 
</dl> <p>Makes or deletes the <code>_order</code> column needed for the <a class="reference internal" href="models/options.html#django.db.models.Options.order_with_respect_to" title="django.db.models.Options.order_with_respect_to"><code>order_with_respect_to</code></a> option on the <code>Meta</code> subclass.</p>   <h3 id="altermodeloptions"><code>AlterModelOptions</code></h3> <dl class="py class" id="s-altermodeloptions"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterModelOptions">
<code>class AlterModelOptions(name, options)</code> </dt> 
</dl> <p>Stores changes to miscellaneous model options (settings on a model’s <code>Meta</code>) like <code>permissions</code> and <code>verbose_name</code>. Does not affect the database, but persists these changes for <a class="reference internal" href="#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code>RunPython</code></a> instances to use. <code>options</code> should be a dictionary mapping option names to values.</p>   <h3 id="altermodelmanagers"><code>AlterModelManagers</code></h3> <dl class="py class" id="s-altermodelmanagers"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterModelManagers">
<code>class AlterModelManagers(name, managers)</code> </dt> 
</dl> <p>Alters the managers that are available during migrations.</p>   <h3 id="addfield"><code>AddField</code></h3> <dl class="py class" id="s-addfield"> <dt class="sig sig-object py" id="django.db.migrations.operations.AddField">
<code>class AddField(model_name, name, field, preserve_default=True)</code> </dt> 
</dl> <p>Adds a field to a model. <code>model_name</code> is the model’s name, <code>name</code> is the field’s name, and <code>field</code> is an unbound Field instance (the thing you would put in the field declaration in <code>models.py</code> - for example, <code>models.IntegerField(null=True)</code>.</p> <p>The <code>preserve_default</code> argument indicates whether the field’s default value is permanent and should be baked into the project state (<code>True</code>), or if it is temporary and just for this migration (<code>False</code>) - usually because the migration is adding a non-nullable field to a table and needs a default value to put into existing rows. It does not affect the behavior of setting defaults in the database directly - Django never sets database defaults and always applies them in the Django ORM code.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>On older databases, adding a field with a default value may cause a full rewrite of the table. This happens even for nullable fields and may have a negative performance impact. To avoid that, the following steps should be taken.</p> <ul class="last simple"> <li>Add the nullable field without the default value and run the <a class="reference internal" href="django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a> command. This should generate a migration with an <code>AddField</code> operation.</li> <li>Add the default value to your field and run the <a class="reference internal" href="django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a> command. This should generate a migration with an <code>AlterField</code> operation.</li> </ul> </div>   <h3 id="removefield"><code>RemoveField</code></h3> <dl class="py class" id="s-removefield"> <dt class="sig sig-object py" id="django.db.migrations.operations.RemoveField">
<code>class RemoveField(model_name, name)</code> </dt> 
</dl> <p>Removes a field from a model.</p> <p>Bear in mind that when reversed, this is actually adding a field to a model. The operation is reversible (apart from any data loss, which is irreversible) if the field is nullable or if it has a default value that can be used to populate the recreated column. If the field is not nullable and does not have a default value, the operation is irreversible.</p>   <h3 id="alterfield"><code>AlterField</code></h3> <dl class="py class" id="s-alterfield"> <dt class="sig sig-object py" id="django.db.migrations.operations.AlterField">
<code>class AlterField(model_name, name, field, preserve_default=True)</code> </dt> 
</dl> <p>Alters a field’s definition, including changes to its type, <a class="reference internal" href="models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code>null</code></a>, <a class="reference internal" href="models/fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code>unique</code></a>, <a class="reference internal" href="models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code>db_column</code></a> and other field attributes.</p> <p>The <code>preserve_default</code> argument indicates whether the field’s default value is permanent and should be baked into the project state (<code>True</code>), or if it is temporary and just for this migration (<code>False</code>) - usually because the migration is altering a nullable field to a non-nullable one and needs a default value to put into existing rows. It does not affect the behavior of setting defaults in the database directly - Django never sets database defaults and always applies them in the Django ORM code.</p> <p>Note that not all changes are possible on all databases - for example, you cannot change a text-type field like <code>models.TextField()</code> into a number-type field like <code>models.IntegerField()</code> on most databases.</p>   <h3 id="renamefield"><code>RenameField</code></h3> <dl class="py class" id="s-renamefield"> <dt class="sig sig-object py" id="django.db.migrations.operations.RenameField">
<code>class RenameField(model_name, old_name, new_name)</code> </dt> 
</dl> <p>Changes a field’s name (and, unless <a class="reference internal" href="models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code>db_column</code></a> is set, its column name).</p>   <h3 id="addindex"><code>AddIndex</code></h3> <dl class="py class" id="s-addindex"> <dt class="sig sig-object py" id="django.db.migrations.operations.AddIndex">
<code>class AddIndex(model_name, index)</code> </dt> 
</dl> <p>Creates an index in the database table for the model with <code>model_name</code>. <code>index</code> is an instance of the <a class="reference internal" href="models/indexes.html#django.db.models.Index" title="django.db.models.Index"><code>Index</code></a> class.</p>   <h3 id="removeindex"><code>RemoveIndex</code></h3> <dl class="py class" id="s-removeindex"> <dt class="sig sig-object py" id="django.db.migrations.operations.RemoveIndex">
<code>class RemoveIndex(model_name, name)</code> </dt> 
</dl> <p>Removes the index named <code>name</code> from the model with <code>model_name</code>.</p>   <h3 id="renameindex"><code>RenameIndex</code></h3> <div class="versionadded" id="s-renameindex"> <span class="title">New in Django 4.1.</span> </div> <dl class="py class"> <dt class="sig sig-object py" id="django.db.migrations.operations.RenameIndex">
<code>class RenameIndex(model_name, new_name, old_name=None, old_fields=None)</code> </dt> 
</dl> <p>Renames an index in the database table for the model with <code>model_name</code>. Exactly one of <code>old_name</code> and <code>old_fields</code> can be provided. <code>old_fields</code> is an iterable of the strings, often corresponding to fields of <a class="reference internal" href="models/options.html#django.db.models.Options.index_together" title="django.db.models.Options.index_together"><code>index_together</code></a>.</p> <p>On databases that don’t support an index renaming statement (SQLite and MariaDB &lt; 10.5.2), the operation will drop and recreate the index, which can be expensive.</p>   <h3 id="addconstraint"><code>AddConstraint</code></h3> <dl class="py class" id="s-addconstraint"> <dt class="sig sig-object py" id="django.db.migrations.operations.AddConstraint">
<code>class AddConstraint(model_name, constraint)</code> </dt> 
</dl> <p>Creates a <a class="reference internal" href="models/constraints.html"><span class="doc">constraint</span></a> in the database table for the model with <code>model_name</code>.</p>   <h3 id="removeconstraint"><code>RemoveConstraint</code></h3> <dl class="py class" id="s-removeconstraint"> <dt class="sig sig-object py" id="django.db.migrations.operations.RemoveConstraint">
<code>class RemoveConstraint(model_name, name)</code> </dt> 
</dl> <p>Removes the constraint named <code>name</code> from the model with <code>model_name</code>.</p>    <h2 id="special-operations">Special Operations</h2>  <h3 id="runsql"><code>RunSQL</code></h3> <dl class="py class" id="s-special-operations"> <dt class="sig sig-object py" id="django.db.migrations.operations.RunSQL">
<code>class RunSQL(sql, reverse_sql=None, state_operations=None, hints=None, elidable=False)</code> </dt> 
</dl> <p>Allows running of arbitrary SQL on the database - useful for more advanced features of database backends that Django doesn’t support directly.</p> <p><code>sql</code>, and <code>reverse_sql</code> if provided, should be strings of SQL to run on the database. On most database backends (all but PostgreSQL), Django will split the SQL into individual statements prior to executing them.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">On PostgreSQL and SQLite, only use <code>BEGIN</code> or <code>COMMIT</code> in your SQL in <a class="reference internal" href="../howto/writing-migrations.html#non-atomic-migrations"><span class="std std-ref">non-atomic migrations</span></a>, to avoid breaking Django’s transaction state.</p> </div> <p>You can also pass a list of strings or 2-tuples. The latter is used for passing queries and parameters in the same way as <a class="reference internal" href="../topics/db/sql.html#executing-custom-sql"><span class="std std-ref">cursor.execute()</span></a>. These three operations are equivalent:</p> <pre data-language="python">migrations.RunSQL("INSERT INTO musician (name) VALUES ('Reinhardt');")
migrations.RunSQL([("INSERT INTO musician (name) VALUES ('Reinhardt');", None)])
migrations.RunSQL([("INSERT INTO musician (name) VALUES (%s);", ["Reinhardt"])])
</pre> <p>If you want to include literal percent signs in the query, you have to double them if you are passing parameters.</p> <p>The <code>reverse_sql</code> queries are executed when the migration is unapplied. They should undo what is done by the <code>sql</code> queries. For example, to undo the above insertion with a deletion:</p> <pre data-language="python">migrations.RunSQL(
    sql=[("INSERT INTO musician (name) VALUES (%s);", ["Reinhardt"])],
    reverse_sql=[("DELETE FROM musician where name=%s;", ["Reinhardt"])],
)
</pre> <p>If <code>reverse_sql</code> is <code>None</code> (the default), the <code>RunSQL</code> operation is irreversible.</p> <p>The <code>state_operations</code> argument allows you to supply operations that are equivalent to the SQL in terms of project state. For example, if you are manually creating a column, you should pass in a list containing an <code>AddField</code> operation here so that the autodetector still has an up-to-date state of the model. If you don’t, when you next run <code>makemigrations</code>, it won’t see any operation that adds that field and so will try to run it again. For example:</p> <pre data-language="python">migrations.RunSQL(
    "ALTER TABLE musician ADD COLUMN name varchar(255) NOT NULL;",
    state_operations=[
        migrations.AddField(
            "musician",
            "name",
            models.CharField(max_length=255),
        ),
    ],
)
</pre> <p>The optional <code>hints</code> argument will be passed as <code>**hints</code> to the <a class="reference internal" href="../topics/db/multi-db.html#allow_migrate" title="allow_migrate"><code>allow_migrate()</code></a> method of database routers to assist them in making routing decisions. See <a class="reference internal" href="../topics/db/multi-db.html#topics-db-multi-db-hints"><span class="std std-ref">Hints</span></a> for more details on database hints.</p> <p>The optional <code>elidable</code> argument determines whether or not the operation will be removed (elided) when <a class="reference internal" href="../topics/migrations.html#migration-squashing"><span class="std std-ref">squashing migrations</span></a>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.db.migrations.operations.RunSQL.noop">
<code>RunSQL.noop</code> </dt> <dd>
<p>Pass the <code>RunSQL.noop</code> attribute to <code>sql</code> or <code>reverse_sql</code> when you want the operation not to do anything in the given direction. This is especially useful in making the operation reversible.</p> </dd>
</dl>   <h3 id="runpython"><code>RunPython</code></h3> <dl class="py class" id="s-runpython"> <dt class="sig sig-object py" id="django.db.migrations.operations.RunPython">
<code>class RunPython(code, reverse_code=None, atomic=None, hints=None, elidable=False)</code> </dt> 
</dl> <p>Runs custom Python code in a historical context. <code>code</code> (and <code>reverse_code</code> if supplied) should be callable objects that accept two arguments; the first is an instance of <code>django.apps.registry.Apps</code> containing historical models that match the operation’s place in the project history, and the second is an instance of <a class="reference internal" href="schema-editor.html#django.db.backends.base.schema.BaseDatabaseSchemaEditor" title="django.db.backends.base.schema.BaseDatabaseSchemaEditor"><code>SchemaEditor</code></a>.</p> <p>The <code>reverse_code</code> argument is called when unapplying migrations. This callable should undo what is done in the <code>code</code> callable so that the migration is reversible. If <code>reverse_code</code> is <code>None</code> (the default), the <code>RunPython</code> operation is irreversible.</p> <p>The optional <code>hints</code> argument will be passed as <code>**hints</code> to the <a class="reference internal" href="../topics/db/multi-db.html#allow_migrate" title="allow_migrate"><code>allow_migrate()</code></a> method of database routers to assist them in making a routing decision. See <a class="reference internal" href="../topics/db/multi-db.html#topics-db-multi-db-hints"><span class="std std-ref">Hints</span></a> for more details on database hints.</p> <p>The optional <code>elidable</code> argument determines whether or not the operation will be removed (elided) when <a class="reference internal" href="../topics/migrations.html#migration-squashing"><span class="std std-ref">squashing migrations</span></a>.</p> <p>You are advised to write the code as a separate function above the <code>Migration</code> class in the migration file, and pass it to <code>RunPython</code>. Here’s an example of using <code>RunPython</code> to create some initial objects on a <code>Country</code> model:</p> <pre data-language="python">from django.db import migrations


def forwards_func(apps, schema_editor):
    # We get the model from the versioned app registry;
    # if we directly import it, it'll be the wrong version
    Country = apps.get_model("myapp", "Country")
    db_alias = schema_editor.connection.alias
    Country.objects.using(db_alias).bulk_create(
        [
            Country(name="USA", code="us"),
            Country(name="France", code="fr"),
        ]
    )


def reverse_func(apps, schema_editor):
    # forwards_func() creates two Country instances,
    # so reverse_func() should delete them.
    Country = apps.get_model("myapp", "Country")
    db_alias = schema_editor.connection.alias
    Country.objects.using(db_alias).filter(name="USA", code="us").delete()
    Country.objects.using(db_alias).filter(name="France", code="fr").delete()


class Migration(migrations.Migration):
    dependencies = []

    operations = [
        migrations.RunPython(forwards_func, reverse_func),
    ]
</pre> <p>This is generally the operation you would use to create <a class="reference internal" href="../topics/migrations.html#data-migrations"><span class="std std-ref">data migrations</span></a>, run custom data updates and alterations, and anything else you need access to an ORM and/or Python code for.</p> <p>Much like <a class="reference internal" href="#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code>RunSQL</code></a>, ensure that if you change schema inside here you’re either doing it outside the scope of the Django model system (e.g. triggers) or that you use <a class="reference internal" href="#django.db.migrations.operations.SeparateDatabaseAndState" title="django.db.migrations.operations.SeparateDatabaseAndState"><code>SeparateDatabaseAndState</code></a> to add in operations that will reflect your changes to the model state - otherwise, the versioned ORM and the autodetector will stop working correctly.</p> <p>By default, <code>RunPython</code> will run its contents inside a transaction on databases that do not support DDL transactions (for example, MySQL and Oracle). This should be safe, but may cause a crash if you attempt to use the <code>schema_editor</code> provided on these backends; in this case, pass <code>atomic=False</code> to the <code>RunPython</code> operation.</p> <p>On databases that do support DDL transactions (SQLite and PostgreSQL), <code>RunPython</code> operations do not have any transactions automatically added besides the transactions created for each migration. Thus, on PostgreSQL, for example, you should avoid combining schema changes and <code>RunPython</code> operations in the same migration or you may hit errors like <code>OperationalError: cannot
ALTER TABLE "mytable" because it has pending trigger events</code>.</p> <p>If you have a different database and aren’t sure if it supports DDL transactions, check the <code>django.db.connection.features.can_rollback_ddl</code> attribute.</p> <p>If the <code>RunPython</code> operation is part of a <a class="reference internal" href="../howto/writing-migrations.html#non-atomic-migrations"><span class="std std-ref">non-atomic migration</span></a>, the operation will only be executed in a transaction if <code>atomic=True</code> is passed to the <code>RunPython</code> operation.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>RunPython</code> does not magically alter the connection of the models for you; any model methods you call will go to the default database unless you give them the current database alias (available from <code>schema_editor.connection.alias</code>, where <code>schema_editor</code> is the second argument to your function).</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="django.db.migrations.operations.RunPython.noop">
<code>static RunPython.noop()</code> </dt> <dd>
<p>Pass the <code>RunPython.noop</code> method to <code>code</code> or <code>reverse_code</code> when you want the operation not to do anything in the given direction. This is especially useful in making the operation reversible.</p> </dd>
</dl>   <h3 id="separatedatabaseandstate"><code>SeparateDatabaseAndState</code></h3> <dl class="py class" id="s-separatedatabaseandstate"> <dt class="sig sig-object py" id="django.db.migrations.operations.SeparateDatabaseAndState">
<code>class SeparateDatabaseAndState(database_operations=None, state_operations=None)</code> </dt> 
</dl> <p>A highly specialized operation that lets you mix and match the database (schema-changing) and state (autodetector-powering) aspects of operations.</p> <p>It accepts two lists of operations. When asked to apply state, it will use the <code>state_operations</code> list (this is a generalized version of <a class="reference internal" href="#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code>RunSQL</code></a>’s <code>state_operations</code> argument). When asked to apply changes to the database, it will use the <code>database_operations</code> list.</p> <p>If the actual state of the database and Django’s view of the state get out of sync, this can break the migration framework, even leading to data loss. It’s worth exercising caution and checking your database and state operations carefully. You can use <a class="reference internal" href="django-admin.html#django-admin-sqlmigrate"><code>sqlmigrate</code></a> and <a class="reference internal" href="django-admin.html#django-admin-dbshell"><code>dbshell</code></a> to check your database operations. You can use <a class="reference internal" href="django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a>, especially with <a class="reference internal" href="django-admin.html#cmdoption-makemigrations-dry-run"><code>--dry-run</code></a>, to check your state operations.</p> <p>For an example using <code>SeparateDatabaseAndState</code>, see <a class="reference internal" href="../howto/writing-migrations.html#changing-a-manytomanyfield-to-use-a-through-model"><span class="std std-ref">Changing a ManyToManyField to use a through model</span></a>.</p>    <h2 id="writing-your-own-migration-operation">Writing your own</h2> <p id="s-writing-your-own">Operations have a relatively simple API, and they’re designed so that you can easily write your own to supplement the built-in Django ones. The basic structure of an <code>Operation</code> looks like this:</p> <pre data-language="python">from django.db.migrations.operations.base import Operation


class MyCustomOperation(Operation):
    # If this is False, it means that this operation will be ignored by
    # sqlmigrate; if true, it will be run and the SQL collected for its output.
    reduces_to_sql = False

    # If this is False, Django will refuse to reverse past this operation.
    reversible = False

    def __init__(self, arg1, arg2):
        # Operations are usually instantiated with arguments in migration
        # files. Store the values of them on self for later use.
        pass

    def state_forwards(self, app_label, state):
        # The Operation should take the 'state' parameter (an instance of
        # django.db.migrations.state.ProjectState) and mutate it to match
        # any schema changes that have occurred.
        pass

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        # The Operation should use schema_editor to apply any changes it
        # wants to make to the database.
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        # If reversible is True, this is called when the operation is reversed.
        pass

    def describe(self):
        # This is used to describe what the operation does in console output.
        return "Custom Operation"

    @property
    def migration_name_fragment(self):
        # Optional. A filename part suitable for automatically naming a
        # migration containing this operation, or None if not applicable.
        return "custom_operation_%s_%s" % (self.arg1, self.arg2)
</pre> <p>You can take this template and work from it, though we suggest looking at the built-in Django operations in <code>django.db.migrations.operations</code> - they cover a lot of the example usage of semi-internal aspects of the migration framework like <code>ProjectState</code> and the patterns used to get historical models, as well as <code>ModelState</code> and the patterns used to mutate historical models in <code>state_forwards()</code>.</p> <p>Some things to note:</p> <ul> <li>You don’t need to learn too much about <code>ProjectState</code> to write migrations; just know that it has an <code>apps</code> property that gives access to an app registry (which you can then call <code>get_model</code> on). </li> <li>
<code>database_forwards</code> and <code>database_backwards</code> both get two states passed to them; these represent the difference the <code>state_forwards</code> method would have applied, but are given to you for convenience and speed reasons. </li> <li>
<p class="first">If you want to work with model classes or model instances from the <code>from_state</code> argument in <code>database_forwards()</code> or <code>database_backwards()</code>, you must render model states using the <code>clear_delayed_apps_cache()</code> method to make related models available:</p> <pre data-language="python">def database_forwards(self, app_label, schema_editor, from_state, to_state):
    # This operation should have access to all models. Ensure that all models are
    # reloaded in case any are delayed.
    from_state.clear_delayed_apps_cache()
    ...
</pre> </li> <li>
<code>to_state</code> in the database_backwards method is the <em>older</em> state; that is, the one that will be the current state once the migration has finished reversing. </li> <li>You might see implementations of <code>references_model</code> on the built-in operations; this is part of the autodetection code and does not matter for custom operations. </li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">For performance reasons, the <a class="reference internal" href="models/fields.html#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> instances in <code>ModelState.fields</code> are reused across migrations. You must never change the attributes on these instances. If you need to mutate a field in <code>state_forwards()</code>, you must remove the old instance from <code>ModelState.fields</code> and add a new instance in its place. The same is true for the <a class="reference internal" href="../topics/db/managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> instances in <code>ModelState.managers</code>.</p> </div> <p>As an example, let’s make an operation that loads PostgreSQL extensions (which contain some of PostgreSQL’s more exciting features). Since there’s no model state changes, all it does is run one command:</p> <pre data-language="python">from django.db.migrations.operations.base import Operation


class LoadExtension(Operation):
    reversible = True

    def __init__(self, name):
        self.name = name

    def state_forwards(self, app_label, state):
        pass

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        schema_editor.execute("CREATE EXTENSION IF NOT EXISTS %s" % self.name)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        schema_editor.execute("DROP EXTENSION %s" % self.name)

    def describe(self):
        return "Creates extension %s" % self.name

    @property
    def migration_name_fragment(self):
        return "create_extension_%s" % self.name
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.2/ref/migration-operations/" class="_attribution-link">https://docs.djangoproject.com/en/4.2/ref/migration-operations/</a>
  </p>
</div>
