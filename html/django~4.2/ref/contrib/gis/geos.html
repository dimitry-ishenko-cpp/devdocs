<h1 id="geos-api">GEOS API</h1>  <h2 id="background">Background</h2>  <h3 id="what-is-geos">What is GEOS?</h3> <p id="s-module-django.contrib.gis.geos"><a class="reference external" href="https://libgeos.org/">GEOS</a> stands for <strong>Geometry Engine - Open Source</strong>, and is a C++ library, ported from the <a class="reference external" href="https://sourceforge.net/projects/jts-topo-suite/">Java Topology Suite</a>. GEOS implements the OpenGIS <a class="reference external" href="https://www.ogc.org/standards/sfs">Simple Features for SQL</a> spatial predicate functions and spatial operators. GEOS, now an OSGeo project, was initially developed and maintained by <a class="reference external" href="http://www.refractions.net/">Refractions Research</a> of Victoria, Canada.</p>   <h3 id="features">Features</h3> <p id="s-features">GeoDjango implements a high-level Python wrapper for the GEOS library, its features include:</p> <ul class="simple"> <li>A BSD-licensed interface to the GEOS geometry routines, implemented purely in Python using <code>ctypes</code>.</li> <li>Loosely-coupled to GeoDjango. For example, <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects may be used outside of a Django project/application. In other words, no need to have <a class="reference internal" href="../../../topics/settings.html#envvar-DJANGO_SETTINGS_MODULE" id="index-0"><code>DJANGO_SETTINGS_MODULE</code></a> set or use a database, etc.</li> <li>Mutability: <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects may be modified.</li> <li>Cross-platform and tested; compatible with Windows, Linux, Solaris, and macOS platforms.</li> </ul>    <h2 id="geos-tutorial">Tutorial</h2> <p id="s-tutorial">This section contains a brief introduction and tutorial to using <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects.</p>  <h3 id="creating-a-geometry">Creating a Geometry</h3> <p id="s-creating-a-geometry"><a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects may be created in a few ways. The first is to simply instantiate the object on some spatial input – the following are examples of creating the same geometry from WKT, HEX, WKB, and GeoJSON:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import GEOSGeometry
&gt;&gt;&gt; pnt = GEOSGeometry("POINT(5 23)")  # WKT
&gt;&gt;&gt; pnt = GEOSGeometry("010100000000000000000014400000000000003740")  # HEX
&gt;&gt;&gt; pnt = GEOSGeometry(
...     memoryview(
...         b"\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x007@"
...     )
... )  # WKB
&gt;&gt;&gt; pnt = GEOSGeometry(
...     '{ "type": "Point", "coordinates": [ 5.000000, 23.000000 ] }'
... )  # GeoJSON
</pre> <p>Another option is to use the constructor for the specific geometry type that you wish to create. For example, a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> object may be created by passing in the X and Y coordinates into its constructor:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point
&gt;&gt;&gt; pnt = Point(5, 23)
</pre> <p>All these constructors take the keyword argument <code>srid</code>. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import GEOSGeometry, LineString, Point
&gt;&gt;&gt; print(GEOSGeometry("POINT (0 0)", srid=4326))
SRID=4326;POINT (0 0)
&gt;&gt;&gt; print(LineString((0, 0), (1, 1), srid=4326))
SRID=4326;LINESTRING (0 0, 1 1)
&gt;&gt;&gt; print(Point(0, 0, srid=32140))
SRID=32140;POINT (0 0)
</pre> <p>Finally, there is the <a class="reference internal" href="#django.contrib.gis.geos.fromfile" title="django.contrib.gis.geos.fromfile"><code>fromfile()</code></a> factory method which returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> object from a file:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import fromfile
&gt;&gt;&gt; pnt = fromfile("/path/to/pnt.wkt")
&gt;&gt;&gt; pnt = fromfile(open("/path/to/pnt.wkt"))
</pre> <div class="admonition-my-logs-are-filled-with-geos-related-errors admonition" id="geos-exceptions-in-logfile"> <p class="first admonition-title">My logs are filled with GEOS-related errors</p> <p class="last">You find many <code>TypeError</code> or <code>AttributeError</code> exceptions filling your web server’s log files. This generally means that you are creating GEOS objects at the top level of some of your Python modules. Then, due to a race condition in the garbage collector, your module is garbage collected before the GEOS object. To prevent this, create <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects inside the local scope of your functions/methods.</p> </div>   <h3 id="geometries-are-pythonic">Geometries are Pythonic</h3> <p id="s-geometries-are-pythonic"><a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects are ‘Pythonic’, in other words components may be accessed, modified, and iterated over using standard Python conventions. For example, you can iterate over the coordinates in a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt = Point(5, 23)
&gt;&gt;&gt; [coord for coord in pnt]
[5.0, 23.0]
</pre> <p>With any geometry object, the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.coords" title="django.contrib.gis.geos.GEOSGeometry.coords"><code>GEOSGeometry.coords</code></a> property may be used to get the geometry coordinates as a Python tuple:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt.coords
(5.0, 23.0)
</pre> <p>You can get/set geometry components using standard Python indexing techniques. However, what is returned depends on the geometry type of the object. For example, indexing on a <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> returns a coordinate tuple:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import LineString
&gt;&gt;&gt; line = LineString((0, 0), (0, 50), (50, 50), (50, 0), (0, 0))
&gt;&gt;&gt; line[0]
(0.0, 0.0)
&gt;&gt;&gt; line[-2]
(50.0, 0.0)
</pre> <p>Whereas indexing on a <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> will return the ring (a <a class="reference internal" href="#django.contrib.gis.geos.LinearRing" title="django.contrib.gis.geos.LinearRing"><code>LinearRing</code></a> object) corresponding to the index:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Polygon
&gt;&gt;&gt; poly = Polygon(((0.0, 0.0), (0.0, 50.0), (50.0, 50.0), (50.0, 0.0), (0.0, 0.0)))
&gt;&gt;&gt; poly[0]
&lt;LinearRing object at 0x1044395b0&gt;
&gt;&gt;&gt; poly[0][-2]  # second-to-last coordinate of external ring
(50.0, 0.0)
</pre> <p>In addition, coordinates/components of the geometry may added or modified, just like a Python list:</p> <pre data-language="pycon">&gt;&gt;&gt; line[0] = (1.0, 1.0)
&gt;&gt;&gt; line.pop()
(0.0, 0.0)
&gt;&gt;&gt; line.append((1.0, 1.0))
&gt;&gt;&gt; line.coords
((1.0, 1.0), (0.0, 50.0), (50.0, 50.0), (50.0, 0.0), (1.0, 1.0))
</pre> <p>Geometries support set-like operators:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import LineString
&gt;&gt;&gt; ls1 = LineString((0, 0), (2, 2))
&gt;&gt;&gt; ls2 = LineString((1, 1), (3, 3))
&gt;&gt;&gt; print(ls1 | ls2)  # equivalent to `ls1.union(ls2)`
MULTILINESTRING ((0 0, 1 1), (1 1, 2 2), (2 2, 3 3))
&gt;&gt;&gt; print(ls1 &amp; ls2)  # equivalent to `ls1.intersection(ls2)`
LINESTRING (1 1, 2 2)
&gt;&gt;&gt; print(ls1 - ls2)  # equivalent to `ls1.difference(ls2)`
LINESTRING(0 0, 1 1)
&gt;&gt;&gt; print(ls1 ^ ls2)  # equivalent to `ls1.sym_difference(ls2)`
MULTILINESTRING ((0 0, 1 1), (2 2, 3 3))
</pre> <div class="admonition-equality-operator-doesn-t-check-spatial-equality admonition"> <p class="first admonition-title">Equality operator doesn’t check spatial equality</p> <p>The <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> equality operator uses <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.equals_exact" title="django.contrib.gis.geos.GEOSGeometry.equals_exact"><code>equals_exact()</code></a>, not <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.equals" title="django.contrib.gis.geos.GEOSGeometry.equals"><code>equals()</code></a>, i.e. it requires the compared geometries to have the same coordinates in the same positions with the same SRIDs:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import LineString
&gt;&gt;&gt; ls1 = LineString((0, 0), (1, 1))
&gt;&gt;&gt; ls2 = LineString((1, 1), (0, 0))
&gt;&gt;&gt; ls3 = LineString((1, 1), (0, 0), srid=4326)
&gt;&gt;&gt; ls1.equals(ls2)
True
&gt;&gt;&gt; ls1 == ls2
False
&gt;&gt;&gt; ls3 == ls2  # different SRIDs
False
</pre> </div>    <h2 id="geometry-objects">Geometry Objects</h2>  <h3 id="geosgeometry"><code>GEOSGeometry</code></h3> <dl class="py class" id="s-geometry-objects"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry">
<code>class GEOSGeometry(geo_input, srid=None)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>geo_input</strong> – Geometry input value (string or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(in Python v3.11)"><code>memoryview</code></a>)</li> <li>
<strong>srid</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a>) – spatial reference identifier</li> </ul> </td> </tr>  </table> </dd>
</dl> <p>This is the base class for all GEOS geometry objects. It initializes on the given <code>geo_input</code> argument, and then assumes the proper geometry subclass (e.g., <code>GEOSGeometry('POINT(1 1)')</code> will create a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> object).</p> <p>The <code>srid</code> parameter, if given, is set as the SRID of the created geometry if <code>geo_input</code> doesn’t have an SRID. If different SRIDs are provided through the <code>geo_input</code> and <code>srid</code> parameters, <code>ValueError</code> is raised:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import GEOSGeometry
&gt;&gt;&gt; GEOSGeometry("POINT EMPTY", srid=4326).ewkt
'SRID=4326;POINT EMPTY'
&gt;&gt;&gt; GEOSGeometry("SRID=4326;POINT EMPTY", srid=4326).ewkt
'SRID=4326;POINT EMPTY'
&gt;&gt;&gt; GEOSGeometry("SRID=1;POINT EMPTY", srid=4326)
Traceback (most recent call last):
...
ValueError: Input geometry already has SRID: 1.
</pre> <p>The following input formats, along with their corresponding Python types, are accepted:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Format</th> <th class="head">Input Type</th> </tr> </thead>  <tr>
<td>WKT / EWKT</td> <td><code>str</code></td> </tr> <tr>
<td>HEX / HEXEWKB</td> <td><code>str</code></td> </tr> <tr>
<td>WKB / EWKB</td> <td><code>memoryview</code></td> </tr> <tr>
<td><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7946.html" id="index-1"><strong>GeoJSON</strong></a></td> <td><code>str</code></td> </tr>  </table> <p>For the GeoJSON format, the SRID is set based on the <code>crs</code> member. If <code>crs</code> isn’t provided, the SRID defaults to 4326.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.from_gml">
<code>classmethod GEOSGeometry.from_gml(gml_string)</code> </dt> <dd>
<p>Constructs a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> from the given GML string.</p> </dd>
</dl>  <h4 id="properties">Properties</h4> <dl class="py attribute" id="s-properties"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.coords">
<code>GEOSGeometry.coords</code> </dt> <dd>
<p>Returns the coordinates of the geometry as a tuple.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.dims">
<code>GEOSGeometry.dims</code> </dt> <dd>
<p>Returns the dimension of the geometry:</p> <ul class="simple"> <li>
<code>0</code> for <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a>s and <a class="reference internal" href="#django.contrib.gis.geos.MultiPoint" title="django.contrib.gis.geos.MultiPoint"><code>MultiPoint</code></a>s</li> <li>
<code>1</code> for <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a>s and <a class="reference internal" href="#django.contrib.gis.geos.MultiLineString" title="django.contrib.gis.geos.MultiLineString"><code>MultiLineString</code></a>s</li> <li>
<code>2</code> for <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a>s and <a class="reference internal" href="#django.contrib.gis.geos.MultiPolygon" title="django.contrib.gis.geos.MultiPolygon"><code>MultiPolygon</code></a>s</li> <li>
<code>-1</code> for empty <a class="reference internal" href="#django.contrib.gis.geos.GeometryCollection" title="django.contrib.gis.geos.GeometryCollection"><code>GeometryCollection</code></a>s</li> <li>the maximum dimension of its elements for non-empty <a class="reference internal" href="#django.contrib.gis.geos.GeometryCollection" title="django.contrib.gis.geos.GeometryCollection"><code>GeometryCollection</code></a>s</li> </ul> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.empty">
<code>GEOSGeometry.empty</code> </dt> <dd>
<p>Returns whether or not the set of points in the geometry is empty.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.geom_type">
<code>GEOSGeometry.geom_type</code> </dt> <dd>
<p>Returns a string corresponding to the type of geometry. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt = GEOSGeometry("POINT(5 23)")
&gt;&gt;&gt; pnt.geom_type
'Point'
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.geom_typeid">
<code>GEOSGeometry.geom_typeid</code> </dt> <dd>
<p>Returns the GEOS geometry type identification number. The following table shows the value for each geometry type:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Geometry</th> <th class="head">ID</th> </tr> </thead>  <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a></td> <td>0</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a></td> <td>1</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.LinearRing" title="django.contrib.gis.geos.LinearRing"><code>LinearRing</code></a></td> <td>2</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a></td> <td>3</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.MultiPoint" title="django.contrib.gis.geos.MultiPoint"><code>MultiPoint</code></a></td> <td>4</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.MultiLineString" title="django.contrib.gis.geos.MultiLineString"><code>MultiLineString</code></a></td> <td>5</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.MultiPolygon" title="django.contrib.gis.geos.MultiPolygon"><code>MultiPolygon</code></a></td> <td>6</td> </tr> <tr>
<td><a class="reference internal" href="#django.contrib.gis.geos.GeometryCollection" title="django.contrib.gis.geos.GeometryCollection"><code>GeometryCollection</code></a></td> <td>7</td> </tr>  </table> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.num_coords">
<code>GEOSGeometry.num_coords</code> </dt> <dd>
<p>Returns the number of coordinates in the geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.num_geom">
<code>GEOSGeometry.num_geom</code> </dt> <dd>
<p>Returns the number of geometries in this geometry. In other words, will return 1 on anything but geometry collections.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.hasz">
<code>GEOSGeometry.hasz</code> </dt> <dd>
<p>Returns a boolean indicating whether the geometry is three-dimensional.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.ring">
<code>GEOSGeometry.ring</code> </dt> <dd>
<p>Returns a boolean indicating whether the geometry is a <code>LinearRing</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.simple">
<code>GEOSGeometry.simple</code> </dt> <dd>
<p>Returns a boolean indicating whether the geometry is ‘simple’. A geometry is simple if and only if it does not intersect itself (except at boundary points). For example, a <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> object is not simple if it intersects itself. Thus, <a class="reference internal" href="#django.contrib.gis.geos.LinearRing" title="django.contrib.gis.geos.LinearRing"><code>LinearRing</code></a> and <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> objects are always simple because they do cannot intersect themselves, by definition.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.valid">
<code>GEOSGeometry.valid</code> </dt> <dd>
<p>Returns a boolean indicating whether the geometry is valid.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.valid_reason">
<code>GEOSGeometry.valid_reason</code> </dt> <dd>
<p>Returns a string describing the reason why a geometry is invalid.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.srid">
<code>GEOSGeometry.srid</code> </dt> <dd>
<p>Property that may be used to retrieve or set the SRID associated with the geometry. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt = Point(5, 23)
&gt;&gt;&gt; print(pnt.srid)
None
&gt;&gt;&gt; pnt.srid = 4326
&gt;&gt;&gt; pnt.srid
4326
</pre> </dd>
</dl>   <h4 id="output-properties">Output Properties</h4> <p id="s-output-properties">The properties in this section export the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> object into a different. This output may be in the form of a string, buffer, or even another object.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.ewkt">
<code>GEOSGeometry.ewkt</code> </dt> <dd>
<p>Returns the “extended” Well-Known Text of the geometry. This representation is specific to PostGIS and is a superset of the OGC WKT standard. <a class="footnote-reference" href="#fnogc" id="id5">[1]</a> Essentially the SRID is prepended to the WKT representation, for example <code>SRID=4326;POINT(5 23)</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The output from this property does not include the 3dm, 3dz, and 4d information that PostGIS supports in its EWKT representations.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.hex">
<code>GEOSGeometry.hex</code> </dt> <dd>
<p>Returns the WKB of this Geometry in hexadecimal form. Please note that the SRID value is not included in this representation because it is not a part of the OGC specification (use the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.hexewkb" title="django.contrib.gis.geos.GEOSGeometry.hexewkb"><code>GEOSGeometry.hexewkb</code></a> property instead).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.hexewkb">
<code>GEOSGeometry.hexewkb</code> </dt> <dd>
<p>Returns the EWKB of this Geometry in hexadecimal form. This is an extension of the WKB specification that includes the SRID value that are a part of this geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.json">
<code>GEOSGeometry.json</code> </dt> <dd>
<p>Returns the GeoJSON representation of the geometry. Note that the result is not a complete GeoJSON structure but only the <code>geometry</code> key content of a GeoJSON structure. See also <a class="reference internal" href="serializers.html"><span class="doc">GeoJSON Serializer</span></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.geojson">
<code>GEOSGeometry.geojson</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.json" title="django.contrib.gis.geos.GEOSGeometry.json"><code>GEOSGeometry.json</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.kml">
<code>GEOSGeometry.kml</code> </dt> <dd>
<p>Returns a <a class="reference external" href="https://developers.google.com/kml/documentation/">KML</a> (Keyhole Markup Language) representation of the geometry. This should only be used for geometries with an SRID of 4326 (WGS84), but this restriction is not enforced.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.ogr">
<code>GEOSGeometry.ogr</code> </dt> <dd>
<p>Returns an <a class="reference internal" href="gdal.html#django.contrib.gis.gdal.OGRGeometry" title="django.contrib.gis.gdal.OGRGeometry"><code>OGRGeometry</code></a> object corresponding to the GEOS geometry.</p> </dd>
</dl> <dl class="py attribute" id="wkb"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.wkb">
<code>GEOSGeometry.wkb</code> </dt> <dd>
<p>Returns the WKB (Well-Known Binary) representation of this Geometry as a Python buffer. SRID value is not included, use the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.ewkb" title="django.contrib.gis.geos.GEOSGeometry.ewkb"><code>GEOSGeometry.ewkb</code></a> property instead.</p> </dd>
</dl> <dl class="py attribute" id="ewkb"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.ewkb">
<code>GEOSGeometry.ewkb</code> </dt> <dd>
<p>Return the EWKB representation of this Geometry as a Python buffer. This is an extension of the WKB specification that includes any SRID value that are a part of this geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.wkt">
<code>GEOSGeometry.wkt</code> </dt> <dd>
<p>Returns the Well-Known Text of the geometry (an OGC standard).</p> </dd>
</dl>   <h4 id="spatial-predicate-methods">Spatial Predicate Methods</h4> <p id="s-spatial-predicate-methods">All of the following spatial predicate methods take another <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> instance (<code>other</code>) as a parameter, and return a boolean.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.contains">
<code>GEOSGeometry.contains(other)</code> </dt> <dd>
<p>Returns <code>True</code> if <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.within" title="django.contrib.gis.geos.GEOSGeometry.within"><code>other.within(this)</code></a> returns <code>True</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.covers">
<code>GEOSGeometry.covers(other)</code> </dt> <dd>
<p>Returns <code>True</code> if this geometry covers the specified geometry.</p> <p>The <code>covers</code> predicate has the following equivalent definitions:</p> <ul class="simple"> <li>Every point of the other geometry is a point of this geometry.</li> <li>The <a class="reference external" href="https://en.wikipedia.org/wiki/DE-9IM">DE-9IM</a> Intersection Matrix for the two geometries is <code>T*****FF*</code>, <code>*T****FF*</code>, <code>***T**FF*</code>, or <code>****T*FF*</code>.</li> </ul> <p>If either geometry is empty, returns <code>False</code>.</p> <p>This predicate is similar to <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.contains" title="django.contrib.gis.geos.GEOSGeometry.contains"><code>GEOSGeometry.contains()</code></a>, but is more inclusive (i.e. returns <code>True</code> for more cases). In particular, unlike <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.contains" title="django.contrib.gis.geos.GEOSGeometry.contains"><code>contains()</code></a> it does not distinguish between points in the boundary and in the interior of geometries. For most situations, <code>covers()</code> should be preferred to <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.contains" title="django.contrib.gis.geos.GEOSGeometry.contains"><code>contains()</code></a>. As an added benefit, <code>covers()</code> is more amenable to optimization and hence should outperform <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.contains" title="django.contrib.gis.geos.GEOSGeometry.contains"><code>contains()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.crosses">
<code>GEOSGeometry.crosses(other)</code> </dt> <dd>
<p>Returns <code>True</code> if the DE-9IM intersection matrix for the two Geometries is <code>T*T******</code> (for a point and a curve,a point and an area or a line and an area) <code>0********</code> (for two curves).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.disjoint">
<code>GEOSGeometry.disjoint(other)</code> </dt> <dd>
<p>Returns <code>True</code> if the DE-9IM intersection matrix for the two geometries is <code>FF*FF****</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.equals">
<code>GEOSGeometry.equals(other)</code> </dt> <dd>
<p>Returns <code>True</code> if the DE-9IM intersection matrix for the two geometries is <code>T*F**FFF*</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.equals_exact">
<code>GEOSGeometry.equals_exact(other, tolerance=0)</code> </dt> <dd>
<p>Returns true if the two geometries are exactly equal, up to a specified tolerance. The <code>tolerance</code> value should be a floating point number representing the error tolerance in the comparison, e.g., <code>poly1.equals_exact(poly2, 0.001)</code> will compare equality to within one thousandth of a unit.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.intersects">
<code>GEOSGeometry.intersects(other)</code> </dt> <dd>
<p>Returns <code>True</code> if <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.disjoint" title="django.contrib.gis.geos.GEOSGeometry.disjoint"><code>GEOSGeometry.disjoint()</code></a> is <code>False</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.overlaps">
<code>GEOSGeometry.overlaps(other)</code> </dt> <dd>
<p>Returns true if the DE-9IM intersection matrix for the two geometries is <code>T*T***T**</code> (for two points or two surfaces) <code>1*T***T**</code> (for two curves).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.relate_pattern">
<code>GEOSGeometry.relate_pattern(other, pattern)</code> </dt> <dd>
<p>Returns <code>True</code> if the elements in the DE-9IM intersection matrix for this geometry and the other matches the given <code>pattern</code> – a string of nine characters from the alphabet: {<code>T</code>, <code>F</code>, <code>*</code>, <code>0</code>}.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.touches">
<code>GEOSGeometry.touches(other)</code> </dt> <dd>
<p>Returns <code>True</code> if the DE-9IM intersection matrix for the two geometries is <code>FT*******</code>, <code>F**T*****</code> or <code>F***T****</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.within">
<code>GEOSGeometry.within(other)</code> </dt> <dd>
<p>Returns <code>True</code> if the DE-9IM intersection matrix for the two geometries is <code>T*F**F***</code>.</p> </dd>
</dl>   <h4 id="topological-methods">Topological Methods</h4> <dl class="py method" id="s-topological-methods"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.buffer">
<code>GEOSGeometry.buffer(width, quadsegs=8)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> that represents all points whose distance from this geometry is less than or equal to the given <code>width</code>. The optional <code>quadsegs</code> keyword sets the number of segments used to approximate a quarter circle (defaults is 8).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.buffer_with_style">
<code>GEOSGeometry.buffer_with_style(width, quadsegs=8, end_cap_style=1, join_style=1, mitre_limit=5.0)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.buffer" title="django.contrib.gis.geos.GEOSGeometry.buffer"><code>buffer()</code></a>, but allows customizing the style of the buffer.</p> <ul class="simple"> <li>
<code>end_cap_style</code> can be round (<code>1</code>), flat (<code>2</code>), or square (<code>3</code>).</li> <li>
<code>join_style</code> can be round (<code>1</code>), mitre (<code>2</code>), or bevel (<code>3</code>).</li> <li>Mitre ratio limit (<code>mitre_limit</code>) only affects mitered join style.</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.difference">
<code>GEOSGeometry.difference(other)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> representing the points making up this geometry that do not make up other.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.interpolate">
<code>GEOSGeometry.interpolate(distance)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.interpolate_normalized">
<code>GEOSGeometry.interpolate_normalized(distance)</code> </dt> <dd>
<p>Given a distance (float), returns the point (or closest point) within the geometry (<a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> or <a class="reference internal" href="#django.contrib.gis.geos.MultiLineString" title="django.contrib.gis.geos.MultiLineString"><code>MultiLineString</code></a>) at that distance. The normalized version takes the distance as a float between 0 (origin) and 1 (endpoint).</p> <p>Reverse of <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.project" title="django.contrib.gis.geos.GEOSGeometry.project"><code>GEOSGeometry.project()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.intersection">
<code>GEOSGeometry.intersection(other)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> representing the points shared by this geometry and other.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.project">
<code>GEOSGeometry.project(point)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.project_normalized">
<code>GEOSGeometry.project_normalized(point)</code> </dt> <dd>
<p>Returns the distance (float) from the origin of the geometry (<a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> or <a class="reference internal" href="#django.contrib.gis.geos.MultiLineString" title="django.contrib.gis.geos.MultiLineString"><code>MultiLineString</code></a>) to the point projected on the geometry (that is to a point of the line the closest to the given point). The normalized version returns the distance as a float between 0 (origin) and 1 (endpoint).</p> <p>Reverse of <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.interpolate" title="django.contrib.gis.geos.GEOSGeometry.interpolate"><code>GEOSGeometry.interpolate()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.relate">
<code>GEOSGeometry.relate(other)</code> </dt> <dd>
<p>Returns the DE-9IM intersection matrix (a string) representing the topological relationship between this geometry and the other.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.simplify">
<code>GEOSGeometry.simplify(tolerance=0.0, preserve_topology=False)</code> </dt> <dd>
<p>Returns a new <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a>, simplified to the specified tolerance using the Douglas-Peucker algorithm. A higher tolerance value implies fewer points in the output. If no tolerance is provided, it defaults to 0.</p> <p>By default, this function does not preserve topology. For example, <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> objects can be split, be collapsed into lines, or disappear. <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> holes can be created or disappear, and lines may cross. By specifying <code>preserve_topology=True</code>, the result will have the same dimension and number of components as the input; this is significantly slower, however.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.sym_difference">
<code>GEOSGeometry.sym_difference(other)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> combining the points in this geometry not in other, and the points in other not in this geometry.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.union">
<code>GEOSGeometry.union(other)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> representing all the points in this geometry and the other.</p> </dd>
</dl>   <h4 id="topological-properties">Topological Properties</h4> <dl class="py attribute" id="s-topological-properties"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.boundary">
<code>GEOSGeometry.boundary</code> </dt> <dd>
<p>Returns the boundary as a newly allocated Geometry object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.centroid">
<code>GEOSGeometry.centroid</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> object representing the geometric center of the geometry. The point is not guaranteed to be on the interior of the geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.convex_hull">
<code>GEOSGeometry.convex_hull</code> </dt> <dd>
<p>Returns the smallest <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> that contains all the points in the geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.envelope">
<code>GEOSGeometry.envelope</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> that represents the bounding envelope of this geometry. Note that it can also return a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> if the input geometry is a point.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.point_on_surface">
<code>GEOSGeometry.point_on_surface</code> </dt> <dd>
<p>Computes and returns a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> guaranteed to be on the interior of this geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.unary_union">
<code>GEOSGeometry.unary_union</code> </dt> <dd>
<p>Computes the union of all the elements of this geometry.</p> <p>The result obeys the following contract:</p> <ul class="simple"> <li>Unioning a set of <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a>s has the effect of fully noding and dissolving the linework.</li> <li>Unioning a set of <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a>s will always return a <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> or <a class="reference internal" href="#django.contrib.gis.geos.MultiPolygon" title="django.contrib.gis.geos.MultiPolygon"><code>MultiPolygon</code></a> geometry (unlike <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.union" title="django.contrib.gis.geos.GEOSGeometry.union"><code>GEOSGeometry.union()</code></a>, which may return geometries of lower dimension if a topology collapse occurs).</li> </ul> </dd>
</dl>   <h4 id="other-properties-methods">Other Properties &amp; Methods</h4> <dl class="py attribute" id="s-other-properties-methods"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.area">
<code>GEOSGeometry.area</code> </dt> <dd>
<p>This property returns the area of the Geometry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.extent">
<code>GEOSGeometry.extent</code> </dt> <dd>
<p>This property returns the extent of this geometry as a 4-tuple, consisting of <code>(xmin, ymin, xmax, ymax)</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.clone">
<code>GEOSGeometry.clone()</code> </dt> <dd>
<p>This method returns a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> that is a clone of the original.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.distance">
<code>GEOSGeometry.distance(geom)</code> </dt> <dd>
<p>Returns the distance between the closest points on this geometry and the given <code>geom</code> (another <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> object).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">GEOS distance calculations are linear – in other words, GEOS does not perform a spherical calculation even if the SRID specifies a geographic coordinate system.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.length">
<code>GEOSGeometry.length</code> </dt> <dd>
<p>Returns the length of this geometry (e.g., 0 for a <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a>, the length of a <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a>, or the circumference of a <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a>).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.prepared">
<code>GEOSGeometry.prepared</code> </dt> <dd>
<p>Returns a GEOS <code>PreparedGeometry</code> for the contents of this geometry. <code>PreparedGeometry</code> objects are optimized for the contains, intersects, covers, crosses, disjoint, overlaps, touches and within operations. Refer to the <a class="reference internal" href="#prepared-geometries"><span class="std std-ref">Prepared Geometries</span></a> documentation for more information.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.srs">
<code>GEOSGeometry.srs</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="gdal.html#django.contrib.gis.gdal.SpatialReference" title="django.contrib.gis.gdal.SpatialReference"><code>SpatialReference</code></a> object corresponding to the SRID of the geometry or <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.transform">
<code>GEOSGeometry.transform(ct, clone=False)</code> </dt> <dd>
<p>Transforms the geometry according to the given coordinate transformation parameter (<code>ct</code>), which may be an integer SRID, spatial reference WKT string, a PROJ string, a <a class="reference internal" href="gdal.html#django.contrib.gis.gdal.SpatialReference" title="django.contrib.gis.gdal.SpatialReference"><code>SpatialReference</code></a> object, or a <a class="reference internal" href="gdal.html#django.contrib.gis.gdal.CoordTransform" title="django.contrib.gis.gdal.CoordTransform"><code>CoordTransform</code></a> object. By default, the geometry is transformed in-place and nothing is returned. However if the <code>clone</code> keyword is set, then the geometry is not modified and a transformed clone of the geometry is returned instead.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Raises <a class="reference internal" href="#django.contrib.gis.geos.GEOSException" title="django.contrib.gis.geos.GEOSException"><code>GEOSException</code></a> if GDAL is not available or if the geometry’s SRID is <code>None</code> or less than 0. It doesn’t impose any constraints on the geometry’s SRID if called with a <a class="reference internal" href="gdal.html#django.contrib.gis.gdal.CoordTransform" title="django.contrib.gis.gdal.CoordTransform"><code>CoordTransform</code></a> object.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.make_valid">
<code>GEOSGeometry.make_valid()</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.1.</span> </div> <p>Returns a valid <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> equivalent, trying not to lose any of the input vertices. If the geometry is already valid, it is returned untouched. This is similar to the <a class="reference internal" href="functions.html#django.contrib.gis.db.models.functions.MakeValid" title="django.contrib.gis.db.models.functions.MakeValid"><code>MakeValid</code></a> database function. Requires GEOS 3.8.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSGeometry.normalize">
<code>GEOSGeometry.normalize(clone=False)</code> </dt> <dd>
<p>Converts this geometry to canonical form. If the <code>clone</code> keyword is set, then the geometry is not modified and a normalized clone of the geometry is returned instead:</p> <pre data-language="pycon">&gt;&gt;&gt; g = MultiPoint(Point(0, 0), Point(2, 2), Point(1, 1))
&gt;&gt;&gt; print(g)
MULTIPOINT (0 0, 2 2, 1 1)
&gt;&gt;&gt; g.normalize()
&gt;&gt;&gt; print(g)
MULTIPOINT (2 2, 1 1, 0 0)
</pre> <div class="versionchanged"> <span class="title">Changed in Django 4.1:</span> <p>The <code>clone</code> argument was added.</p> </div> </dd>
</dl>    <h3 id="point"><code>Point</code></h3> <dl class="py class" id="s-point"> <dt class="sig sig-object py" id="django.contrib.gis.geos.Point">
<code>class Point(x=None, y=None, z=None, srid=None)</code> </dt> <dd>
<p><code>Point</code> objects are instantiated using arguments that represent the component coordinates of the point or with a single sequence coordinates. For example, the following are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt = Point(5, 23)
&gt;&gt;&gt; pnt = Point([5, 23])
</pre> <p>Empty <code>Point</code> objects may be instantiated by passing no arguments or an empty sequence. The following are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; pnt = Point()
&gt;&gt;&gt; pnt = Point([])
</pre> </dd>
</dl>   <h3 id="linestring"><code>LineString</code></h3> <dl class="py class" id="s-linestring"> <dt class="sig sig-object py" id="django.contrib.gis.geos.LineString">
<code>class LineString(*args, **kwargs)</code> </dt> <dd>
<p><code>LineString</code> objects are instantiated using arguments that are either a sequence of coordinates or <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> objects. For example, the following are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; ls = LineString((0, 0), (1, 1))
&gt;&gt;&gt; ls = LineString(Point(0, 0), Point(1, 1))
</pre> <p>In addition, <code>LineString</code> objects may also be created by passing in a single sequence of coordinate or <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> objects:</p> <pre data-language="pycon">&gt;&gt;&gt; ls = LineString(((0, 0), (1, 1)))
&gt;&gt;&gt; ls = LineString([Point(0, 0), Point(1, 1)])
</pre> <p>Empty <code>LineString</code> objects may be instantiated by passing no arguments or an empty sequence. The following are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; ls = LineString()
&gt;&gt;&gt; ls = LineString([])
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.LineString.closed">
<code>closed</code> </dt> <dd>
<p>Returns whether or not this <code>LineString</code> is closed.</p> </dd>
</dl> </dd>
</dl>   <h3 id="linearring"><code>LinearRing</code></h3> <dl class="py class" id="s-linearring"> <dt class="sig sig-object py" id="django.contrib.gis.geos.LinearRing">
<code>class LinearRing(*args, **kwargs)</code> </dt> <dd>
<p><code>LinearRing</code> objects are constructed in the exact same way as <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> objects, however the coordinates must be <em>closed</em>, in other words, the first coordinates must be the same as the last coordinates. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; ls = LinearRing((0, 0), (0, 1), (1, 1), (0, 0))
</pre> <p>Notice that <code>(0, 0)</code> is the first and last coordinate – if they were not equal, an error would be raised.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.LinearRing.is_counterclockwise">
<code>is_counterclockwise</code> </dt> <dd>
<p>Returns whether this <code>LinearRing</code> is counterclockwise.</p> </dd>
</dl> </dd>
</dl>   <h3 id="polygon"><code>Polygon</code></h3> <dl class="py class" id="s-polygon"> <dt class="sig sig-object py" id="django.contrib.gis.geos.Polygon">
<code>class Polygon(*args, **kwargs)</code> </dt> <dd>
<p><code>Polygon</code> objects may be instantiated by passing in parameters that represent the rings of the polygon. The parameters must either be <a class="reference internal" href="#django.contrib.gis.geos.LinearRing" title="django.contrib.gis.geos.LinearRing"><code>LinearRing</code></a> instances, or a sequence that may be used to construct a <a class="reference internal" href="#django.contrib.gis.geos.LinearRing" title="django.contrib.gis.geos.LinearRing"><code>LinearRing</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; ext_coords = ((0, 0), (0, 1), (1, 1), (1, 0), (0, 0))
&gt;&gt;&gt; int_coords = ((0.4, 0.4), (0.4, 0.6), (0.6, 0.6), (0.6, 0.4), (0.4, 0.4))
&gt;&gt;&gt; poly = Polygon(ext_coords, int_coords)
&gt;&gt;&gt; poly = Polygon(LinearRing(ext_coords), LinearRing(int_coords))
</pre> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.Polygon.from_bbox">
<code>classmethod from_bbox(bbox)</code> </dt> <dd>
<p>Returns a polygon object from the given bounding-box, a 4-tuple comprising <code>(xmin, ymin, xmax, ymax)</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.Polygon.num_interior_rings">
<code>num_interior_rings</code> </dt> <dd>
<p>Returns the number of interior rings in this geometry.</p> </dd>
</dl> </dd>
</dl> <div class="admonition-comparing-polygons admonition"> <p class="first admonition-title">Comparing Polygons</p> <p>Note that it is possible to compare <code>Polygon</code> objects directly with <code>&lt;</code> or <code>&gt;</code>, but as the comparison is made through Polygon’s <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a>, it does not mean much (but is consistent and quick). You can always force the comparison with the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.area" title="django.contrib.gis.geos.GEOSGeometry.area"><code>area</code></a> property:</p> <pre data-language="pycon">&gt;&gt;&gt; if poly_1.area &gt; poly_2.area:
...     pass
...
</pre> </div>    <h2 id="geos-geometry-collections">Geometry Collections</h2>  <h3 id="multipoint"><code>MultiPoint</code></h3> <dl class="py class" id="s-geometry-collections"> <dt class="sig sig-object py" id="django.contrib.gis.geos.MultiPoint">
<code>class MultiPoint(*args, **kwargs)</code> </dt> <dd>
<p><code>MultiPoint</code> objects may be instantiated by passing in <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> objects as arguments, or a single sequence of <a class="reference internal" href="#django.contrib.gis.geos.Point" title="django.contrib.gis.geos.Point"><code>Point</code></a> objects:</p> <pre data-language="pycon">&gt;&gt;&gt; mp = MultiPoint(Point(0, 0), Point(1, 1))
&gt;&gt;&gt; mp = MultiPoint((Point(0, 0), Point(1, 1)))
</pre> </dd>
</dl>   <h3 id="multilinestring"><code>MultiLineString</code></h3> <dl class="py class" id="s-multilinestring"> <dt class="sig sig-object py" id="django.contrib.gis.geos.MultiLineString">
<code>class MultiLineString(*args, **kwargs)</code> </dt> <dd>
<p><code>MultiLineString</code> objects may be instantiated by passing in <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> objects as arguments, or a single sequence of <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> objects:</p> <pre data-language="pycon">&gt;&gt;&gt; ls1 = LineString((0, 0), (1, 1))
&gt;&gt;&gt; ls2 = LineString((2, 2), (3, 3))
&gt;&gt;&gt; mls = MultiLineString(ls1, ls2)
&gt;&gt;&gt; mls = MultiLineString([ls1, ls2])
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.MultiLineString.merged">
<code>merged</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#django.contrib.gis.geos.LineString" title="django.contrib.gis.geos.LineString"><code>LineString</code></a> representing the line merge of all the components in this <code>MultiLineString</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.MultiLineString.closed">
<code>closed</code> </dt> <dd>
<p>Returns <code>True</code> if and only if all elements are closed.</p> </dd>
</dl> </dd>
</dl>   <h3 id="multipolygon"><code>MultiPolygon</code></h3> <dl class="py class" id="s-multipolygon"> <dt class="sig sig-object py" id="django.contrib.gis.geos.MultiPolygon">
<code>class MultiPolygon(*args, **kwargs)</code> </dt> <dd>
<p><code>MultiPolygon</code> objects may be instantiated by passing <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> objects as arguments, or a single sequence of <a class="reference internal" href="#django.contrib.gis.geos.Polygon" title="django.contrib.gis.geos.Polygon"><code>Polygon</code></a> objects:</p> <pre data-language="pycon">&gt;&gt;&gt; p1 = Polygon(((0, 0), (0, 1), (1, 1), (0, 0)))
&gt;&gt;&gt; p2 = Polygon(((1, 1), (1, 2), (2, 2), (1, 1)))
&gt;&gt;&gt; mp = MultiPolygon(p1, p2)
&gt;&gt;&gt; mp = MultiPolygon([p1, p2])
</pre> </dd>
</dl>   <h3 id="geometrycollection"><code>GeometryCollection</code></h3> <dl class="py class" id="s-geometrycollection"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GeometryCollection">
<code>class GeometryCollection(*args, **kwargs)</code> </dt> <dd>
<p><code>GeometryCollection</code> objects may be instantiated by passing in other <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> as arguments, or a single sequence of <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> objects:</p> <pre data-language="pycon">&gt;&gt;&gt; poly = Polygon(((0, 0), (0, 1), (1, 1), (0, 0)))
&gt;&gt;&gt; gc = GeometryCollection(Point(0, 0), MultiPoint(Point(0, 0), Point(1, 1)), poly)
&gt;&gt;&gt; gc = GeometryCollection((Point(0, 0), MultiPoint(Point(0, 0), Point(1, 1)), poly))
</pre> </dd>
</dl>    <h2 id="id7">Prepared Geometries</h2> <p id="s-prepared-geometries">In order to obtain a prepared geometry, access the <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry.prepared" title="django.contrib.gis.geos.GEOSGeometry.prepared"><code>GEOSGeometry.prepared</code></a> property. Once you have a <code>PreparedGeometry</code> instance its spatial predicate methods, listed below, may be used with other <code>GEOSGeometry</code> objects. An operation with a prepared geometry can be orders of magnitude faster – the more complex the geometry that is prepared, the larger the speedup in the operation. For more information, please consult the <a class="reference external" href="https://trac.osgeo.org/geos/wiki/PreparedGeometry">GEOS wiki page on prepared geometries</a>.</p> <p>For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, Polygon
&gt;&gt;&gt; poly = Polygon.from_bbox((0, 0, 5, 5))
&gt;&gt;&gt; prep_poly = poly.prepared
&gt;&gt;&gt; prep_poly.contains(Point(2.5, 2.5))
True
</pre>  <h3 id="preparedgeometry"><code>PreparedGeometry</code></h3> <dl class="py class" id="s-preparedgeometry"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry">
<code>class PreparedGeometry</code> </dt> <dd>
<p>All methods on <code>PreparedGeometry</code> take an <code>other</code> argument, which must be a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> instance.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.contains">
<code>contains(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.contains_properly">
<code>contains_properly(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.covers">
<code>covers(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.crosses">
<code>crosses(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.disjoint">
<code>disjoint(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.intersects">
<code>intersects(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.overlaps">
<code>overlaps(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.touches">
<code>touches(other)</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.PreparedGeometry.within">
<code>within(other)</code> </dt> 
</dl> </dd>
</dl>    <h2 id="geometry-factories">Geometry Factories</h2> <dl class="py function" id="s-geometry-factories"> <dt class="sig sig-object py" id="django.contrib.gis.geos.fromfile">
<code>fromfile(file_h)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>file_h</strong> (a Python <code>file</code> object or a string path to the file) – input file that contains spatial data</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> corresponding to the spatial data in the file</td> </tr>  </table> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import fromfile
&gt;&gt;&gt; g = fromfile("/home/bob/geom.wkt")
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.gis.geos.fromstr">
<code>fromstr(string, srid=None)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>string</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>) – string that contains spatial data</li> <li>
<strong>srid</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a>) – spatial reference identifier</li> </ul> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> corresponding to the spatial data in the string</p> </td> </tr>  </table> <p><code>fromstr(string, srid)</code> is equivalent to <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry(string, srid)</code></a>.</p> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import fromstr
&gt;&gt;&gt; pnt = fromstr("POINT(-90.5 29.5)", srid=4326)
</pre> </dd>
</dl>   <h2 id="i-o-objects">I/O Objects</h2>  <h3 id="reader-objects">Reader Objects</h3> <p id="s-i-o-objects">The reader I/O classes return a <a class="reference internal" href="#django.contrib.gis.geos.GEOSGeometry" title="django.contrib.gis.geos.GEOSGeometry"><code>GEOSGeometry</code></a> instance from the WKB and/or WKT input given to their <code>read(geom)</code> method.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBReader">
<code>class WKBReader</code> </dt> <dd>
<p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import WKBReader
&gt;&gt;&gt; wkb_r = WKBReader()
&gt;&gt;&gt; wkb_r.read("0101000000000000000000F03F000000000000F03F")
&lt;Point object at 0x103a88910&gt;
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTReader">
<code>class WKTReader</code> </dt> <dd>
<p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import WKTReader
&gt;&gt;&gt; wkt_r = WKTReader()
&gt;&gt;&gt; wkt_r.read("POINT(1 1)")
&lt;Point object at 0x103a88b50&gt;
</pre> </dd>
</dl>   <h3 id="writer-objects">Writer Objects</h3> <p id="s-writer-objects">All writer objects have a <code>write(geom)</code> method that returns either the WKB or WKT of the given geometry. In addition, <a class="reference internal" href="#django.contrib.gis.geos.WKBWriter" title="django.contrib.gis.geos.WKBWriter"><code>WKBWriter</code></a> objects also have properties that may be used to change the byte order, and or include the SRID value (in other words, EWKB).</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter">
<code>class WKBWriter(dim=2)</code> </dt> <dd>
<p><code>WKBWriter</code> provides the most control over its output. By default it returns OGC-compliant WKB when its <code>write</code> method is called. However, it has properties that allow for the creation of EWKB, a superset of the WKB standard that includes additional information. See the <a class="reference internal" href="#django.contrib.gis.geos.WKBWriter.outdim" title="django.contrib.gis.geos.WKBWriter.outdim"><code>WKBWriter.outdim</code></a> documentation for more details about the <code>dim</code> argument.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter.write">
<code>write(geom)</code> </dt> 
</dl> <p>Returns the WKB of the given geometry as a Python <code>buffer</code> object. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKBWriter
&gt;&gt;&gt; pnt = Point(1, 1)
&gt;&gt;&gt; wkb_w = WKBWriter()
&gt;&gt;&gt; wkb_w.write(pnt)
&lt;read-only buffer for 0x103a898f0, size -1, offset 0 at 0x103a89930&gt;
</pre> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter.write_hex">
<code>write_hex(geom)</code> </dt> 
</dl> <p>Returns WKB of the geometry in hexadecimal. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKBWriter
&gt;&gt;&gt; pnt = Point(1, 1)
&gt;&gt;&gt; wkb_w = WKBWriter()
&gt;&gt;&gt; wkb_w.write_hex(pnt)
'0101000000000000000000F03F000000000000F03F'
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter.byteorder">
<code>byteorder</code> </dt> 
</dl> <p>This property may be set to change the byte-order of the geometry representation.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Byteorder Value</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td>0</td> <td>Big Endian (e.g., compatible with RISC systems)</td> </tr> <tr>
<td>1</td> <td>Little Endian (e.g., compatible with x86 systems)</td> </tr>  </table> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKBWriter
&gt;&gt;&gt; wkb_w = WKBWriter()
&gt;&gt;&gt; pnt = Point(1, 1)
&gt;&gt;&gt; wkb_w.write_hex(pnt)
'0101000000000000000000F03F000000000000F03F'
&gt;&gt;&gt; wkb_w.byteorder = 0
'00000000013FF00000000000003FF0000000000000'
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter.outdim">
<code>outdim</code> </dt> 
</dl> <p>This property may be set to change the output dimension of the geometry representation. In other words, if you have a 3D geometry then set to 3 so that the Z value is included in the WKB.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Outdim Value</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td>2</td> <td>The default, output 2D WKB.</td> </tr> <tr>
<td>3</td> <td>Output 3D WKB.</td> </tr>  </table> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKBWriter
&gt;&gt;&gt; wkb_w = WKBWriter()
&gt;&gt;&gt; wkb_w.outdim
2
&gt;&gt;&gt; pnt = Point(1, 1, 1)
&gt;&gt;&gt; wkb_w.write_hex(pnt)  # By default, no Z value included:
'0101000000000000000000F03F000000000000F03F'
&gt;&gt;&gt; wkb_w.outdim = 3  # Tell writer to include Z values
&gt;&gt;&gt; wkb_w.write_hex(pnt)
'0101000080000000000000F03F000000000000F03F000000000000F03F'
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKBWriter.srid">
<code>srid</code> </dt> 
</dl> <p>Set this property with a boolean to indicate whether the SRID of the geometry should be included with the WKB representation. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKBWriter
&gt;&gt;&gt; wkb_w = WKBWriter()
&gt;&gt;&gt; pnt = Point(1, 1, srid=4326)
&gt;&gt;&gt; wkb_w.write_hex(pnt)  # By default, no SRID included:
'0101000000000000000000F03F000000000000F03F'
&gt;&gt;&gt; wkb_w.srid = True  # Tell writer to include SRID
&gt;&gt;&gt; wkb_w.write_hex(pnt)
'0101000020E6100000000000000000F03F000000000000F03F'
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTWriter">
<code>class WKTWriter(dim=2, trim=False, precision=None)</code> </dt> <dd>
<p>This class allows outputting the WKT representation of a geometry. See the <a class="reference internal" href="#django.contrib.gis.geos.WKBWriter.outdim" title="django.contrib.gis.geos.WKBWriter.outdim"><code>WKBWriter.outdim</code></a>, <a class="reference internal" href="#django.contrib.gis.geos.WKTWriter.trim" title="django.contrib.gis.geos.WKTWriter.trim"><code>trim</code></a>, and <a class="reference internal" href="#django.contrib.gis.geos.WKTWriter.precision" title="django.contrib.gis.geos.WKTWriter.precision"><code>precision</code></a> attributes for details about the constructor arguments.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTWriter.write">
<code>write(geom)</code> </dt> 
</dl> <p>Returns the WKT of the given geometry. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKTWriter
&gt;&gt;&gt; pnt = Point(1, 1)
&gt;&gt;&gt; wkt_w = WKTWriter()
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1.0000000000000000 1.0000000000000000)'
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTWriter.outdim">
<code>outdim</code> </dt> <dd>
<p>See <a class="reference internal" href="#django.contrib.gis.geos.WKBWriter.outdim" title="django.contrib.gis.geos.WKBWriter.outdim"><code>WKBWriter.outdim</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTWriter.trim">
<code>trim</code> </dt> 
</dl> <p>This property is used to enable or disable trimming of unnecessary decimals.</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKTWriter
&gt;&gt;&gt; pnt = Point(1, 1)
&gt;&gt;&gt; wkt_w = WKTWriter()
&gt;&gt;&gt; wkt_w.trim
False
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1.0000000000000000 1.0000000000000000)'
&gt;&gt;&gt; wkt_w.trim = True
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1 1)'
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.gis.geos.WKTWriter.precision">
<code>precision</code> </dt> 
</dl> <p>This property controls the rounding precision of coordinates; if set to <code>None</code> rounding is disabled.</p> <pre data-language="python">&gt;&gt;&gt; from django.contrib.gis.geos import Point, WKTWriter
&gt;&gt;&gt; pnt = Point(1.44, 1.66)
&gt;&gt;&gt; wkt_w = WKTWriter()
&gt;&gt;&gt; print(wkt_w.precision)
None
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1.4399999999999999 1.6599999999999999)'
&gt;&gt;&gt; wkt_w.precision = 0
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1 2)'
&gt;&gt;&gt; wkt_w.precision = 1
&gt;&gt;&gt; wkt_w.write(pnt)
'POINT (1.4 1.7)'
</pre> </dd>
</dl> <h4 class="rubric">Footnotes</h4> <table class="docutils footnote" frame="void" id="fnogc" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[1]</a></td>
<td>
<em>See</em> <a class="reference external" href="https://postgis.net/docs/using_postgis_dbmanagement.html#EWKB_EWKT">PostGIS EWKB, EWKT and Canonical Forms</a>, PostGIS documentation at Ch. 4.1.2.</td>
</tr>  </table>    <h2 id="settings">Settings</h2>  <h3 id="std:setting-GEOS_LIBRARY_PATH"><code>GEOS_LIBRARY_PATH</code></h3> <p id="s-settings">A string specifying the location of the GEOS C library. Typically, this setting is only used if the GEOS C library is in a non-standard location (e.g., <code>/home/bob/lib/libgeos_c.so</code>).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The setting must be the <em>full</em> path to the <strong>C</strong> shared library; in other words you want to use <code>libgeos_c.so</code>, not <code>libgeos.so</code>.</p> </div>    <h2 id="exceptions">Exceptions</h2> <dl class="py exception" id="s-exceptions"> <dt class="sig sig-object py" id="django.contrib.gis.geos.GEOSException">
<code>exception GEOSException</code> </dt> <dd>
<p>The base GEOS exception, indicates a GEOS-related error.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.2/ref/contrib/gis/geos/" class="_attribution-link">https://docs.djangoproject.com/en/4.2/ref/contrib/gis/geos/</a>
  </p>
</div>
