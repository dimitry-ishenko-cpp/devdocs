<h1 id="class-Time" class="class"> class Time </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="comparable.html">Comparable</a></dd>
</dl> <section class="description"> <p>A <code>Time</code> object represents a date and time:</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0, 0, 0) # =&gt; 2000-01-01 00:00:00 -0600
</pre> <p>Although its value can be expressed as a single numeric (see <a href="time.html#class-Time-label-Epoch+Seconds">Epoch Seconds</a> below), it can be convenient to deal with the value by parts:</p> <pre class="ruby" data-language="ruby">t = Time.new(-2000, 1, 1, 0, 0, 0.0)
# =&gt; -2000-01-01 00:00:00 -0600
t.year # =&gt; -2000
t.month # =&gt; 1
t.mday # =&gt; 1
t.hour # =&gt; 0
t.min # =&gt; 0
t.sec # =&gt; 0
t.subsec # =&gt; 0

t = Time.new(2000, 12, 31, 23, 59, 59.5)
# =&gt; 2000-12-31 23:59:59.5 -0600
t.year # =&gt; 2000
t.month # =&gt; 12
t.mday # =&gt; 31
t.hour # =&gt; 23
t.min # =&gt; 59
t.sec # =&gt; 59
t.subsec # =&gt; (1/2)
</pre> <h2 id="class-Time-label-Epoch+Seconds">Epoch Seconds</h2> <p><em>Epoch seconds</em> is the exact number of seconds (including fractional subseconds) since the Unix Epoch, January 1, 1970.</p> <p>You can retrieve that value exactly using method <a href="time.html#method-i-to_r"><code>Time.to_r</code></a>:</p> <pre class="ruby" data-language="ruby">Time.at(0).to_r        # =&gt; (0/1)
Time.at(0.999999).to_r # =&gt; (9007190247541737/9007199254740992)
</pre> <p>Other retrieval methods such as <a href="time.html#method-i-to_i"><code>Time#to_i</code></a> and <a href="time.html#method-i-to_f"><code>Time#to_f</code></a> may return a value that rounds or truncates subseconds.</p> <h2 id="class-Time-label-Time+Resolution">Time Resolution</h2> <p>A <code>Time</code> object derived from the system clock (for example, by method <a href="time.html#method-c-now"><code>Time.now</code></a>) has the resolution supported by the system.</p> <h2 id="class-Time-label-Examples">Examples</h2> <p>All of these examples were done using the EST timezone which is GMT-5.</p> <h3 id="class-Time-label-Creating+a+New+Time+Instance">Creating a New <code>Time</code> Instance</h3> <p>You can create a new instance of <a href="time.html"><code>Time</code></a> with <a href="time.html#method-c-new"><code>Time.new</code></a>. This will use the current system time. <a href="time.html#method-c-now"><code>Time.now</code></a> is an alias for this. You can also pass parts of the time to <a href="time.html#method-c-new"><code>Time.new</code></a> such as year, month, minute, etc. When you want to construct a time this way you must pass at least a year. If you pass the year with nothing else time will default to January 1 of that year at 00:00:00 with the current system timezone. Here are some examples:</p> <pre class="ruby" data-language="ruby">Time.new(2002)         #=&gt; 2002-01-01 00:00:00 -0500
Time.new(2002, 10)     #=&gt; 2002-10-01 00:00:00 -0500
Time.new(2002, 10, 31) #=&gt; 2002-10-31 00:00:00 -0500
</pre> <p>You can pass a UTC offset:</p> <pre class="ruby" data-language="ruby">Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=&gt; 2002-10-31 02:02:02 +0200
</pre> <p>Or <a href="time.html#class-Time-label-Timezone+Objects">a timezone object</a>:</p> <pre class="ruby" data-language="ruby">zone = timezone("Europe/Athens")      # Eastern European Time, UTC+2
Time.new(2002, 10, 31, 2, 2, 2, zone) #=&gt; 2002-10-31 02:02:02 +0200
</pre> <p>You can also use <a href="time.html#method-c-local"><code>Time.local</code></a> and <a href="time.html#method-c-utc"><code>Time.utc</code></a> to infer local and UTC timezones instead of using the current system setting.</p> <p>You can also create a new time using <a href="time.html#method-c-at"><code>Time.at</code></a> which takes the number of seconds (with subsecond) since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix Epoch</a>.</p> <pre class="ruby" data-language="ruby">Time.at(628232400) #=&gt; 1989-11-28 00:00:00 -0500
</pre> <h3 id="class-Time-label-Working+with+an+Instance+of+Time">Working with an Instance of <code>Time</code>
</h3> <p>Once you have an instance of <a href="time.html"><code>Time</code></a> there is a multitude of things you can do with it. Below are some examples. For all of the following examples, we will work on the assumption that you have done the following:</p> <pre class="ruby" data-language="ruby">t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")
</pre> <p>Was that a monday?</p> <pre class="ruby" data-language="ruby">t.monday? #=&gt; false
</pre> <p>What year was that again?</p> <pre class="ruby" data-language="ruby">t.year #=&gt; 1993
</pre> <p>Was it daylight savings at the time?</p> <pre class="ruby" data-language="ruby">t.dst? #=&gt; false
</pre> <p>What’s the day a year later?</p> <pre class="ruby" data-language="ruby">t + (60*60*24*365) #=&gt; 1994-02-24 12:00:00 +0900
</pre> <p>How many seconds was that since the Unix Epoch?</p> <pre class="ruby" data-language="ruby">t.to_i #=&gt; 730522800
</pre> <p>You can also do standard functions like compare two times.</p> <pre class="ruby" data-language="ruby">t1 = Time.new(2010)
t2 = Time.new(2011)

t1 == t2 #=&gt; false
t1 == t1 #=&gt; true
t1 &lt;  t2 #=&gt; true
t1 &gt;  t2 #=&gt; false

Time.new(2010,10,31).between?(t1, t2) #=&gt; true
</pre> <h2 id="class-Time-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class <code>Time</code>:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="comparable.html#module-Comparable-label-What-27s+Here">module Comparable</a>.</p> </li>
</ul> <p>Here, class <code>Time</code> provides methods that are useful for:</p> <ul>
<li> <p>{Creating <code>Time</code> objects}[rdoc-ref:Time@Methods+for+Creating].</p> </li>
<li> <p>{Fetching <code>Time</code> values}[rdoc-ref:Time@Methods+for+Fetching].</p> </li>
<li> <p>{Querying a <code>Time</code> object}[rdoc-ref:Time@Methods+for+Querying].</p> </li>
<li> <p>{Comparing <code>Time</code> objects}[rdoc-ref:Time@Methods+for+Comparing].</p> </li>
<li> <p>{Converting a <code>Time</code> object}[rdoc-ref:Time@Methods+for+Converting].</p> </li>
<li> <p>{Rounding a <code>Time</code><a href="time.html#class-Time-label-Methods+for+Rounding">}</a>.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Creating">Methods for Creating</h3> <ul>
<li> <p><a href="time.html#method-c-new"><code>::new</code></a>: Returns a new time from specified arguments (year, month, etc.), including an optional timezone value.</p> </li>
<li> <p><a href="time.html#method-c-local"><code>::local</code></a> (aliased as <a href="time.html#method-c-mktime"><code>::mktime</code></a>): Same as <a href="time.html#method-c-new"><code>::new</code></a>, except the timezone is the local timezone.</p> </li>
<li> <p><a href="time.html#method-c-utc"><code>::utc</code></a> (aliased as <a href="time.html#method-c-gm"><code>::gm</code></a>): Same as <a href="time.html#method-c-new"><code>::new</code></a>, except the timezone is UTC.</p> </li>
<li> <p><a href="time.html#method-c-at"><code>::at</code></a>: Returns a new time based on seconds since epoch.</p> </li>
<li> <p><a href="time.html#method-c-now"><code>::now</code></a>: Returns a new time based on the current system time.</p> </li>
<li> <p><a href="time.html#method-i-2B"><code>+</code></a> (plus): Returns a new time increased by the given number of seconds.</p> </li>
<li> <p><a href="time.html#method-i-2D"><code>-</code></a> (minus): Returns a new time decreased by the given number of seconds.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Fetching">Methods for Fetching</h3> <ul>
<li> <p><a href="time.html#method-i-year"><code>year</code></a>: Returns the year of the time.</p> </li>
<li> <p><a href="time.html#method-i-month"><code>month</code></a> (aliased as <a href="time.html#method-i-mon"><code>mon</code></a>): Returns the month of the time.</p> </li>
<li> <p><a href="time.html#method-i-mday"><code>mday</code></a> (aliased as <a href="time.html#method-i-day"><code>day</code></a>): Returns the day of the month.</p> </li>
<li> <p><a href="time.html#method-i-hour"><code>hour</code></a>: Returns the hours value for the time.</p> </li>
<li> <p><a href="time.html#method-i-min"><code>min</code></a>: Returns the minutes value for the time.</p> </li>
<li> <p><a href="time.html#method-i-sec"><code>sec</code></a>: Returns the seconds value for the time.</p> </li>
<li> <p><a href="time.html#method-i-usec"><code>usec</code></a> (aliased as <a href="time.html#method-i-tv_usec"><code>tv_usec</code></a>): Returns the number of microseconds in the subseconds value of the time.</p> </li>
<li> <p><a href="time.html#method-i-nsec"><code>nsec</code></a> (aliased as <a href="time.html#method-i-tv_nsec"><code>tv_nsec</code></a>: Returns the number of nanoseconds in the subsecond part of the time.</p> </li>
<li> <p><a href="time.html#method-i-subsec"><code>subsec</code></a>: Returns the subseconds value for the time.</p> </li>
<li> <p><a href="time.html#method-i-wday"><code>wday</code></a>: Returns the integer weekday value of the time (0 == Sunday).</p> </li>
<li> <p><a href="time.html#method-i-yday"><code>yday</code></a>: Returns the integer yearday value of the time (1 == January 1).</p> </li>
<li> <p><a href="time.html#method-i-hash"><code>hash</code></a>: Returns the integer hash value for the time.</p> </li>
<li> <p><a href="time.html#method-i-utc_offset"><code>utc_offset</code></a> (aliased as <a href="time.html#method-i-gmt_offset"><code>gmt_offset</code></a> and <a href="time.html#method-i-gmtoff"><code>gmtoff</code></a>): Returns the offset in seconds between time and UTC.</p> </li>
<li> <p><a href="time.html#method-i-to_f"><code>to_f</code></a>: Returns the float number of seconds since epoch for the time.</p> </li>
<li> <p><a href="time.html#method-i-to_i"><code>to_i</code></a> (aliased as <a href="time.html#method-i-tv_sec"><code>tv_sec</code></a>): Returns the integer number of seconds since epoch for the time.</p> </li>
<li> <p><a href="time.html#method-i-to_r"><code>to_r</code></a>: Returns the <a href="rational.html"><code>Rational</code></a> number of seconds since epoch for the time.</p> </li>
<li> <p><a href="time.html#method-i-zone"><code>zone</code></a>: Returns a string representation of the timezone of the time.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Querying">Methods for Querying</h3> <ul>
<li> <p><a href="time.html#method-i-utc-3F"><code>utc?</code></a> (aliased as <a href="time.html#method-i-gmt-3F"><code>gmt?</code></a>): Returns whether the time is UTC.</p> </li>
<li> <p><a href="time.html#method-i-dst-3F"><code>dst?</code></a> (aliased as <a href="time.html#method-i-isdst"><code>isdst</code></a>): Returns whether the time is DST (daylight saving time).</p> </li>
<li> <p><a href="time.html#method-i-sunday-3F"><code>sunday?</code></a>: Returns whether the time is a Sunday.</p> </li>
<li> <p><a href="time.html#method-i-monday-3F"><code>monday?</code></a>: Returns whether the time is a Monday.</p> </li>
<li> <p><a href="time.html#method-i-tuesday-3F"><code>tuesday?</code></a>: Returns whether the time is a Tuesday.</p> </li>
<li> <p><a href="time.html#method-i-wednesday-3F"><code>wednesday?</code></a>: Returns whether the time is a Wednesday.</p> </li>
<li> <p><a href="time.html#method-i-thursday-3F"><code>thursday?</code></a>: Returns whether the time is a Thursday.</p> </li>
<li> <p><a href="time.html#method-i-friday-3F"><code>friday?</code></a>: Returns whether time is a Friday.</p> </li>
<li> <p><a href="time.html#method-i-saturday-3F"><code>saturday?</code></a>: Returns whether the time is a Saturday.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="time.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Compares <code>self</code> to another time.</p> </li>
<li> <p><a href="time.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether the time is equal to another time.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Converting">Methods for Converting</h3> <ul>
<li> <p><a href="time.html#method-i-asctime"><code>asctime</code></a> (aliased as <a href="time.html#method-i-ctime"><code>ctime</code></a>): Returns the time as a string.</p> </li>
<li> <p><a href="time.html#method-i-inspect"><code>inspect</code></a>: Returns the time in detail as a string.</p> </li>
<li> <p><a href="time.html#method-i-strftime"><code>strftime</code></a>: Returns the time as a string, according to a given format.</p> </li>
<li> <p><a href="time.html#method-i-to_a"><code>to_a</code></a>: Returns a 10-element array of values from the time.</p> </li>
<li> <p><a href="time.html#method-i-to_s"><code>to_s</code></a>: Returns a string representation of the time.</p> </li>
<li> <p><a href="time.html#method-i-getutc"><code>getutc</code></a> (aliased as <a href="time.html#method-i-getgm"><code>getgm</code></a>): Returns a new time converted to UTC.</p> </li>
<li> <p><a href="time.html#method-i-getlocal"><code>getlocal</code></a>: Returns a new time converted to local time.</p> </li>
<li> <p><a href="time.html#method-i-utc"><code>utc</code></a> (aliased as <a href="time.html#method-i-gmtime"><code>gmtime</code></a>): Converts time to UTC in place.</p> </li>
<li> <p><a href="time.html#method-i-localtime"><code>localtime</code></a>: Converts time to local time in place.</p> </li>
<li> <p><a href="time.html#method-i-deconstruct_keys"><code>deconstruct_keys</code></a>: Returns a hash of time components used in pattern-matching.</p> </li>
</ul> <h3 id="class-Time-label-Methods+for+Rounding">Methods for Rounding</h3> <ul>
<li> <p><a href="time.html#method-i-round"><code>round</code></a>:Returns a new time with subseconds rounded.</p> </li>
<li> <p><a href="time.html#method-i-ceil"><code>ceil</code></a>: Returns a new time with subseconds raised to a ceiling.</p> </li>
<li> <p><a href="time.html#method-i-floor"><code>floor</code></a>: Returns a new time with subseconds lowered to a floor.</p> </li>
</ul> <p>For the forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>.</p> <h2 id="class-Time-label-Timezone+Specifiers">Timezone Specifiers</h2> <p>Certain <code>Time</code> methods accept arguments that specify timezones:</p> <ul>
<li> <p><a href="time.html#method-c-at"><code>Time.at</code></a>: keyword argument <code>in:</code>.</p> </li>
<li> <p><a href="time.html#method-c-new"><code>Time.new</code></a>: positional argument <code>zone</code> or keyword argument <code>in:</code>.</p> </li>
<li> <p><a href="time.html#method-c-now"><code>Time.now</code></a>: keyword argument <code>in:</code>.</p> </li>
<li> <p><a href="time.html#method-i-getlocal"><code>Time#getlocal</code></a>: positional argument <code>zone</code>.</p> </li>
<li> <p><a href="time.html#method-i-localtime"><code>Time#localtime</code></a>: positional argument <code>zone</code>.</p> </li>
</ul> <p>The value given with any of these must be one of the following (each detailed below):</p> <ul>
<li> <p><a href="time.html#class-Time-label-Hours-2FMinutes+Offsets">Hours/minutes offset</a>.</p> </li>
<li> <p><a href="time.html#class-Time-label-Single-Letter+Offsets">Single-letter offset</a>.</p> </li>
<li> <p><a href="time.html#class-Time-label-Integer+Offsets">Integer offset</a>.</p> </li>
<li> <p><a href="time.html#class-Time-label-Timezone+Objects">Timezone object</a>.</p> </li>
<li> <p><a href="time.html#class-Time-label-Timezone+Names">Timezone name</a>.</p> </li>
</ul> <h3 id="class-Time-label-Hours-2FMinutes+Offsets">Hours/Minutes Offsets</h3> <p>The zone value may be a string offset from UTC in the form <code>'+HH:MM'</code> or <code>'-HH:MM'</code>, where:</p> <ul>
<li> <p><code>HH</code> is the 2-digit hour in the range <code>0..23</code>.</p> </li>
<li> <p><code>MM</code> is the 2-digit minute in the range <code>0..59</code>.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1, 20, 15, 1) # =&gt; 2000-01-01 20:15:01 UTC
Time.at(t, in: '-23:59')            # =&gt; 1999-12-31 20:16:01 -2359
Time.at(t, in: '+23:59')            # =&gt; 2000-01-02 20:14:01 +2359
</pre> <h3 id="class-Time-label-Single-Letter+Offsets">Single-Letter Offsets</h3> <p>The zone value may be a letter in the range <code>'A'..'I'</code> or <code>'K'..'Z'</code>; see <a href="https://en.wikipedia.org/wiki/List_of_military_time_zones">List of military time zones</a>:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1, 20, 15, 1) # =&gt; 2000-01-01 20:15:01 UTC
Time.at(t, in: 'A')                 # =&gt; 2000-01-01 21:15:01 +0100
Time.at(t, in: 'I')                 # =&gt; 2000-01-02 05:15:01 +0900
Time.at(t, in: 'K')                 # =&gt; 2000-01-02 06:15:01 +1000
Time.at(t, in: 'Y')                 # =&gt; 2000-01-01 08:15:01 -1200
Time.at(t, in: 'Z')                 # =&gt; 2000-01-01 20:15:01 UTC
</pre> <h3 id="class-Time-label-Integer+Offsets">Integer Offsets</h3> <p>The zone value may be an integer number of seconds in the range <code>-86399..86399</code>:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1, 20, 15, 1) # =&gt; 2000-01-01 20:15:01 UTC
Time.at(t, in: -86399)              # =&gt; 1999-12-31 20:15:02 -235959
Time.at(t, in: 86399)               # =&gt; 2000-01-02 20:15:00 +235959
</pre> <h3 id="class-Time-label-Timezone+Objects">Timezone Objects</h3> <p>The zone value may be an object responding to certain timezone methods, an instance of <a href="https://github.com/panthomakos/timezone">Timezone</a> and <a href="https://tzinfo.github.io">TZInfo</a> for example.</p> <p>The timezone methods are:</p> <ul>
<li> <p><code>local_to_utc</code>:</p> <ul>
<li> <p>Called when <a href="time.html#method-c-new"><code>Time.new</code></a> is invoked with <code>tz</code> as the value of positional argument <code>zone</code> or keyword argument <code>in:</code>.</p> </li>
<li> <p>Argument: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a>.</p> </li>
<li> <p>Returns: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a> in the UTC timezone.</p> </li>
</ul> </li>
<li> <p><code>utc_to_local</code>:</p> <ul>
<li> <p>Called when <a href="time.html#method-c-at"><code>Time.at</code></a> or <a href="time.html#method-c-now"><code>Time.now</code></a> is invoked with <code>tz</code> as the value for keyword argument <code>in:</code>, and when <a href="time.html#method-i-getlocal"><code>Time#getlocal</code></a> or <a href="time.html#method-i-localtime"><code>Time#localtime</code></a> is called with <code>tz</code> as the value for positional argument <code>zone</code>.</p> </li>
<li> <p>Argument: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a>.</p> </li>
<li> <p>Returns: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a> in the local timezone.</p> </li>
</ul> </li>
</ul> <p>A custom timezone class may have these instance methods, which will be called if defined:</p> <ul>
<li> <p><code>abbr</code>:</p> <ul>
<li> <p>Called when <a href="time.html#method-i-strftime"><code>Time#strftime</code></a> is invoked with a format involving <code>%Z</code>.</p> </li>
<li> <p>Argument: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a>.</p> </li>
<li> <p>Returns: a string abbreviation for the timezone name.</p> </li>
</ul> </li>
<li> <p><code>dst?</code>:</p> <ul>
<li> <p>Called when <a href="time.html#method-c-at"><code>Time.at</code></a> or <a href="time.html#method-c-now"><code>Time.now</code></a> is invoked with <code>tz</code> as the value for keyword argument <code>in:</code>, and when <a href="time.html#method-i-getlocal"><code>Time#getlocal</code></a> or <a href="time.html#method-i-localtime"><code>Time#localtime</code></a> is called with <code>tz</code> as the value for positional argument <code>zone</code>.</p> </li>
<li> <p>Argument: a <a href="time.html#class-Time-label-Time-Like+Objects">Time-like object</a>.</p> </li>
<li> <p>Returns: whether the time is daylight saving time.</p> </li>
</ul> </li>
<li> <p><code>name</code>:</p> <ul>
<li> <p>Called when <code>Marshal.dump(t)</code> is invoked</p> </li>
<li> <p>Argument: none.</p> </li>
<li> <p>Returns: the string name of the timezone.</p> </li>
</ul> </li>
</ul> <h4 id="class-Time-label-Time-Like+Objects">
<code>Time</code>-Like Objects</h4> <p>A <code>Time</code>-like object is a container object capable of interfacing with timezone libraries for timezone conversion.</p> <p>The argument to the timezone conversion methods above will have attributes similar to <a href="time.html"><code>Time</code></a>, except that timezone related attributes are meaningless.</p> <p>The objects returned by <code>local_to_utc</code> and <code>utc_to_local</code> methods of the timezone object may be of the same class as their arguments, of arbitrary object classes, or of class <a href="integer.html"><code>Integer</code></a>.</p> <p>For a returned class other than <code>Integer</code>, the class must have the following methods:</p> <ul>
<li> <p><code>year</code></p> </li>
<li> <p><code>mon</code></p> </li>
<li> <p><code>mday</code></p> </li>
<li> <p><code>hour</code></p> </li>
<li> <p><code>min</code></p> </li>
<li> <p><code>sec</code></p> </li>
<li> <p><code>isdst</code></p> </li>
<li> <p><code>to_i</code></p> </li>
</ul> <p>For a returned <code>Integer</code>, its components, decomposed in UTC, are interpreted as times in the specified timezone.</p> <h3 id="class-Time-label-Timezone+Names">Timezone Names</h3> <p>If the class (the receiver of class methods, or the class of the receiver of instance methods) has <code>find_timezone</code> singleton method, this method is called to achieve the corresponding timezone object from a timezone name.</p> <p>For example, using <a href="https://github.com/panthomakos/timezone">Timezone</a>:</p> <pre class="ruby" data-language="ruby">class TimeWithTimezone &lt; Time
  require 'timezone'
  def self.find_timezone(z) = Timezone[z]
end

TimeWithTimezone.now(in: "America/New_York")        #=&gt; 2023-12-25 00:00:00 -0500
TimeWithTimezone.new("2023-12-25 America/New_York") #=&gt; 2023-12-25 00:00:00 -0500
</pre> <p>Or, using <a href="https://tzinfo.github.io">TZInfo</a>:</p> <pre class="ruby" data-language="ruby">class TimeWithTZInfo &lt; Time
  require 'tzinfo'
  def self.find_timezone(z) = TZInfo::Timezone.get(z)
end

TimeWithTZInfo.now(in: "America/New_York")          #=&gt; 2023-12-25 00:00:00 -0500
TimeWithTZInfo.new("2023-12-25 America/New_York")   #=&gt; 2023-12-25 00:00:00 -0500
</pre> <p>You can define this method per subclasses, or on the toplevel <a href="time.html"><code>Time</code></a> class.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-at"> <span class="method-name">at</span><span class="method-args">(time, subsec = false, unit = :microsecond, in: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="at-source"> <pre class="ruby" data-language="ruby"># File timev.rb, line 284
def self.at(time, subsec = false, unit = :microsecond, in: nil)
  if Primitive.mandatory_only?
    Primitive.time_s_at1(time)
  else
    Primitive.time_s_at(time, subsec, unit, Primitive.arg!(:in))
  end
end</pre> </div> <p>Returns a new <code>Time</code> object based on the given arguments.</p> <p>Required argument <code>time</code> may be either of:</p> <ul>
<li> <p>A <code>Time</code> object, whose value is the basis for the returned time; also influenced by optional keyword argument <code>in:</code> (see below).</p> </li>
<li> <p>A numeric number of <a href="time.html#class-Time-label-Epoch+Seconds">Epoch seconds</a> for the returned time.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 12, 31, 23, 59, 59) # =&gt; 2000-12-31 23:59:59 -0600
secs = t.to_i                          # =&gt; 978328799
Time.at(secs)                          # =&gt; 2000-12-31 23:59:59 -0600
Time.at(secs + 0.5)                    # =&gt; 2000-12-31 23:59:59.5 -0600
Time.at(1000000000)                    # =&gt; 2001-09-08 20:46:40 -0500
Time.at(0)                             # =&gt; 1969-12-31 18:00:00 -0600
Time.at(-1000000000)                   # =&gt; 1938-04-24 17:13:20 -0500
</pre> <p>Optional numeric argument <code>subsec</code> and optional symbol argument <code>units</code> work together to specify subseconds for the returned time; argument <code>units</code> specifies the units for <code>subsec</code>:</p> <ul>
<li> <p><code>:millisecond</code>: <code>subsec</code> in milliseconds:</p> <pre class="ruby" data-language="ruby">Time.at(secs, 0, :millisecond)     # =&gt; 2000-12-31 23:59:59 -0600
Time.at(secs, 500, :millisecond)   # =&gt; 2000-12-31 23:59:59.5 -0600
Time.at(secs, 1000, :millisecond)  # =&gt; 2001-01-01 00:00:00 -0600
Time.at(secs, -1000, :millisecond) # =&gt; 2000-12-31 23:59:58 -0600
</pre> </li>
<li> <p><code>:microsecond</code> or <code>:usec</code>: <code>subsec</code> in microseconds:</p> <pre class="ruby" data-language="ruby">Time.at(secs, 0, :microsecond)        # =&gt; 2000-12-31 23:59:59 -0600
Time.at(secs, 500000, :microsecond)   # =&gt; 2000-12-31 23:59:59.5 -0600
Time.at(secs, 1000000, :microsecond)  # =&gt; 2001-01-01 00:00:00 -0600
Time.at(secs, -1000000, :microsecond) # =&gt; 2000-12-31 23:59:58 -0600
</pre> </li>
<li> <p><code>:nanosecond</code> or <code>:nsec</code>: <code>subsec</code> in nanoseconds:</p> <pre class="ruby" data-language="ruby">Time.at(secs, 0, :nanosecond)           # =&gt; 2000-12-31 23:59:59 -0600
Time.at(secs, 500000000, :nanosecond)   # =&gt; 2000-12-31 23:59:59.5 -0600
Time.at(secs, 1000000000, :nanosecond)  # =&gt; 2001-01-01 00:00:00 -0600
Time.at(secs, -1000000000, :nanosecond) # =&gt; 2000-12-31 23:59:58 -0600
</pre> </li>
</ul> <p>Optional keyword argument <code>in: zone</code> specifies the timezone for the returned time:</p> <pre class="ruby" data-language="ruby">Time.at(secs, in: '+12:00') # =&gt; 2001-01-01 17:59:59 +1200
Time.at(secs, in: '-12:00') # =&gt; 2000-12-31 17:59:59 -1200
</pre> <p>For the forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-gm"> <span class="method-name">gm</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-c-utc">utc</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-httpdate"> <span class="method-name">httpdate</span><span class="method-args">(date)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="httpdate-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 566
def httpdate(date)
  if date.match?(/\A\s*
      (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\x20
      (\d{2})\x20
      (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
      (\d{4})\x20
      (\d{2}):(\d{2}):(\d{2})\x20
      GMT
      \s*\z/ix)
    self.rfc2822(date).utc
  elsif /\A\s*
         (?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\x20
         (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d)\x20
         (\d\d):(\d\d):(\d\d)\x20
         GMT
         \s*\z/ix =~ date
    year = $3.to_i
    if year &lt; 50
      year += 2000
    else
      year += 1900
    end
    self.utc(year, $2, $1.to_i, $4.to_i, $5.to_i, $6.to_i)
  elsif /\A\s*
         (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\x20
         (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
         (\d\d|\x20\d)\x20
         (\d\d):(\d\d):(\d\d)\x20
         (\d{4})
         \s*\z/ix =~ date
    self.utc($6.to_i, MonthValue[$1.upcase], $2.to_i,
             $3.to_i, $4.to_i, $5.to_i)
  else
    raise ArgumentError.new("not RFC 2616 compliant date: #{date.inspect}")
  end
end</pre> </div> <p>Parses <code>date</code> as an HTTP-date defined by RFC 2616 and converts it to a <a href="time.html"><code>Time</code></a> object.</p> <p><a href="argumenterror.html"><code>ArgumentError</code></a> is raised if <code>date</code> is not compliant with RFC 2616 or if the <a href="time.html"><code>Time</code></a> class cannot represent specified date.</p> <p>See <a href="time.html#method-i-httpdate"><code>httpdate</code></a> for more information on this format.</p> <pre class="ruby" data-language="ruby">require 'time'

Time.httpdate("Thu, 06 Oct 2011 02:26:12 GMT")
#=&gt; 2011-10-06 02:26:12 UTC
</pre> <p>You must require ‘time’ to use this method.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-iso8601"> <span class="method-name">iso8601</span><span class="method-args">(time)</span> </div> </div>  <div class="aliases"> Alias for: <a href="time.html#method-c-xmlschema">xmlschema</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/time.rb, line 9
def self.json_create(object)
  if usec = object.delete('u') # used to be tv_usec -&gt; tv_nsec
    object['n'] = usec * 1000
  end
  if method_defined?(:tv_nsec)
    at(object['s'], Rational(object['n'], 1000))
  else
    at(object['s'], object['n'] / 1000)
  end
end</pre> </div> <p>See <a href="time.html#method-i-as_json"><code>as_json</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-local"> <span class="method-callseq"> local(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0) → new_time </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> local(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy) → new_time </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="local-source"> <pre class="c" data-language="c">static VALUE
time_s_mktime(int argc, VALUE *argv, VALUE klass)
{
    struct vtm vtm;

    time_arg(argc, argv, &amp;vtm);
    return time_localtime(time_new_timew(klass, timelocalw(&amp;vtm)));
}</pre> </div> <p>Like <a href="time.html#method-c-utc"><code>Time.utc</code></a>, except that the returned <code>Time</code> object has the local timezone, not the UTC timezone:</p> <pre class="ruby" data-language="ruby"># With seven arguments.
Time.local(0, 1, 2, 3, 4, 5, 6)
# =&gt; 0000-01-02 03:04:05.000006 -0600
# With exactly ten arguments.
Time.local(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
# =&gt; 0005-04-03 02:01:00 -0600
</pre>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-c-mktime">mktime</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-mktime"> <span class="method-name">mktime</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-c-local">local</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(year = nil, mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil, precision: 9) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File timev.rb, line 395
def initialize(year = (now = true), mon = (str = year; nil), mday = nil, hour = nil, min = nil, sec = nil, zone = nil,
               in: nil, precision: 9)
  if zone
    if Primitive.arg!(:in)
      raise ArgumentError, "timezone argument given as positional and keyword arguments"
    end
  else
    zone = Primitive.arg!(:in)
  end

  if now
    return Primitive.time_init_now(zone)
  end

  if str and Primitive.time_init_parse(str, zone, precision)
    return self
  end

  Primitive.time_init_args(year, mon, mday, hour, min, sec, zone)
end</pre> </div> <p>Returns a new <code>Time</code> object based on the given arguments, by default in the local timezone.</p> <p>With no positional arguments, returns the value of <a href="time.html#method-c-now"><code>Time.now</code></a>:</p> <pre class="ruby" data-language="ruby">Time.new # =&gt; 2021-04-24 17:27:46.0512465 -0500
</pre> <p>With one string argument that represents a time, returns a new <code>Time</code> object based on the given argument, in the local timezone.</p> <pre class="ruby" data-language="ruby">Time.new('2000-12-31 23:59:59.5')              # =&gt; 2000-12-31 23:59:59.5 -0600
Time.new('2000-12-31 23:59:59.5 +0900')        # =&gt; 2000-12-31 23:59:59.5 +0900
Time.new('2000-12-31 23:59:59.5', in: '+0900') # =&gt; 2000-12-31 23:59:59.5 +0900
Time.new('2000-12-31 23:59:59.5')              # =&gt; 2000-12-31 23:59:59.5 -0600
Time.new('2000-12-31 23:59:59.56789', precision: 3) # =&gt; 2000-12-31 23:59:59.567 -0600
</pre> <p>With one to six arguments, returns a new <code>Time</code> object based on the given arguments, in the local timezone.</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 2, 3, 4, 5) # =&gt; 2000-01-02 03:04:05 -0600
</pre> <p>For the positional arguments (other than <code>zone</code>):</p> <ul>
<li> <p><code>year</code>: Year, with no range limits:</p> <pre class="ruby" data-language="ruby">Time.new(999999999)  # =&gt; 999999999-01-01 00:00:00 -0600
Time.new(-999999999) # =&gt; -999999999-01-01 00:00:00 -0600
</pre> </li>
<li> <p><code>month</code>: Month in range (1..12), or case-insensitive 3-letter month name:</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1)     # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 12)    # =&gt; 2000-12-01 00:00:00 -0600
Time.new(2000, 'jan') # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 'JAN') # =&gt; 2000-01-01 00:00:00 -0600
</pre> </li>
<li> <p><code>mday</code>: Month day in range(1..31):</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1)  # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 1, 31) # =&gt; 2000-01-31 00:00:00 -0600
</pre> </li>
<li> <p><code>hour</code>: Hour in range (0..23), or 24 if <code>min</code>, <code>sec</code>, and <code>usec</code> are zero:</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0)  # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 1, 1, 23) # =&gt; 2000-01-01 23:00:00 -0600
Time.new(2000, 1, 1, 24) # =&gt; 2000-01-02 00:00:00 -0600
</pre> </li>
<li> <p><code>min</code>: Minute in range (0..59):</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0, 0)  # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 1, 1, 0, 59) # =&gt; 2000-01-01 00:59:00 -0600
</pre> </li>
<li> <p><code>sec</code>: Second in range (0…61):</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0, 0, 0)  # =&gt; 2000-01-01 00:00:00 -0600
Time.new(2000, 1, 1, 0, 0, 59) # =&gt; 2000-01-01 00:00:59 -0600
Time.new(2000, 1, 1, 0, 0, 60) # =&gt; 2000-01-01 00:01:00 -0600
</pre> <p><code>sec</code> may be <a href="float.html"><code>Float</code></a> or <a href="rational.html"><code>Rational</code></a>.</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0, 0, 59.5)  # =&gt; 2000-12-31 23:59:59.5 +0900
Time.new(2000, 1, 1, 0, 0, 59.7r) # =&gt; 2000-12-31 23:59:59.7 +0900
</pre> </li>
</ul> <p>These values may be:</p> <ul>
<li> <p>Integers, as above.</p> </li>
<li> <p>Numerics convertible to integers:</p> <pre class="ruby" data-language="ruby">Time.new(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0)
# =&gt; 0000-01-01 00:00:00 -0600
</pre> </li>
<li> <p><a href="string.html"><code>String</code></a> integers:</p> <pre class="ruby" data-language="ruby">a = %w[0 1 1 0 0 0]
# =&gt; ["0", "1", "1", "0", "0", "0"]
Time.new(*a) # =&gt; 0000-01-01 00:00:00 -0600
</pre> </li>
</ul> <p>When positional argument <code>zone</code> or keyword argument <code>in:</code> is given, the new <code>Time</code> object is in the specified timezone. For the forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>:</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1, 0, 0, 0, '+12:00')
# =&gt; 2000-01-01 00:00:00 +1200
Time.new(2000, 1, 1, 0, 0, 0, in: '-12:00')
# =&gt; 2000-01-01 00:00:00 -1200
Time.new(in: '-12:00')
# =&gt; 2022-08-23 08:49:26.1941467 -1200
</pre> <p>Since <code>in:</code> keyword argument just provides the default, so if the first argument in single string form contains time zone information, this keyword argument will be silently ignored.</p> <pre class="ruby" data-language="ruby">Time.new('2000-01-01 00:00:00 +0100', in: '-0500').utc_offset  # =&gt; 3600
</pre> <ul><li> <p><code>precision</code>: maximum effective digits in sub-second part, default is 9. More digits will be truncated, as other operations of <code>Time</code>. Ignored unless the first argument is a string.</p> </li></ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-now"> <span class="method-name">now</span><span class="method-args">(in: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="now-source"> <pre class="ruby" data-language="ruby"># File timev.rb, line 225
def self.now(in: nil)
  Primitive.time_s_now(Primitive.arg!(:in))
end</pre> </div> <p>Creates a new <code>Time</code> object from the current system time. This is the same as <a href="time.html#method-c-new"><code>Time.new</code></a> without arguments.</p> <pre class="ruby" data-language="ruby">Time.now               # =&gt; 2009-06-24 12:39:54 +0900
Time.now(in: '+04:00') # =&gt; 2009-06-24 07:39:54 +0400
</pre> <p>For forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <span class="method-name">parse</span><span class="method-args">(date, now=self.now) { |year| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 381
def parse(date, now=self.now)
  comp = !block_given?
  d = Date._parse(date, comp)
  year = d[:year]
  year = yield(year) if year &amp;&amp; !comp
  make_time(date, year, d[:yday], d[:mon], d[:mday], d[:hour], d[:min], d[:sec], d[:sec_fraction], d[:zone], now)
end</pre> </div> <p>Takes a string representation of a <a href="time.html"><code>Time</code></a> and attempts to parse it using a heuristic.</p> <p>This method **does not** function as a validator. If the input string does not match valid formats strictly, you may get a cryptic result. Should consider to use ‘Time.strptime` instead of this method as possible.</p> <pre class="ruby" data-language="ruby">require 'time'

Time.parse("2010-10-31") #=&gt; 2010-10-31 00:00:00 -0500
</pre> <p>Any missing pieces of the date are inferred based on the current date.</p> <pre class="ruby" data-language="ruby">require 'time'

# assuming the current date is "2011-10-31"
Time.parse("12:00") #=&gt; 2011-10-31 12:00:00 -0500
</pre> <p>We can change the date used to infer our missing elements by passing a second object that responds to <a href="time.html#method-i-mon"><code>mon</code></a>, <a href="time.html#method-i-day"><code>day</code></a> and <a href="time.html#method-i-year"><code>year</code></a>, such as <a href="date.html"><code>Date</code></a>, <a href="time.html"><code>Time</code></a> or <a href="datetime.html"><code>DateTime</code></a>. We can also use our own object.</p> <pre class="ruby" data-language="ruby">require 'time'

class MyDate
  attr_reader :mon, :day, :year

  def initialize(mon, day, year)
    @mon, @day, @year = mon, day, year
  end
end

d  = Date.parse("2010-10-28")
t  = Time.parse("2010-10-29")
dt = DateTime.parse("2010-10-30")
md = MyDate.new(10,31,2010)

Time.parse("12:00", d)  #=&gt; 2010-10-28 12:00:00 -0500
Time.parse("12:00", t)  #=&gt; 2010-10-29 12:00:00 -0500
Time.parse("12:00", dt) #=&gt; 2010-10-30 12:00:00 -0500
Time.parse("12:00", md) #=&gt; 2010-10-31 12:00:00 -0500
</pre> <p>If a block is given, the year described in <code>date</code> is converted by the block. This is specifically designed for handling two digit years. For example, if you wanted to treat all two digit years prior to 70 as the year 2000+ you could write this:</p> <pre class="ruby" data-language="ruby">require 'time'

Time.parse("01-10-31") {|year| year + (year &lt; 70 ? 2000 : 1900)}
#=&gt; 2001-10-31 00:00:00 -0500
Time.parse("70-10-31") {|year| year + (year &lt; 70 ? 2000 : 1900)}
#=&gt; 1970-10-31 00:00:00 -0500
</pre> <p>If the upper components of the given time are broken or missing, they are supplied with those of <code>now</code>. For the lower components, the minimum values (1 or 0) are assumed if broken or missing. For example:</p> <pre class="ruby" data-language="ruby">require 'time'

# Suppose it is "Thu Nov 29 14:33:20 2001" now and
# your time zone is EST which is GMT-5.
now = Time.parse("Thu Nov 29 14:33:20 2001")
Time.parse("16:30", now)     #=&gt; 2001-11-29 16:30:00 -0500
Time.parse("7/23", now)      #=&gt; 2001-07-23 00:00:00 -0500
Time.parse("Aug 31", now)    #=&gt; 2001-08-31 00:00:00 -0500
Time.parse("Aug 2000", now)  #=&gt; 2000-08-01 00:00:00 -0500
</pre> <p>Since there are numerous conflicts among locally defined time zone abbreviations all over the world, this method is not intended to understand all of them. For example, the abbreviation “CST” is used variously as:</p> <pre>-06:00 in America/Chicago,
-05:00 in America/Havana,
+08:00 in Asia/Harbin,
+09:30 in Australia/Darwin,
+10:30 in Australia/Adelaide,
etc.</pre> <p>Based on this fact, this method only understands the time zone abbreviations described in RFC 822 and the system time zone, in the order named. (i.e. a definition in RFC 822 overrides the system time zone definition.) The system time zone is taken from <code>Time.local(year, 1, 1).zone</code> and <code>Time.local(year, 7, 1).zone</code>. If the extracted time zone abbreviation does not match any of them, it is ignored and the given time is regarded as a local time.</p> <p><a href="argumenterror.html"><code>ArgumentError</code></a> is raised if <a href="date.html#method-c-_parse"><code>Date._parse</code></a> cannot extract information from <code>date</code> or if the <a href="time.html"><code>Time</code></a> class cannot represent specified date.</p> <p>This method can be used as a fail-safe for other parsing methods as:</p> <pre class="ruby" data-language="ruby">Time.rfc2822(date) rescue Time.parse(date)
Time.httpdate(date) rescue Time.parse(date)
Time.xmlschema(date) rescue Time.parse(date)
</pre> <p>A failure of <a href="time.html#method-c-parse"><code>Time.parse</code></a> should be checked, though.</p> <p>You must require ‘time’ to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-rfc2822"> <span class="method-name">rfc2822</span><span class="method-args">(date)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rfc2822-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 508
def rfc2822(date)
  if /\A\s*
      (?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s*,\s*)?
      (\d{1,2})\s+
      (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+
      (\d{2,})\s+
      (\d{2})\s*
      :\s*(\d{2})
      (?:\s*:\s*(\d\d))?\s+
      ([+-]\d{4}|
       UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Z])/ix =~ date
    # Since RFC 2822 permit comments, the regexp has no right anchor.
    day = $1.to_i
    mon = MonthValue[$2.upcase]
    year = $3.to_i
    short_year_p = $3.length &lt;= 3
    hour = $4.to_i
    min = $5.to_i
    sec = $6 ? $6.to_i : 0
    zone = $7

    if short_year_p
      # following year completion is compliant with RFC 2822.
      year = if year &lt; 50
               2000 + year
             else
               1900 + year
             end
    end

    off = zone_offset(zone)
    year, mon, day, hour, min, sec =
      apply_offset(year, mon, day, hour, min, sec, off)
    t = self.utc(year, mon, day, hour, min, sec)
    force_zone!(t, zone, off)
    t
  else
    raise ArgumentError.new("not RFC 2822 compliant date: #{date.inspect}")
  end
end</pre> </div> <p>Parses <code>date</code> as date-time defined by RFC 2822 and converts it to a <a href="time.html"><code>Time</code></a> object. The format is identical to the date format defined by RFC 822 and updated by RFC 1123.</p> <p><a href="argumenterror.html"><code>ArgumentError</code></a> is raised if <code>date</code> is not compliant with RFC 2822 or if the <a href="time.html"><code>Time</code></a> class cannot represent specified date.</p> <p>See <a href="time.html#method-i-rfc2822"><code>rfc2822</code></a> for more information on this format.</p> <pre class="ruby" data-language="ruby">require 'time'

Time.rfc2822("Wed, 05 Oct 2011 22:26:12 -0400")
#=&gt; 2010-10-05 22:26:12 -0400
</pre> <p>You must require ‘time’ to use this method.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-c-rfc822">rfc822</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-rfc822"> <span class="method-name">rfc822</span><span class="method-args">(date)</span> </div> </div>  <div class="aliases"> Alias for: <a href="time.html#method-c-rfc2822">rfc2822</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-strptime"> <span class="method-name">strptime</span><span class="method-args">(date, format, now=self.now) { |year| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="strptime-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 456
def strptime(date, format, now=self.now)
  d = Date._strptime(date, format)
  raise ArgumentError, "invalid date or strptime format - `#{date}' `#{format}'" unless d
  if seconds = d[:seconds]
    if sec_fraction = d[:sec_fraction]
      usec = sec_fraction * 1000000
      usec *= -1 if seconds &lt; 0
    else
      usec = 0
    end
    t = Time.at(seconds, usec)
    if zone = d[:zone]
      force_zone!(t, zone)
    end
  else
    year = d[:year]
    year = yield(year) if year &amp;&amp; block_given?
    yday = d[:yday]
    if (d[:cwyear] &amp;&amp; !year) || ((d[:cwday] || d[:cweek]) &amp;&amp; !(d[:mon] &amp;&amp; d[:mday]))
      # make_time doesn't deal with cwyear/cwday/cweek
      return Date.strptime(date, format).to_time
    end
    if (d[:wnum0] || d[:wnum1]) &amp;&amp; !yday &amp;&amp; !(d[:mon] &amp;&amp; d[:mday])
      yday = Date.strptime(date, format).yday
    end
    t = make_time(date, year, yday, d[:mon], d[:mday], d[:hour], d[:min], d[:sec], d[:sec_fraction], d[:zone], now)
  end
  t
end</pre> </div> <p>Works similar to <code>parse</code> except that instead of using a heuristic to detect the format of the input string, you provide a second argument that describes the format of the string.</p> <p>If a block is given, the year described in <code>date</code> is converted by the block. For example:</p> <pre>Time.strptime(...) {|y| y &lt; 100 ? (y &gt;= 69 ? y + 1900 : y + 2000) : y}</pre> <p>Below is a list of the formatting options:</p> <dl class="rdoc-list note-list">
<dt>%a </dt>
<dd> <p>The abbreviated weekday name (“Sun”)</p> </dd>
<dt>%A </dt>
<dd> <p>The full weekday name (“Sunday”)</p> </dd>
<dt>%b </dt>
<dd> <p>The abbreviated month name (“Jan”)</p> </dd>
<dt>%B </dt>
<dd> <p>The full month name (“January”)</p> </dd>
<dt>%c </dt>
<dd> <p>The preferred local date and time representation</p> </dd>
<dt>%C </dt>
<dd> <p>Century (20 in 2009)</p> </dd>
<dt>%d </dt>
<dd> <p>Day of the month (01..31)</p> </dd>
<dt>%D </dt>
<dd> <p><a href="date.html"><code>Date</code></a> (%m/%d/%y)</p> </dd>
<dt>%e </dt>
<dd> <p>Day of the month, blank-padded ( 1..31)</p> </dd>
<dt>%F </dt>
<dd> <p>Equivalent to %Y-%m-%d (the ISO 8601 date format)</p> </dd>
<dt>%g </dt>
<dd> <p>The last two digits of the commercial year</p> </dd>
<dt>%G </dt>
<dd> <p>The week-based year according to ISO-8601 (week 1 starts on Monday and includes January 4)</p> </dd>
<dt>%h </dt>
<dd> <p>Equivalent to %b</p> </dd>
<dt>%H </dt>
<dd> <p>Hour of the day, 24-hour clock (00..23)</p> </dd>
<dt>%I </dt>
<dd> <p>Hour of the day, 12-hour clock (01..12)</p> </dd>
<dt>%j </dt>
<dd> <p>Day of the year (001..366)</p> </dd>
<dt>%k </dt>
<dd> <p>hour, 24-hour clock, blank-padded ( 0..23)</p> </dd>
<dt>%l </dt>
<dd> <p>hour, 12-hour clock, blank-padded ( 0..12)</p> </dd>
<dt>%L </dt>
<dd> <p>Millisecond of the second (000..999)</p> </dd>
<dt>%m </dt>
<dd> <p>Month of the year (01..12)</p> </dd>
<dt>%M </dt>
<dd> <p>Minute of the hour (00..59)</p> </dd>
<dt>%n </dt>
<dd> <p>Newline (n)</p> </dd>
<dt>%N </dt>
<dd> <p>Fractional seconds digits</p> </dd>
<dt>%p </dt>
<dd> <p>Meridian indicator (“AM” or “PM”)</p> </dd>
<dt>%P </dt>
<dd> <p>Meridian indicator (“am” or “pm”)</p> </dd>
<dt>%r </dt>
<dd> <p>time, 12-hour (same as %I:%M:%S %p)</p> </dd>
<dt>%R </dt>
<dd> <p>time, 24-hour (%H:%M)</p> </dd>
<dt>%s </dt>
<dd> <p>Number of seconds since 1970-01-01 00:00:00 UTC.</p> </dd>
<dt>%S </dt>
<dd> <p>Second of the minute (00..60)</p> </dd>
<dt>%t </dt>
<dd> <p>Tab character (t)</p> </dd>
<dt>%T </dt>
<dd> <p>time, 24-hour (%H:%M:%S)</p> </dd>
<dt>%u </dt>
<dd> <p>Day of the week as a decimal, Monday being 1. (1..7)</p> </dd>
<dt>%U </dt>
<dd> <p>Week number of the current year, starting with the first Sunday as the first day of the first week (00..53)</p> </dd>
<dt>%v </dt>
<dd> <p>VMS date (%e-%b-%Y)</p> </dd>
<dt>%V </dt>
<dd> <p>Week number of year according to ISO 8601 (01..53)</p> </dd>
<dt>%W </dt>
<dd> <p>Week number of the current year, starting with the first Monday as the first day of the first week (00..53)</p> </dd>
<dt>%w </dt>
<dd> <p>Day of the week (Sunday is 0, 0..6)</p> </dd>
<dt>%x </dt>
<dd> <p>Preferred representation for the date alone, no time</p> </dd>
<dt>%X </dt>
<dd> <p>Preferred representation for the time alone, no date</p> </dd>
<dt>%y </dt>
<dd> <p>Year without a century (00..99)</p> </dd>
<dt>%Y </dt>
<dd> <p>Year which may include century, if provided</p> </dd>
<dt>%z </dt>
<dd> <p><a href="time.html"><code>Time</code></a> zone as hour offset from UTC (e.g. +0900)</p> </dd>
<dt>%Z </dt>
<dd> <p><a href="time.html"><code>Time</code></a> zone name</p> </dd>
<dt>%% </dt>
<dd> <p>Literal “%” character</p> </dd>
<dt>%+ </dt>
<dd> <p>date(1) (%a %b %e %H:%M:%S %Z %Y)</p> </dd>
</dl> <pre class="ruby" data-language="ruby">require 'time'

Time.strptime("2000-10-31", "%Y-%m-%d") #=&gt; 2000-10-31 00:00:00 -0500
</pre> <p>You must require ‘time’ to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-utc"> <span class="method-callseq"> utc(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0) → new_time </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> utc(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy) → new_time </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="utc-source"> <pre class="c" data-language="c">static VALUE
time_s_mkutc(int argc, VALUE *argv, VALUE klass)
{
    struct vtm vtm;

    time_arg(argc, argv, &amp;vtm);
    return time_gmtime(time_new_timew(klass, timegmw(&amp;vtm)));
}</pre> </div> <p>Returns a new <code>Time</code> object based the on given arguments, in the UTC timezone.</p> <p>With one to seven arguments given, the arguments are interpreted as in the first calling sequence above:</p> <pre class="ruby" data-language="ruby">Time.utc(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0)
</pre> <p>Examples:</p> <pre class="ruby" data-language="ruby">Time.utc(2000)  # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(-2000) # =&gt; -2000-01-01 00:00:00 UTC
</pre> <p>There are no minimum and maximum values for the required argument <code>year</code>.</p> <p>For the optional arguments:</p> <ul>
<li> <p><code>month</code>: Month in range (1..12), or case-insensitive 3-letter month name:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1)     # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 12)    # =&gt; 2000-12-01 00:00:00 UTC
Time.utc(2000, 'jan') # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 'JAN') # =&gt; 2000-01-01 00:00:00 UTC
</pre> </li>
<li> <p><code>mday</code>: Month day in range(1..31):</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1)  # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 1, 31) # =&gt; 2000-01-31 00:00:00 UTC
</pre> </li>
<li> <p><code>hour</code>: Hour in range (0..23), or 24 if <code>min</code>, <code>sec</code>, and <code>usec</code> are zero:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1, 0)  # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 1, 1, 23) # =&gt; 2000-01-01 23:00:00 UTC
Time.utc(2000, 1, 1, 24) # =&gt; 2000-01-02 00:00:00 UTC
</pre> </li>
<li> <p><code>min</code>: Minute in range (0..59):</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1, 0, 0)  # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 1, 1, 0, 59) # =&gt; 2000-01-01 00:59:00 UTC
</pre> </li>
<li> <p><code>sec</code>: Second in range (0..59), or 60 if <code>usec</code> is zero:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1, 0, 0, 0)  # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 1, 1, 0, 0, 59) # =&gt; 2000-01-01 00:00:59 UTC
Time.utc(2000, 1, 1, 0, 0, 60) # =&gt; 2000-01-01 00:01:00 UTC
</pre> </li>
<li> <p><code>usec</code>: Microsecond in range (0..999999):</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1, 0, 0, 0, 0)      # =&gt; 2000-01-01 00:00:00 UTC
Time.utc(2000, 1, 1, 0, 0, 0, 999999) # =&gt; 2000-01-01 00:00:00.999999 UTC
</pre> </li>
</ul> <p>The values may be:</p> <ul>
<li> <p>Integers, as above.</p> </li>
<li> <p>Numerics convertible to integers:</p> <pre class="ruby" data-language="ruby">Time.utc(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0, 0.0)
# =&gt; 0000-01-01 00:00:00 UTC
</pre> </li>
<li> <p><a href="string.html"><code>String</code></a> integers:</p> <pre class="ruby" data-language="ruby">a = %w[0 1 1 0 0 0 0 0]
# =&gt; ["0", "1", "1", "0", "0", "0", "0", "0"]
Time.utc(*a) # =&gt; 0000-01-01 00:00:00 UTC
</pre> </li>
</ul> <p>When exactly ten arguments are given, the arguments are interpreted as in the second calling sequence above:</p> <pre class="ruby" data-language="ruby">Time.utc(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy)
</pre> <p>where the <code>dummy</code> arguments are ignored:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Time.utc(*a) # =&gt; 0005-04-03 02:01:00 UTC
</pre> <p>This form is useful for creating a <code>Time</code> object from a 10-element array returned by <a href="time.html#method-i-to_a"><code>Time.to_a</code></a>:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6) # =&gt; 2000-01-02 03:04:05 +000006
a = t.to_a   # =&gt; [5, 4, 3, 2, 1, 2000, 0, 2, false, nil]
Time.utc(*a) # =&gt; 2000-01-02 03:04:05 UTC
</pre> <p>The two forms have their first six arguments in common, though in different orders; the ranges of these common arguments are the same for both forms; see above.</p> <p>Raises an exception if the number of arguments is eight, nine, or greater than ten.</p> <p>Related: <a href="time.html#method-c-local"><code>Time.local</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-c-gm">gm</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-xmlschema"> <span class="method-name">xmlschema</span><span class="method-args">(time)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="xmlschema-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 620
def xmlschema(time)
  if /\A\s*
      (-?\d+)-(\d\d)-(\d\d)
      T
      (\d\d):(\d\d):(\d\d)
      (\.\d+)?
      (Z|[+-]\d\d(?::?\d\d)?)?
      \s*\z/ix =~ time
    year = $1.to_i
    mon = $2.to_i
    day = $3.to_i
    hour = $4.to_i
    min = $5.to_i
    sec = $6.to_i
    usec = 0
    if $7
      usec = Rational($7) * 1000000
    end
    if $8
      zone = $8
      off = zone_offset(zone)
      year, mon, day, hour, min, sec =
        apply_offset(year, mon, day, hour, min, sec, off)
      t = self.utc(year, mon, day, hour, min, sec, usec)
      force_zone!(t, zone, off)
      t
    else
      self.local(year, mon, day, hour, min, sec, usec)
    end
  else
    raise ArgumentError.new("invalid xmlschema format: #{time.inspect}")
  end
end</pre> </div> <p>Parses <code>time</code> as a dateTime defined by the XML Schema and converts it to a <a href="time.html"><code>Time</code></a> object. The format is a restricted version of the format defined by ISO 8601.</p> <p><a href="argumenterror.html"><code>ArgumentError</code></a> is raised if <code>time</code> is not compliant with the format or if the <a href="time.html"><code>Time</code></a> class cannot represent the specified time.</p> <p>See <a href="time.html#method-i-xmlschema"><code>xmlschema</code></a> for more information on this format.</p> <pre class="ruby" data-language="ruby">require 'time'

Time.xmlschema("2011-10-05T22:26:12-04:00")
#=&gt; 2011-10-05 22:26:12-04:00
</pre> <p>You must require ‘time’ to use this method.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-c-iso8601">iso8601</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-zone_offset"> <span class="method-name">zone_offset</span><span class="method-args">(zone, year=self.now.year)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="zone_offset-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 82
def zone_offset(zone, year=self.now.year)
  off = nil
  zone = zone.upcase
  if /\A([+-])(\d\d)(:?)(\d\d)(?:\3(\d\d))?\z/ =~ zone
    off = ($1 == '-' ? -1 : 1) * (($2.to_i * 60 + $4.to_i) * 60 + $5.to_i)
  elsif zone.match?(/\A[+-]\d\d\z/)
    off = zone.to_i * 3600
  elsif ZoneOffset.include?(zone)
    off = ZoneOffset[zone] * 3600
  elsif ((t = self.local(year, 1, 1)).zone.upcase == zone rescue false)
    off = t.utc_offset
  elsif ((t = self.local(year, 7, 1)).zone.upcase == zone rescue false)
    off = t.utc_offset
  end
  off
end</pre> </div> <p>Return the number of seconds the specified time zone differs from UTC.</p> <p><a href="numeric.html"><code>Numeric</code></a> time zones that include minutes, such as <code>-10:00</code> or <code>+1330</code> will work, as will simpler hour-only time zones like <code>-10</code> or <code>+13</code>.</p> <p>Textual time zones listed in ZoneOffset are also supported.</p> <p>If the time zone does not match any of the above, <code>zone_offset</code> will check if the local time zone (both with and without potential Daylight Saving Time changes being in effect) matches <code>zone</code>. Specifying a value for <code>year</code> will change the year used to find the local time zone.</p> <p>If <code>zone_offset</code> is unable to determine the offset, nil will be returned.</p> <pre class="ruby" data-language="ruby">require 'time'

Time.zone_offset("EST") #=&gt; -18000
</pre> <p>You must require ‘time’ to use this method.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> self + numeric → new_time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">static VALUE
time_plus(VALUE time1, VALUE time2)
{
    struct time_object *tobj;
    GetTimeval(time1, tobj);

    if (IsTimeval(time2)) {
        rb_raise(rb_eTypeError, "time + time?");
    }
    return time_add(tobj, time1, time2, 1);
}</pre> </div> <p>Returns a new <code>Time</code> object whose value is the sum of the numeric value of <code>self</code> and the given <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000) # =&gt; 2000-01-01 00:00:00 -0600
t + (60 * 60 * 24) # =&gt; 2000-01-02 00:00:00 -0600
t + 0.5            # =&gt; 2000-01-01 00:00:00.5 -0600
</pre> <p>Related: <a href="time.html#method-i-2D"><code>Time#-</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2D"> <span class="method-callseq"> self - numeric → new_time </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> self - other_time → float </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">static VALUE
time_minus(VALUE time1, VALUE time2)
{
    struct time_object *tobj;

    GetTimeval(time1, tobj);
    if (IsTimeval(time2)) {
        struct time_object *tobj2;

        GetTimeval(time2, tobj2);
        return rb_Float(rb_time_unmagnify_to_float(wsub(tobj-&gt;timew, tobj2-&gt;timew)));
    }
    return time_add(tobj, time1, time2, -1);
}</pre> </div> <p>When <code>numeric</code> is given, returns a new <code>Time</code> object whose value is the difference of the numeric value of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000) # =&gt; 2000-01-01 00:00:00 -0600
t - (60 * 60 * 24) # =&gt; 1999-12-31 00:00:00 -0600
t - 0.5            # =&gt; 1999-12-31 23:59:59.5 -0600
</pre> <p>When <code>other_time</code> is given, returns a <a href="float.html"><code>Float</code></a> whose value is the difference of the numeric values of <code>self</code> and <code>other_time</code> in seconds:</p> <pre class="ruby" data-language="ruby">t - t # =&gt; 0.0
</pre> <p>Related: <a href="time.html#method-i-2B"><code>Time#+</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> self &lt;=&gt; other_time → -1, 0, +1, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
time_cmp(VALUE time1, VALUE time2)
{
    struct time_object *tobj1, *tobj2;
    int n;

    GetTimeval(time1, tobj1);
    if (IsTimeval(time2)) {
        GetTimeval(time2, tobj2);
        n = wcmp(tobj1-&gt;timew, tobj2-&gt;timew);
    }
    else {
        return rb_invcmp(time1, time2);
    }
    if (n == 0) return INT2FIX(0);
    if (n &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre> </div> <p>Compares <code>self</code> with <code>other_time</code>; returns:</p> <ul>
<li> <p><code>-1</code>, if <code>self</code> is less than <code>other_time</code>.</p> </li>
<li> <p><code>0</code>, if <code>self</code> is equal to <code>other_time</code>.</p> </li>
<li> <p><code>1</code>, if <code>self</code> is greater then <code>other_time</code>.</p> </li>
<li> <p><code>nil</code>, if <code>self</code> and <code>other_time</code> are incomparable.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">t = Time.now     # =&gt; 2007-11-19 08:12:12 -0600
t2 = t + 2592000 # =&gt; 2007-12-19 08:12:12 -0600
t &lt;=&gt; t2         # =&gt; -1
t2 &lt;=&gt; t         # =&gt; 1

t = Time.now     # =&gt; 2007-11-19 08:13:38 -0600
t2 = t + 0.1     # =&gt; 2007-11-19 08:13:38 -0600
t.nsec           # =&gt; 98222999
t2.nsec          # =&gt; 198222999
t &lt;=&gt; t2         # =&gt; -1
t2 &lt;=&gt; t         # =&gt; 1
t &lt;=&gt; t          # =&gt; 0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/time.rb, line 36
def as_json(*)
  nanoseconds = [ tv_usec * 1000 ]
  respond_to?(:tv_nsec) and nanoseconds &lt;&lt; tv_nsec
  nanoseconds = nanoseconds.max
  {
    JSON.create_id =&gt; self.class.name,
    's'            =&gt; tv_sec,
    'n'            =&gt; nanoseconds,
  }
end</pre> </div> <p>Methods <code>Time#as_json</code> and <code>Time.json_create</code> may be used to serialize and deserialize a Time object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <code>Time#as_json</code> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/time'
x = Time.now.as_json
# =&gt; {"json_class"=&gt;"Time", "s"=&gt;1700931656, "n"=&gt;472846644}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Time object:</p> <pre class="ruby" data-language="ruby">Time.json_create(x)
# =&gt; 2023-11-25 11:00:56.472846644 -0600
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-asctime"> <span class="method-name">asctime</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-ctime">ctime</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ceil"> <span class="method-callseq"> ceil(ndigits = 0) → new_time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ceil-source"> <pre class="c" data-language="c">static VALUE
time_ceil(int argc, VALUE *argv, VALUE time)
{
    VALUE ndigits, v, den;
    struct time_object *tobj;

    if (!rb_check_arity(argc, 0, 1) || NIL_P(ndigits = argv[0]))
        den = INT2FIX(1);
    else
        den = ndigits_denominator(ndigits);

    GetTimeval(time, tobj);
    v = w2v(rb_time_unmagnify(tobj-&gt;timew));

    v = modv(v, den);
    if (!rb_equal(v, INT2FIX(0))) {
        v = subv(den, v);
    }
    return time_add(tobj, time, v, 1);
}</pre> </div> <p>Returns a new <code>Time</code> object whose numerical value is greater than or equal to <code>self</code> with its seconds truncated to precision <code>ndigits</code>:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
t          # =&gt; 2010-03-30 05:43:25.123456789 UTC
t.ceil     # =&gt; 2010-03-30 05:43:26 UTC
t.ceil(2)  # =&gt; 2010-03-30 05:43:25.13 UTC
t.ceil(4)  # =&gt; 2010-03-30 05:43:25.1235 UTC
t.ceil(6)  # =&gt; 2010-03-30 05:43:25.123457 UTC
t.ceil(8)  # =&gt; 2010-03-30 05:43:25.12345679 UTC
t.ceil(10) # =&gt; 2010-03-30 05:43:25.123456789 UTC

t = Time.utc(1999, 12, 31, 23, 59, 59)
t              # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.4).ceil # =&gt; 2000-01-01 00:00:00 UTC
(t + 0.9).ceil # =&gt; 2000-01-01 00:00:00 UTC
(t + 1.4).ceil # =&gt; 2000-01-01 00:00:01 UTC
(t + 1.9).ceil # =&gt; 2000-01-01 00:00:01 UTC
</pre> <p>Related: <a href="time.html#method-i-floor"><code>Time#floor</code></a>, <a href="time.html#method-i-round"><code>Time#round</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ctime"> <span class="method-callseq"> ctime → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ctime-source"> <pre class="c" data-language="c">static VALUE
time_asctime(VALUE time)
{
    return strftimev("%a %b %e %T %Y", time, rb_usascii_encoding());
}</pre> </div> <p>Returns a string representation of <code>self</code>, formatted by <code>strftime('%a %b %e %T %Y')</code> or its shorthand version <code>strftime('%c')</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
t.ctime                      # =&gt; "Sun Dec 31 23:59:59 2000"
t.strftime('%a %b %e %T %Y') # =&gt; "Sun Dec 31 23:59:59 2000"
t.strftime('%c')             # =&gt; "Sun Dec 31 23:59:59 2000"
</pre> <p>Related: <a href="time.html#method-i-to_s"><code>Time#to_s</code></a>, <a href="time.html#method-i-inspect"><code>Time#inspect</code></a>:</p> <pre class="ruby" data-language="ruby">t.inspect                    # =&gt; "2000-12-31 23:59:59.5 +000001"
t.to_s                       # =&gt; "2000-12-31 23:59:59 +0000"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-asctime">asctime</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-day"> <span class="method-name">day</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-mday">mday</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-callseq"> deconstruct_keys(array_of_names_or_nil) → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
time_deconstruct_keys(VALUE time, VALUE keys)
{
    struct time_object *tobj;
    VALUE h;
    long i;

    GetTimeval(time, tobj);
    MAKE_TM_ENSURE(time, tobj, tobj-&gt;vtm.yday != 0);

    if (NIL_P(keys)) {
        h = rb_hash_new_with_size(11);

        rb_hash_aset(h, sym_year, tobj-&gt;vtm.year);
        rb_hash_aset(h, sym_month, INT2FIX(tobj-&gt;vtm.mon));
        rb_hash_aset(h, sym_day, INT2FIX(tobj-&gt;vtm.mday));
        rb_hash_aset(h, sym_yday, INT2FIX(tobj-&gt;vtm.yday));
        rb_hash_aset(h, sym_wday, INT2FIX(tobj-&gt;vtm.wday));
        rb_hash_aset(h, sym_hour, INT2FIX(tobj-&gt;vtm.hour));
        rb_hash_aset(h, sym_min, INT2FIX(tobj-&gt;vtm.min));
        rb_hash_aset(h, sym_sec, INT2FIX(tobj-&gt;vtm.sec));
        rb_hash_aset(h, sym_subsec,
                     quov(w2v(wmod(tobj-&gt;timew, WINT2FIXWV(TIME_SCALE))), INT2FIX(TIME_SCALE)));
        rb_hash_aset(h, sym_dst, RBOOL(tobj-&gt;vtm.isdst));
        rb_hash_aset(h, sym_zone, time_zone(time));

        return h;
    }
    if (UNLIKELY(!RB_TYPE_P(keys, T_ARRAY))) {
        rb_raise(rb_eTypeError,
                 "wrong argument type %"PRIsVALUE" (expected Array or nil)",
                 rb_obj_class(keys));

    }

    h = rb_hash_new_with_size(RARRAY_LEN(keys));

    for (i=0; i&lt;RARRAY_LEN(keys); i++) {
        VALUE key = RARRAY_AREF(keys, i);

        if (sym_year == key) rb_hash_aset(h, key, tobj-&gt;vtm.year);
        if (sym_month == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.mon));
        if (sym_day == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.mday));
        if (sym_yday == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.yday));
        if (sym_wday == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.wday));
        if (sym_hour == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.hour));
        if (sym_min == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.min));
        if (sym_sec == key) rb_hash_aset(h, key, INT2FIX(tobj-&gt;vtm.sec));
        if (sym_subsec == key) {
            rb_hash_aset(h, key, quov(w2v(wmod(tobj-&gt;timew, WINT2FIXWV(TIME_SCALE))), INT2FIX(TIME_SCALE)));
        }
        if (sym_dst == key) rb_hash_aset(h, key, RBOOL(tobj-&gt;vtm.isdst));
        if (sym_zone == key) rb_hash_aset(h, key, time_zone(time));
    }
    return h;
}</pre> </div> <p>Returns a hash of the name/value pairs, to use in pattern matching. Possible keys are: <code>:year</code>, <code>:month</code>, <code>:day</code>, <code>:yday</code>, <code>:wday</code>, <code>:hour</code>, <code>:min</code>, <code>:sec</code>, <code>:subsec</code>, <code>:dst</code>, <code>:zone</code>.</p> <p>Possible usages:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2022, 10, 5, 21, 25, 30)

if t in wday: 3, day: ..7  # uses deconstruct_keys underneath
  puts "first Wednesday of the month"
end
#=&gt; prints "first Wednesday of the month"

case t
in year: ...2022
  puts "too old"
in month: ..9
  puts "quarter 1-3"
in wday: 1..5, month:
  puts "working day in month #{month}"
end
#=&gt; prints "working day in month 10"
</pre> <p>Note that deconstruction by pattern can also be combined with class check:</p> <pre class="ruby" data-language="ruby">if t in Time(wday: 3, day: ..7)
  puts "first Wednesday of the month"
end
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-dst-3F"> <span class="method-callseq"> dst? → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>self</code> is in daylight saving time, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.local(2000, 1, 1) # =&gt; 2000-01-01 00:00:00 -0600
t.zone                     # =&gt; "Central Standard Time"
t.dst?                     # =&gt; false
t = Time.local(2000, 7, 1) # =&gt; 2000-07-01 00:00:00 -0500
t.zone                     # =&gt; "Central Daylight Time"
t.dst?                     # =&gt; true
</pre> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-isdst">isdst</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other_time) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
time_eql(VALUE time1, VALUE time2)
{
    struct time_object *tobj1, *tobj2;

    GetTimeval(time1, tobj1);
    if (IsTimeval(time2)) {
        GetTimeval(time2, tobj2);
        return rb_equal(w2v(tobj1-&gt;timew), w2v(tobj2-&gt;timew));
    }
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> and <code>other_time</code> are both <code>Time</code> objects with the exact same time value.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-floor"> <span class="method-callseq"> floor(ndigits = 0) → new_time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="floor-source"> <pre class="c" data-language="c">static VALUE
time_floor(int argc, VALUE *argv, VALUE time)
{
    VALUE ndigits, v, den;
    struct time_object *tobj;

    if (!rb_check_arity(argc, 0, 1) || NIL_P(ndigits = argv[0]))
        den = INT2FIX(1);
    else
        den = ndigits_denominator(ndigits);

    GetTimeval(time, tobj);
    v = w2v(rb_time_unmagnify(tobj-&gt;timew));

    v = modv(v, den);
    return time_add(tobj, time, v, -1);
}</pre> </div> <p>Returns a new <code>Time</code> object whose numerical value is less than or equal to <code>self</code> with its seconds truncated to precision <code>ndigits</code>:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
t           # =&gt; 2010-03-30 05:43:25.123456789 UTC
t.floor     # =&gt; 2010-03-30 05:43:25 UTC
t.floor(2)  # =&gt; 2010-03-30 05:43:25.12 UTC
t.floor(4)  # =&gt; 2010-03-30 05:43:25.1234 UTC
t.floor(6)  # =&gt; 2010-03-30 05:43:25.123456 UTC
t.floor(8)  # =&gt; 2010-03-30 05:43:25.12345678 UTC
t.floor(10) # =&gt; 2010-03-30 05:43:25.123456789 UTC

t = Time.utc(1999, 12, 31, 23, 59, 59)
t               # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.4).floor # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.9).floor # =&gt; 1999-12-31 23:59:59 UTC
(t + 1.4).floor # =&gt; 2000-01-01 00:00:00 UTC
(t + 1.9).floor # =&gt; 2000-01-01 00:00:00 UTC
</pre> <p>Related: <a href="time.html#method-i-ceil"><code>Time#ceil</code></a>, <a href="time.html#method-i-round"><code>Time#round</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-friday-3F"> <span class="method-callseq"> friday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="friday-3F-source"> <pre class="c" data-language="c">static VALUE
time_friday(VALUE time)
{
    wday_p(5);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Friday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 7) # =&gt; 2000-01-07 00:00:00 UTC
t.friday?                # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-saturday-3F"><code>Time#saturday?</code></a>, <a href="time.html#method-i-sunday-3F"><code>Time#sunday?</code></a>, <a href="time.html#method-i-monday-3F"><code>Time#monday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-getgm"> <span class="method-name">getgm</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-getutc">getutc</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-getlocal"> <span class="method-callseq"> getlocal(zone = nil) → new_time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="getlocal-source"> <pre class="c" data-language="c">static VALUE
time_getlocaltime(int argc, VALUE *argv, VALUE time)
{
    VALUE off;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(off = argv[0])) {
        VALUE zone = off;
        if (maybe_tzobj_p(zone)) {
            VALUE t = time_dup(time);
            if (zone_localtime(off, t)) return t;
        }

        if (NIL_P(off = utc_offset_arg(off))) {
            off = zone;
            if (NIL_P(zone = find_timezone(time, off))) invalid_utc_offset(off);
            time = time_dup(time);
            if (!zone_localtime(zone, time)) invalid_utc_offset(off);
            return time;
        }
        else if (off == UTC_ZONE) {
            return time_gmtime(time_dup(time));
        }
        validate_utc_offset(off);

        time = time_dup(time);
        time_set_utc_offset(time, off);
        return time_fixoff(time);
    }

    return time_localtime(time_dup(time));
}</pre> </div> <p>Returns a new <code>Time</code> object representing the value of <code>self</code> converted to a given timezone; if <code>zone</code> is <code>nil</code>, the local timezone is used:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000)                    # =&gt; 2000-01-01 00:00:00 UTC
t.getlocal                            # =&gt; 1999-12-31 18:00:00 -0600
t.getlocal('+12:00')                  # =&gt; 2000-01-01 12:00:00 +1200
</pre> <p>For forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-getutc"> <span class="method-callseq"> getutc → new_time </span> </div> </div> <div class="method-description"> <p>Returns a new <code>Time</code> object representing the value of <code>self</code> converted to the UTC timezone:</p> <pre class="ruby" data-language="ruby">local = Time.local(2000) # =&gt; 2000-01-01 00:00:00 -0600
local.utc?               # =&gt; false
utc = local.getutc       # =&gt; 2000-01-01 06:00:00 UTC
utc.utc?                 # =&gt; true
utc == local             # =&gt; true
</pre> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-getgm">getgm</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-gmt-3F"> <span class="method-name">gmt?</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-utc-3F">utc?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-gmt_offset"> <span class="method-name">gmt_offset</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-gmtoff">gmtoff</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-gmtime"> <span class="method-name">gmtime</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-utc">utc</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-gmtoff"> <span class="method-name">gmtoff</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-gmt_offset">gmt_offset</a>, <a href="time.html#method-i-utc_offset">utc_offset</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
time_hash(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return rb_hash(w2v(tobj-&gt;timew));
}</pre> </div> <p>Returns the integer hash code for <code>self</code>.</p> <p>Related: <a href="object.html#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hour"> <span class="method-callseq"> hour → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hour-source"> <pre class="c" data-language="c">static VALUE
time_hour(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);
    return INT2FIX(tobj-&gt;vtm.hour);
}</pre> </div> <p>Returns the integer hour of the day for <code>self</code>, in range (0..23):</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.hour # =&gt; 3
</pre> <p>Related: <a href="time.html#method-i-year"><code>Time#year</code></a>, <a href="time.html#method-i-mon"><code>Time#mon</code></a>, <a href="time.html#method-i-min"><code>Time#min</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-httpdate"> <span class="method-name">httpdate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="httpdate-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 692
def httpdate
  getutc.strftime('%a, %d %b %Y %T GMT')
end</pre> </div> <p>Returns a string which represents the time as RFC 1123 date of HTTP-date defined by RFC 2616:</p> <pre>day-of-week, DD month-name CCYY hh:mm:ss GMT</pre> <p>Note that the result is always UTC (GMT).</p> <pre class="ruby" data-language="ruby">require 'time'

t = Time.now
t.httpdate # =&gt; "Thu, 06 Oct 2011 02:26:12 GMT"
</pre> <p>You must require ‘time’ to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
time_inspect(VALUE time)
{
    struct time_object *tobj;
    VALUE str, subsec;

    GetTimeval(time, tobj);
    str = strftimev("%Y-%m-%d %H:%M:%S", time, rb_usascii_encoding());
    subsec = w2v(wmod(tobj-&gt;timew, WINT2FIXWV(TIME_SCALE)));
    if (subsec == INT2FIX(0)) {
    }
    else if (FIXNUM_P(subsec) &amp;&amp; FIX2LONG(subsec) &lt; TIME_SCALE) {
        long len;
        rb_str_catf(str, ".%09ld", FIX2LONG(subsec));
        for (len=RSTRING_LEN(str); RSTRING_PTR(str)[len-1] == '0' &amp;&amp; len &gt; 0; len--)
            ;
        rb_str_resize(str, len);
    }
    else {
        rb_str_cat_cstr(str, " ");
        subsec = quov(subsec, INT2FIX(TIME_SCALE));
        rb_str_concat(str, rb_obj_as_string(subsec));
    }
    if (TZMODE_UTC_P(tobj)) {
        rb_str_cat_cstr(str, " UTC");
    }
    else {
        /* ?TODO: subsecond offset */
        long off = NUM2LONG(rb_funcall(tobj-&gt;vtm.utc_offset, rb_intern("round"), 0));
        char sign = (off &lt; 0) ? (off = -off, '-') : '+';
        int sec = off % 60;
        int min = (off /= 60) % 60;
        off /= 60;
        rb_str_catf(str, " %c%.2d%.2d", sign, (int)off, min);
        if (sec) rb_str_catf(str, "%.2d", sec);
    }
    return str;
}</pre> </div> <p>Returns a string representation of <code>self</code> with subseconds:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
t.inspect # =&gt; "2000-12-31 23:59:59.5 +000001"
</pre> <p>Related: <a href="time.html#method-i-ctime"><code>Time#ctime</code></a>, <a href="time.html#method-i-to_s"><code>Time#to_s</code></a>:</p> <pre class="ruby" data-language="ruby">t.ctime   # =&gt; "Sun Dec 31 23:59:59 2000"
t.to_s    # =&gt; "2000-12-31 23:59:59 +0000"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-isdst"> <span class="method-name">isdst</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-dst-3F">dst?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-iso8601"> <span class="method-name">iso8601</span><span class="method-args">(fraction_digits=0)</span> </div> </div>  <div class="aliases"> Alias for: <a href="time.html#method-i-xmlschema">xmlschema</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-localtime"> <span class="method-callseq"> localtime → self or new_time </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> localtime(zone) → new_time </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="localtime-source"> <pre class="c" data-language="c">static VALUE
time_localtime_m(int argc, VALUE *argv, VALUE time)
{
    VALUE off;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(off = argv[0])) {
        return time_zonelocal(time, off);
    }

    return time_localtime(time);
}</pre> </div> <p>With no argument given:</p> <ul>
<li> <p>Returns <code>self</code> if <code>self</code> is a local time.</p> </li>
<li> <p>Otherwise returns a new <code>Time</code> in the user’s local timezone:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1, 20, 15, 1) # =&gt; 2000-01-01 20:15:01 UTC
t.localtime                         # =&gt; 2000-01-01 14:15:01 -0600
</pre> </li>
</ul> <p>With argument <code>zone</code> given, returns the new <code>Time</code> object created by converting <code>self</code> to the given time zone:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1, 20, 15, 1) # =&gt; 2000-01-01 20:15:01 UTC
t.localtime("-09:00")               # =&gt; 2000-01-01 11:15:01 -0900
</pre> <p>For forms of argument <code>zone</code>, see <a href="time.html#class-Time-label-Timezone+Specifiers">Timezone Specifiers</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mday"> <span class="method-name">mday</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-day">day</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <span class="method-callseq"> min → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
time_min(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);
    return INT2FIX(tobj-&gt;vtm.min);
}</pre> </div> <p>Returns the integer minute of the hour for <code>self</code>, in range (0..59):</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.min # =&gt; 4
</pre> <p>Related: <a href="time.html#method-i-year"><code>Time#year</code></a>, <a href="time.html#method-i-mon"><code>Time#mon</code></a>, <a href="time.html#method-i-sec"><code>Time#sec</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mon"> <span class="method-callseq"> mon → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mon-source"> <pre class="c" data-language="c">static VALUE
time_mon(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);
    return INT2FIX(tobj-&gt;vtm.mon);
}</pre> </div> <p>Returns the integer month of the year for <code>self</code>, in range (1..12):</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.mon # =&gt; 1
</pre> <p>Related: <a href="time.html#method-i-year"><code>Time#year</code></a>, <a href="time.html#method-i-hour"><code>Time#hour</code></a>, <a href="time.html#method-i-min"><code>Time#min</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-month">month</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-monday-3F"> <span class="method-callseq"> monday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="monday-3F-source"> <pre class="c" data-language="c">static VALUE
time_monday(VALUE time)
{
    wday_p(1);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Monday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 3) # =&gt; 2000-01-03 00:00:00 UTC
t.monday?                # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-tuesday-3F"><code>Time#tuesday?</code></a>, <a href="time.html#method-i-wednesday-3F"><code>Time#wednesday?</code></a>, <a href="time.html#method-i-thursday-3F"><code>Time#thursday?</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-month"> <span class="method-name">month</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-mon">mon</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-nsec"> <span class="method-callseq"> nsec → integer </span> </div> </div> <div class="method-description"> <p>Returns the number of nanoseconds in the subseconds part of <code>self</code> in the range (0..999_999_999); lower-order digits are truncated, not rounded:</p> <pre class="ruby" data-language="ruby">t = Time.now # =&gt; 2022-07-11 15:04:53.3219637 -0500
t.nsec       # =&gt; 321963700
</pre> <p>Related: <a href="time.html#method-i-subsec"><code>Time#subsec</code></a> (returns exact subseconds).</p> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-tv_nsec">tv_nsec</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rfc2822"> <span class="method-name">rfc2822</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rfc2822-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 672
def rfc2822
  strftime('%a, %d %b %Y %T ') &lt;&lt; (utc? ? '-0000' : strftime('%z'))
end</pre> </div> <p>Returns a string which represents the time as date-time defined by RFC 2822:</p> <pre>day-of-week, DD month-name CCYY hh:mm:ss zone</pre> <p>where zone is [+-]hhmm.</p> <p>If <code>self</code> is a UTC time, -0000 is used as zone.</p> <pre class="ruby" data-language="ruby">require 'time'

t = Time.now
t.rfc2822  # =&gt; "Wed, 05 Oct 2011 22:26:12 -0400"
</pre> <p>You must require ‘time’ to use this method.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-rfc822">rfc822</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-rfc822"> <span class="method-name">rfc822</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="time.html#method-i-rfc2822">rfc2822</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-round"> <span class="method-callseq"> round(ndigits = 0) → new_time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="round-source"> <pre class="c" data-language="c">static VALUE
time_round(int argc, VALUE *argv, VALUE time)
{
    VALUE ndigits, v, den;
    struct time_object *tobj;

    if (!rb_check_arity(argc, 0, 1) || NIL_P(ndigits = argv[0]))
        den = INT2FIX(1);
    else
        den = ndigits_denominator(ndigits);

    GetTimeval(time, tobj);
    v = w2v(rb_time_unmagnify(tobj-&gt;timew));

    v = modv(v, den);
    if (lt(v, quov(den, INT2FIX(2))))
        return time_add(tobj, time, v, -1);
    else
        return time_add(tobj, time, subv(den, v), 1);
}</pre> </div> <p>Returns a new <code>Time</code> object whose numeric value is that of <code>self</code>, with its seconds value rounded to precision <code>ndigits</code>:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
t          # =&gt; 2010-03-30 05:43:25.123456789 UTC
t.round    # =&gt; 2010-03-30 05:43:25 UTC
t.round(0) # =&gt; 2010-03-30 05:43:25 UTC
t.round(1) # =&gt; 2010-03-30 05:43:25.1 UTC
t.round(2) # =&gt; 2010-03-30 05:43:25.12 UTC
t.round(3) # =&gt; 2010-03-30 05:43:25.123 UTC
t.round(4) # =&gt; 2010-03-30 05:43:25.1235 UTC

t = Time.utc(1999, 12,31, 23, 59, 59)
t                # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.4).round  # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.49).round # =&gt; 1999-12-31 23:59:59 UTC
(t + 0.5).round  # =&gt; 2000-01-01 00:00:00 UTC
(t + 1.4).round  # =&gt; 2000-01-01 00:00:00 UTC
(t + 1.49).round # =&gt; 2000-01-01 00:00:00 UTC
(t + 1.5).round  # =&gt; 2000-01-01 00:00:01 UTC
</pre> <p>Related: <a href="time.html#method-i-ceil"><code>Time#ceil</code></a>, <a href="time.html#method-i-floor"><code>Time#floor</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-saturday-3F"> <span class="method-callseq"> saturday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="saturday-3F-source"> <pre class="c" data-language="c">static VALUE
time_saturday(VALUE time)
{
    wday_p(6);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Saturday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 1) # =&gt; 2000-01-01 00:00:00 UTC
t.saturday?              # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-sunday-3F"><code>Time#sunday?</code></a>, <a href="time.html#method-i-monday-3F"><code>Time#monday?</code></a>, <a href="time.html#method-i-tuesday-3F"><code>Time#tuesday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sec"> <span class="method-callseq"> sec → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sec-source"> <pre class="c" data-language="c">static VALUE
time_sec(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);
    return INT2FIX(tobj-&gt;vtm.sec);
}</pre> </div> <p>Returns the integer second of the minute for <code>self</code>, in range (0..60):</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.sec # =&gt; 5
</pre> <p>Note: the second value may be 60 when there is a <a href="https://en.wikipedia.org/wiki/Leap_second">leap second</a>.</p> <p>Related: <a href="time.html#method-i-year"><code>Time#year</code></a>, <a href="time.html#method-i-mon"><code>Time#mon</code></a>, <a href="time.html#method-i-min"><code>Time#min</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-strftime"> <span class="method-callseq"> strftime(format_string) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="strftime-source"> <pre class="c" data-language="c">static VALUE
time_strftime(VALUE time, VALUE format)
{
    struct time_object *tobj;
    const char *fmt;
    long len;
    rb_encoding *enc;
    VALUE tmp;

    GetTimeval(time, tobj);
    MAKE_TM_ENSURE(time, tobj, tobj-&gt;vtm.yday != 0);
    StringValue(format);
    if (!rb_enc_str_asciicompat_p(format)) {
        rb_raise(rb_eArgError, "format should have ASCII compatible encoding");
    }
    tmp = rb_str_tmp_frozen_acquire(format);
    fmt = RSTRING_PTR(tmp);
    len = RSTRING_LEN(tmp);
    enc = rb_enc_get(format);
    if (len == 0) {
        rb_warning("strftime called with empty format string");
        return rb_enc_str_new(0, 0, enc);
    }
    else {
        VALUE str = rb_strftime_alloc(fmt, len, enc, time, &amp;tobj-&gt;vtm, tobj-&gt;timew,
                                      TZMODE_UTC_P(tobj));
        rb_str_tmp_frozen_release(format, tmp);
        if (!str) rb_raise(rb_eArgError, "invalid format: %"PRIsVALUE, format);
        return str;
    }
}</pre> </div> <p>Returns a string representation of <code>self</code>, formatted according to the given string <code>format</code>. See <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-subsec"> <span class="method-callseq"> subsec → numeric </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="subsec-source"> <pre class="c" data-language="c">static VALUE
time_subsec(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return quov(w2v(wmod(tobj-&gt;timew, WINT2FIXWV(TIME_SCALE))), INT2FIX(TIME_SCALE));
}</pre> </div> <p>Returns the exact subseconds for <code>self</code> as a <a href="numeric.html"><code>Numeric</code></a> (<a href="integer.html"><code>Integer</code></a> or <a href="rational.html"><code>Rational</code></a>):</p> <pre class="ruby" data-language="ruby">t = Time.now # =&gt; 2022-07-11 15:11:36.8490302 -0500
t.subsec     # =&gt; (4245151/5000000)
</pre> <p>If the subseconds is zero, returns integer zero:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 1, 2, 3, 4) # =&gt; 2000-01-01 02:03:04 -0600
t.subsec                          # =&gt; 0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sunday-3F"> <span class="method-callseq"> sunday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sunday-3F-source"> <pre class="c" data-language="c">static VALUE
time_sunday(VALUE time)
{
    wday_p(0);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Sunday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 2) # =&gt; 2000-01-02 00:00:00 UTC
t.sunday?                # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-monday-3F"><code>Time#monday?</code></a>, <a href="time.html#method-i-tuesday-3F"><code>Time#tuesday?</code></a>, <a href="time.html#method-i-wednesday-3F"><code>Time#wednesday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-thursday-3F"> <span class="method-callseq"> thursday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="thursday-3F-source"> <pre class="c" data-language="c">static VALUE
time_thursday(VALUE time)
{
    wday_p(4);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Thursday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 6) # =&gt; 2000-01-06 00:00:00 UTC
t.thursday?              # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-friday-3F"><code>Time#friday?</code></a>, <a href="time.html#method-i-saturday-3F"><code>Time#saturday?</code></a>, <a href="time.html#method-i-sunday-3F"><code>Time#sunday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
time_to_a(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM_ENSURE(time, tobj, tobj-&gt;vtm.yday != 0);
    return rb_ary_new3(10,
                    INT2FIX(tobj-&gt;vtm.sec),
                    INT2FIX(tobj-&gt;vtm.min),
                    INT2FIX(tobj-&gt;vtm.hour),
                    INT2FIX(tobj-&gt;vtm.mday),
                    INT2FIX(tobj-&gt;vtm.mon),
                    tobj-&gt;vtm.year,
                    INT2FIX(tobj-&gt;vtm.wday),
                    INT2FIX(tobj-&gt;vtm.yday),
                    RBOOL(tobj-&gt;vtm.isdst),
                    time_zone(time));
}</pre> </div> <p>Returns a 10-element array of values representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1).to_a
# =&gt; [0,   0,   0,    1,   1,   2000, 6,    1,    false, "UTC"]
#    [sec, min, hour, day, mon, year, wday, yday, dst?,   zone]
</pre> <p>The returned array is suitable for use as an argument to <a href="time.html#method-c-utc"><code>Time.utc</code></a> or <a href="time.html#method-c-local"><code>Time.local</code></a> to create a new <code>Time</code> object.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_date"> <span class="method-callseq"> to_date → date </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_date-source"> <pre class="c" data-language="c">static VALUE
time_to_date(VALUE self)
{
    VALUE y, nth, ret;
    int ry, m, d;

    y = f_year(self);
    m = FIX2INT(f_mon(self));
    d = FIX2INT(f_mday(self));

    decode_year(y, -1, &amp;nth, &amp;ry);

    ret = d_simple_new_internal(cDate,
                                nth, 0,
                                GREGORIAN,
                                ry, m, d,
                                HAVE_CIVIL);
    {
        get_d1(ret);
        set_sg(dat, DEFAULT_SG);
    }
    return ret;
}</pre> </div> <p>Returns a <a href="date.html"><code>Date</code></a> object which denotes self.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_datetime"> <span class="method-callseq"> to_datetime → datetime </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_datetime-source"> <pre class="c" data-language="c">static VALUE
time_to_datetime(VALUE self)
{
    VALUE y, sf, nth, ret;
    int ry, m, d, h, min, s, of;

    y = f_year(self);
    m = FIX2INT(f_mon(self));
    d = FIX2INT(f_mday(self));

    h = FIX2INT(f_hour(self));
    min = FIX2INT(f_min(self));
    s = FIX2INT(f_sec(self));
    if (s == 60)
        s = 59;

    sf = sec_to_ns(f_subsec(self));
    of = FIX2INT(f_utc_offset(self));

    decode_year(y, -1, &amp;nth, &amp;ry);

    ret = d_complex_new_internal(cDateTime,
                                 nth, 0,
                                 0, sf,
                                 of, GREGORIAN,
                                 ry, m, d,
                                 h, min, s,
                                 HAVE_CIVIL | HAVE_TIME);
    {
        get_d1(ret);
        set_sg(dat, DEFAULT_SG);
    }
    return ret;
}</pre> </div> <p>Returns a <a href="datetime.html"><code>DateTime</code></a> object which denotes self.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_f"> <span class="method-callseq"> to_f → float </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_f-source"> <pre class="c" data-language="c">static VALUE
time_to_f(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return rb_Float(rb_time_unmagnify_to_float(tobj-&gt;timew));
}</pre> </div> <p>Returns the value of <code>self</code> as a <a href="float.html"><code>Float</code></a> number <a href="time.html#class-Time-label-Epoch+Seconds">Epoch seconds</a>; subseconds are included.</p> <p>The stored value of <code>self</code> is a <a href="#">Rational</a>, which means that the returned value may be approximate:</p> <pre class="ruby" data-language="ruby">Time.utc(1970, 1, 1, 0, 0, 0).to_f         # =&gt; 0.0
Time.utc(1970, 1, 1, 0, 0, 0, 999999).to_f # =&gt; 0.999999
Time.utc(1950, 1, 1, 0, 0, 0).to_f         # =&gt; -631152000.0
Time.utc(1990, 1, 1, 0, 0, 0).to_f         # =&gt; 631152000.0
</pre> <p>Related: <a href="time.html#method-i-to_i"><code>Time#to_i</code></a>, <a href="time.html#method-i-to_r"><code>Time#to_r</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_i"> <span class="method-callseq"> to_i → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_i-source"> <pre class="c" data-language="c">static VALUE
time_to_i(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return w2v(wdiv(tobj-&gt;timew, WINT2FIXWV(TIME_SCALE)));
}</pre> </div> <p>Returns the value of <code>self</code> as integer <a href="time.html#class-Time-label-Epoch+Seconds">Epoch seconds</a>; subseconds are truncated (not rounded):</p> <pre class="ruby" data-language="ruby">Time.utc(1970, 1, 1, 0, 0, 0).to_i         # =&gt; 0
Time.utc(1970, 1, 1, 0, 0, 0, 999999).to_i # =&gt; 0
Time.utc(1950, 1, 1, 0, 0, 0).to_i         # =&gt; -631152000
Time.utc(1990, 1, 1, 0, 0, 0).to_i         # =&gt; 631152000
</pre> <p>Related: <a href="time.html#method-i-to_f"><code>Time#to_f</code></a> <a href="time.html#method-i-to_r"><code>Time#to_r</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-tv_sec">tv_sec</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/time.rb, line 56
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/time'
puts Time.now.to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Time","s":1700931678,"n":980650786}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_r"> <span class="method-callseq"> to_r → rational </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_r-source"> <pre class="c" data-language="c">static VALUE
time_to_r(VALUE time)
{
    struct time_object *tobj;
    VALUE v;

    GetTimeval(time, tobj);
    v = rb_time_unmagnify_to_rational(tobj-&gt;timew);
    if (!RB_TYPE_P(v, T_RATIONAL)) {
        v = rb_Rational1(v);
    }
    return v;
}</pre> </div> <p>Returns the value of <code>self</code> as a <a href="rational.html"><code>Rational</code></a> exact number of <a href="time.html#class-Time-label-Epoch+Seconds">Epoch seconds</a>;</p> <pre class="ruby" data-language="ruby">Time.now.to_r # =&gt; (16571402750320203/10000000)
</pre> <p>Related: <a href="time.html#method-i-to_f"><code>Time#to_f</code></a>, <a href="time.html#method-i-to_i"><code>Time#to_i</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
time_to_s(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (TZMODE_UTC_P(tobj))
        return strftimev("%Y-%m-%d %H:%M:%S UTC", time, rb_usascii_encoding());
    else
        return strftimev("%Y-%m-%d %H:%M:%S %z", time, rb_usascii_encoding());
}</pre> </div> <p>Returns a string representation of <code>self</code>, without subseconds:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
t.to_s    # =&gt; "2000-12-31 23:59:59 +0000"
</pre> <p>Related: <a href="time.html#method-i-ctime"><code>Time#ctime</code></a>, <a href="time.html#method-i-inspect"><code>Time#inspect</code></a>:</p> <pre class="ruby" data-language="ruby">t.ctime   # =&gt; "Sun Dec 31 23:59:59 2000"
t.inspect # =&gt; "2000-12-31 23:59:59.5 +000001"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_time"> <span class="method-callseq"> to_time → time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_time-source"> <pre class="c" data-language="c">static VALUE
time_to_time(VALUE self)
{
    return self;
}</pre> </div> <p>Returns self.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tuesday-3F"> <span class="method-callseq"> tuesday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tuesday-3F-source"> <pre class="c" data-language="c">static VALUE
time_tuesday(VALUE time)
{
    wday_p(2);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Tuesday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 4) # =&gt; 2000-01-04 00:00:00 UTC
t.tuesday?               # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-wednesday-3F"><code>Time#wednesday?</code></a>, <a href="time.html#method-i-thursday-3F"><code>Time#thursday?</code></a>, <a href="time.html#method-i-friday-3F"><code>Time#friday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tv_nsec"> <span class="method-name">tv_nsec</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-nsec">nsec</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-tv_sec"> <span class="method-name">tv_sec</span> </div> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-to_i">to_i</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tv_usec"> <span class="method-name">tv_usec</span> </div> </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-usec">usec</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-usec"> <span class="method-callseq"> usec → integer </span> </div> </div> <div class="method-description"> <p>Returns the number of microseconds in the subseconds part of <code>self</code> in the range (0..999_999); lower-order digits are truncated, not rounded:</p> <pre class="ruby" data-language="ruby">t = Time.now # =&gt; 2022-07-11 14:59:47.5484697 -0500
t.usec       # =&gt; 548469
</pre> <p>Related: <a href="time.html#method-i-subsec"><code>Time#subsec</code></a> (returns exact subseconds).</p> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-tv_usec">tv_usec</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-utc"> <span class="method-callseq"> utc → self </span> </div> </div> <div class="method-description"> <p>Returns <code>self</code>, converted to the UTC timezone:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000) # =&gt; 2000-01-01 00:00:00 -0600
t.utc?             # =&gt; false
t.utc              # =&gt; 2000-01-01 06:00:00 UTC
t.utc?             # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-getutc"><code>Time#getutc</code></a> (returns a new converted <code>Time</code> object).</p> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-gmtime">gmtime</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-utc-3F"> <span class="method-callseq"> utc? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="utc-3F-source"> <pre class="c" data-language="c">static VALUE
time_utc_p(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return RBOOL(TZMODE_UTC_P(tobj));
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a time in UTC (GMT):</p> <pre class="ruby" data-language="ruby">now = Time.now
# =&gt; 2022-08-18 10:24:13.5398485 -0500
now.utc? # =&gt; false
utc = Time.utc(2000, 1, 1, 20, 15, 1)
# =&gt; 2000-01-01 20:15:01 UTC
utc.utc? # =&gt; true
</pre> <p>Related: <a href="time.html#method-c-utc"><code>Time.utc</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-gmt-3F">gmt?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-utc_offset"> <span class="method-callseq"> utc_offset → integer </span> </div> </div> <div class="method-description"> <p>Returns the offset in seconds between the timezones of UTC and <code>self</code>:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1).utc_offset   # =&gt; 0
Time.local(2000, 1, 1).utc_offset # =&gt; -21600 # -6*3600, or minus six hours.
</pre> </div> <div class="aliases"> Alias for: <a href="time.html#method-i-gmtoff">gmtoff</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-wday"> <span class="method-callseq"> wday → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="wday-source"> <pre class="c" data-language="c">static VALUE
time_wday(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM_ENSURE(time, tobj, tobj-&gt;vtm.wday != VTM_WDAY_INITVAL);
    return INT2FIX((int)tobj-&gt;vtm.wday);
}</pre> </div> <p>Returns the integer day of the week for <code>self</code>, in range (0..6), with Sunday as zero.</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.wday    # =&gt; 0
t.sunday? # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-year"><code>Time#year</code></a>, <a href="time.html#method-i-hour"><code>Time#hour</code></a>, <a href="time.html#method-i-min"><code>Time#min</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-wednesday-3F"> <span class="method-callseq"> wednesday? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="wednesday-3F-source"> <pre class="c" data-language="c">static VALUE
time_wednesday(VALUE time)
{
    wday_p(3);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> represents a Wednesday, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">t = Time.utc(2000, 1, 5) # =&gt; 2000-01-05 00:00:00 UTC
t.wednesday?             # =&gt; true
</pre> <p>Related: <a href="time.html#method-i-thursday-3F"><code>Time#thursday?</code></a>, <a href="time.html#method-i-friday-3F"><code>Time#friday?</code></a>, <a href="time.html#method-i-saturday-3F"><code>Time#saturday?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-xmlschema"> <span class="method-name">xmlschema</span><span class="method-args">(fraction_digits=0)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="xmlschema-source"> <pre class="ruby" data-language="ruby"># File lib/time.rb, line 717
def xmlschema(fraction_digits=0)
  fraction_digits = fraction_digits.to_i
  s = strftime("%FT%T")
  if fraction_digits &gt; 0
    s &lt;&lt; strftime(".%#{fraction_digits}N")
  end
  s &lt;&lt; (utc? ? 'Z' : strftime("%:z"))
end</pre> </div> <p>Returns a string which represents the time as a dateTime defined by XML Schema:</p> <pre>CCYY-MM-DDThh:mm:ssTZD
CCYY-MM-DDThh:mm:ss.sssTZD</pre> <p>where TZD is Z or [+-]hh:mm.</p> <p>If self is a UTC time, Z is used as TZD. [+-]hh:mm is used otherwise.</p> <p><code>fraction_digits</code> specifies a number of digits to use for fractional seconds. Its default value is 0.</p> <pre class="ruby" data-language="ruby">require 'time'

t = Time.now
t.iso8601  # =&gt; "2011-10-05T22:26:12-04:00"
</pre> <p>You must require ‘time’ to use this method.</p>  </div> <div class="aliases"> Also aliased as: <a href="time.html#method-i-iso8601">iso8601</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-yday"> <span class="method-callseq"> yday → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="yday-source"> <pre class="c" data-language="c">static VALUE
time_yday(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM_ENSURE(time, tobj, tobj-&gt;vtm.yday != 0);
    return INT2FIX(tobj-&gt;vtm.yday);
}</pre> </div> <p>Returns the integer day of the year of <code>self</code>, in range (1..366).</p> <pre class="ruby" data-language="ruby">Time.new(2000, 1, 1).yday   # =&gt; 1
Time.new(2000, 12, 31).yday # =&gt; 366
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-year"> <span class="method-callseq"> year → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="year-source"> <pre class="c" data-language="c">static VALUE
time_year(VALUE time)
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);
    return tobj-&gt;vtm.year;
}</pre> </div> <p>Returns the integer year for <code>self</code>:</p> <pre class="ruby" data-language="ruby">t = Time.new(2000, 1, 2, 3, 4, 5, 6)
# =&gt; 2000-01-02 03:04:05 +000006
t.year # =&gt; 2000
</pre> <p>Related: <a href="time.html#method-i-mon"><code>Time#mon</code></a>, <a href="time.html#method-i-hour"><code>Time#hour</code></a>, <a href="time.html#method-i-min"><code>Time#min</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-zone"> <span class="method-callseq"> zone → string or timezone </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="zone-source"> <pre class="c" data-language="c">static VALUE
time_zone(VALUE time)
{
    struct time_object *tobj;
    VALUE zone;

    GetTimeval(time, tobj);
    MAKE_TM(time, tobj);

    if (TZMODE_UTC_P(tobj)) {
        return rb_usascii_str_new_cstr("UTC");
    }
    zone = tobj-&gt;vtm.zone;
    if (NIL_P(zone))
        return Qnil;

    if (RB_TYPE_P(zone, T_STRING))
        zone = rb_str_dup(zone);
    return zone;
}</pre> </div> <p>Returns the string name of the time zone for <code>self</code>:</p> <pre class="ruby" data-language="ruby">Time.utc(2000, 1, 1).zone # =&gt; "UTC"
Time.new(2000, 1, 1).zone # =&gt; "Central Standard Time"
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
