<h1 id="class-DRb::DRbSSLSocket::SSLConfig" class="class"> class DRb::DRbSSLSocket::SSLConfig </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../object.html">Object</a></dd>
</dl> <section class="description"> <p><a href="sslconfig.html"><code>SSLConfig</code></a> handles the needed SSL information for establishing a <a href="../drbsslsocket.html"><code>DRbSSLSocket</code></a> connection, including generating the X509 / RSA pair.</p> <p>An instance of this config can be passed to <a href="../drbsslsocket.html#method-c-new"><code>DRbSSLSocket.new</code></a>, <a href="../drbsslsocket.html#method-c-open"><code>DRbSSLSocket.open</code></a> and <a href="../drbsslsocket.html#method-c-open_server"><code>DRbSSLSocket.open_server</code></a></p> <p>See <a href="sslconfig.html#method-c-new"><code>DRb::DRbSSLSocket::SSLConfig.new</code></a> for more details</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DEFAULT">DEFAULT </dt>
<dd>
<p>Default values for a <a href="sslconfig.html"><code>SSLConfig</code></a> instance.</p> <p>See <a href="sslconfig.html#method-c-new"><code>DRb::DRbSSLSocket::SSLConfig.new</code></a> for more details</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(config)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 135
def initialize(config)
  @config  = config
  @cert    = config[:SSLCertificate]
  @pkey    = config[:SSLPrivateKey]
  @ssl_ctx = nil
end</pre> </div> <p>Create a new <a href="sslconfig.html"><code>DRb::DRbSSLSocket::SSLConfig</code></a> instance</p> <p>The <a href="../drbsslsocket.html"><code>DRb::DRbSSLSocket</code></a> will take either a <code>config</code> <a href="../../hash.html"><code>Hash</code></a> or an instance of <a href="sslconfig.html"><code>SSLConfig</code></a>, and will setup the certificate for its session for the configuration. If want it to generate a generic certificate, the bare minimum is to provide the :SSLCertName</p> <h3 id="method-c-new-label-Config+options">Config options</h3> <p>From <code>config</code> Hash:</p> <dl class="rdoc-list note-list">
<dt>:SSLCertificate </dt>
<dd> <p>An instance of <a href="../../openssl/x509/certificate.html"><code>OpenSSL::X509::Certificate</code></a>. If this is not provided, then a generic X509 is generated, with a correspond :SSLPrivateKey</p> </dd>
<dt>:SSLPrivateKey </dt>
<dd> <p>A private key instance, like <a href="../../openssl/pkey/rsa.html"><code>OpenSSL::PKey::RSA</code></a>. This key must be the key that signed the :SSLCertificate</p> </dd>
<dt>:SSLClientCA </dt>
<dd> <p>An <a href="../../openssl/x509/certificate.html"><code>OpenSSL::X509::Certificate</code></a>, or <a href="../../array.html"><code>Array</code></a> of certificates that will used as ClientCAs in the SSL Context</p> </dd>
<dt>:SSLCACertificatePath </dt>
<dd> <p>A path to the directory of CA certificates. The certificates must be in PEM format.</p> </dd>
<dt>:SSLCACertificateFile </dt>
<dd> <p>A path to a CA certificate file, in PEM format.</p> </dd>
<dt>:SSLTmpDhCallback </dt>
<dd> <p>A DH callback. See <a href="../../openssl/ssl/sslcontext.html#attribute-i-tmp_dh_callback"><code>OpenSSL::SSL::SSLContext.tmp_dh_callback</code></a></p> </dd>
<dt>:SSLMinVersion </dt>
<dd> <p>This is the minimum SSL version to allow. See <a href="../../openssl/ssl/sslcontext.html#method-i-min_version-3D"><code>OpenSSL::SSL::SSLContext#min_version=</code></a>.</p> </dd>
<dt>:SSLMaxVersion </dt>
<dd> <p>This is the maximum SSL version to allow. See <a href="../../openssl/ssl/sslcontext.html#method-i-max_version-3D"><code>OpenSSL::SSL::SSLContext#max_version=</code></a>.</p> </dd>
<dt>:SSLVerifyMode </dt>
<dd> <p>This is the SSL verification mode. See OpenSSL::SSL::VERIFY_* for available modes. The default is OpenSSL::SSL::VERIFY_NONE</p> </dd>
<dt>:SSLVerifyDepth </dt>
<dd> <p>Number of CA certificates to walk, when verifying a certificate chain.</p> </dd>
<dt>:SSLVerifyCallback </dt>
<dd> <p>A callback to be used for additional verification. See <a href="../../openssl/ssl/sslcontext.html#attribute-i-verify_callback"><code>OpenSSL::SSL::SSLContext.verify_callback</code></a></p> </dd>
<dt>:SSLCertificateStore </dt>
<dd> <p>A <a href="../../openssl/x509/store.html"><code>OpenSSL::X509::Store</code></a> used for verification of certificates</p> </dd>
<dt>:SSLCertName </dt>
<dd> <p>Issuer name for the certificate. This is required when generating the certificate (if :SSLCertificate and :SSLPrivateKey were not given). The value of this is to be an <a href="../../array.html"><code>Array</code></a> of pairs:</p> <pre class="ruby" data-language="ruby">[["C", "Raleigh"], ["ST","North Carolina"],
 ["CN","fqdn.example.com"]]
</pre> <p>See also <a href="../../openssl/x509/name.html"><code>OpenSSL::X509::Name</code></a></p> </dd>
<dt>:SSLCertComment </dt>
<dd> <p>A comment to be used for generating the certificate. The default is “Generated by Ruby/OpenSSL”</p> </dd>
</dl> <h3 id="method-c-new-label-Example">Example</h3> <p>These values can be added after the fact, like a <a href="../../hash.html"><code>Hash</code></a>.</p> <pre class="ruby" data-language="ruby">require 'drb/ssl'
c = DRb::DRbSSLSocket::SSLConfig.new {}
c[:SSLCertificate] =
  OpenSSL::X509::Certificate.new(File.read('mycert.crt'))
c[:SSLPrivateKey] = OpenSSL::PKey::RSA.new(File.read('mycert.key'))
c[:SSLVerifyMode] = OpenSSL::SSL::VERIFY_PEER
c[:SSLCACertificatePath] = "/etc/ssl/certs/"
c.setup_certificate
</pre> <p>or</p> <pre class="ruby" data-language="ruby">require 'drb/ssl'
c = DRb::DRbSSLSocket::SSLConfig.new({
        :SSLCertName =&gt; [["CN" =&gt; DRb::DRbSSLSocket.getservername]]
        })
c.setup_certificate
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 143
def [](key);
  @config[key] || DEFAULT[key]
end</pre> </div> <p>A convenience method to access the values like a <a href="../../hash.html"><code>Hash</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(tcp)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 158
def accept(tcp)
  ssl = OpenSSL::SSL::SSLSocket.new(tcp, @ssl_ctx)
  ssl.sync = true
  ssl.accept
  ssl
end</pre> </div> <p>Accept connection to <a href="../../io.html"><code>IO</code></a> <code>tcp</code>, with context of the current certificate configuration</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-connect"> <span class="method-name">connect</span><span class="method-args">(tcp)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="connect-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 149
def connect(tcp)
  ssl = ::OpenSSL::SSL::SSLSocket.new(tcp, @ssl_ctx)
  ssl.sync = true
  ssl.connect
  ssl
end</pre> </div> <p>Connect to <a href="../../io.html"><code>IO</code></a> <code>tcp</code>, with context of the current certificate configuration</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-setup_certificate"> <span class="method-name">setup_certificate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="setup_certificate-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 168
def setup_certificate
  if @cert &amp;&amp; @pkey
    return
  end

  rsa = OpenSSL::PKey::RSA.new(2048){|p, n|
    next unless self[:verbose]
    case p
    when 0; $stderr.putc "."  # BN_generate_prime
    when 1; $stderr.putc "+"  # BN_generate_prime
    when 2; $stderr.putc "*"  # searching good prime,
                              # n = #of try,
                              # but also data from BN_generate_prime
    when 3; $stderr.putc "\n" # found good prime, n==0 - p, n==1 - q,
                              # but also data from BN_generate_prime
    else;   $stderr.putc "*"  # BN_generate_prime
    end
  }

  cert = OpenSSL::X509::Certificate.new
  cert.version = 3
  cert.serial = 0
  name = OpenSSL::X509::Name.new(self[:SSLCertName])
  cert.subject = name
  cert.issuer = name
  cert.not_before = Time.now
  cert.not_after = Time.now + (365*24*60*60)
  cert.public_key = rsa.public_key

  ef = OpenSSL::X509::ExtensionFactory.new(nil,cert)
  cert.extensions = [
    ef.create_extension("basicConstraints","CA:FALSE"),
    ef.create_extension("subjectKeyIdentifier", "hash") ]
  ef.issuer_certificate = cert
  cert.add_extension(ef.create_extension("authorityKeyIdentifier",
                                         "keyid:always,issuer:always"))
  if comment = self[:SSLCertComment]
    cert.add_extension(ef.create_extension("nsComment", comment))
  end
  cert.sign(rsa, "SHA256")

  @cert = cert
  @pkey = rsa
end</pre> </div> <p>Ensures that :SSLCertificate and :SSLPrivateKey have been provided or that a new certificate is generated with the other parameters provided.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-setup_ssl_context"> <span class="method-name">setup_ssl_context</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="setup_ssl_context-source"> <pre class="ruby" data-language="ruby"># File lib/drb/ssl.rb, line 215
def setup_ssl_context
  ctx = ::OpenSSL::SSL::SSLContext.new
  ctx.cert            = @cert
  ctx.key             = @pkey
  ctx.min_version     = self[:SSLMinVersion]
  ctx.max_version     = self[:SSLMaxVersion]
  ctx.client_ca       = self[:SSLClientCA]
  ctx.ca_path         = self[:SSLCACertificatePath]
  ctx.ca_file         = self[:SSLCACertificateFile]
  ctx.tmp_dh_callback = self[:SSLTmpDhCallback]
  ctx.verify_mode     = self[:SSLVerifyMode]
  ctx.verify_depth    = self[:SSLVerifyDepth]
  ctx.verify_callback = self[:SSLVerifyCallback]
  ctx.cert_store      = self[:SSLCertificateStore]
  @ssl_ctx = ctx
end</pre> </div> <p>Establish the <a href="../../openssl/ssl/sslcontext.html"><code>OpenSSL::SSL::SSLContext</code></a> with the configuration parameters provided.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
