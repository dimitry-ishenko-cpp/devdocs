<h1 id="class-Hash" class="class"> class Hash </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <p>A Hash maps each of its unique keys to a specific value.</p> <p>A Hash has certain similarities to an <a href="array.html"><code>Array</code></a>, but:</p> <ul>
<li> <p>An <a href="array.html"><code>Array</code></a> index is always an <a href="integer.html"><code>Integer</code></a>.</p> </li>
<li> <p>A Hash key can be (almost) any object.</p> </li>
</ul> <h3 id="class-Hash-label-Hash+Data+Syntax">Hash Data Syntax</h3> <p>The older syntax for Hash data uses the “hash rocket,” <code>=&gt;</code>:</p> <pre class="ruby" data-language="ruby">h = {:foo =&gt; 0, :bar =&gt; 1, :baz =&gt; 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Alternatively, but only for a Hash key that’s a <a href="symbol.html"><code>Symbol</code></a>, you can use a newer JSON-style syntax, where each bareword becomes a Symbol:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>You can also use a <a href="string.html"><code>String</code></a> in place of a bareword:</p> <pre class="ruby" data-language="ruby">h = {'foo': 0, 'bar': 1, 'baz': 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>And you can mix the styles:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, :bar =&gt; 1, 'baz': 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>But it’s an error to try the JSON-style syntax for a key that’s not a bareword or a String:</p> <pre># Raises SyntaxError (syntax error, unexpected ':', expecting =&gt;):
h = {0: 'zero'}</pre> <p><a href="hash.html"><code>Hash</code></a> value can be omitted, meaning that value will be fetched from the context by the name of the key:</p> <pre class="ruby" data-language="ruby">x = 0
y = 100
h = {x:, y:}
h # =&gt; {:x=&gt;0, :y=&gt;100}
</pre> <h3 id="class-Hash-label-Common+Uses">Common Uses</h3> <p>You can use a Hash to give names to objects:</p> <pre class="ruby" data-language="ruby">person = {name: 'Matz', language: 'Ruby'}
person # =&gt; {:name=&gt;"Matz", :language=&gt;"Ruby"}
</pre> <p>You can use a Hash to give names to method arguments:</p> <pre class="ruby" data-language="ruby">def some_method(hash)
  p hash
end
some_method({foo: 0, bar: 1, baz: 2}) # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Note: when the last argument in a method call is a Hash, the curly braces may be omitted:</p> <pre class="ruby" data-language="ruby">some_method(foo: 0, bar: 1, baz: 2) # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>You can use a Hash to initialize an object:</p> <pre class="ruby" data-language="ruby">class Dev
  attr_accessor :name, :language
  def initialize(hash)
    self.name = hash[:name]
    self.language = hash[:language]
  end
end
matz = Dev.new(name: 'Matz', language: 'Ruby')
matz # =&gt; #&lt;Dev: @name="Matz", @language="Ruby"&gt;
</pre> <h3 id="class-Hash-label-Creating+a+Hash">Creating a Hash</h3> <p>You can create a Hash object explicitly with:</p> <ul><li> <p>A <a href="syntax/literals_rdoc.html#label-Hash+Literals">hash literal</a>.</p> </li></ul> <p>You can convert certain objects to Hashes with:</p> <ul><li> <p>Method <a href="kernel.html#method-i-Hash"><code>Hash</code></a>.</p> </li></ul> <p>You can create a Hash by calling method <a href="hash.html#method-c-new"><code>Hash.new</code></a>.</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h # =&gt; {}
h.class # =&gt; Hash
</pre> <p>You can create a Hash by calling method <a href="hash.html#method-c-5B-5D"><code>Hash.[]</code></a>.</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = Hash[]
h # =&gt; {}
</pre> <p>Create a Hash with initial entries:</p> <pre class="ruby" data-language="ruby">h = Hash[foo: 0, bar: 1, baz: 2]
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>You can create a Hash by using its literal form (curly braces).</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = {}
h # =&gt; {}
</pre> <p>Create a Hash with initial entries:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <h3 id="class-Hash-label-Hash+Value+Basics">Hash Value Basics</h3> <p>The simplest way to retrieve a Hash value (instance method <a href="hash.html#method-i-5B-5D"><code>[]</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:foo] # =&gt; 0
</pre> <p>The simplest way to create or update a Hash value (instance method <a href="hash.html#method-i-5B-5D-3D"><code>[]=</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:bat] = 3 # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
h[:foo] = 4 # =&gt; 4
h # =&gt; {:foo=&gt;4, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre> <p>The simplest way to delete a Hash entry (instance method <a href="hash.html#method-i-delete"><code>delete</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:bar) # =&gt; 1
h # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <h3 id="class-Hash-label-Entry+Order">Entry Order</h3> <p>A Hash object presents its entries in the order of their creation. This is seen in:</p> <ul>
<li> <p>Iterative methods such as <code>each</code>, <code>each_key</code>, <code>each_pair</code>, <code>each_value</code>.</p> </li>
<li> <p>Other order-sensitive methods such as <code>shift</code>, <code>keys</code>, <code>values</code>.</p> </li>
<li> <p>The <a href="string.html"><code>String</code></a> returned by method <code>inspect</code>.</p> </li>
</ul> <p>A new Hash has its initial ordering per the given entries:</p> <pre class="ruby" data-language="ruby">h = Hash[foo: 0, bar: 1]
h # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>New entries are added at the end:</p> <pre class="ruby" data-language="ruby">h[:baz] = 2
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Updating a value does not affect the order:</p> <pre class="ruby" data-language="ruby">h[:baz] = 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;3}
</pre> <p>But re-creating a deleted entry can affect the order:</p> <pre class="ruby" data-language="ruby">h.delete(:foo)
h[:foo] = 5
h # =&gt; {:bar=&gt;1, :baz=&gt;3, :foo=&gt;5}
</pre> <h3 id="class-Hash-label-Hash+Keys">Hash Keys</h3> <h4 id="class-Hash-label-Hash+Key+Equivalence">Hash Key Equivalence</h4> <p>Two objects are treated as the same hash key when their <code>hash</code> value is identical and the two objects are <code>eql?</code> to each other.</p> <h4 id="class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</h4> <p>Modifying a Hash key while it is in use damages the hash’s index.</p> <p>This Hash has keys that are Arrays:</p> <pre class="ruby" data-language="ruby">a0 = [ :foo, :bar ]
a1 = [ :baz, :bat ]
h = {a0 =&gt; 0, a1 =&gt; 1}
h.include?(a0) # =&gt; true
h[a0] # =&gt; 0
a0.hash # =&gt; 110002110
</pre> <p>Modifying array element <code>a0[0]</code> changes its hash value:</p> <pre class="ruby" data-language="ruby">a0[0] = :bam
a0.hash # =&gt; 1069447059
</pre> <p>And damages the Hash index:</p> <pre class="ruby" data-language="ruby">h.include?(a0) # =&gt; false
h[a0] # =&gt; nil
</pre> <p>You can repair the hash index using method <code>rehash</code>:</p> <pre class="ruby" data-language="ruby">h.rehash # =&gt; {[:bam, :bar]=&gt;0, [:baz, :bat]=&gt;1}
h.include?(a0) # =&gt; true
h[a0] # =&gt; 0
</pre> <p>A <a href="string.html"><code>String</code></a> key is always safe. That’s because an unfrozen <a href="string.html"><code>String</code></a> passed as a key will be replaced by a duplicated and frozen String:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.frozen? # =&gt; false
h = {s =&gt; 0}
first_key = h.keys.first
first_key.frozen? # =&gt; true
</pre> <h4 id="class-Hash-label-User-Defined+Hash+Keys">User-Defined Hash Keys</h4> <p>To be useable as a Hash key, objects must implement the methods <code>hash</code> and <code>eql?</code>. Note: this requirement does not apply if the Hash uses <a href="hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a> since comparison will then rely on the keys’ object id instead of <code>hash</code> and <code>eql?</code>.</p> <p><a href="object.html"><code>Object</code></a> defines basic implementation for <code>hash</code> and <code>eq?</code> that makes each object a distinct key. Typically, user-defined classes will want to override these methods to provide meaningful behavior, or for example inherit <a href="struct.html"><code>Struct</code></a> that has useful definitions for these.</p> <p>A typical implementation of <code>hash</code> is based on the object’s data while <code>eql?</code> is usually aliased to the overridden <code>==</code> method:</p> <pre class="ruby" data-language="ruby">class Book
  attr_reader :author, :title

  def initialize(author, title)
    @author = author
    @title = title
  end

  def ==(other)
    self.class === other &amp;&amp;
      other.author == @author &amp;&amp;
      other.title == @title
  end

  alias eql? ==

  def hash
    [self.class, @author, @title].hash
  end
end

book1 = Book.new 'matz', 'Ruby in a Nutshell'
book2 = Book.new 'matz', 'Ruby in a Nutshell'

reviews = {}

reviews[book1] = 'Great reference!'
reviews[book2] = 'Nice and compact!'

reviews.length #=&gt; 1
</pre> <h3 id="class-Hash-label-Default+Values">Default Values</h3> <p>The methods <a href="hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="hash.html#method-i-values_at"><code>values_at</code></a> and <a href="hash.html#method-i-dig"><code>dig</code></a> need to return the value associated to a certain key. When that key is not found, that value will be determined by its default proc (if any) or else its default (initially ‘nil`).</p> <p>You can retrieve the default value with method <a href="hash.html#method-i-default"><code>default</code></a>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default # =&gt; nil
</pre> <p>You can set the default value by passing an argument to method <a href="hash.html#method-c-new"><code>Hash.new</code></a> or with method <a href="hash.html#method-i-default-3D"><code>default=</code></a></p> <pre class="ruby" data-language="ruby">h = Hash.new(-1)
h.default # =&gt; -1
h.default = 0
h.default # =&gt; 0
</pre> <p>This default value is returned for <a href="hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="hash.html#method-i-values_at"><code>values_at</code></a> and <a href="hash.html#method-i-dig"><code>dig</code></a> when a key is not found:</p> <pre class="ruby" data-language="ruby">counts = {foo: 42}
counts.default # =&gt; nil (default)
counts[:foo] = 42
counts[:bar] # =&gt; nil
counts.default = 0
counts[:bar] # =&gt; 0
counts.values_at(:foo, :bar, :baz) # =&gt; [42, 0, 0]
counts.dig(:bar) # =&gt; 0
</pre> <p>Note that the default value is used without being duplicated. It is not advised to set the default value to a mutable object:</p> <pre class="ruby" data-language="ruby">synonyms = Hash.new([])
synonyms[:hello] # =&gt; []
synonyms[:hello] &lt;&lt; :hi # =&gt; [:hi], but this mutates the default!
synonyms.default # =&gt; [:hi]
synonyms[:world] &lt;&lt; :universe
synonyms[:world] # =&gt; [:hi, :universe], oops
synonyms.keys # =&gt; [], oops
</pre> <p>To use a mutable object as default, it is recommended to use a default proc</p> <h4 id="class-Hash-label-Default+Proc">Default <a href="proc.html"><code>Proc</code></a>
</h4> <p>When the default proc for a Hash is set (i.e., not <code>nil</code>), the default value returned by method <a href="hash.html#method-i-5B-5D"><code>[]</code></a> is determined by the default proc alone.</p> <p>You can retrieve the default proc with method <a href="hash.html#method-i-default_proc"><code>default_proc</code></a>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default_proc # =&gt; nil
</pre> <p>You can set the default proc by calling <a href="hash.html#method-c-new"><code>Hash.new</code></a> with a block or calling the method <a href="hash.html#method-i-default_proc-3D"><code>default_proc=</code></a></p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
h.default_proc.class # =&gt; Proc
</pre> <p>When the default proc is set (i.e., not <code>nil</code>) and method <a href="hash.html#method-i-5B-5D"><code>[]</code></a> is called with with a non-existent key, <a href="hash.html#method-i-5B-5D"><code>[]</code></a> calls the default proc with both the Hash object itself and the missing key, then returns the proc’s return value:</p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| "Default value for #{key}" }
h[:nosuch] # =&gt; "Default value for nosuch"
</pre> <p>Note that in the example above no entry for key <code>:nosuch</code> is created:</p> <pre class="ruby" data-language="ruby">h.include?(:nosuch) # =&gt; false
</pre> <p>However, the proc itself can add a new entry:</p> <pre class="ruby" data-language="ruby">synonyms = Hash.new { |hash, key| hash[key] = [] }
synonyms.include?(:hello) # =&gt; false
synonyms[:hello] &lt;&lt; :hi # =&gt; [:hi]
synonyms[:world] &lt;&lt; :universe # =&gt; [:universe]
synonyms.keys # =&gt; [:hello, :world]
</pre> <p>Note that setting the default proc will clear the default value and vice versa.</p> <p>Be aware that a default proc that modifies the hash is not thread-safe in the sense that multiple threads can call into the default proc concurrently for the same key.</p> <h3 id="class-Hash-label-What-27s+Here">What’s Here</h3> <p>First, what’s elsewhere. Class Hash:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p> </li>
</ul> <p>Here, class Hash provides methods that are useful for:</p> <ul>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Creating+a+Hash">Creating a Hash</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Setting+Hash+State">Setting Hash State</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Fetching">Fetching</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Assigning">Assigning</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Deleting">Deleting</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Converting">Converting</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Methods+for+Transforming+Keys+and+Values">Transforming Keys and Values</a></p> </li>
<li> <p><a href="hash.html#class-Hash-label-Other+Methods">And more.…</a></p> </li>
</ul> <p>Class Hash also includes methods from module <a href="enumerable.html"><code>Enumerable</code></a>.</p> <h4 id="class-Hash-label-Methods+for+Creating+a+Hash">Methods for Creating a Hash</h4> <ul>
<li> <p><a href="hash.html#method-c-5B-5D"><code>::[]</code></a>: Returns a new hash populated with given objects.</p> </li>
<li> <p><a href="hash.html#method-c-new"><code>::new</code></a>: Returns a new empty hash.</p> </li>
<li> <p><a href="hash.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new hash created from a given object.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Setting+Hash+State">Methods for Setting Hash State</h4> <ul>
<li> <p><a href="hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a>: Sets <code>self</code> to consider only identity in comparing keys.</p> </li>
<li> <p><a href="hash.html#method-i-default-3D"><code>default=</code></a>: Sets the default to a given value.</p> </li>
<li> <p><a href="hash.html#method-i-default_proc-3D"><code>default_proc=</code></a>: Sets the default proc to a given proc.</p> </li>
<li> <p><a href="hash.html#method-i-rehash"><code>rehash</code></a>: Rebuilds the hash table by recomputing the hash index for each key.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Querying">Methods for Querying</h4> <ul>
<li> <p><a href="hash.html#method-i-any-3F"><code>any?</code></a>: Returns whether any element satisfies a given criterion.</p> </li>
<li> <p><a href="hash.html#method-i-compare_by_identity-3F"><code>compare_by_identity?</code></a>: Returns whether the hash considers only identity when comparing keys.</p> </li>
<li> <p><a href="hash.html#method-i-default"><code>default</code></a>: Returns the default value, or the default value for a given key.</p> </li>
<li> <p><a href="hash.html#method-i-default_proc"><code>default_proc</code></a>: Returns the default proc.</p> </li>
<li> <p><a href="hash.html#method-i-empty-3F"><code>empty?</code></a>: Returns whether there are no entries.</p> </li>
<li> <p><a href="hash.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether a given object is equal to <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
<li> <p><a href="hash.html#method-i-has_value-3F"><code>has_value?</code></a>: Returns whether a given object is a value in <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-include-3F"><code>include?</code></a>, <a href="hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="hash.html#method-i-member-3F"><code>member?</code></a>, <a href="hash.html#method-i-key-3F"><code>key?</code></a>: Returns whether a given object is a key in <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-length"><code>length</code></a>, <a href="hash.html#method-i-size"><code>size</code></a>: Returns the count of entries.</p> </li>
<li> <p><a href="hash.html#method-i-value-3F"><code>value?</code></a>: Returns whether a given object is a value in <code>self</code>.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Comparing">Methods for Comparing</h4> <ul>
<li> <p><a href="hash.html#method-i-3C"><code>&lt;</code></a>: Returns whether <code>self</code> is a proper subset of a given object.</p> </li>
<li> <p><a href="hash.html#method-i-3C-3D"><code>&lt;=</code></a>: Returns whether <code>self</code> is a subset of a given object.</p> </li>
<li> <p><a href="hash.html#method-i-3D-3D"><code>==</code></a>: Returns whether a given object is equal to <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-3E"><code>&gt;</code></a>: Returns whether <code>self</code> is a proper superset of a given object</p> </li>
<li> <p><a href="hash.html#method-i-3E-3D"><code>&gt;=</code></a>: Returns whether <code>self</code> is a superset of a given object.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Fetching">Methods for Fetching</h4> <ul>
<li> <p><a href="hash.html#method-i-5B-5D"><code>[]</code></a>: Returns the value associated with a given key.</p> </li>
<li> <p><a href="hash.html#method-i-assoc"><code>assoc</code></a>: Returns a 2-element array containing a given key and its value.</p> </li>
<li> <p><a href="hash.html#method-i-dig"><code>dig</code></a>: Returns the object in nested objects that is specified by a given key and additional arguments.</p> </li>
<li> <p><a href="hash.html#method-i-fetch"><code>fetch</code></a>: Returns the value for a given key.</p> </li>
<li> <p><a href="hash.html#method-i-fetch_values"><code>fetch_values</code></a>: Returns array containing the values associated with given keys.</p> </li>
<li> <p><a href="hash.html#method-i-key"><code>key</code></a>: Returns the key for the first-found entry with a given value.</p> </li>
<li> <p><a href="hash.html#method-i-keys"><code>keys</code></a>: Returns an array containing all keys in <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-rassoc"><code>rassoc</code></a>: Returns a 2-element array consisting of the key and value of the first-found entry having a given value.</p> </li>
<li> <p><a href="hash.html#method-i-values"><code>values</code></a>: Returns an array containing all values in <code>self</code>/</p> </li>
<li> <p><a href="hash.html#method-i-values_at"><code>values_at</code></a>: Returns an array containing values for given keys.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Assigning">Methods for Assigning</h4> <ul>
<li> <p><a href="hash.html#method-i-5B-5D-3D"><code>[]=</code></a>, <a href="hash.html#method-i-store"><code>store</code></a>: Associates a given key with a given value.</p> </li>
<li> <p><a href="hash.html#method-i-merge"><code>merge</code></a>: Returns the hash formed by merging each given hash into a copy of <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-merge-21"><code>merge!</code></a>, <a href="hash.html#method-i-update"><code>update</code></a>: Merges each given hash into <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-replace"><code>replace</code></a>: Replaces the entire contents of <code>self</code> with the contents of a given hash.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Deleting">Methods for Deleting</h4> <p>These methods remove entries from <code>self</code>:</p> <ul>
<li> <p><a href="hash.html#method-i-clear"><code>clear</code></a>: Removes all entries from <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-compact-21"><code>compact!</code></a>: Removes all <code>nil</code>-valued entries from <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-delete"><code>delete</code></a>: Removes the entry for a given key.</p> </li>
<li> <p><a href="hash.html#method-i-delete_if"><code>delete_if</code></a>: Removes entries selected by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-filter-21"><code>filter!</code></a>, <a href="hash.html#method-i-select-21"><code>select!</code></a>: Keep only those entries selected by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-keep_if"><code>keep_if</code></a>: Keep only those entries selected by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-reject-21"><code>reject!</code></a>: Removes entries selected by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-shift"><code>shift</code></a>: Removes and returns the first entry.</p> </li>
</ul> <p>These methods return a copy of <code>self</code> with some entries removed:</p> <ul>
<li> <p><a href="hash.html#method-i-compact"><code>compact</code></a>: Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed.</p> </li>
<li> <p><a href="hash.html#method-i-except"><code>except</code></a>: Returns a copy of <code>self</code> with entries removed for specified keys.</p> </li>
<li> <p><a href="hash.html#method-i-filter"><code>filter</code></a>, <a href="hash.html#method-i-select"><code>select</code></a>: Returns a copy of <code>self</code> with only those entries selected by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-reject"><code>reject</code></a>: Returns a copy of <code>self</code> with entries removed as specified by a given block.</p> </li>
<li> <p><a href="hash.html#method-i-slice"><code>slice</code></a>: Returns a hash containing the entries for given keys.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Iterating">Methods for Iterating</h4> <ul>
<li> <p><a href="hash.html#method-i-each"><code>each</code></a>, <a href="hash.html#method-i-each_pair"><code>each_pair</code></a>: Calls a given block with each key-value pair.</p> </li>
<li> <p><a href="hash.html#method-i-each_key"><code>each_key</code></a>: Calls a given block with each key.</p> </li>
<li> <p><a href="hash.html#method-i-each_value"><code>each_value</code></a>: Calls a given block with each value.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Converting">Methods for Converting</h4> <ul>
<li> <p><a href="hash.html#method-i-inspect"><code>inspect</code></a>, <a href="hash.html#method-i-to_s"><code>to_s</code></a>: Returns a new <a href="string.html"><code>String</code></a> containing the hash entries.</p> </li>
<li> <p><a href="hash.html#method-i-to_a"><code>to_a</code></a>: Returns a new array of 2-element arrays; each nested array contains a key-value pair from <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-to_h"><code>to_h</code></a>: Returns <code>self</code> if a Hash; if a subclass of Hash, returns a Hash containing the entries from <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-to_hash"><code>to_hash</code></a>: Returns <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-to_proc"><code>to_proc</code></a>: Returns a proc that maps a given key to its value.</p> </li>
</ul> <h4 id="class-Hash-label-Methods+for+Transforming+Keys+and+Values">Methods for Transforming Keys and Values</h4> <ul>
<li> <p><a href="hash.html#method-i-transform_keys"><code>transform_keys</code></a>: Returns a copy of <code>self</code> with modified keys.</p> </li>
<li> <p><a href="hash.html#method-i-transform_keys-21"><code>transform_keys!</code></a>: Modifies keys in <code>self</code></p> </li>
<li> <p><a href="hash.html#method-i-transform_values"><code>transform_values</code></a>: Returns a copy of <code>self</code> with modified values.</p> </li>
<li> <p><a href="hash.html#method-i-transform_values-21"><code>transform_values!</code></a>: Modifies values in <code>self</code>.</p> </li>
</ul> <h4 id="class-Hash-label-Other+Methods">Other Methods</h4> <ul>
<li> <p><a href="hash.html#method-i-flatten"><code>flatten</code></a>: Returns an array that is a 1-dimensional flattening of <code>self</code>.</p> </li>
<li> <p><a href="hash.html#method-i-invert"><code>invert</code></a>: Returns a hash with the each key-value pair inverted.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-5B-5D"> <span class="method-callseq"> Hash[] → new_empty_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Hash[hash] → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> Hash[ [*2_element_arrays] ] → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> Hash[*objects] → new_hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            if (!RHASH_EMPTY_P(tmp)  &amp;&amp; rb_hash_compare_by_id_p(tmp)) {
                /* hash_copy for non-empty hash will copy compare_by_identity
                   flag, but we don't want it copied. Work around by
                   converting hash to flattened array and using that. */
                tmp = rb_hash_to_a(tmp);
            }
            else {
                hash = hash_alloc(klass);
                if (!RHASH_EMPTY_P(tmp))
                    hash_copy(hash, tmp);
                return hash;
            }
        }
        else {
            tmp = rb_check_array_type(argv[0]);
        }

        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
                    rb_raise(rb_eArgError, "wrong element type %s at %ld (expected array)",
                             rb_builtin_class_name(e), i);
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, "invalid number of elements (%ld for 1..2)",
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, "odd number of arguments for Hash");
    }

    hash = hash_alloc(klass);
    rb_hash_bulk_insert(argc, argv, hash);
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Returns a new Hash object populated with the given objects, if any. See <a href="hash.html#method-c-new"><code>Hash::new</code></a>.</p> <p>With no argument, returns a new empty Hash.</p> <p>When the single given argument is a Hash, returns a new Hash populated with the entries from the given Hash, excluding the default value or proc.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
Hash[h] # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>When the single given argument is an <a href="array.html"><code>Array</code></a> of 2-element Arrays, returns a new Hash object wherein each 2-element array forms a key-value entry:</p> <pre class="ruby" data-language="ruby">Hash[ [ [:foo, 0], [:bar, 1] ] ] # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>When the argument count is an even number; returns a new Hash object wherein each successive pair of arguments has become a key-value entry:</p> <pre class="ruby" data-language="ruby">Hash[:foo, 0, :bar, 1] # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>Raises an exception if the argument list does not conform to any of the above.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(default_value = nil) → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new {|hash, key| ... } → new_hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_hash_initialize(int argc, VALUE *argv, VALUE hash)
{
    rb_hash_modify(hash);

    if (rb_block_given_p()) {
        rb_check_arity(argc, 0, 0);
        SET_PROC_DEFAULT(hash, rb_block_proc());
    }
    else {
        rb_check_arity(argc, 0, 1);

        VALUE options, ifnone;
        rb_scan_args(argc, argv, "01:", &amp;ifnone, &amp;options);
        if (NIL_P(ifnone) &amp;&amp; !NIL_P(options)) {
            ifnone = options;
            rb_warn_deprecated_to_remove("3.4", "Calling Hash.new with keyword arguments", "Hash.new({ key: value })");
        }
        RHASH_SET_IFNONE(hash, ifnone);
    }

    return hash;
}</pre> </div> <p>Returns a new empty Hash object.</p> <p>The initial default value and initial default proc for the new hash depend on which form above was used. See <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>.</p> <p>If neither an argument nor a block given, initializes both the default value and the default proc to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default # =&gt; nil
h.default_proc # =&gt; nil
</pre> <p>If argument <code>default_value</code> given but no block given, initializes the default value to the given <code>default_value</code> and the default proc to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new(false)
h.default # =&gt; false
h.default_proc # =&gt; nil
</pre> <p>If a block given but no argument, stores the block as the default proc and sets the default value to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new {|hash, key| "Default value for #{key}" }
h.default # =&gt; nil
h.default_proc.class # =&gt; Proc
h[:nosuch] # =&gt; "Default value for nosuch"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-ruby2_keywords_hash"> <span class="method-callseq"> ruby2_keywords_hash(hash) → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    VALUE tmp = rb_hash_dup(hash);
    if (RHASH_EMPTY_P(hash) &amp;&amp; rb_hash_compare_by_id_p(hash)) {
        rb_hash_compare_by_id(tmp);
    }
    RHASH(tmp)-&gt;basic.flags |= RHASH_PASS_AS_KEYWORDS;
    return tmp;
}</pre> </div> <p>Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.</p> <pre class="ruby" data-language="ruby">h = {k: 1}
h = Hash.ruby2_keywords_hash(h)
def foo(k: 42)
  k
end
foo(*[h]) #=&gt; 1 with neither a warning or an error
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-ruby2_keywords_hash-3F"> <span class="method-callseq"> ruby2_keywords_hash?(hash) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash_p(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    return RBOOL(RHASH(hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS);
}</pre> </div> <p>Checks if a given hash is flagged by <a href="module.html#method-i-ruby2_keywords"><code>Module#ruby2_keywords</code></a> (or <a href="proc.html#method-i-ruby2_keywords"><code>Proc#ruby2_keywords</code></a>). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.</p> <pre class="ruby" data-language="ruby">ruby2_keywords def foo(*args)
  Hash.ruby2_keywords_hash?(args.last)
end
foo(k: 1)   #=&gt; true
foo({k: 1}) #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(obj) → obj, new_hash, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_try_convert(VALUE dummy, VALUE hash)
{
    return rb_check_hash_type(hash);
}</pre> </div> <p>If <code>obj</code> is a Hash object, returns <code>obj</code>.</p> <p>Otherwise if <code>obj</code> responds to <code>:to_hash</code>, calls <code>obj.to_hash</code> and returns the result.</p> <p>Returns <code>nil</code> if <code>obj</code> does not respond to <code>:to_hash</code></p> <p>Raises an exception unless <code>obj.to_hash</code> returns a Hash object.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C"> <span class="method-callseq"> hash &lt; other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-source"> <pre class="c" data-language="c">static VALUE
rb_hash_lt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a proper subset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 &lt; h2 # =&gt; true
h2 &lt; h1 # =&gt; false
h1 &lt; h1 # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D"> <span class="method-callseq"> hash &lt;= other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_le(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a subset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 &lt;= h2 # =&gt; true
h2 &lt;= h1 # =&gt; false
h1 &lt;= h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> hash == object → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_equal(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, FALSE);
}</pre> </div> <p>Returns <code>true</code> if all of the following are true:</p> <ul>
<li> <p><code>object</code> is a Hash object.</p> </li>
<li> <p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p> </li>
<li> <p>For each key <code>key</code>, <code>hash[key] == object[key]</code>.</p> </li>
</ul> <p>Otherwise, returns <code>false</code>.</p> <p>Equal:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1 == h2 # =&gt; true
h3 = {baz: 2, bar: 1, foo: 0}
h1 == h3 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3E"> <span class="method-callseq"> hash &gt; other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="c" data-language="c">static VALUE
rb_hash_gt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a proper superset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 &gt; h2 # =&gt; true
h2 &gt; h1 # =&gt; false
h1 &gt; h1 # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3E-3D"> <span class="method-callseq"> hash &gt;= other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3E-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_ge(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a superset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 &gt;= h2 # =&gt; true
h2 &gt;= h1 # =&gt; false
h1 &gt;= h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> hash[key] → value </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aref(VALUE hash, VALUE key)
{
    st_data_t val;

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        return rb_hash_default_value(hash, key);
    }
}</pre> </div> <p>Returns the value associated with the given <code>key</code>, if found:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:foo] # =&gt; 0
</pre> <p>If <code>key</code> is not found, returns a default value (see <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:nosuch] # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> hash[key] = value → value </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    bool iter_p = hash_iterating_p(hash);

    rb_hash_modify(hash);

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_p, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_p, key, hash_aset_str, val);
    }
    return val;
}</pre> </div> <p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p> <p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:foo] = 2 # =&gt; 2
h.store(:bar, 3) # =&gt; 3
h # =&gt; {:foo=&gt;2, :bar=&gt;3}
</pre> <p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:baz] = 2 # =&gt; 2
h.store(:bat, 3) # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-store">store</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-any-3F"> <span class="method-callseq"> any? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> any?(object) → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> any? {|key, value| ... } → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_any_p(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2];
    args[0] = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (RHASH_EMPTY_P(hash)) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        args[1] = argv[0];

        rb_hash_foreach(hash, any_p_i_pattern, (VALUE)args);
    }
    else {
        if (!rb_block_given_p()) {
            /* yields pairs, never false */
            return Qtrue;
        }
        if (rb_block_pair_yield_optimizable())
            rb_hash_foreach(hash, any_p_i_fast, (VALUE)args);
        else
            rb_hash_foreach(hash, any_p_i, (VALUE)args);
    }
    return args[0];
}</pre> </div> <p>Returns <code>true</code> if any element satisfies a given criterion; <code>false</code> otherwise.</p> <p>If <code>self</code> has no element, returns <code>false</code> and argument or block are not used.</p> <p>With no argument and no block, returns <code>true</code> if <code>self</code> is non-empty; <code>false</code> if empty.</p> <p>With argument <code>object</code> and no block, returns <code>true</code> if for any key <code>key</code> <code>h.assoc(key) == object</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.any?([:bar, 1]) # =&gt; true
h.any?([:bar, 0]) # =&gt; false
h.any?([:baz, 1]) # =&gt; false
</pre> <p>With no argument and a block, calls the block with each key-value pair; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.any? {|key, value| value &lt; 3 } # =&gt; true
h.any? {|key, value| value &gt; 3 } # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-any-3F"><code>Enumerable#any?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assoc"> <span class="method-callseq"> assoc(key) → new_array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assoc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_assoc(VALUE hash, VALUE key)
{
    VALUE args[2];

    if (RHASH_EMPTY_P(hash)) return Qnil;

    if (RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type != &amp;identhash) {
        VALUE value = Qundef;
        st_table assoctable = *RHASH_ST_TABLE(hash);
        assoctable.type = &amp;(struct st_hash_type){
            .compare = assoc_cmp,
            .hash = assoctable.type-&gt;hash,
        };
        VALUE arg = (VALUE)&amp;(struct assoc_arg){
            .tbl = &amp;assoctable,
            .key = (st_data_t)key,
        };

        if (RB_OBJ_FROZEN(hash)) {
            value = assoc_lookup(arg);
        }
        else {
            hash_iter_lev_inc(hash);
            value = rb_ensure(assoc_lookup, arg, hash_foreach_ensure, hash);
        }
        hash_verify(hash);
        if (!UNDEF_P(value)) return rb_assoc_new(key, value);
    }

    args[0] = key;
    args[1] = Qnil;
    rb_hash_foreach(hash, assoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>If the given <code>key</code> is found, returns a 2-element <a href="array.html"><code>Array</code></a> containing that key and its value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.assoc(:bar) # =&gt; [:bar, 1]
</pre> <p>Returns <code>nil</code> if key <code>key</code> is not found.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear"> <span class="method-callseq"> clear → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">VALUE
rb_hash_clear(VALUE hash)
{
    rb_hash_modify_check(hash);

    if (hash_iterating_p(hash)) {
        rb_hash_foreach(hash, clear_i, 0);
    }
    else if (RHASH_AR_TABLE_P(hash)) {
        ar_clear(hash);
    }
    else {
        st_clear(RHASH_ST_TABLE(hash));
        compact_after_delete(hash);
    }

    return hash;
}</pre> </div> <p>Removes all hash entries; returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compact"> <span class="method-callseq"> compact → new_hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact(VALUE hash)
{
    VALUE result = rb_hash_dup(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, delete_if_nil, result);
        compact_after_delete(result);
    }
    else if (rb_hash_compare_by_id_p(hash)) {
        result = rb_hash_compare_by_id(result);
    }
    return result;
}</pre> </div> <p>Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: nil, baz: 2, bat: nil}
h1 = h.compact
h1 # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compact-21"> <span class="method-callseq"> compact! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compact-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact_bang(VALUE hash)
{
    st_index_t n;
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (n) {
        rb_hash_foreach(hash, delete_if_nil, hash);
        if (n != RHASH_SIZE(hash))
            return hash;
    }
    return Qnil;
}</pre> </div> <p>Returns <code>self</code> with all its <code>nil</code>-valued entries removed (in place):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: nil, baz: 2, bat: nil}
h.compact! # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <p>Returns <code>nil</code> if no entries were removed.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compare_by_identity"> <span class="method-callseq"> compare_by_identity → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-source"> <pre class="c" data-language="c">VALUE
rb_hash_compare_by_id(VALUE hash)
{
    VALUE tmp;
    st_table *identtable;

    if (rb_hash_compare_by_id_p(hash)) return hash;

    rb_hash_modify_check(hash);
    if (hash_iterating_p(hash)) {
        rb_raise(rb_eRuntimeError, "compare_by_identity during iteration");
    }

    if (RHASH_TABLE_EMPTY_P(hash)) {
        // Fast path: There's nothing to rehash, so we don't need a `tmp` table.
        // We're most likely an AR table, so this will need an allocation.
        ar_force_convert_table(hash, __FILE__, __LINE__);
        HASH_ASSERT(RHASH_ST_TABLE_P(hash));

        RHASH_ST_TABLE(hash)-&gt;type = &amp;identhash;
    }
    else {
        // Slow path: Need to rehash the members of `self` into a new
        // `tmp` table using the new `identhash` compare/hash functions.
        tmp = hash_alloc(0);
        hash_st_table_init(tmp, &amp;identhash, RHASH_SIZE(hash));
        identtable = RHASH_ST_TABLE(tmp);

        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        rb_hash_free(hash);

        // We know for sure `identtable` is an st table,
        // so we can skip `ar_force_convert_table` here.
        RHASH_ST_TABLE_SET(hash, identtable);
        RHASH_ST_CLEAR(tmp);
    }

    return hash;
}</pre> </div> <p>Sets <code>self</code> to consider only identity in comparing keys; two keys are considered the same only if they are the same object; returns <code>self</code>.</p> <p>By default, these two object are considered to be the same key, so <code>s1</code> will overwrite <code>s0</code>:</p> <pre class="ruby" data-language="ruby">s0 = 'x'
s1 = 'x'
h = {}
h.compare_by_identity? # =&gt; false
h[s0] = 0
h[s1] = 1
h # =&gt; {"x"=&gt;1}
</pre> <p>After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:</p> <pre class="ruby" data-language="ruby">h = {}
h.compare_by_identity # =&gt; {}
h.compare_by_identity? # =&gt; true
h[s0] = 0
h[s1] = 1
h # =&gt; {"x"=&gt;0, "x"=&gt;1}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compare_by_identity-3F"> <span class="method-callseq"> compare_by_identity? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-3F-source"> <pre class="c" data-language="c">VALUE
rb_hash_compare_by_id_p(VALUE hash)
{
    return RBOOL(RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type == &amp;identhash);
}</pre> </div> <p>Returns <code>true</code> if <a href="hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a> has been called, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-default"> <span class="method-callseq"> default → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> default(key) → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="default-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_check_arity(argc, 0, 1);
    ifnone = RHASH_IFNONE(hash);
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        if (argc == 0) return Qnil;
        return call_default_proc(ifnone, hash, argv[0]);
    }
    return ifnone;
}</pre> </div> <p>Returns the default value for the given <code>key</code>. The returned value will be determined either by the default proc or by the default value. See <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>.</p> <p>With no argument, returns the current default value:</p> <pre class="ruby" data-language="ruby">h = {}
h.default # =&gt; nil
</pre> <p>If <code>key</code> is given, returns the default value for <code>key</code>, regardless of whether that key exists:</p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
h[:foo] = "Hello"
h.default(:foo) # =&gt; "No key foo"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-default-3D"> <span class="method-callseq"> default = value → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="default-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_set_default(VALUE hash, VALUE ifnone)
{
    rb_hash_modify_check(hash);
    SET_DEFAULT(hash, ifnone);
    return ifnone;
}</pre> </div> <p>Sets the default value to <code>value</code>; returns <code>value</code>:</p> <pre class="ruby" data-language="ruby">h = {}
h.default # =&gt; nil
h.default = false # =&gt; false
h.default # =&gt; false
</pre> <p>See <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-default_proc"> <span class="method-callseq"> default_proc → proc or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default_proc(VALUE hash)
{
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        return RHASH_IFNONE(hash);
    }
    return Qnil;
}</pre> </div> <p>Returns the default proc for <code>self</code> (see <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {}
h.default_proc # =&gt; nil
h.default_proc = proc {|hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-default_proc-3D"> <span class="method-callseq"> default_proc = proc → proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_set_default_proc(VALUE hash, VALUE proc)
{
    VALUE b;

    rb_hash_modify_check(hash);
    if (NIL_P(proc)) {
        SET_DEFAULT(hash, proc);
        return proc;
    }
    b = rb_check_convert_type_with_id(proc, T_DATA, "Proc", idTo_proc);
    if (NIL_P(b) || !rb_obj_is_proc(b)) {
        rb_raise(rb_eTypeError,
                 "wrong default_proc type %s (expected Proc)",
                 rb_obj_classname(proc));
    }
    proc = b;
    SET_PROC_DEFAULT(hash, proc);
    return proc;
}</pre> </div> <p>Sets the default proc for <code>self</code> to <code>proc</code>: (see <a href="hash.html#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {}
h.default_proc # =&gt; nil
h.default_proc = proc { |hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
h.default_proc = nil
h.default_proc # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(key) → value or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(key) {|key| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">static VALUE
rb_hash_delete_m(VALUE hash, VALUE key)
{
    VALUE val;

    rb_hash_modify_check(hash);
    val = rb_hash_delete_entry(hash, key);

    if (!UNDEF_P(val)) {
        compact_after_delete(hash);
        return val;
    }
    else {
        if (rb_block_given_p()) {
            return rb_yield(key);
        }
        else {
            return Qnil;
        }
    }
}</pre> </div> <p>Deletes the entry for the given <code>key</code> and returns its associated value.</p> <p>If no block is given and <code>key</code> is found, deletes the entry and returns the associated value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:bar) # =&gt; 1
h # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <p>If no block given and <code>key</code> is not found, returns <code>nil</code>.</p> <p>If a block is given and <code>key</code> is found, ignores the block, deletes the entry, and returns the associated value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:baz) { |key| raise 'Will never happen'} # =&gt; 2
h # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>If a block is given and <code>key</code> is not found, calls the block and returns the block’s return value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:nosuch) { |key| "Key #{key} not found" } # =&gt; "Key nosuch not found"
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {|key, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete_if → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="c" data-language="c">VALUE
rb_hash_delete_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, delete_if_i, hash);
        compact_after_delete(hash);
    }
    return hash;
}</pre> </div> <p>If a block given, calls the block with each key-value pair; deletes each entry for which the block returns a truthy value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete_if {|key, value| value &gt; 0 } # =&gt; {:foo=&gt;0}
</pre> <p>If no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.delete_if # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:delete_if&gt;
e.each { |key, value| value &gt; 0 } # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(key, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_hash_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_hash_aref(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Finds and returns the object in nested objects that is specified by <code>key</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See <a href="dig_methods_rdoc.html">Dig Methods</a>.</p> <p>Nested Hashes:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: {baz: 2}}}
h.dig(:foo) # =&gt; {:bar=&gt;{:baz=&gt;2}}
h.dig(:foo, :bar) # =&gt; {:baz=&gt;2}
h.dig(:foo, :bar, :baz) # =&gt; 2
h.dig(:foo, :bar, :BAZ) # =&gt; nil
</pre> <p>Nested Hashes and Arrays:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: [:a, :b, :c]}}
h.dig(:foo, :bar, 2) # =&gt; :c
</pre> <p>This method will use the <a href="hash.html#class-Hash-label-Default+Values">default values</a> for keys that are not present:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: [:a, :b, :c]}}
h.dig(:hello) # =&gt; nil
h.default_proc = -&gt; (hash, _key) { hash }
h.dig(:hello, :world) # =&gt; h
h.dig(:hello, :world, :foo, :bar, 2) # =&gt; :c
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|key, value| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> each → new_enumerator </span> </div> </div> <div class="method-description"> <p>Calls the given block with each key-value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_pair {|key, value| puts "#{key}: #{value}"} # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_pair # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;
h1 = e.each {|key, value| puts "#{key}: #{value}"}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-each_pair">each_pair</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_key"> <span class="method-callseq"> each_key {|key| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_key → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_key(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}</pre> </div> <p>Calls the given block with each key; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_key {|key| puts key }  # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
baz
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_key # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_key&gt;
h1 = e.each {|key| puts key }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
baz
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_pair"> <span class="method-callseq"> each_pair {|key, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_pair_yield_optimizable())
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}</pre> </div> <p>Calls the given block with each key-value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_pair {|key, value| puts "#{key}: #{value}"} # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_pair # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;
h1 = e.each {|key, value| puts "#{key}: #{value}"}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_value"> <span class="method-callseq"> each_value {|value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_value → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_value-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_value(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}</pre> </div> <p>Calls the given block with each value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_value {|value| puts value } # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
2
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_value # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_value&gt;
h1 = e.each {|value| puts value }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_empty_p(VALUE hash)
{
    return RBOOL(RHASH_EMPTY_P(hash));
}</pre> </div> <p>Returns <code>true</code> if there are no hash entries, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">{}.empty? # =&gt; true
{foo: 0, bar: 1, baz: 2}.empty? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql? object → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_eql(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, TRUE);
}</pre> </div> <p>Returns <code>true</code> if all of the following are true:</p> <ul>
<li> <p><code>object</code> is a Hash object.</p> </li>
<li> <p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p> </li>
<li> <p>For each key <code>key</code>, <code>h[key] eql? object[key]</code>.</p> </li>
</ul> <p>Otherwise, returns <code>false</code>.</p> <p>Equal:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1.eql? h2 # =&gt; true
h3 = {baz: 2, bar: 1, foo: 0}
h1.eql? h3 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-except"> <span class="method-callseq"> except(*keys) → a_hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="except-source"> <pre class="c" data-language="c">static VALUE
rb_hash_except(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, result;

    result = hash_dup_with_compare_by_id(hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        rb_hash_delete(result, key);
    }
    compact_after_delete(result);

    return result;
}</pre> </div> <p>Returns a new Hash excluding entries for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = { a: 100, b: 200, c: 300 }
h.except(:a)          #=&gt; {:b=&gt;200, :c=&gt;300}
</pre> <p>Any given <code>keys</code> that are not found are ignored.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fetch"> <span class="method-callseq"> fetch(key) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch(key, default_value) → object </span> </div> <div class="method-heading"> <span class="method-callseq"> fetch(key) {|key| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="c" data-language="c">static VALUE
rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
{
    VALUE key;
    st_data_t val;
    long block_given;

    rb_check_arity(argc, 1, 2);
    key = argv[0];

    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn("block supersedes default value argument");
    }

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        if (block_given) {
            return rb_yield(key);
        }
        else if (argc == 1) {
            VALUE desc = rb_protect(rb_inspect, key, 0);
            if (NIL_P(desc)) {
                desc = rb_any_to_s(key);
            }
            desc = rb_str_ellipsize(desc, 65);
            rb_key_err_raise(rb_sprintf("key not found: %"PRIsVALUE, desc), hash, key);
        }
        else {
            return argv[1];
        }
    }
}</pre> </div> <p>Returns the value for the given <code>key</code>, if found.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.fetch(:bar) # =&gt; 1
</pre> <p>If <code>key</code> is not found and no block was given, returns <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">{}.fetch(:nosuch, :default) # =&gt; :default
</pre> <p>If <code>key</code> is not found and a block was given, yields <code>key</code> to the block and returns the block’s return value:</p> <pre class="ruby" data-language="ruby">{}.fetch(:nosuch) {|key| "No key #{key}"} # =&gt; "No key nosuch"
</pre> <p>Raises <a href="keyerror.html"><code>KeyError</code></a> if neither <code>default_value</code> nor a block was given.</p> <p>Note that this method does not use the values of either <a href="hash.html#method-i-default"><code>default</code></a> or <a href="hash.html#method-i-default_proc"><code>default_proc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fetch_values"> <span class="method-callseq"> fetch_values(*keys) → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch_values(*keys) {|key| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="fetch_values-source"> <pre class="c" data-language="c">static VALUE
rb_hash_fetch_values(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_fetch(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> containing the values associated with the given keys *keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.fetch_values(:baz, :foo) # =&gt; [2, 0]
</pre> <p>Returns a new empty <a href="array.html"><code>Array</code></a> if no arguments given.</p> <p>When a block is given, calls the block with each missing key, treating the block’s return value as the value for that key:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
values # =&gt; [1, 0, "bad", "bam"]
</pre> <p>When no block is given, raises an exception if any given key is not found.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter"> <span class="method-name">filter</span> </div> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-select">select</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter-21"> <span class="method-name">filter!</span> </div> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-select-21">select!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-flatten"> <span class="method-callseq"> flatten → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flatten(level) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="flatten-source"> <pre class="c" data-language="c">static VALUE
rb_hash_flatten(int argc, VALUE *argv, VALUE hash)
{
    VALUE ary;

    rb_check_arity(argc, 0, 1);

    if (argc) {
        int level = NUM2INT(argv[0]);

        if (level == 0) return rb_hash_to_a(hash);

        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
        level--;

        if (level &gt; 0) {
            VALUE ary_flatten_level = INT2FIX(level);
            rb_funcallv(ary, id_flatten_bang, 1, &amp;ary_flatten_level);
        }
        else if (level &lt; 0) {
            /* flatten recursively */
            rb_funcallv(ary, id_flatten_bang, 0, 0);
        }
    }
    else {
        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
    }

    return ary;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> object that is a 1-dimensional flattening of <code>self</code>.</p>  <p>By default, nested Arrays are not flattened:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, 3], baz: 2}
h.flatten # =&gt; [:foo, 0, :bar, [:bat, 3], :baz, 2]
</pre> <p>Takes the depth of recursive flattening from <a href="integer.html"><code>Integer</code></a> argument <code>level</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
h.flatten(1) # =&gt; [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
h.flatten(2) # =&gt; [:foo, 0, :bar, :bat, [:baz, [:bat]]]
h.flatten(3) # =&gt; [:foo, 0, :bar, :bat, :baz, [:bat]]
h.flatten(4) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
</pre> <p>When <code>level</code> is negative, flattens all nested Arrays:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
h.flatten(-1) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
h.flatten(-2) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
</pre> <p>When <code>level</code> is zero, returns the equivalent of <a href="hash.html#method-i-to_a"><code>to_a</code></a> :</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, 3], baz: 2}
h.flatten(0) # =&gt; [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
h.flatten(0) == h.to_a # =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-has_key-3F"> <span class="method-callseq"> has_key?(key) → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-has_value-3F"> <span class="method-callseq"> has_value?(value) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="has_value-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}</pre> </div> <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-value-3F">value?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → an_integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_hash(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    st_index_t hval = rb_hash_start(size);
    hval = rb_hash_uint(hval, (st_index_t)rb_hash_hash);
    if (size) {
        rb_hash_foreach(hash, hash_i, (VALUE)&amp;hval);
    }
    hval = rb_hash_end(hval);
    return ST2FIX(hval);
}</pre> </div> <p>Returns the <a href="integer.html"><code>Integer</code></a> hash-code for the hash.</p> <p>Two Hash objects have the same hash-code if their content is the same (regardless of order):</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {baz: 2, bar: 1, foo: 0}
h2.hash == h1.hash # =&gt; true
h2.eql? h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    return RBOOL(hash_stlike_lookup(hash, key, NULL));
}</pre> </div> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-member-3F">member?</a>, <a href="hash.html#method-i-has_key-3F">has_key?</a>, <a href="hash.html#method-i-key-3F">key?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span> </div> </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-replace">replace</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_hash_inspect(VALUE hash)
{
    if (RHASH_EMPTY_P(hash))
        return rb_usascii_str_new2("{}");
    return rb_exec_recursive(inspect_hash, hash, 0);
}</pre> </div> <p>Returns a new <a href="string.html"><code>String</code></a> containing the hash entries:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.inspect # =&gt; "{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-invert"> <span class="method-callseq"> invert → new_hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="invert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_invert(VALUE hash)
{
    VALUE h = rb_hash_new_with_size(RHASH_SIZE(hash));

    rb_hash_foreach(hash, rb_hash_invert_i, h);
    return h;
}</pre> </div> <p>Returns a new Hash object with the each key-value pair inverted:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.invert
h1 # =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}
</pre> <p>Overwrites any repeated new keys: (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 0, baz: 0}
h.invert # =&gt; {0=&gt;:baz}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-keep_if"> <span class="method-callseq"> keep_if {|key, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> keep_if → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="keep_if-source"> <pre class="c" data-language="c">static VALUE
rb_hash_keep_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, keep_if_i, hash);
    }
    return hash;
}</pre> </div> <p>Calls the block for each key-value pair; retains the entry if the block returns a truthy value; otherwise deletes the entry; returns <code>self</code>.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.keep_if { |key, value| key.start_with?('b') } # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.keep_if # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:keep_if&gt;
e.each { |key, value| key.start_with?('b') } # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-key"> <span class="method-callseq"> key(value) → key or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_key(VALUE hash, VALUE value)
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    rb_hash_foreach(hash, key_i, (VALUE)args);

    return args[1];
}</pre> </div> <p>Returns the key for the first-found entry with the given <code>value</code> (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 2, baz: 2}
h.key(0) # =&gt; :foo
h.key(2) # =&gt; :bar
</pre> <p>Returns <code>nil</code> if no such value is found.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(key) → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-keys"> <span class="method-callseq"> keys → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="c" data-language="c">VALUE
rb_hash_keys(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    VALUE keys =  rb_ary_new_capa(size);

    if (size == 0) return keys;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        RARRAY_PTR_USE(keys, ptr, {
            if (RHASH_AR_TABLE_P(hash)) {
                size = ar_keys(hash, ptr, size);
            }
            else {
                st_table *table = RHASH_ST_TABLE(hash);
                size = st_keys(table, ptr, size);
            }
        });
        rb_gc_writebarrier_remember(keys);
        rb_ary_set_len(keys, size);
    }
    else {
        rb_hash_foreach(hash, keys_i, keys);
    }

    return keys;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> containing all keys in <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.keys # =&gt; [:foo, :bar, :baz]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> </div> </div> <div class="method-description"> <p>Returns the count of entries in <code>self</code>:</p> <pre class="ruby" data-language="ruby">{foo: 0, bar: 1, baz: 2}.length # =&gt; 3
</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-size">size</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-member-3F"> <span class="method-callseq"> member?(key) → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-merge"> <span class="method-callseq"> merge → copy_of_self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> merge(*other_hashes) → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> merge(*other_hashes) { |key, old_value, new_value| ... } → new_hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="merge-source"> <pre class="c" data-language="c">static VALUE
rb_hash_merge(int argc, VALUE *argv, VALUE self)
{
    return rb_hash_update(argc, argv, copy_compare_by_id(rb_hash_dup(self), self));
}</pre> </div> <p>Returns the new Hash formed by merging each of <code>other_hashes</code> into a copy of <code>self</code>.</p> <p>Each argument in <code>other_hashes</code> must be a Hash.</p>  <p>With arguments and no block:</p> <ul>
<li> <p>Returns the new Hash object formed by merging each successive Hash in <code>other_hashes</code> into <code>self</code>.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>Each duplicate-key entry’s value overwrites the previous value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h.merge(h1, h2) # =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}
</pre> <p>With arguments and a block:</p> <ul>
<li> <p>Returns a new Hash object that is the merge of <code>self</code> and each given hash.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>For each duplicate key:</p> <ul>
<li> <p>Calls the block with the key and the old and new values.</p> </li>
<li> <p>The block’s return value becomes the new value for the entry.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
h3 # =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}
</pre> <p>With no arguments:</p> <ul>
<li> <p>Returns a copy of <code>self</code>.</p> </li>
<li> <p>The block, if given, is ignored.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.merge # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-merge-21"> <span class="method-callseq"> merge! → self </span> </div> <div class="method-heading"> <span class="method-callseq"> merge!(*other_hashes) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> merge!(*other_hashes) { |key, old_value, new_value| ... } → self </span> </div> </div> <div class="method-description"> <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p> <p>Each argument in <code>other_hashes</code> must be a Hash.</p> <p>With arguments and no block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged into it.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new entry is added at the end.</p> </li>
<li> <p>Each duplicate-key entry’s value overwrites the previous value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h.merge!(h1, h2) # =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}
</pre> <p>With arguments and a block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>For each duplicate key:</p> <ul>
<li> <p>Calls the block with the key and the old and new values.</p> </li>
<li> <p>The block’s return value becomes the new value for the entry.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
h3 # =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}
</pre> <p>With no arguments:</p> <ul>
<li> <p>Returns <code>self</code>, unmodified.</p> </li>
<li> <p>The block, if given, is ignored.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.merge # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-update">update</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rassoc"> <span class="method-callseq"> rassoc(value) → new_array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rassoc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_rassoc(VALUE hash, VALUE obj)
{
    VALUE args[2];

    args[0] = obj;
    args[1] = Qnil;
    rb_hash_foreach(hash, rassoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>Returns a new 2-element <a href="array.html"><code>Array</code></a> consisting of the key and value of the first-found entry whose value is <code>==</code> to value (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 1}
h.rassoc(1) # =&gt; [:bar, 1]
</pre> <p>Returns <code>nil</code> if no such value found.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rehash"> <span class="method-callseq"> rehash → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rehash-source"> <pre class="c" data-language="c">VALUE
rb_hash_rehash(VALUE hash)
{
    VALUE tmp;
    st_table *tbl;

    if (hash_iterating_p(hash)) {
        rb_raise(rb_eRuntimeError, "rehash during iteration");
    }
    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        tmp = hash_alloc(0);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);

        hash_ar_free_and_clear_table(hash);
        ar_copy(hash, tmp);
    }
    else if (RHASH_ST_TABLE_P(hash)) {
        st_table *old_tab = RHASH_ST_TABLE(hash);
        tmp = hash_alloc(0);

        hash_st_table_init(tmp, old_tab-&gt;type, old_tab-&gt;num_entries);
        tbl = RHASH_ST_TABLE(tmp);

        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);

        hash_st_free(hash);
        RHASH_ST_TABLE_SET(hash, tbl);
        RHASH_ST_CLEAR(tmp);
    }
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Rebuilds the hash table by recomputing the hash index for each key; returns <code>self</code>.</p> <p>The hash table becomes invalid if the hash value of a key has changed after the entry was created. See <a href="hash.html#class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reject"> <span class="method-callseq"> reject {|key, value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">static VALUE
rb_hash_reject(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, delete_if_i, result);
        compact_after_delete(result);
    }
    return result;
}</pre> </div> <p>Returns a new Hash object whose entries are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.reject {|key, value| key.start_with?('b') }
h1 # =&gt; {:foo=&gt;0}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.reject # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject&gt;
h1 = e.each {|key, value| key.start_with?('b') }
h1 # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reject-21"> <span class="method-callseq"> reject! {|key, value| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_reject_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, delete_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Returns <code>self</code>, whose remaining entries are those for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.reject! {|key, value| value &lt; 2 } # =&gt; {:baz=&gt;2}
</pre> <p>Returns <code>nil</code> if no entries are removed.</p> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.reject! # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject!&gt;
e.each {|key, value| key.start_with?('b') } # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-replace"> <span class="method-callseq"> replace(other_hash) → self </span> </div> </div> <div class="method-description"> <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.replace({bat: 3, bam: 4}) # =&gt; {:bat=&gt;3, :bam=&gt;4}
</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-initialize_copy">initialize_copy</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|key, value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, keep_if_i, result);
        compact_after_delete(result);
    }
    return result;
}</pre> </div> <p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.select {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;
e.each {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-select-21"> <span class="method-callseq"> select! {|key, value| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="select-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p> <pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre> <p>Returns <code>nil</code> if no entries were removed.</p> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select!  # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;
e.each { |key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-filter-21">filter!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shift"> <span class="method-callseq"> shift → [key, value] or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="c" data-language="c">static VALUE
rb_hash_shift(VALUE hash)
{
    struct shift_var var;

    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        var.key = Qundef;
        if (!hash_iterating_p(hash)) {
            if (ar_shift(hash, &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (!UNDEF_P(var.key)) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    if (RHASH_ST_TABLE_P(hash)) {
        var.key = Qundef;
        if (!hash_iterating_p(hash)) {
            if (st_shift(RHASH_ST_TABLE(hash), &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (!UNDEF_P(var.key)) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    return Qnil;
}</pre> </div> <p>Removes the first hash entry (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>); returns a 2-element <a href="array.html"><code>Array</code></a> containing the removed key and value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.shift # =&gt; [:foo, 0]
h # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre> <p>Returns nil if the hash is empty.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}</pre> </div> <p>Returns the count of entries in <code>self</code>:</p> <pre class="ruby" data-language="ruby">{foo: 0, bar: 1, baz: 2}.length # =&gt; 3
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-slice"> <span class="method-callseq"> slice(*keys) → new_hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="slice-source"> <pre class="c" data-language="c">static VALUE
rb_hash_slice(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, value, result;

    if (argc == 0 || RHASH_EMPTY_P(hash)) {
        return copy_compare_by_id(rb_hash_new(), hash);
    }
    result = copy_compare_by_id(rb_hash_new_with_size(argc), hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        value = rb_hash_lookup2(hash, key, Qundef);
        if (!UNDEF_P(value))
            rb_hash_aset(result, key, value);
    }

    return result;
}</pre> </div> <p>Returns a new Hash object containing the entries for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.slice(:baz, :foo) # =&gt; {:baz=&gt;2, :foo=&gt;0}
</pre> <p>Any given <code>keys</code> that are not found are ignored.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-store"> <span class="method-callseq"> store(key, value) </span> </div> </div> <div class="method-description"> <p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p> <p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:foo] = 2 # =&gt; 2
h.store(:bar, 3) # =&gt; 3
h # =&gt; {:foo=&gt;2, :bar=&gt;3}
</pre> <p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="hash.html#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:baz] = 2 # =&gt; 2
h.store(:bat, 3) # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_a(VALUE hash)
{
    VALUE ary;

    ary = rb_ary_new_capa(RHASH_SIZE(hash));
    rb_hash_foreach(hash, to_a_i, ary);

    return ary;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> of 2-element <a href="array.html"><code>Array</code></a> objects; each nested <a href="array.html"><code>Array</code></a> contains a key-value pair from <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.to_a # =&gt; [[:foo, 0], [:bar, 1], [:baz, 2]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → self or new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|key, value| ... } → new_hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_h(VALUE hash)
{
    if (rb_block_given_p()) {
        return rb_hash_to_h_block(hash);
    }
    if (rb_obj_class(hash) != rb_cHash) {
        const VALUE flags = RBASIC(hash)-&gt;flags;
        hash = hash_dup(hash, rb_cHash, flags &amp; RHASH_PROC_DEFAULT);
    }
    return hash;
}</pre> </div> <p>For an instance of Hash, returns <code>self</code>.</p> <p>For a subclass of Hash, returns a new Hash containing the content of <code>self</code>.</p> <p>When a block is given, returns a new Hash object whose content is based on the block; the block should return a 2-element <a href="array.html"><code>Array</code></a> object specifying the key-value pair to be included in the returned Array:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.to_h {|key, value| [value, key] }
h1 # =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_hash"> <span class="method-callseq"> to_hash → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_hash(VALUE hash)
{
    return hash;
}</pre> </div> <p>Returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_proc"> <span class="method-callseq"> to_proc → proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_proc(VALUE hash)
{
    return rb_func_lambda_new(hash_proc_call, hash, 1, 1);
}</pre> </div> <p>Returns a <a href="proc.html"><code>Proc</code></a> object that maps a key to its value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
proc = h.to_proc
proc.class # =&gt; Proc
proc.call(:foo) # =&gt; 0
proc.call(:bar) # =&gt; 1
proc.call(:nosuch) # =&gt; nil
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span> </div> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transform_keys"> <span class="method-callseq"> transform_keys {|key| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys(hash2) → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys(hash2) {|other_key| ...} → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys(int argc, VALUE *argv, VALUE hash)
{
    VALUE result;
    struct transform_keys_args transarg = {0};

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        transarg.trans = to_hash(argv[0]);
        transarg.block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        if (transarg.trans) {
            transarg.result = result;
            rb_hash_foreach(hash, transform_keys_hash_i, (VALUE)&amp;transarg);
        }
        else {
            rb_hash_foreach(hash, transform_keys_i, result);
        }
    }

    return result;
}</pre> </div> <p>Returns a new Hash object; each entry has:</p> <ul>
<li> <p>A key provided by the block.</p> </li>
<li> <p>The value from <code>self</code>.</p> </li>
</ul> <p>An optional hash argument can be provided to map keys to new keys. Any key not given will be mapped using the provided block, or remain the same if no block is given.</p> <p>Transform keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_keys {|key| key.to_s }
h1 # =&gt; {"foo"=&gt;0, "bar"=&gt;1, "baz"=&gt;2}

h.transform_keys(foo: :bar, bar: :foo)
#=&gt; {bar: 0, foo: 1, baz: 2}

h.transform_keys(foo: :hello, &amp;:to_s)
#=&gt; {:hello=&gt;0, "bar"=&gt;1, "baz"=&gt;2}
</pre> <p>Overwrites values for duplicate keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_keys {|key| :bat }
h1 # =&gt; {:bat=&gt;2}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_keys # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_keys&gt;
h1 = e.each { |key| key.to_s }
h1 # =&gt; {"foo"=&gt;0, "bar"=&gt;1, "baz"=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transform_keys-21"> <span class="method-callseq"> transform_keys! {|key| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys!(hash2) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys!(hash2) {|other_key| ...} → self </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys_bang(int argc, VALUE *argv, VALUE hash)
{
    VALUE trans = 0;
    int block_given = 0;

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        trans = to_hash(argv[0]);
        block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        long i;
        VALUE new_keys = hash_alloc(0);
        VALUE pairs = rb_ary_hidden_new(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, pairs);
        for (i = 0; i &lt; RARRAY_LEN(pairs); i += 2) {
            VALUE key = RARRAY_AREF(pairs, i), new_key, val;

            if (!trans) {
                new_key = rb_yield(key);
            }
            else if (!UNDEF_P(new_key = rb_hash_lookup2(trans, key, Qundef))) {
                /* use the transformed key */
            }
            else if (block_given) {
                new_key = rb_yield(key);
            }
            else {
                new_key = key;
            }
            val = RARRAY_AREF(pairs, i+1);
            if (!hash_stlike_lookup(new_keys, key, NULL)) {
                rb_hash_stlike_delete(hash, &amp;key, NULL);
            }
            rb_hash_aset(hash, new_key, val);
            rb_hash_aset(new_keys, new_key, Qnil);
        }
        rb_ary_clear(pairs);
        rb_hash_clear(new_keys);
    }
    compact_after_delete(hash);
    return hash;
}</pre> </div> <p>Same as <a href="hash.html#method-i-transform_keys"><code>Hash#transform_keys</code></a> but modifies the receiver in place instead of returning a new hash.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transform_values"> <span class="method-callseq"> transform_values {|value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    SET_DEFAULT(result, Qnil);

    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(result, transform_values_foreach_func, transform_values_foreach_replace, result);
        compact_after_delete(result);
    }

    return result;
}</pre> </div> <p>Returns a new Hash object; each entry has:</p> <ul>
<li> <p>A key from <code>self</code>.</p> </li>
<li> <p>A value provided by the block.</p> </li>
</ul> <p>Transform values:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_values {|value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_values # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_values&gt;
h1 = e.each { |value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transform_values-21"> <span class="method-callseq"> transform_values! {|value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);

    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(hash, transform_values_foreach_func, transform_values_foreach_replace, hash);
    }

    return hash;
}</pre> </div> <p>Returns <code>self</code>, whose keys are unchanged, and whose values are determined by the given block.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.transform_values! {|value| value * 100} # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_values! # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}:transform_values!&gt;
h1 = e.each {|value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-update"> <span class="method-name">update</span> </div> </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-merge-21">merge!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-value-3F"> <span class="method-callseq"> value?(value) → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-has_value-3F">has_value?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values"> <span class="method-callseq"> values → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="c" data-language="c">VALUE
rb_hash_values(VALUE hash)
{
    VALUE values;
    st_index_t size = RHASH_SIZE(hash);

    values = rb_ary_new_capa(size);
    if (size == 0) return values;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        if (RHASH_AR_TABLE_P(hash)) {
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE(values, ptr, {
                size = ar_values(hash, ptr, size);
            });
        }
        else if (RHASH_ST_TABLE_P(hash)) {
            st_table *table = RHASH_ST_TABLE(hash);
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE(values, ptr, {
                size = st_values(table, ptr, size);
            });
        }
        rb_ary_set_len(values, size);
    }

    else {
        rb_hash_foreach(hash, values_i, values);
    }

    return values;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> containing all values in <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.values # =&gt; [0, 1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(*keys) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_hash_values_at(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_aref(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Returns a new <a href="array.html"><code>Array</code></a> containing values for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.values_at(:baz, :foo) # =&gt; [2, 0]
</pre> <p>The <a href="hash.html#class-Hash-label-Default+Values">default values</a> are returned for any keys that are not found:</p> <pre class="ruby" data-language="ruby">h.values_at(:hello, :foo) # =&gt; [nil, 0]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
