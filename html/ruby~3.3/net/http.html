<h1 id="class-Net::HTTP" class="class"> class Net::HTTP </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent">Protocol</dd>
</dl> <section class="description"> <p>Class Net::HTTP provides a rich library that implements the client in a client-server model that uses the HTTP request-response protocol. For information about HTTP, see:</p> <ul>
<li> <p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Technical_overview">Technical overview</a>.</p> </li>
</ul> <h2 id="class-Net::HTTP-label-About+the+Examples">About the Examples</h2> <p>Examples here assume that <code>net/http</code> has been required (which also requires <code>uri</code>):</p> <pre class="ruby" data-language="ruby">require 'net/http'
</pre> <p>Many code examples here use these example websites:</p> <ul>
<li> <p><a href="https://jsonplaceholder.typicode.com">jsonplaceholder.typicode.com</a>.</p> </li>
<li> <p><a href="http://example.com">example.com</a>.</p> </li>
</ul> <p>Some examples also assume these variables:</p> <pre class="ruby" data-language="ruby">uri = URI('https://jsonplaceholder.typicode.com/')
uri.freeze # Examples may not modify.
hostname = uri.hostname # =&gt; "jsonplaceholder.typicode.com"
path = uri.path         # =&gt; "/"
port = uri.port         # =&gt; 443
</pre> <p>So that example requests may be written as:</p> <pre class="ruby" data-language="ruby">Net::HTTP.get(uri)
Net::HTTP.get(hostname, '/index.html')
Net::HTTP.start(hostname) do |http|
  http.get('/todos/1')
  http.get('/todos/2')
end
</pre> <p>An example that needs a modified <a href="../uri.html"><code>URI</code></a> first duplicates <code>uri</code>, then modifies the duplicate:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
_uri.path = '/todos/1'
</pre> <h2 id="class-Net::HTTP-label-Strategies">Strategies</h2> <ul>
<li> <p>If you will make only a few GET requests, consider using <a href="../openuri.html"><code>OpenURI</code></a>.</p> </li>
<li> <p>If you will make only a few requests of all kinds, consider using the various singleton convenience methods in this class. Each of the following methods automatically starts and finishes a <a href="http#class-Net::HTTP-label-Sessions">session</a> that sends a single request:</p> <pre class="ruby" data-language="ruby"># Return string response body.
Net::HTTP.get(hostname, path)
Net::HTTP.get(uri)

# Write string response body to $stdout.
Net::HTTP.get_print(hostname, path)
Net::HTTP.get_print(uri)

# Return response as Net::HTTPResponse object.
Net::HTTP.get_response(hostname, path)
Net::HTTP.get_response(uri)
data = '{"title": "foo", "body": "bar", "userId": 1}'
Net::HTTP.post(uri, data)
params = {title: 'foo', body: 'bar', userId: 1}
Net::HTTP.post_form(uri, params)
</pre> </li>
<li> <p>If performance is important, consider using sessions, which lower request overhead. This <a href="http#class-Net::HTTP-label-Sessions">session</a> has multiple requests for <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP methods</a> and <a href="https://en.wikipedia.org/wiki/WebDAV#Implementation">WebDAV methods</a>:</p> <pre class="ruby" data-language="ruby">Net::HTTP.start(hostname) do |http|
  # Session started automatically before block execution.
  http.get(path)
  http.head(path)
  body = 'Some text'
  http.post(path, body)  # Can also have a block.
  http.put(path, body)
  http.delete(path)
  http.options(path)
  http.trace(path)
  http.patch(path, body) # Can also have a block.
  http.copy(path)
  http.lock(path, body)
  http.mkcol(path, body)
  http.move(path)
  http.propfind(path, body)
  http.proppatch(path, body)
  http.unlock(path, body)
  # Session finished automatically at block exit.
end
</pre> </li>
</ul> <p>The methods cited above are convenience methods that, via their few arguments, allow minimal control over the requests. For greater control, consider using <a href="httprequest">request objects</a>.</p> <h2 id="class-Net::HTTP-label-URIs">URIs</h2> <p>On the internet, a <a href="../uri.html"><code>URI</code></a> (<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Universal Resource Identifier</a>) is a string that identifies a particular resource. It consists of some or all of: scheme, hostname, path, query, and fragment; see <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax">URI syntax</a>.</p> <p>A Ruby <a href="../uri/generic.html"><code>URI::Generic</code></a> object represents an internet <a href="../uri.html"><code>URI</code></a>. It provides, among others, methods <code>scheme</code>, <code>hostname</code>, <code>path</code>, <code>query</code>, and <code>fragment</code>.</p> <h3 id="class-Net::HTTP-label-Schemes">Schemes</h3> <p>An internet URI has a <a href="https://en.wikipedia.org/wiki/List_of_URI_schemes">scheme</a>.</p> <p>The two schemes supported in Net::HTTP are <code>'https'</code> and <code>'http'</code>:</p> <pre class="ruby" data-language="ruby">uri.scheme                       # =&gt; "https"
URI('http://example.com').scheme # =&gt; "http"
</pre> <h3 id="class-Net::HTTP-label-Hostnames">Hostnames</h3> <p>A hostname identifies a server (host) to which requests may be sent:</p> <pre class="ruby" data-language="ruby">hostname = uri.hostname # =&gt; "jsonplaceholder.typicode.com"
Net::HTTP.start(hostname) do |http|
  # Some HTTP stuff.
end
</pre> <h3 id="class-Net::HTTP-label-Paths">Paths</h3> <p>A host-specific path identifies a resource on the host:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
_uri.path = '/todos/1'
hostname = _uri.hostname
path = _uri.path
Net::HTTP.get(hostname, path)
</pre> <h3 id="class-Net::HTTP-label-Queries">Queries</h3> <p>A host-specific query adds name/value pairs to the URI:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
params = {userId: 1, completed: false}
_uri.query = URI.encode_www_form(params)
_uri # =&gt; #&lt;URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&amp;completed=false&gt;
Net::HTTP.get(_uri)
</pre> <h3 id="class-Net::HTTP-label-Fragments">Fragments</h3> <p>A <a href="https://en.wikipedia.org/wiki/URI_fragment">URI fragment</a> has no effect in Net::HTTP; the same data is returned, regardless of whether a fragment is included.</p> <h2 id="class-Net::HTTP-label-Request+Headers">Request Headers</h2> <p>Request headers may be used to pass additional information to the host, similar to arguments passed in a method call; each header is a name/value pair.</p> <p>Each of the Net::HTTP methods that sends a request to the host has optional argument <code>headers</code>, where the headers are expressed as a hash of field-name/value pairs:</p> <pre class="ruby" data-language="ruby">headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
Net::HTTP.get(uri, headers)
</pre> <p>See lists of both standard request fields and common request fields at <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields">Request Fields</a>. A host may also accept other custom fields.</p> <h2 id="class-Net::HTTP-label-HTTP+Sessions">HTTP Sessions</h2> <p>A <em>session</em> is a connection between a server (host) and a client that:</p> <ul>
<li> <p>Is begun by instance method <a href="http#method-i-start"><code>Net::HTTP#start</code></a>.</p> </li>
<li> <p>May contain any number of requests.</p> </li>
<li> <p>Is ended by instance method <a href="http#method-i-finish"><code>Net::HTTP#finish</code></a>.</p> </li>
</ul> <p>See example sessions at <a href="http#class-Net::HTTP-label-Strategies">Strategies</a>.</p> <h3 id="class-Net::HTTP-label-Session+Using+Net-3A-3AHTTP.start">Session Using Net::HTTP.start</h3> <p>If you have many requests to make to a single host (and port), consider using singleton method <a href="http#method-c-start"><code>Net::HTTP.start</code></a> with a block; the method handles the session automatically by:</p> <ul>
<li> <p>Calling <a href="http#method-i-start"><code>start</code></a> before block execution.</p> </li>
<li> <p>Executing the block.</p> </li>
<li> <p>Calling <a href="http#method-i-finish"><code>finish</code></a> after block execution.</p> </li>
</ul> <p>In the block, you can use these instance methods, each of which that sends a single request:</p> <ul>
<li> <p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP methods</a>:</p> <ul>
<li> <p><a href="http#method-i-get"><code>get</code></a>, <a href="http#method-i-request_get"><code>request_get</code></a>: GET.</p> </li>
<li> <p><a href="http#method-i-head"><code>head</code></a>, <a href="http#method-i-request_head"><code>request_head</code></a>: HEAD.</p> </li>
<li> <p><a href="http#method-i-post"><code>post</code></a>, <a href="http#method-i-request_post"><code>request_post</code></a>: POST.</p> </li>
<li> <p><a href="http#method-i-delete"><code>delete</code></a>: DELETE.</p> </li>
<li> <p><a href="http#method-i-options"><code>options</code></a>: OPTIONS.</p> </li>
<li> <p><a href="http#method-i-trace"><code>trace</code></a>: TRACE.</p> </li>
<li> <p><a href="http#method-i-patch"><code>patch</code></a>: PATCH.</p> </li>
</ul> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/WebDAV#Implementation">WebDAV methods</a>:</p> <ul>
<li> <p><a href="http#method-i-copy"><code>copy</code></a>: COPY.</p> </li>
<li> <p><a href="http#method-i-lock"><code>lock</code></a>: LOCK.</p> </li>
<li> <p><a href="http#method-i-mkcol"><code>mkcol</code></a>: MKCOL.</p> </li>
<li> <p><a href="http#method-i-move"><code>move</code></a>: MOVE.</p> </li>
<li> <p><a href="http#method-i-propfind"><code>propfind</code></a>: PROPFIND.</p> </li>
<li> <p><a href="http#method-i-proppatch"><code>proppatch</code></a>: PROPPATCH.</p> </li>
<li> <p><a href="http#method-i-unlock"><code>unlock</code></a>: UNLOCK.</p> </li>
</ul> </li>
</ul> <h3 id="class-Net::HTTP-label-Session+Using+Net-3A-3AHTTP.start+and+Net-3A-3AHTTP.finish">Session Using Net::HTTP.start and Net::HTTP.finish</h3> <p>You can manage a session manually using methods <a href="http#method-i-start"><code>start</code></a> and <a href="http#method-i-finish"><code>finish</code></a>:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.start
http.get('/todos/1')
http.get('/todos/2')
http.delete('/posts/1')
http.finish # Needed to free resources.
</pre> <h3 id="class-Net::HTTP-label-Single-Request+Session">Single-Request Session</h3> <p>Certain convenience methods automatically handle a session by:</p> <ul>
<li> <p>Creating an HTTP object</p> </li>
<li> <p>Starting a session.</p> </li>
<li> <p>Sending a single request.</p> </li>
<li> <p>Finishing the session.</p> </li>
<li> <p>Destroying the object.</p> </li>
</ul> <p>Such methods that send GET requests:</p> <ul>
<li> <p><a href="http#method-c-get"><code>::get</code></a>: Returns the string response body.</p> </li>
<li> <p><a href="http#method-c-get_print"><code>::get_print</code></a>: Writes the string response body to $stdout.</p> </li>
<li> <p><a href="http#method-c-get_response"><code>::get_response</code></a>: Returns a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> </li>
</ul> <p>Such methods that send POST requests:</p> <ul>
<li> <p><a href="http#method-c-post"><code>::post</code></a>: Posts data to the host.</p> </li>
<li> <p><a href="http#method-c-post_form"><code>::post_form</code></a>: Posts form data to the host.</p> </li>
</ul> <h2 id="class-Net::HTTP-label-HTTP+Requests+and+Responses">HTTP Requests and Responses</h2> <p>Many of the methods above are convenience methods, each of which sends a request and returns a string without directly using Net::HTTPRequest and Net::HTTPResponse objects.</p> <p>You can, however, directly create a request object, send the request, and retrieve the response object; see:</p> <ul>
<li> <p><a href="httprequest"><code>Net::HTTPRequest</code></a>.</p> </li>
<li> <p><a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> </li>
</ul> <h2 id="class-Net::HTTP-label-Following+Redirection">Following Redirection</h2> <p>Each returned response is an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>. See the <a href="httpresponse#class-Net::HTTPResponse-label-Response+Subclasses">response class hierarchy</a>.</p> <p>In particular, class <a href="httpredirection"><code>Net::HTTPRedirection</code></a> is the parent of all redirection classes. This allows you to craft a case statement to handle redirections properly:</p> <pre class="ruby" data-language="ruby">def fetch(uri, limit = 10)
  # You should choose a better exception.
  raise ArgumentError, 'Too many HTTP redirects' if limit == 0

  res = Net::HTTP.get_response(URI(uri))
  case res
  when Net::HTTPSuccess     # Any success class.
    res
  when Net::HTTPRedirection # Any redirection class.
    location = res['Location']
    warn "Redirected to #{location}"
    fetch(location, limit - 1)
  else                      # Any other class.
    res.value
  end
end

fetch(uri)
</pre> <h2 id="class-Net::HTTP-label-Basic+Authentication">Basic Authentication</h2> <p>Basic authentication is performed according to <a href="http://www.ietf.org/rfc/rfc2617.txt">RFC2617</a>:</p> <pre class="ruby" data-language="ruby">req = Net::HTTP::Get.new(uri)
req.basic_auth('user', 'pass')
res = Net::HTTP.start(hostname) do |http|
  http.request(req)
end
</pre> <h2 id="class-Net::HTTP-label-Streaming+Response+Bodies">Streaming Response Bodies</h2> <p>By default Net::HTTP reads an entire response into memory. If you are handling large files or wish to implement a progress bar you can instead stream the body directly to an <a href="../io.html"><code>IO</code></a>.</p> <pre class="ruby" data-language="ruby">Net::HTTP.start(hostname) do |http|
  req = Net::HTTP::Get.new(uri)
  http.request(req) do |res|
    open('t.tmp', 'w') do |f|
      res.read_body do |chunk|
        f.write chunk
      end
    end
  end
end
</pre> <h2 id="class-Net::HTTP-label-HTTPS">HTTPS</h2> <p>HTTPS is enabled for an HTTP connection by <a href="http#method-i-use_ssl-3D"><code>Net::HTTP#use_ssl=</code></a>:</p> <pre class="ruby" data-language="ruby">Net::HTTP.start(hostname, :use_ssl =&gt; true) do |http|
  req = Net::HTTP::Get.new(uri)
  res = http.request(req)
end
</pre> <p>Or if you simply want to make a GET request, you may pass in a <a href="../uri.html"><code>URI</code></a> object that has an HTTPS URL. Net::HTTP automatically turns on TLS verification if the <a href="../uri.html"><code>URI</code></a> object has a ‘https’ <a href="../uri.html"><code>URI</code></a> scheme:</p> <pre class="ruby" data-language="ruby">uri # =&gt; #&lt;URI::HTTPS https://jsonplaceholder.typicode.com/&gt;
Net::HTTP.get(uri)
</pre> <h2 id="class-Net::HTTP-label-Proxy+Server">Proxy Server</h2> <p>An HTTP object can have a <a href="https://en.wikipedia.org/wiki/Proxy_server">proxy server</a>.</p> <p>You can create an HTTP object with a proxy server using method <a href="http#method-c-new"><code>Net::HTTP.new</code></a> or method <a href="http#method-c-start"><code>Net::HTTP.start</code></a>.</p> <p>The proxy may be defined either by argument <code>p_addr</code> or by environment variable <code>'http_proxy'</code>.</p> <h3 id="class-Net::HTTP-label-Proxy+Using+Argument+p_addr+as+a+String">Proxy Using Argument <code>p_addr</code> as a String</h3> <p>When argument <code>p_addr</code> is a string hostname, the returned <code>http</code> has the given host as its proxy:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname, nil, 'proxy.example')
http.proxy?          # =&gt; true
http.proxy_from_env? # =&gt; false
http.proxy_address   # =&gt; "proxy.example"
# These use default values.
http.proxy_port      # =&gt; 80
http.proxy_user      # =&gt; nil
http.proxy_pass      # =&gt; nil
</pre> <p>The port, username, and password for the proxy may also be given:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=false&gt;
http.proxy?          # =&gt; true
http.proxy_from_env? # =&gt; false
http.proxy_address   # =&gt; "proxy.example"
http.proxy_port      # =&gt; 8000
http.proxy_user      # =&gt; "pname"
http.proxy_pass      # =&gt; "ppass"
</pre> <h3 id="class-Net::HTTP-label-Proxy+Using+-27ENV-5B-27http_proxy-27-5D-27">Proxy Using ‘<code>ENV['http_proxy']</code>’</h3> <p>When environment variable <code>'http_proxy'</code> is set to a URI string, the returned <code>http</code> will have the server at that <a href="../uri.html"><code>URI</code></a> as its proxy; note that the URI string must have a protocol such as <code>'http'</code> or <code>'https'</code>:</p> <pre class="ruby" data-language="ruby">ENV['http_proxy'] = 'http://example.com'
http = Net::HTTP.new(hostname)
http.proxy?          # =&gt; true
http.proxy_from_env? # =&gt; true
http.proxy_address   # =&gt; "example.com"
# These use default values.
http.proxy_port      # =&gt; 80
http.proxy_user      # =&gt; nil
http.proxy_pass      # =&gt; nil
</pre> <p>The URI string may include proxy username, password, and port number:</p> <pre class="ruby" data-language="ruby">ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
http = Net::HTTP.new(hostname)
http.proxy?          # =&gt; true
http.proxy_from_env? # =&gt; true
http.proxy_address   # =&gt; "example.com"
http.proxy_port      # =&gt; 8000
http.proxy_user      # =&gt; "pname"
http.proxy_pass      # =&gt; "ppass"
</pre> <h3 id="class-Net::HTTP-label-Filtering+Proxies">Filtering Proxies</h3> <p>With method <a href="http#method-c-new"><code>Net::HTTP.new</code></a> (but not <a href="http#method-c-start"><code>Net::HTTP.start</code></a>), you can use argument <code>p_no_proxy</code> to filter proxies:</p> <ul>
<li> <p>Reject a certain address:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
http.proxy_address # =&gt; nil
</pre> </li>
<li> <p>Reject certain domains or subdomains:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
http.proxy_address # =&gt; nil
</pre> </li>
<li> <p>Reject certain addresses and port combinations:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
http.proxy_address # =&gt; "proxy.example"

http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
http.proxy_address # =&gt; nil
</pre> </li>
<li> <p>Reject a list of the types above delimited using a comma:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
http.proxy_address # =&gt; nil

http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
http.proxy_address # =&gt; nil
</pre> </li>
</ul> <h2 id="class-Net::HTTP-label-Compression+and+Decompression">Compression and Decompression</h2> <p>Net::HTTP does not compress the body of a request before sending.</p> <p>By default, Net::HTTP adds header <code>'Accept-Encoding'</code> to a new <a href="httprequest">request object</a>:</p> <pre class="ruby" data-language="ruby">Net::HTTP::Get.new(uri)['Accept-Encoding']
# =&gt; "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
</pre> <p>This requests the server to zip-encode the response body if there is one; the server is not required to do so.</p> <p>Net::HTTP does not automatically decompress a response body if the response has header <code>'Content-Range'</code>.</p> <p>Otherwise decompression (or not) depends on the value of header <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-encoding-response-header">Content-Encoding</a>:</p> <ul>
<li> <p><code>'deflate'</code>, <code>'gzip'</code>, or <code>'x-gzip'</code>: decompresses the body and deletes the header.</p> </li>
<li> <p><code>'none'</code> or <code>'identity'</code>: does not decompress the body, but deletes the header.</p> </li>
<li> <p>Any other value: leaves the body and header unchanged.</p> </li>
</ul> <h2 id="class-Net::HTTP-label-What-27s+Here">What’s Here</h2> <p>This is a categorized summary of methods and attributes.</p> <h3 id="class-Net::HTTP-label-Net-3A-3AHTTP+Objects">Net::HTTP Objects</h3> <ul>
<li> <p><a href="http#method-c-new">::new</a>: Creates a new instance.</p> </li>
<li> <p><a href="http#method-i-inspect">#inspect</a>: Returns a string representation of <code>self</code>.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Sessions">Sessions</h3> <ul>
<li> <p><a href="http#method-c-start">::start</a>: Begins a new session in a new Net::HTTP object.</p> </li>
<li> <p><a href="http#method-i-started-3F">#started?</a> (aliased as <a href="http#method-i-active-3F">#active?</a>): Returns whether in a session.</p> </li>
<li> <p><a href="http#method-i-finish">#finish</a>: Ends an active session.</p> </li>
<li> <p><a href="http#method-i-start">#start</a>: Begins a new session in an existing Net::HTTP object (<code>self</code>).</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Connections">Connections</h3> <ul>
<li> <p><a href="http#attribute-i-continue_timeout">:continue_timeout</a>: Returns the continue timeout.</p> </li>
<li> <p><a href="http#method-i-continue_timeout-3D">#continue_timeout=</a>: Sets the continue timeout seconds.</p> </li>
<li> <p><a href="http#attribute-i-keep_alive_timeout">:keep_alive_timeout</a>: Returns the keep-alive timeout.</p> </li>
<li> <p><a href="http#attribute-i-keep_alive_timeout">:keep_alive_timeout=</a>: Sets the keep-alive timeout.</p> </li>
<li> <p><a href="http#attribute-i-max_retries">:max_retries</a>: Returns the maximum retries.</p> </li>
<li> <p><a href="http#method-i-max_retries-3D">#max_retries=</a>: Sets the maximum retries.</p> </li>
<li> <p><a href="http#attribute-i-open_timeout">:open_timeout</a>: Returns the open timeout.</p> </li>
<li> <p><a href="http#attribute-i-open_timeout">:open_timeout=</a>: Sets the open timeout.</p> </li>
<li> <p><a href="http#attribute-i-read_timeout">:read_timeout</a>: Returns the open timeout.</p> </li>
<li> <p><a href="http#method-i-read_timeout-3D">:read_timeout=</a>: Sets the read timeout.</p> </li>
<li> <p><a href="http#attribute-i-ssl_timeout">:ssl_timeout</a>: Returns the ssl timeout.</p> </li>
<li> <p><a href="http#attribute-i-ssl_timeout">:ssl_timeout=</a>: Sets the ssl timeout.</p> </li>
<li> <p><a href="http#attribute-i-write_timeout">:write_timeout</a>: Returns the write timeout.</p> </li>
<li> <p><a href="http#method-i-write_timeout-3D">write_timeout=</a>: Sets the write timeout.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Requests">Requests</h3> <ul>
<li> <p><a href="http#method-c-get">::get</a>: Sends a GET request and returns the string response body.</p> </li>
<li> <p><a href="http#method-c-get_print">::get_print</a>: Sends a GET request and write the string response body to $stdout.</p> </li>
<li> <p><a href="http#method-c-get_response">::get_response</a>: Sends a GET request and returns a response object.</p> </li>
<li> <p><a href="http#method-c-post_form">::post_form</a>: Sends a POST request with form data and returns a response object.</p> </li>
<li> <p><a href="http#method-c-post">::post</a>: Sends a POST request with data and returns a response object.</p> </li>
<li> <p><a href="http#method-i-copy">#copy</a>: Sends a COPY request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-delete">#delete</a>: Sends a DELETE request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-get">#get</a>: Sends a GET request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-head">#head</a>: Sends a HEAD request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-lock">#lock</a>: Sends a LOCK request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-mkcol">#mkcol</a>: Sends a MKCOL request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-move">#move</a>: Sends a MOVE request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-options">#options</a>: Sends a OPTIONS request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-patch">#patch</a>: Sends a PATCH request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-post">#post</a>: Sends a POST request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-propfind">#propfind</a>: Sends a PROPFIND request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-proppatch">#proppatch</a>: Sends a PROPPATCH request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-put">#put</a>: Sends a PUT request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-request">#request</a>: Sends a request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-request_get">#request_get</a> (aliased as <a href="http#method-i-get2">#get2</a>): Sends a GET request and forms a response object; if a block given, calls the block with the object, otherwise returns the object.</p> </li>
<li> <p><a href="http#method-i-request_head">#request_head</a> (aliased as <a href="http#method-i-head2">#head2</a>): Sends a HEAD request and forms a response object; if a block given, calls the block with the object, otherwise returns the object.</p> </li>
<li> <p><a href="http#method-i-request_post">#request_post</a> (aliased as <a href="http#method-i-post2">#post2</a>): Sends a POST request and forms a response object; if a block given, calls the block with the object, otherwise returns the object.</p> </li>
<li> <p><a href="http#method-i-send_request">#send_request</a>: Sends a request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-trace">#trace</a>: Sends a TRACE request and returns a response object.</p> </li>
<li> <p><a href="http#method-i-unlock">#unlock</a>: Sends an UNLOCK request and returns a response object.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Responses">Responses</h3> <ul>
<li> <p><a href="http#attribute-i-close_on_empty_response">:close_on_empty_response</a>: Returns whether to close connection on empty response.</p> </li>
<li> <p><a href="http#attribute-i-close_on_empty_response">:close_on_empty_response=</a>: Sets whether to close connection on empty response.</p> </li>
<li> <p><a href="http#attribute-i-ignore_eof">:ignore_eof</a>: Returns whether to ignore end-of-file when reading a response body with <code>Content-Length</code> headers.</p> </li>
<li> <p><a href="http#attribute-i-ignore_eof">:ignore_eof=</a>: Sets whether to ignore end-of-file when reading a response body with <code>Content-Length</code> headers.</p> </li>
<li> <p><a href="http#attribute-i-response_body_encoding">:response_body_encoding</a>: Returns the encoding to use for the response body.</p> </li>
<li> <p><a href="http#method-i-response_body_encoding-3D">#response_body_encoding=</a>: Sets the response body encoding.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Proxies">Proxies</h3> <ul>
<li> <p><a href="http#method-i-proxy_address">:proxy_address</a>: Returns the proxy address.</p> </li>
<li> <p><a href="http#attribute-i-proxy_address">:proxy_address=</a>: Sets the proxy address.</p> </li>
<li> <p><a href="http#method-c-proxy_class-3F">::proxy_class?</a>: Returns whether <code>self</code> is a proxy class.</p> </li>
<li> <p><a href="http#method-i-proxy-3F">#proxy?</a>: Returns whether <code>self</code> has a proxy.</p> </li>
<li> <p><a href="http#method-i-proxy_address">#proxy_address</a> (aliased as <a href="http#method-i-proxyaddr">#proxyaddr</a>): Returns the proxy address.</p> </li>
<li> <p><a href="http#method-i-proxy_from_env-3F">#proxy_from_env?</a>: Returns whether the proxy is taken from an environment variable.</p> </li>
<li> <p><a href="http#attribute-i-proxy_from_env">:proxy_from_env=</a>: Sets whether the proxy is to be taken from an environment variable.</p> </li>
<li> <p><a href="http#method-i-proxy_pass">:proxy_pass</a>: Returns the proxy password.</p> </li>
<li> <p><a href="http#attribute-i-proxy_pass">:proxy_pass=</a>: Sets the proxy password.</p> </li>
<li> <p><a href="http#method-i-proxy_port">:proxy_port</a>: Returns the proxy port.</p> </li>
<li> <p><a href="http#attribute-i-proxy_port">:proxy_port=</a>: Sets the proxy port.</p> </li>
<li> <p><a href="http#method-i-proxy_user">#proxy_user</a>: Returns the proxy user name.</p> </li>
<li> <p><a href="http#attribute-i-proxy_user">:proxy_user=</a>: Sets the proxy user.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Security">Security</h3> <ul>
<li> <p><a href="http#attribute-i-ca_file">:ca_file</a>: Returns the path to a CA certification file.</p> </li>
<li> <p><a href="http#attribute-i-ca_file">:ca_file=</a>: Sets the path to a CA certification file.</p> </li>
<li> <p><a href="http#attribute-i-ca_path">:ca_path</a>: Returns the path of to CA directory containing certification files.</p> </li>
<li> <p><a href="http#attribute-i-ca_path">:ca_path=</a>: Sets the path of to CA directory containing certification files.</p> </li>
<li> <p><a href="http#attribute-i-cert">:cert</a>: Returns the <a href="../openssl/x509/certificate.html"><code>OpenSSL::X509::Certificate</code></a> object to be used for client certification.</p> </li>
<li> <p><a href="http#attribute-i-cert">:cert=</a>: Sets the <a href="../openssl/x509/certificate.html"><code>OpenSSL::X509::Certificate</code></a> object to be used for client certification.</p> </li>
<li> <p><a href="http#attribute-i-cert_store">:cert_store</a>: Returns the X509::Store to be used for verifying peer certificate.</p> </li>
<li> <p><a href="http#attribute-i-cert_store">:cert_store=</a>: Sets the X509::Store to be used for verifying peer certificate.</p> </li>
<li> <p><a href="http#attribute-i-ciphers">:ciphers</a>: Returns the available SSL ciphers.</p> </li>
<li> <p><a href="http#attribute-i-ciphers">:ciphers=</a>: Sets the available SSL ciphers.</p> </li>
<li> <p><a href="http#attribute-i-extra_chain_cert">:extra_chain_cert</a>: Returns the extra X509 certificates to be added to the certificate chain.</p> </li>
<li> <p><a href="http#attribute-i-extra_chain_cert">:extra_chain_cert=</a>: Sets the extra X509 certificates to be added to the certificate chain.</p> </li>
<li> <p><a href="http#attribute-i-key">:key</a>: Returns the <a href="../openssl/pkey/rsa.html"><code>OpenSSL::PKey::RSA</code></a> or <a href="../openssl/pkey/dsa.html"><code>OpenSSL::PKey::DSA</code></a> object.</p> </li>
<li> <p><a href="http#attribute-i-key">:key=</a>: Sets the <a href="../openssl/pkey/rsa.html"><code>OpenSSL::PKey::RSA</code></a> or <a href="../openssl/pkey/dsa.html"><code>OpenSSL::PKey::DSA</code></a> object.</p> </li>
<li> <p><a href="http#attribute-i-max_version">:max_version</a>: Returns the maximum SSL version.</p> </li>
<li> <p><a href="http#attribute-i-max_version">:max_version=</a>: Sets the maximum SSL version.</p> </li>
<li> <p><a href="http#attribute-i-min_version">:min_version</a>: Returns the minimum SSL version.</p> </li>
<li> <p><a href="http#attribute-i-min_version">:min_version=</a>: Sets the minimum SSL version.</p> </li>
<li> <p><a href="http#method-i-peer_cert">#peer_cert</a>: Returns the X509 certificate chain for the session’s socket peer.</p> </li>
<li> <p><a href="http#attribute-i-ssl_version">:ssl_version</a>: Returns the SSL version.</p> </li>
<li> <p><a href="http#attribute-i-ssl_version">:ssl_version=</a>: Sets the SSL version.</p> </li>
<li> <p><a href="http#method-i-use_ssl-3D">#use_ssl=</a>: Sets whether a new session is to use Transport Layer Security.</p> </li>
<li> <p><a href="http#method-i-use_ssl-3F">#use_ssl?</a>: Returns whether <code>self</code> uses SSL.</p> </li>
<li> <p><a href="http#attribute-i-verify_callback">:verify_callback</a>: Returns the callback for the server certification verification.</p> </li>
<li> <p><a href="http#attribute-i-verify_callback">:verify_callback=</a>: Sets the callback for the server certification verification.</p> </li>
<li> <p><a href="http#attribute-i-verify_depth">:verify_depth</a>: Returns the maximum depth for the certificate chain verification.</p> </li>
<li> <p><a href="http#attribute-i-verify_depth">:verify_depth=</a>: Sets the maximum depth for the certificate chain verification.</p> </li>
<li> <p><a href="http#attribute-i-verify_hostname">:verify_hostname</a>: Returns the flags for server the certification verification at the beginning of the SSL/TLS session.</p> </li>
<li> <p><a href="http#attribute-i-verify_hostname">:verify_hostname=</a>: Sets he flags for server the certification verification at the beginning of the SSL/TLS session.</p> </li>
<li> <p><a href="http#attribute-i-verify_mode">:verify_mode</a>: Returns the flags for server the certification verification at the beginning of the SSL/TLS session.</p> </li>
<li> <p><a href="http#attribute-i-verify_mode">:verify_mode=</a>: Sets the flags for server the certification verification at the beginning of the SSL/TLS session.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-Addresses+and+Ports">Addresses and Ports</h3> <ul>
<li> <p><a href="http#attribute-i-address">:address</a>: Returns the string host name or host IP.</p> </li>
<li> <p><a href="http#method-c-default_port">::default_port</a>: Returns integer 80, the default port to use for <a href="http"><code>HTTP</code></a> requests.</p> </li>
<li> <p><a href="http#method-c-http_default_port">::http_default_port</a>: Returns integer 80, the default port to use for <a href="http"><code>HTTP</code></a> requests.</p> </li>
<li> <p><a href="http#method-c-https_default_port">::https_default_port</a>: Returns integer 443, the default port to use for HTTPS requests.</p> </li>
<li> <p><a href="http#method-i-ipaddr">#ipaddr</a>: Returns the IP address for the connection.</p> </li>
<li> <p><a href="http#method-i-ipaddr-3D">#ipaddr=</a>: Sets the IP address for the connection.</p> </li>
<li> <p><a href="http#attribute-i-local_host">:local_host</a>: Returns the string local host used to establish the connection.</p> </li>
<li> <p><a href="http#attribute-i-local_host">:local_host=</a>: Sets the string local host used to establish the connection.</p> </li>
<li> <p><a href="http#attribute-i-local_port">:local_port</a>: Returns the integer local port used to establish the connection.</p> </li>
<li> <p><a href="http#attribute-i-local_port">:local_port=</a>: Sets the integer local port used to establish the connection.</p> </li>
<li> <p><a href="http#attribute-i-port">:port</a>: Returns the integer port number.</p> </li>
</ul> <h3 id="class-Net::HTTP-label-HTTP+Version">HTTP Version</h3> <ul><li> <p><a href="http#method-c-version_1_2-3F">::version_1_2?</a> (aliased as <a href="http#method-c-is_version_1_2-3F">::is_version_1_2?</a> and <a href="http#method-c-version_1_2">::version_1_2</a>): Returns true; retained for compatibility.</p> </li></ul> <h3 id="class-Net::HTTP-label-Debugging">Debugging</h3> <ul><li> <p><a href="http#method-i-set_debug_output">#set_debug_output</a>: Sets the output stream for debugging.</p> </li></ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-proxy_address"> <span class="method-name">proxy_address</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the address of the proxy host, or <code>nil</code> if none; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server at <code>Net::HTTP</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-proxy_pass"> <span class="method-name">proxy_pass</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the password for accessing the proxy, or <code>nil</code> if none; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server at <code>Net::HTTP</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-proxy_port"> <span class="method-name">proxy_port</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the port number of the proxy host, or <code>nil</code> if none; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server at <code>Net::HTTP</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-proxy_user"> <span class="method-name">proxy_user</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the user name for accessing the proxy, or <code>nil</code> if none; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server at <code>Net::HTTP</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-address"> <span class="method-name">address</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the string host name or host IP given as argument <code>address</code> in <a href="http#method-c-new"><code>::new</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ca_file"> <span class="method-name">ca_file</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the path to a CA certification file in PEM format.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ca_path"> <span class="method-name">ca_path</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the path of to CA directory containing certification files in PEM format.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert"> <span class="method-name">cert</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the <a href="../openssl/x509/certificate.html"><code>OpenSSL::X509::Certificate</code></a> object to be used for client certification.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert_store"> <span class="method-name">cert_store</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the X509::Store to be used for verifying peer certificate.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ciphers"> <span class="method-name">ciphers</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the available SSL ciphers. See <a href="../openssl/ssl/sslcontext.html#method-i-ciphers">OpenSSL::SSL::SSLContext#ciphers=</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-close_on_empty_response"> <span class="method-name">close_on_empty_response</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns whether to close the connection when the response is empty; initially <code>false</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-continue_timeout"> <span class="method-name">continue_timeout</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the continue timeout value; see <a href="http#attribute-i-continue_timeout"><code>continue_timeout</code></a>=.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-extra_chain_cert"> <span class="method-name">extra_chain_cert</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the extra X509 certificates to be added to the certificate chain. See <a href="../openssl/ssl/sslcontext.html#method-i-add_certificate"><code>OpenSSL::SSL::SSLContext#add_certificate</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ignore_eof"> <span class="method-name">ignore_eof</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns whether to ignore end-of-file when reading a response body with <code>Content-Length</code> headers; initially <code>true</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-keep_alive_timeout"> <span class="method-name">keep_alive_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the numeric (Integer or Float) number of seconds to keep the connection open after a request is sent; initially 2. If a new request is made during the given interval, the still-open connection is used; otherwise the connection will have been closed and a new connection is opened.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-key"> <span class="method-name">key</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the <a href="../openssl/pkey/rsa.html"><code>OpenSSL::PKey::RSA</code></a> or <a href="../openssl/pkey/dsa.html"><code>OpenSSL::PKey::DSA</code></a> object.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-local_host"> <span class="method-name">local_host</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the string local host used to establish the connection; initially <code>nil</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-local_port"> <span class="method-name">local_port</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the integer local port used to establish the connection; initially <code>nil</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-max_retries"> <span class="method-name">max_retries</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the maximum number of times to retry an idempotent request; see <a href="http#method-i-max_retries-3D"><code>max_retries=</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-max_version"> <span class="method-name">max_version</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the maximum SSL version. See OpenSSL::SSL::SSLContext#max_version=.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-min_version"> <span class="method-name">min_version</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the minimum SSL version. See OpenSSL::SSL::SSLContext#min_version=.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-open_timeout"> <span class="method-name">open_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the numeric (Integer or Float) number of seconds to wait for a connection to open; initially 60. If the connection is not made in the given interval, an exception is raised.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-port"> <span class="method-name">port</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the integer port number given as argument <code>port</code> in <a href="http#method-c-new"><code>::new</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_address"> <span class="method-name">proxy_address</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Sets the proxy address; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_from_env"> <span class="method-name">proxy_from_env</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Sets whether to determine the proxy from environment variable ‘<code>ENV['http_proxy']</code>’; see <a href="http#class-Net::HTTP-label-Proxy+Using+-27ENV-5B-27http_proxy-27-5D-27">Proxy Using ENV[‘http_proxy’]</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_pass"> <span class="method-name">proxy_pass</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Sets the proxy password; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_port"> <span class="method-name">proxy_port</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Sets the proxy port; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_user"> <span class="method-name">proxy_user</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Sets the proxy user; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-read_timeout"> <span class="method-name">read_timeout</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the numeric (Integer or Float) number of seconds to wait for one block to be read (via one read(2) call); see <a href="http#method-i-read_timeout-3D"><code>read_timeout=</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-response_body_encoding"> <span class="method-name">response_body_encoding</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the encoding to use for the response body; see <a href="http#method-i-response_body_encoding-3D"><code>response_body_encoding=</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ssl_timeout"> <span class="method-name">ssl_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the SSL timeout seconds.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ssl_version"> <span class="method-name">ssl_version</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the SSL version. See OpenSSL::SSL::SSLContext#ssl_version=.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_callback"> <span class="method-name">verify_callback</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the callback for the server certification verification.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_depth"> <span class="method-name">verify_depth</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the maximum depth for the certificate chain verification.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_hostname"> <span class="method-name">verify_hostname</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns whether to verify that the server certificate is valid for the hostname. See OpenSSL::SSL::SSLContext#verify_hostname=.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_mode"> <span class="method-name">verify_mode</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the flags for server the certification verification at the beginning of the SSL/TLS session. OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-write_timeout"> <span class="method-name">write_timeout</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the numeric (Integer or Float) number of seconds to wait for one block to be written (via one write(2) call); see <a href="http#method-i-write_timeout-3D"><code>write_timeout=</code></a>.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-default_port"> <span class="method-name">default_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="default_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 900
def HTTP.default_port
  http_default_port()
end</pre> </div> <p>Returns integer <code>80</code>, the default port to use for HTTP requests:</p> <pre class="ruby" data-language="ruby">Net::HTTP.default_port # =&gt; 80
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-get"> <span class="method-callseq"> Net::HTTP.get(hostname, path, port = 80) → body </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Net::HTTP:get(uri, headers = {}, port = uri.port) → body </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="get-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 802
def HTTP.get(uri_or_host, path_or_headers = nil, port = nil)
  get_response(uri_or_host, path_or_headers, port).body
end</pre> </div> <p>Sends a GET request and returns the HTTP response body as a string.</p> <p>With string arguments <code>hostname</code> and <code>path</code>:</p> <pre class="ruby" data-language="ruby">hostname = 'jsonplaceholder.typicode.com'
path = '/todos/1'
puts Net::HTTP.get(hostname, path)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
</pre> <p>With <a href="../uri.html"><code>URI</code></a> object <code>uri</code> and optional hash argument <code>headers</code>:</p> <pre class="ruby" data-language="ruby">uri = URI('https://jsonplaceholder.typicode.com/todos/1')
headers = {'Content-type' =&gt; 'application/json; charset=UTF-8'}
Net::HTTP.get(uri, headers)
</pre> <p>Related:</p> <ul>
<li> <p><a href="http/get"><code>Net::HTTP::Get</code></a>: request class for HTTP method <code>GET</code>.</p> </li>
<li> <p><a href="http#method-i-get"><code>Net::HTTP#get</code></a>: convenience method for HTTP method <code>GET</code>.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-get_print"> <span class="method-callseq"> Net::HTTP.get_print(hostname, path, port = 80) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Net::HTTP:get_print(uri, headers = {}, port = uri.port) → nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="get_print-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 761
def HTTP.get_print(uri_or_host, path_or_headers = nil, port = nil)
  get_response(uri_or_host, path_or_headers, port) {|res|
    res.read_body do |chunk|
      $stdout.print chunk
    end
  }
  nil
end</pre> </div> <p>Like <a href="http#method-c-get"><code>Net::HTTP.get</code></a>, but writes the returned body to $stdout; returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-get_response"> <span class="method-callseq"> Net::HTTP.get_response(hostname, path, port = 80) → http_response </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Net::HTTP:get_response(uri, headers = {}, port = uri.port) → http_response </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="get_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 812
def HTTP.get_response(uri_or_host, path_or_headers = nil, port = nil, &amp;block)
  if path_or_headers &amp;&amp; !path_or_headers.is_a?(Hash)
    host = uri_or_host
    path = path_or_headers
    new(host, port || HTTP.default_port).start {|http|
      return http.request_get(path, &amp;block)
    }
  else
    uri = uri_or_host
    headers = path_or_headers
    start(uri.hostname, uri.port,
          :use_ssl =&gt; uri.scheme == 'https') {|http|
      return http.request_get(uri, headers, &amp;block)
    }
  end
end</pre> </div> <p>Like <a href="http#method-c-get"><code>Net::HTTP.get</code></a>, but returns a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object instead of the body string.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-http_default_port"> <span class="method-name">http_default_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="http_default_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 908
def HTTP.http_default_port
  80
end</pre> </div> <p>Returns integer <code>80</code>, the default port to use for HTTP requests:</p> <pre class="ruby" data-language="ruby">Net::HTTP.http_default_port # =&gt; 80
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-https_default_port"> <span class="method-name">https_default_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="https_default_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 916
def HTTP.https_default_port
  443
end</pre> </div> <p>Returns integer <code>443</code>, the default port to use for HTTPS requests:</p> <pre class="ruby" data-language="ruby">Net::HTTP.https_default_port # =&gt; 443
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-is_version_1_2-3F"> <span class="method-name">is_version_1_2?</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-c-version_1_2-3F">version_1_2?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1065
def HTTP.new(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
  http = super address, port

  if proxy_class? then # from Net::HTTP::Proxy()
    http.proxy_from_env = @proxy_from_env
    http.proxy_address  = @proxy_address
    http.proxy_port     = @proxy_port
    http.proxy_user     = @proxy_user
    http.proxy_pass     = @proxy_pass
  elsif p_addr == :ENV then
    http.proxy_from_env = true
  else
    if p_addr &amp;&amp; p_no_proxy &amp;&amp; !URI::Generic.use_proxy?(address, address, port, p_no_proxy)
      p_addr = nil
      p_port = nil
    end
    http.proxy_address = p_addr
    http.proxy_port    = p_port || default_port
    http.proxy_user    = p_user
    http.proxy_pass    = p_pass
  end

  http
end</pre> </div> <p>Returns a new Net::HTTP object <code>http</code> (but does not open a TCP connection or HTTP session).</p> <p>With only string argument <code>address</code> given (and <code>ENV['http_proxy']</code> undefined or <code>nil</code>), the returned <code>http</code>:</p> <ul>
<li> <p>Has the given address.</p> </li>
<li> <p>Has the default port number, <a href="http#method-c-default_port"><code>Net::HTTP.default_port</code></a> (80).</p> </li>
<li> <p>Has no proxy.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=false&gt;
http.address # =&gt; "jsonplaceholder.typicode.com"
http.port    # =&gt; 80
http.proxy?  # =&gt; false
</pre> <p>With integer argument <code>port</code> also given, the returned <code>http</code> has the given port:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname, 8000)
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:8000 open=false&gt;
http.port # =&gt; 8000
</pre> <p>For proxy-defining arguments <code>p_addr</code> through <code>p_no_proxy</code>, see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> <div class="aliases"> Also aliased as: <a href="http#method-c-newobj">newobj</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-newobj"> <span class="method-name">newobj</span><span class="method-args">(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-c-new">new</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-post"> <span class="method-name">post</span><span class="method-args">(url, data, header = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="post-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 855
def HTTP.post(url, data, header = nil)
  start(url.hostname, url.port,
        :use_ssl =&gt; url.scheme == 'https' ) {|http|
    http.post(url, data, header)
  }
end</pre> </div> <p>Posts data to a host; returns a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> <p>Argument <code>url</code> must be a URL; argument <code>data</code> must be a string:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
_uri.path = '/posts'
data = '{"title": "foo", "body": "bar", "userId": 1}'
headers = {'content-type': 'application/json'}
res = Net::HTTP.post(_uri, data, headers) # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
puts res.body
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{
  "title": "foo",
  "body": "bar",
  "userId": 1,
  "id": 101
}
</pre> <p>Related:</p> <ul>
<li> <p><a href="http/post"><code>Net::HTTP::Post</code></a>: request class for HTTP method <code>POST</code>.</p> </li>
<li> <p><a href="http#method-i-post"><code>Net::HTTP#post</code></a>: convenience method for HTTP method <code>POST</code>.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-post_form"> <span class="method-name">post_form</span><span class="method-args">(url, params)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="post_form-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 882
def HTTP.post_form(url, params)
  req = Post.new(url)
  req.form_data = params
  req.basic_auth url.user, url.password if url.user
  start(url.hostname, url.port,
        :use_ssl =&gt; url.scheme == 'https' ) {|http|
    http.request(req)
  }
end</pre> </div> <p>Posts data to a host; returns a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> <p>Argument <code>url</code> must be a <a href="../uri.html"><code>URI</code></a>; argument <code>data</code> must be a hash:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
_uri.path = '/posts'
data = {title: 'foo', body: 'bar', userId: 1}
res = Net::HTTP.post_form(_uri, data) # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
puts res.body
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{
  "title": "foo",
  "body": "bar",
  "userId": "1",
  "id": 101
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-proxy_class-3F"> <span class="method-name">proxy_class?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_class-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1762
def proxy_class?
  defined?(@is_proxy_class) ? @is_proxy_class : false
end</pre> </div> <p>Returns true if self is a class which was created by HTTP::Proxy.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-start"> <span class="method-callseq"> start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) → http </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1010
def HTTP.start(address, *arg, &amp;block) # :yield: +http+
  arg.pop if opt = Hash.try_convert(arg[-1])
  port, p_addr, p_port, p_user, p_pass = *arg
  p_addr = :ENV if arg.size &lt; 2
  port = https_default_port if !port &amp;&amp; opt &amp;&amp; opt[:use_ssl]
  http = new(address, port, p_addr, p_port, p_user, p_pass)
  http.ipaddr = opt[:ipaddr] if opt &amp;&amp; opt[:ipaddr]

  if opt
    if opt[:use_ssl]
      opt = {verify_mode: OpenSSL::SSL::VERIFY_PEER}.update(opt)
    end
    http.methods.grep(/\A(\w+)=\z/) do |meth|
      key = $1.to_sym
      opt.key?(key) or next
      http.__send__(meth, opt[key])
    end
  end

  http.start(&amp;block)
end</pre> </div> <p>Creates a new Net::HTTP object, <code>http</code>, via Net::HTTP.new:</p> <ul>
<li> <p>For arguments <code>address</code> and <code>port</code>, see <a href="http#method-c-new"><code>Net::HTTP.new</code></a>.</p> </li>
<li> <p>For proxy-defining arguments <code>p_addr</code> through <code>p_pass</code>, see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p> </li>
<li> <p>For argument <code>opts</code>, see below.</p> </li>
</ul> <p>With no block given:</p> <ul>
<li> <p>Calls <code>http.start</code> with no block (see <a href="http#method-i-start"><code>start</code></a>), which opens a TCP connection and HTTP session.</p> </li>
<li> <p>Returns <code>http</code>.</p> </li>
<li> <p>The caller should call <a href="http#method-i-finish"><code>finish</code></a> to close the session:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.start(hostname)
http.started? # =&gt; true
http.finish
http.started? # =&gt; false
</pre> </li>
</ul> <p>With a block given:</p> <ul>
<li> <p>Calls <code>http.start</code> with the block (see <a href="http#method-i-start"><code>start</code></a>), which:</p> <ul>
<li> <p>Opens a TCP connection and HTTP session.</p> </li>
<li> <p>Calls the block, which may make any number of requests to the host.</p> </li>
<li> <p>Closes the HTTP session and TCP connection on block exit.</p> </li>
<li> <p>Returns the block’s value <code>object</code>.</p> </li>
</ul> </li>
<li> <p>Returns <code>object</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">hostname = 'jsonplaceholder.typicode.com'
Net::HTTP.start(hostname) do |http|
  puts http.get('/todos/1').body
  puts http.get('/todos/2').body
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
{
  "userId": 1,
  "id": 2,
  "title": "quis ut nam facilis et officia qui",
  "completed": false
}
</pre> <p>If the last argument given is a hash, it is the <code>opts</code> hash, where each key is a method or accessor to be called, and its value is the value to be set.</p> <p>The keys may include:</p> <ul>
<li> <p><a href="http#attribute-i-ca_file"><code>ca_file</code></a></p> </li>
<li> <p><a href="http#attribute-i-ca_path"><code>ca_path</code></a></p> </li>
<li> <p><a href="http#attribute-i-cert"><code>cert</code></a></p> </li>
<li> <p><a href="http#attribute-i-cert_store"><code>cert_store</code></a></p> </li>
<li> <p><a href="http#attribute-i-ciphers"><code>ciphers</code></a></p> </li>
<li> <p><a href="http#attribute-i-close_on_empty_response"><code>close_on_empty_response</code></a></p> </li>
<li> <p><code>ipaddr</code> (calls <a href="http#method-i-ipaddr-3D"><code>ipaddr=</code></a>)</p> </li>
<li> <p><a href="http#attribute-i-keep_alive_timeout"><code>keep_alive_timeout</code></a></p> </li>
<li> <p><a href="http#attribute-i-key"><code>key</code></a></p> </li>
<li> <p><a href="http#attribute-i-open_timeout"><code>open_timeout</code></a></p> </li>
<li> <p><a href="http#attribute-i-read_timeout"><code>read_timeout</code></a></p> </li>
<li> <p><a href="http#attribute-i-ssl_timeout"><code>ssl_timeout</code></a></p> </li>
<li> <p><a href="http#attribute-i-ssl_version"><code>ssl_version</code></a></p> </li>
<li> <p><code>use_ssl</code> (calls <a href="http#method-i-use_ssl-3D"><code>use_ssl=</code></a>)</p> </li>
<li> <p><a href="http#attribute-i-verify_callback"><code>verify_callback</code></a></p> </li>
<li> <p><a href="http#attribute-i-verify_depth"><code>verify_depth</code></a></p> </li>
<li> <p><a href="http#attribute-i-verify_mode"><code>verify_mode</code></a></p> </li>
<li> <p><a href="http#attribute-i-write_timeout"><code>write_timeout</code></a></p> </li>
</ul> <p>Note: If <code>port</code> is <code>nil</code> and <code>opts[:use_ssl]</code> is a truthy value, the value passed to <code>new</code> is <a href="http#method-c-https_default_port"><code>Net::HTTP.https_default_port</code></a>, not <code>port</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-version_1_2"> <span class="method-name">version_1_2</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="version_1_2-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 736
def HTTP.version_1_2
  true
end</pre> </div> <p>Returns <code>true</code>; retained for compatibility.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-version_1_2-3F"> <span class="method-name">version_1_2?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="version_1_2-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 741
def HTTP.version_1_2?
  true
end</pre> </div> <p>Returns <code>true</code>; retained for compatibility.</p>  </div> <div class="aliases"> Also aliased as: <a href="http#method-c-is_version_1_2-3F">is_version_1_2?</a> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-active-3F"> <span class="method-name">active?</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-started-3F">started?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-continue_timeout-3D"> <span class="method-name">continue_timeout=</span><span class="method-args">(sec)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="continue_timeout-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1380
def continue_timeout=(sec)
  @socket.continue_timeout = sec if @socket
  @continue_timeout = sec
end</pre> </div> <p>Sets the continue timeout value, which is the number of seconds to wait for an expected 100 Continue response. If the HTTP object does not receive a response in this many seconds it sends the request body.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-copy"> <span class="method-name">copy</span><span class="method-args">(path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="copy-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2123
def copy(path, initheader = nil)
  request(Copy.new(path, initheader))
end</pre> </div> <p>Sends a COPY request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/copy"><code>Net::HTTP::Copy</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.copy('/todos/1')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(path, initheader = {'Depth' =&gt; 'Infinity'})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2097
def delete(path, initheader = {'Depth' =&gt; 'Infinity'})
  request(Delete.new(path, initheader))
end</pre> </div> <p>Sends a DELETE request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/delete"><code>Net::HTTP::Delete</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.delete('/todos/1')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-finish"> <span class="method-name">finish</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="finish-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1708
def finish
  raise IOError, 'HTTP session not yet started' unless started?
  do_finish
end</pre> </div> <p>Finishes the HTTP session:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.start
http.started? # =&gt; true
http.finish   # =&gt; nil
http.started? # =&gt; false
</pre> <p>Raises <a href="../ioerror.html"><code>IOError</code></a> if not in a session.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-get"> <span class="method-callseq"> get(path, initheader = nil) {|res| ... } </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="get-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1914
def get(path, initheader = nil, dest = nil, &amp;block) # :yield: +body_segment+
  res = nil

  request(Get.new(path, initheader)) {|r|
    r.read_body dest, &amp;block
    res = r
  }
  res
end</pre> </div> <p>Sends a GET request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/get"><code>Net::HTTP::Get</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <p>With a block given, calls the block with the response body:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.get('/todos/1') do |res|
  p res
end # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
</pre> <p>With no block given, simply returns the response object:</p> <pre class="ruby" data-language="ruby">http.get('/') # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>Related:</p> <ul>
<li> <p><a href="http/get"><code>Net::HTTP::Get</code></a>: request class for HTTP method GET.</p> </li>
<li> <p><a href="http#method-c-get"><code>Net::HTTP.get</code></a>: sends GET request, returns response body.</p> </li>
</ul>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-get2"> <span class="method-name">get2</span><span class="method-args">(path, initheader = nil)</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-request_get">request_get</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-head"> <span class="method-name">head</span><span class="method-args">(path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="head-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1938
def head(path, initheader = nil)
  request(Head.new(path, initheader))
end</pre> </div> <p>Sends a HEAD request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/head"><code>Net::HTTP::Head</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>:</p> <pre class="ruby" data-language="ruby">res = http.head('/todos/1') # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
res.body                    # =&gt; nil
res.to_hash.take(3)
# =&gt;
[["date", ["Wed, 15 Feb 2023 15:25:42 GMT"]],
 ["content-type", ["application/json; charset=utf-8"]],
 ["connection", ["close"]]]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-head2"> <span class="method-name">head2</span><span class="method-args">(path, initheader = nil, &amp;block)</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-request_head">request_head</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1135
def inspect
  "#&lt;#{self.class} #{@address}:#{@port} open=#{started?}&gt;"
end</pre> </div> <p>Returns a string representation of <code>self</code>:</p> <pre class="ruby" data-language="ruby">Net::HTTP.new(hostname).inspect
# =&gt; "#&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=false&gt;"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ipaddr"> <span class="method-name">ipaddr</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ipaddr-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1274
def ipaddr
  started? ?  @socket.io.peeraddr[3] : @ipaddr
end</pre> </div> <p>Returns the IP address for the connection.</p> <p>If the session has not been started, returns the value set by <a href="http#method-i-ipaddr-3D"><code>ipaddr=</code></a>, or <code>nil</code> if it has not been set:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.ipaddr # =&gt; nil
http.ipaddr = '172.67.155.76'
http.ipaddr # =&gt; "172.67.155.76"
</pre> <p>If the session has been started, returns the IP address from the socket:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.start
http.ipaddr # =&gt; "172.67.155.76"
http.finish
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ipaddr-3D"> <span class="method-name">ipaddr=</span><span class="method-args">(addr)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ipaddr-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1286
def ipaddr=(addr)
  raise IOError, "ipaddr value changed, but session already started" if started?
  @ipaddr = addr
end</pre> </div> <p>Sets the IP address for the connection:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.ipaddr # =&gt; nil
http.ipaddr = '172.67.155.76'
http.ipaddr # =&gt; "172.67.155.76"
</pre> <p>The IP address may not be set if the session has been started.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lock"> <span class="method-name">lock</span><span class="method-args">(path, body, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lock-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2043
def lock(path, body, initheader = nil)
  request(Lock.new(path, initheader), body)
end</pre> </div> <p>Sends a LOCK request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/lock"><code>Net::HTTP::Lock</code></a> object created from string <code>path</code>, string <code>body</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.lock('/todos/1', data)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-max_retries-3D"> <span class="method-name">max_retries=</span><span class="method-args">(retries)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="max_retries-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1320
def max_retries=(retries)
  retries = retries.to_int
  if retries &lt; 0
    raise ArgumentError, 'max_retries should be non-negative integer number'
  end
  @max_retries = retries
end</pre> </div> <p>Sets the maximum number of times to retry an idempotent request in case of Net::ReadTimeout, <a href="../ioerror.html"><code>IOError</code></a>, <a href="../eoferror.html"><code>EOFError</code></a>, Errno::ECONNRESET, Errno::ECONNABORTED, Errno::EPIPE, <a href="../openssl/ssl/sslerror.html"><code>OpenSSL::SSL::SSLError</code></a>, <a href="../timeout/error.html"><code>Timeout::Error</code></a>. The initial value is 1.</p> <p>Argument <code>retries</code> must be a non-negative numeric value:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.max_retries = 2   # =&gt; 2
http.max_retries       # =&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mkcol"> <span class="method-name">mkcol</span><span class="method-args">(path, body = nil, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mkcol-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2137
def mkcol(path, body = nil, initheader = nil)
  request(Mkcol.new(path, initheader), body)
end</pre> </div> <p>Sends a MKCOL request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/mkcol"><code>Net::HTTP::Mkcol</code></a> object created from string <code>path</code>, string <code>body</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http.mkcol('/todos/1', data)
http = Net::HTTP.new(hostname)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-move"> <span class="method-name">move</span><span class="method-args">(path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="move-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2110
def move(path, initheader = nil)
  request(Move.new(path, initheader))
end</pre> </div> <p>Sends a MOVE request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/move"><code>Net::HTTP::Move</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.move('/todos/1')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-options"> <span class="method-name">options</span><span class="method-args">(path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="options-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2070
def options(path, initheader = nil)
  request(Options.new(path, initheader))
end</pre> </div> <p>Sends an <a href="http/options"><code>Options</code></a> request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/options"><code>Net::HTTP::Options</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.options('/')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-patch"> <span class="method-callseq"> patch(path, data, initheader = nil) {|res| ... } </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="patch-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2001
def patch(path, data, initheader = nil, dest = nil, &amp;block) # :yield: +body_segment+
  send_entity(path, data, initheader, dest, Patch, &amp;block)
end</pre> </div> <p>Sends a PATCH request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/patch"><code>Net::HTTP::Patch</code></a> object created from string <code>path</code>, string <code>data</code>, and initial headers hash <code>initheader</code>.</p> <p>With a block given, calls the block with the response body:</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.patch('/todos/1', data) do |res|
  p res
end # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false,\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\"\n}"
</pre> <p>With no block given, simply returns the response object:</p> <pre class="ruby" data-language="ruby">http.patch('/todos/1', data) # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-peer_cert"> <span class="method-name">peer_cert</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="peer_cert-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1537
def peer_cert
  if not use_ssl? or not @socket
    return nil
  end
  @socket.io.peer_cert
end</pre> </div> <p>Returns the X509 certificate chain (an array of strings) for the session’s socket peer, or <code>nil</code> if none.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-post"> <span class="method-callseq"> post(path, data, initheader = nil) {|res| ... } </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="post-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1972
def post(path, data, initheader = nil, dest = nil, &amp;block) # :yield: +body_segment+
  send_entity(path, data, initheader, dest, Post, &amp;block)
end</pre> </div> <p>Sends a POST request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/post"><code>Net::HTTP::Post</code></a> object created from string <code>path</code>, string <code>data</code>, and initial headers hash <code>initheader</code>.</p> <p>With a block given, calls the block with the response body:</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.post('/todos', data) do |res|
  p res
end # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"{\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\",\n  \"id\": 201\n}"
</pre> <p>With no block given, simply returns the response object:</p> <pre class="ruby" data-language="ruby">http.post('/todos', data) # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre> <p>Related:</p> <ul>
<li> <p><a href="http/post"><code>Net::HTTP::Post</code></a>: request class for HTTP method POST.</p> </li>
<li> <p><a href="http#method-c-post"><code>Net::HTTP.post</code></a>: sends POST request, returns response body.</p> </li>
</ul>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-post2"> <span class="method-name">post2</span><span class="method-args">(path, data, initheader = nil)</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-request_post">request_post</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-propfind"> <span class="method-name">propfind</span><span class="method-args">(path, body = nil, initheader = {'Depth' =&gt; '0'})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="propfind-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2084
def propfind(path, body = nil, initheader = {'Depth' =&gt; '0'})
  request(Propfind.new(path, initheader), body)
end</pre> </div> <p>Sends a PROPFIND request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/propfind"><code>Net::HTTP::Propfind</code></a> object created from string <code>path</code>, string <code>body</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.propfind('/todos/1', data)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proppatch"> <span class="method-name">proppatch</span><span class="method-args">(path, body, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proppatch-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2029
def proppatch(path, body, initheader = nil)
  request(Proppatch.new(path, initheader), body)
end</pre> </div> <p>Sends a PROPPATCH request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/proppatch"><code>Net::HTTP::Proppatch</code></a> object created from string <code>path</code>, string <code>body</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.proppatch('/todos/1', data)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy-3F"> <span class="method-name">proxy?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1785
def proxy?
  !!(@proxy_from_env ? proxy_uri : @proxy_address)
end</pre> </div> <p>Returns <code>true</code> if a proxy server is defined, <code>false</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy_address"> <span class="method-name">proxy_address</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_address-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1807
def proxy_address
  if @proxy_from_env then
    proxy_uri&amp;.hostname
  else
    @proxy_address
  end
end</pre> </div> <p>Returns the address of the proxy server, if defined, <code>nil</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-proxyaddr">proxyaddr</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy_from_env-3F"> <span class="method-name">proxy_from_env?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_from_env-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1792
def proxy_from_env?
  @proxy_from_env
end</pre> </div> <p>Returns <code>true</code> if the proxy server is defined in the environment, <code>false</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy_pass"> <span class="method-name">proxy_pass</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_pass-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1838
def proxy_pass
  if @proxy_from_env
    pass = proxy_uri&amp;.password
    unescape(pass) if pass
  else
    @proxy_pass
  end
end</pre> </div> <p>Returns the password of the proxy server, if defined, <code>nil</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy_port"> <span class="method-name">proxy_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1817
def proxy_port
  if @proxy_from_env then
    proxy_uri&amp;.port
  else
    @proxy_port
  end
end</pre> </div> <p>Returns the port number of the proxy server, if defined, <code>nil</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-proxyport">proxyport</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-proxy_user"> <span class="method-name">proxy_user</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="proxy_user-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1827
def proxy_user
  if @proxy_from_env
    user = proxy_uri&amp;.user
    unescape(user) if user
  else
    @proxy_user
  end
end</pre> </div> <p>Returns the user name of the proxy server, if defined, <code>nil</code> otherwise; see <a href="http#class-Net::HTTP-label-Proxy+Server">Proxy Server</a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-proxyaddr"> <span class="method-name">proxyaddr</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-proxy_address">proxy_address</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-proxyport"> <span class="method-name">proxyport</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-proxy_port">proxy_port</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-put"> <span class="method-name">put</span><span class="method-args">(path, data, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="put-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2015
def put(path, data, initheader = nil)
  request(Put.new(path, initheader), data)
end</pre> </div> <p>Sends a PUT request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/put"><code>Net::HTTP::Put</code></a> object created from string <code>path</code>, string <code>data</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.put('/todos/1', data) # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-read_timeout-3D"> <span class="method-name">read_timeout=</span><span class="method-args">(sec)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="read_timeout-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1343
def read_timeout=(sec)
  @socket.read_timeout = sec if @socket
  @read_timeout = sec
end</pre> </div> <p>Sets the read timeout, in seconds, for <code>self</code> to integer <code>sec</code>; the initial value is 60.</p> <p>Argument <code>sec</code> must be a non-negative numeric value:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.read_timeout # =&gt; 60
http.get('/todos/1') # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
http.read_timeout = 0
http.get('/todos/1') # Raises Net::ReadTimeout.
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-request"> <span class="method-name">request</span><span class="method-args">(req, body = nil) { |response| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="request-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2295
def request(req, body = nil, &amp;block)  # :yield: +response+
  unless started?
    start {
      req['connection'] ||= 'close'
      return request(req, body, &amp;block)
    }
  end
  if proxy_user()
    req.proxy_basic_auth proxy_user(), proxy_pass() unless use_ssl?
  end
  req.set_body_internal body
  res = transport_request(req, &amp;block)
  if sspi_auth?(res)
    sspi_auth(req)
    res = transport_request(req, &amp;block)
  end
  res
end</pre> </div> <p>Sends the given request <code>req</code> to the server; forms the response into a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> <p>The given <code>req</code> must be an instance of a <a href="httprequest#class-Net::HTTPRequest-label-Request+Subclasses">subclass of Net::HTTPRequest</a>. Argument <code>body</code> should be given only if needed for the request.</p> <p>With no block given, returns the response object:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)

req = Net::HTTP::Get.new('/todos/1')
http.request(req)
# =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;

req = Net::HTTP::Post.new('/todos')
http.request(req, 'xyzzy')
# =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre> <p>With a block given, calls the block with the response and returns the response:</p> <pre class="ruby" data-language="ruby">req = Net::HTTP::Get.new('/todos/1')
http.request(req) do |res|
  p res
end # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;Net::HTTPOK 200 OK readbody=false&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-request_get"> <span class="method-name">request_get</span><span class="method-args">(path, initheader = nil) { |response| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="request_get-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2176
def request_get(path, initheader = nil, &amp;block) # :yield: +response+
  request(Get.new(path, initheader), &amp;block)
end</pre> </div> <p>Sends a GET request to the server; forms the response into a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> <p>The request is based on the <a href="http/get"><code>Net::HTTP::Get</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <p>With no block given, returns the response object:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.request_get('/todos') # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>With a block given, calls the block with the response object and returns the response object:</p> <pre class="ruby" data-language="ruby">http.request_get('/todos') do |res|
  p res
end # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;Net::HTTPOK 200 OK readbody=false&gt;
</pre>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-get2">get2</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-request_head"> <span class="method-name">request_head</span><span class="method-args">(path, initheader = nil, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="request_head-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2189
def request_head(path, initheader = nil, &amp;block)
  request(Head.new(path, initheader), &amp;block)
end</pre> </div> <p>Sends a HEAD request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/head"><code>Net::HTTP::Head</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.head('/todos/1') # =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
</pre>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-head2">head2</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-request_post"> <span class="method-name">request_post</span><span class="method-args">(path, data, initheader = nil) { |response| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="request_post-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2216
def request_post(path, data, initheader = nil, &amp;block) # :yield: +response+
  request Post.new(path, initheader), data, &amp;block
end</pre> </div> <p>Sends a POST request to the server; forms the response into a <a href="httpresponse"><code>Net::HTTPResponse</code></a> object.</p> <p>The request is based on the <a href="http/post"><code>Net::HTTP::Post</code></a> object created from string <code>path</code>, string <code>data</code>, and initial headers hash <code>initheader</code>.</p> <p>With no block given, returns the response object:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.post('/todos', 'xyzzy')
# =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre> <p>With a block given, calls the block with the response body and returns the response object:</p> <pre class="ruby" data-language="ruby">http.post('/todos', 'xyzzy') do |res|
  p res
end # =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"{\n  \"xyzzy\": \"\",\n  \"id\": 201\n}"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-post2">post2</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-response_body_encoding-3D"> <span class="method-name">response_body_encoding=</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="response_body_encoding-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1229
def response_body_encoding=(value)
  value = Encoding.find(value) if value.is_a?(String)
  @response_body_encoding = value
end</pre> </div> <p>Sets the encoding to be used for the response body; returns the encoding.</p> <p>The given <code>value</code> may be:</p> <ul>
<li> <p>An <a href="../encoding.html"><code>Encoding</code></a> object.</p> </li>
<li> <p>The name of an encoding.</p> </li>
<li> <p>An alias for an encoding name.</p> </li>
</ul> <p>See <a href="../encoding.html"><code>Encoding</code></a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.response_body_encoding = Encoding::US_ASCII # =&gt; #&lt;Encoding:US-ASCII&gt;
http.response_body_encoding = 'US-ASCII'         # =&gt; "US-ASCII"
http.response_body_encoding = 'ASCII'            # =&gt; "ASCII"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-send_request"> <span class="method-name">send_request</span><span class="method-args">(name, path, data = nil, header = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="send_request-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2259
def send_request(name, path, data = nil, header = nil)
  has_response_body = name != 'HEAD'
  r = HTTPGenericRequest.new(name,(data ? true : false),has_response_body,path,header)
  request r, data
end</pre> </div> <p>Sends an HTTP request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="httprequest"><code>Net::HTTPRequest</code></a> object created from string <code>path</code>, string <code>data</code>, and initial headers hash <code>header</code>. That object is an instance of the <a href="httprequest#class-Net::HTTPRequest-label-Request+Subclasses">subclass of Net::HTTPRequest</a>, that corresponds to the given uppercase string <code>name</code>, which must be an <a href="https://en.wikipedia.org/wiki/HTTP#Request_methods">HTTP request method</a> or a <a href="https://en.wikipedia.org/wiki/WebDAV#Implementation">WebDAV request method</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.send_request('GET', '/todos/1')
# =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
http.send_request('POST', '/todos', 'xyzzy')
# =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_debug_output"> <span class="method-name">set_debug_output</span><span class="method-args">(output)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="set_debug_output-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1188
def set_debug_output(output)
  warn 'Net::HTTP#set_debug_output called after HTTP started', uplevel: 1 if started?
  @debug_output = output
end</pre> </div> <p><strong>WARNING</strong> This method opens a serious security hole. Never use this method in production code.</p> <p>Sets the output stream for debugging:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
File.open('t.tmp', 'w') do |file|
  http.set_debug_output(file)
  http.start
  http.get('/nosuch/1')
  http.finish
end
puts File.read('t.tmp')
</pre> <p>Output:</p> <pre>opening connection to jsonplaceholder.typicode.com:80...
opened
&lt;- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
-&gt; "HTTP/1.1 404 Not Found\r\n"
-&gt; "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
-&gt; "Content-Type: application/json; charset=utf-8\r\n"
-&gt; "Content-Length: 2\r\n"
-&gt; "Connection: keep-alive\r\n"
-&gt; "X-Powered-By: Express\r\n"
-&gt; "X-Ratelimit-Limit: 1000\r\n"
-&gt; "X-Ratelimit-Remaining: 999\r\n"
-&gt; "X-Ratelimit-Reset: 1670879660\r\n"
-&gt; "Vary: Origin, Accept-Encoding\r\n"
-&gt; "Access-Control-Allow-Credentials: true\r\n"
-&gt; "Cache-Control: max-age=43200\r\n"
-&gt; "Pragma: no-cache\r\n"
-&gt; "Expires: -1\r\n"
-&gt; "X-Content-Type-Options: nosniff\r\n"
-&gt; "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
-&gt; "Via: 1.1 vegur\r\n"
-&gt; "CF-Cache-Status: MISS\r\n"
-&gt; "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
-&gt; "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
-&gt; "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
-&gt; "Server: cloudflare\r\n"
-&gt; "CF-RAY: 778977dc484ce591-DFW\r\n"
-&gt; "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
-&gt; "\r\n"
reading 2 bytes...
-&gt; "{}"
read 2 bytes
Conn keep-alive</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-start"> <span class="method-name">start</span><span class="method-args">() { |http| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1565
def start  # :yield: http
  raise IOError, 'HTTP session already opened' if @started
  if block_given?
    begin
      do_start
      return yield(self)
    ensure
      do_finish
    end
  end
  do_start
  self
end</pre> </div> <p>Starts an HTTP session.</p> <p>Without a block, returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=false&gt;
http.start
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=true&gt;
http.started? # =&gt; true
http.finish
</pre> <p>With a block, calls the block with <code>self</code>, finishes the session when the block exits, and returns the block’s value:</p> <pre class="ruby" data-language="ruby">http.start do |http|
  http
end
# =&gt; #&lt;Net::HTTP jsonplaceholder.typicode.com:80 open=false&gt;
http.started? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-started-3F"> <span class="method-name">started?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="started-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1413
def started?
  @started
end</pre> </div> <p>Returns <code>true</code> if the HTTP session has been started:</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.started? # =&gt; false
http.start
http.started? # =&gt; true
http.finish # =&gt; nil
http.started? # =&gt; false

Net::HTTP.start(hostname) do |http|
  http.started?
end # =&gt; true
http.started? # =&gt; false
</pre>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-active-3F">active?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-trace"> <span class="method-name">trace</span><span class="method-args">(path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="trace-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2150
def trace(path, initheader = nil)
  request(Trace.new(path, initheader))
end</pre> </div> <p>Sends a TRACE request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/trace"><code>Net::HTTP::Trace</code></a> object created from string <code>path</code> and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">http = Net::HTTP.new(hostname)
http.trace('/todos/1')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unlock"> <span class="method-name">unlock</span><span class="method-args">(path, body, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unlock-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2057
def unlock(path, body, initheader = nil)
  request(Unlock.new(path, initheader), body)
end</pre> </div> <p>Sends an UNLOCK request to the server; returns an instance of a subclass of <a href="httpresponse"><code>Net::HTTPResponse</code></a>.</p> <p>The request is based on the <a href="http/unlock"><code>Net::HTTP::Unlock</code></a> object created from string <code>path</code>, string <code>body</code>, and initial headers hash <code>initheader</code>.</p> <pre class="ruby" data-language="ruby">data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
http = Net::HTTP.new(hostname)
http.unlock('/todos/1', data)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-use_ssl-3D"> <span class="method-name">use_ssl=</span><span class="method-args">(flag)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="use_ssl-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1435
def use_ssl=(flag)
  flag = flag ? true : false
  if started? and @use_ssl != flag
    raise IOError, "use_ssl value changed, but session already started"
  end
  @use_ssl = flag
end</pre> </div> <p>Sets whether a new session is to use <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>:</p> <p>Raises <a href="../ioerror.html"><code>IOError</code></a> if attempting to change during a session.</p> <p>Raises <a href="../openssl/ssl/sslerror.html"><code>OpenSSL::SSL::SSLError</code></a> if the port is not an HTTPS port.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-use_ssl-3F"> <span class="method-name">use_ssl?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="use_ssl-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1425
def use_ssl?
  @use_ssl
end</pre> </div> <p>Returns <code>true</code> if <code>self</code> uses SSL, <code>false</code> otherwise. See <a href="http#method-i-use_ssl-3D"><code>Net::HTTP#use_ssl=</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_timeout-3D"> <span class="method-name">write_timeout=</span><span class="method-args">(sec)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_timeout-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1367
def write_timeout=(sec)
  @socket.write_timeout = sec if @socket
  @write_timeout = sec
end</pre> </div> <p>Sets the write timeout, in seconds, for <code>self</code> to integer <code>sec</code>; the initial value is 60.</p> <p>Argument <code>sec</code> must be a non-negative numeric value:</p> <pre class="ruby" data-language="ruby">_uri = uri.dup
_uri.path = '/posts'
body = 'bar' * 200000
data = &lt;&lt;EOF
{"title": "foo", "body": "#{body}", "userId": "1"}
EOF
headers = {'content-type': 'application/json'}
http = Net::HTTP.new(hostname)
http.write_timeout # =&gt; 60
http.post(_uri.path, data, headers)
# =&gt; #&lt;Net::HTTPCreated 201 Created readbody=true&gt;
http.write_timeout = 0
http.post(_uri.path, data, headers) # Raises Net::WriteTimeout.
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-D"> <span class="method-name">D</span><span class="method-args">(msg)</span> </div> </div>  <div class="aliases"> Alias for: <a href="http#method-i-debug">debug</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-addr_port"> <span class="method-name">addr_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="addr_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2464
def addr_port
  addr = address
  addr = "[#{addr}]" if addr.include?(":")
  default_port = use_ssl? ? HTTP.https_default_port : HTTP.http_default_port
  default_port == port ? addr : "#{addr}:#{port}"
end</pre> </div> <p>utils</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-begin_transport"> <span class="method-name">begin_transport</span><span class="method-args">(req)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="begin_transport-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2381
def begin_transport(req)
  if @socket.closed?
    connect
  elsif @last_communicated
    if @last_communicated + @keep_alive_timeout &lt; Process.clock_gettime(Process::CLOCK_MONOTONIC)
      debug 'Conn close because of keep_alive_timeout'
      @socket.close
      connect
    elsif @socket.io.to_io.wait_readable(0) &amp;&amp; @socket.eof?
      debug "Conn close because of EOF"
      @socket.close
      connect
    end
  end

  if not req.response_body_permitted? and @close_on_empty_response
    req['connection'] ||= 'close'
  end

  req.update_uri address, port, use_ssl?
  req['host'] ||= addr_port()
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-connect"> <span class="method-name">connect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="connect-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1585
def connect
  if use_ssl?
    # reference early to load OpenSSL before connecting,
    # as OpenSSL may take time to load.
    @ssl_context = OpenSSL::SSL::SSLContext.new
  end

  if proxy? then
    conn_addr = proxy_address
    conn_port = proxy_port
  else
    conn_addr = conn_address
    conn_port = port
  end

  debug "opening connection to #{conn_addr}:#{conn_port}..."
  s = Timeout.timeout(@open_timeout, Net::OpenTimeout) {
    begin
      TCPSocket.open(conn_addr, conn_port, @local_host, @local_port)
    rescue =&gt; e
      raise e, "Failed to open TCP connection to " +
        "#{conn_addr}:#{conn_port} (#{e.message})"
    end
  }
  s.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1)
  debug "opened"
  if use_ssl?
    if proxy?
      plain_sock = BufferedIO.new(s, read_timeout: @read_timeout,
                                  write_timeout: @write_timeout,
                                  continue_timeout: @continue_timeout,
                                  debug_output: @debug_output)
      buf = +"CONNECT #{conn_address}:#{@port} HTTP/#{HTTPVersion}\r\n" \
        "Host: #{@address}:#{@port}\r\n"
      if proxy_user
        credential = ["#{proxy_user}:#{proxy_pass}"].pack('m0')
        buf &lt;&lt; "Proxy-Authorization: Basic #{credential}\r\n"
      end
      buf &lt;&lt; "\r\n"
      plain_sock.write(buf)
      HTTPResponse.read_new(plain_sock).value
      # assuming nothing left in buffers after successful CONNECT response
    end

    ssl_parameters = Hash.new
    iv_list = instance_variables
    SSL_IVNAMES.each_with_index do |ivname, i|
      if iv_list.include?(ivname)
        value = instance_variable_get(ivname)
        unless value.nil?
          ssl_parameters[SSL_ATTRIBUTES[i]] = value
        end
      end
    end
    @ssl_context.set_params(ssl_parameters)
    unless @ssl_context.session_cache_mode.nil? # a dummy method on JRuby
      @ssl_context.session_cache_mode =
          OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT |
              OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_STORE
    end
    if @ssl_context.respond_to?(:session_new_cb) # not implemented under JRuby
      @ssl_context.session_new_cb = proc {|sock, sess| @ssl_session = sess }
    end

    # Still do the post_connection_check below even if connecting
    # to IP address
    verify_hostname = @ssl_context.verify_hostname

    # Server Name Indication (SNI) RFC 3546/6066
    case @address
    when Resolv::IPv4::Regex, Resolv::IPv6::Regex
      # don't set SNI, as IP addresses in SNI is not valid
      # per RFC 6066, section 3.

      # Avoid openssl warning
      @ssl_context.verify_hostname = false
    else
      ssl_host_address = @address
    end

    debug "starting SSL for #{conn_addr}:#{conn_port}..."
    s = OpenSSL::SSL::SSLSocket.new(s, @ssl_context)
    s.sync_close = true
    s.hostname = ssl_host_address if s.respond_to?(:hostname=) &amp;&amp; ssl_host_address

    if @ssl_session and
       Process.clock_gettime(Process::CLOCK_REALTIME) &lt; @ssl_session.time.to_f + @ssl_session.timeout
      s.session = @ssl_session
    end
    ssl_socket_connect(s, @open_timeout)
    if (@ssl_context.verify_mode != OpenSSL::SSL::VERIFY_NONE) &amp;&amp; verify_hostname
      s.post_connection_check(@address)
    end
    debug "SSL established, protocol: #{s.ssl_version}, cipher: #{s.cipher[0]}"
  end
  @socket = BufferedIO.new(s, read_timeout: @read_timeout,
                           write_timeout: @write_timeout,
                           continue_timeout: @continue_timeout,
                           debug_output: @debug_output)
  @last_communicated = nil
  on_connect
rescue =&gt; exception
  if s
    debug "Conn close because of connect error #{exception}"
    s.close
  end
  raise
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-debug"> <span class="method-name">debug</span><span class="method-args">(msg)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="debug-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2472
def debug(msg)
  return unless @debug_output
  @debug_output &lt;&lt; msg
  @debug_output &lt;&lt; "\n"
end</pre> </div> <p>Adds a message to debugging output</p>  </div> <div class="aliases"> Also aliased as: <a href="http#method-i-D">D</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-do_finish"> <span class="method-name">do_finish</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="do_finish-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1713
def do_finish
  @started = false
  @socket.close if @socket
  @socket = nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-do_start"> <span class="method-name">do_start</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="do_start-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1579
def do_start
  connect
  @started = true
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-edit_path"> <span class="method-name">edit_path</span><span class="method-args">(path)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="edit_path-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1867
def edit_path(path)
  if proxy?
    if path.start_with?("ftp://") || use_ssl?
      path
    else
      "http://#{addr_port}#{path}"
    end
  else
    path
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-end_transport"> <span class="method-name">end_transport</span><span class="method-args">(req, res)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="end_transport-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2404
def end_transport(req, res)
  @curr_http_version = res.http_version
  @last_communicated = nil
  if @socket.closed?
    debug 'Conn socket closed'
  elsif not res.body and @close_on_empty_response
    debug 'Conn close'
    @socket.close
  elsif keep_alive?(req, res)
    debug 'Conn keep-alive'
    @last_communicated = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  else
    debug 'Conn close'
    @socket.close
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-keep_alive-3F"> <span class="method-name">keep_alive?</span><span class="method-args">(req, res)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="keep_alive-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2421
def keep_alive?(req, res)
  return false if req.connection_close?
  if @curr_http_version &lt;= '1.0'
    res.connection_keep_alive?
  else   # HTTP/1.1 or later
    not res.connection_close?
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-on_connect"> <span class="method-name">on_connect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="on_connect-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1695
def on_connect
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-send_entity"> <span class="method-name">send_entity</span><span class="method-args">(path, data, initheader, dest, type, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="send_entity-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2318
def send_entity(path, data, initheader, dest, type, &amp;block)
  res = nil
  request(type.new(path, initheader), data) {|r|
    r.read_body dest, &amp;block
    res = r
  }
  res
end</pre> </div> <p>Executes a request which uses a representation and returns its body.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sspi_auth"> <span class="method-name">sspi_auth</span><span class="method-args">(req)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sspi_auth-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2445
def sspi_auth(req)
  n = Win32::SSPI::NegotiateAuth.new
  req["Proxy-Authorization"] = "Negotiate #{n.get_initial_token}"
  # Some versions of ISA will close the connection if this isn't present.
  req["Connection"] = "Keep-Alive"
  req["Proxy-Connection"] = "Keep-Alive"
  res = transport_request(req)
  authphrase = res["Proxy-Authenticate"]  or return res
  req["Proxy-Authorization"] = "Negotiate #{n.complete_authentication(authphrase)}"
rescue =&gt; err
  raise HTTPAuthenticationError.new('HTTP authentication failed', err)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sspi_auth-3F"> <span class="method-name">sspi_auth?</span><span class="method-args">(res)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sspi_auth-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2430
def sspi_auth?(res)
  return false unless @sspi_enabled
  if res.kind_of?(HTTPProxyAuthenticationRequired) and
      proxy? and res["Proxy-Authenticate"].include?("Negotiate")
    begin
      require 'win32/sspi'
      true
    rescue LoadError
      false
    end
  else
    false
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transport_request"> <span class="method-name">transport_request</span><span class="method-args">(req) { |res| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="transport_request-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 2329
def transport_request(req)
  count = 0
  begin
    begin_transport req
    res = catch(:response) {
      begin
        req.exec @socket, @curr_http_version, edit_path(req.path)
      rescue Errno::EPIPE
        # Failure when writing full request, but we can probably
        # still read the received response.
      end

      begin
        res = HTTPResponse.read_new(@socket)
        res.decode_content = req.decode_content
        res.body_encoding = @response_body_encoding
        res.ignore_eof = @ignore_eof
      end while res.kind_of?(HTTPInformation)

      res.uri = req.uri

      res
    }
    res.reading_body(@socket, req.response_body_permitted?) {
      yield res if block_given?
    }
  rescue Net::OpenTimeout
    raise
  rescue Net::ReadTimeout, IOError, EOFError,
         Errno::ECONNRESET, Errno::ECONNABORTED, Errno::EPIPE, Errno::ETIMEDOUT,
         # avoid a dependency on OpenSSL
         defined?(OpenSSL::SSL) ? OpenSSL::SSL::SSLError : IOError,
         Timeout::Error =&gt; exception
    if count &lt; max_retries &amp;&amp; IDEMPOTENT_METHODS_.include?(req.method)
      count += 1
      @socket.close if @socket
      debug "Conn close because of error #{exception}, and retry"
      retry
    end
    debug "Conn close because of error #{exception}"
    @socket.close if @socket
    raise
  end

  end_transport req, res
  res
rescue =&gt; exception
  debug "Conn close because of error #{exception}"
  @socket.close if @socket
  raise exception
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unescape"> <span class="method-name">unescape</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unescape-source"> <pre class="ruby" data-language="ruby"># File lib/net/http.rb, line 1852
def unescape(value)
  require 'cgi/util'
  CGI.unescape(value)
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
