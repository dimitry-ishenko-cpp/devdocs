<h1 id="class-Array" class="class"> class Array </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <p>An Array is an ordered, integer-indexed collection of objects, called <em>elements</em>. Any object (even another array) may be an array element, and an array can contain objects of different types.</p> <h2 id="class-Array-label-Array+Indexes">Array Indexes</h2> <p>Array indexing starts at 0, as in C or Java.</p> <p>A positive index is an offset from the first element:</p> <ul>
<li> <p>Index 0 indicates the first element.</p> </li>
<li> <p>Index 1 indicates the second element.</p> </li>
<li> <p>…</p> </li>
</ul> <p>A negative index is an offset, backwards, from the end of the array:</p> <ul>
<li> <p>Index -1 indicates the last element.</p> </li>
<li> <p>Index -2 indicates the next-to-last element.</p> </li>
<li> <p>…</p> </li>
</ul> <p>A non-negative index is <em>in range</em> if and only if it is smaller than the size of the array. For a 3-element array:</p> <ul>
<li> <p>Indexes 0 through 2 are in range.</p> </li>
<li> <p>Index 3 is out of range.</p> </li>
</ul> <p>A negative index is <em>in range</em> if and only if its absolute value is not larger than the size of the array. For a 3-element array:</p> <ul>
<li> <p>Indexes -1 through -3 are in range.</p> </li>
<li> <p>Index -4 is out of range.</p> </li>
</ul> <p>Although the effective index into an array is always an integer, some methods (both within and outside of class Array) accept one or more non-integer arguments that are <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible objects</a>.</p> <h2 id="class-Array-label-Creating+Arrays">Creating Arrays</h2> <p>You can create an Array object explicitly with:</p> <ul>
<li> <p>An array literal:</p> <pre class="ruby" data-language="ruby">[1, 'one', :one, [2, 'two', :two]]
</pre> </li>
<li> <p>A array literal:</p> <pre class="ruby" data-language="ruby">%w[foo bar baz] # =&gt; ["foo", "bar", "baz"]
%w[1 % *]       # =&gt; ["1", "%", "*"]
</pre> </li>
<li> <p>A array literal:</p> <pre class="ruby" data-language="ruby">%i[foo bar baz] # =&gt; [:foo, :bar, :baz]
%i[1 % *]       # =&gt; [:"1", :%, :*]
</pre> </li>
<li> <p>Method <a href="kernel.html#method-i-Array"><code>Kernel#Array</code></a>:</p> <pre class="ruby" data-language="ruby">Array(["a", "b"])             # =&gt; ["a", "b"]
Array(1..5)                   # =&gt; [1, 2, 3, 4, 5]
Array(key: :value)            # =&gt; [[:key, :value]]
Array(nil)                    # =&gt; []
Array(1)                      # =&gt; [1]
Array({:a =&gt; "a", :b =&gt; "b"}) # =&gt; [[:a, "a"], [:b, "b"]]
</pre> </li>
<li> <p>Method <a href="array.html#method-c-new"><code>Array.new</code></a>:</p> <pre class="ruby" data-language="ruby">Array.new               # =&gt; []
Array.new(3)            # =&gt; [nil, nil, nil]
Array.new(4) {Hash.new} # =&gt; [{}, {}, {}, {}]
Array.new(3, true)      # =&gt; [true, true, true]
</pre> <p>Note that the last example above populates the array with references to the same object. This is recommended only in cases where that object is a natively immutable object such as a symbol, a numeric, <code>nil</code>, <code>true</code>, or <code>false</code>.</p> <p>Another way to create an array with various objects, using a block; this usage is safe for mutable objects such as hashes, strings or other arrays:</p> <pre class="ruby" data-language="ruby">Array.new(4) {|i| i.to_s } # =&gt; ["0", "1", "2", "3"]
</pre> <p>Here is a way to create a multi-dimensional array:</p> <pre class="ruby" data-language="ruby">Array.new(3) {Array.new(3)}
# =&gt; [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
</pre> </li>
</ul> <p>A number of Ruby methods, both in the core and in the standard library, provide instance method <code>to_a</code>, which converts an object to an array.</p> <ul>
<li> <p><a href="argf.html#method-i-to_a"><code>ARGF#to_a</code></a></p> </li>
<li> <p><a href="array.html#method-i-to_a"><code>Array#to_a</code></a></p> </li>
<li> <p><a href="enumerable.html#method-i-to_a"><code>Enumerable#to_a</code></a></p> </li>
<li> <p><a href="hash.html#method-i-to_a"><code>Hash#to_a</code></a></p> </li>
<li> <p><a href="matchdata.html#method-i-to_a"><code>MatchData#to_a</code></a></p> </li>
<li> <p><a href="nilclass.html#method-i-to_a"><code>NilClass#to_a</code></a></p> </li>
<li> <p><a href="optionparser.html#method-i-to_a"><code>OptionParser#to_a</code></a></p> </li>
<li> <p><a href="range.html#method-i-to_a"><code>Range#to_a</code></a></p> </li>
<li> <p><a href="set.html#method-i-to_a"><code>Set#to_a</code></a></p> </li>
<li> <p><a href="struct.html#method-i-to_a"><code>Struct#to_a</code></a></p> </li>
<li> <p><a href="time.html#method-i-to_a"><code>Time#to_a</code></a></p> </li>
<li> <p><a href="benchmark/tms.html#method-i-to_a"><code>Benchmark::Tms#to_a</code></a></p> </li>
<li> <p><a href="csv/table.html#method-i-to_a"><code>CSV::Table#to_a</code></a></p> </li>
<li> <p><a href="enumerator/lazy.html#method-i-to_a"><code>Enumerator::Lazy#to_a</code></a></p> </li>
<li> <p>Gem::List#to_a</p> </li>
<li> <p><span><code>Gem::NameTuple#to_a</code></span></p> </li>
<li> <p><span><code>Gem::Platform#to_a</code></span></p> </li>
<li> <p><span><code>Gem::RequestSet::Lockfile::Tokenizer#to_a</code></span></p> </li>
<li> <p><span><code>Gem::SourceList#to_a</code></span></p> </li>
<li> <p><a href="openssl/x509/extension.html#method-i-to_a"><code>OpenSSL::X509::Extension#to_a</code></a></p> </li>
<li> <p><a href="openssl/x509/name.html#method-i-to_a"><code>OpenSSL::X509::Name#to_a</code></a></p> </li>
<li> <p>Racc::ISet#to_a</p> </li>
<li> <p><a href="rinda/ringfinger.html#method-i-to_a"><code>Rinda::RingFinger#to_a</code></a></p> </li>
<li> <p><a href="ripper/lexer/elem.html#method-i-to_a"><code>Ripper::Lexer::Elem#to_a</code></a></p> </li>
<li> <p><a href="rubyvm/instructionsequence.html#method-i-to_a"><code>RubyVM::InstructionSequence#to_a</code></a></p> </li>
<li> <p><a href="yaml/dbm.html#method-i-to_a"><code>YAML::DBM#to_a</code></a></p> </li>
</ul> <h2 id="class-Array-label-Example+Usage">Example Usage</h2> <p>In addition to the methods it mixes in through the <a href="enumerable.html"><code>Enumerable</code></a> module, the Array class has proprietary methods for accessing, searching and otherwise manipulating arrays.</p> <p>Some of the more common ones are illustrated below.</p> <h2 id="class-Array-label-Accessing+Elements">Accessing Elements</h2> <p>Elements in an array can be retrieved using the <a href="array.html#method-i-5B-5D"><code>Array#[]</code></a> method. It can take a single integer argument (a numeric index), a pair of arguments (start and length) or a range. Negative indices start counting from the end, with -1 being the last element.</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5, 6]
arr[2]    #=&gt; 3
arr[100]  #=&gt; nil
arr[-3]   #=&gt; 4
arr[2, 3] #=&gt; [3, 4, 5]
arr[1..4] #=&gt; [2, 3, 4, 5]
arr[1..-3] #=&gt; [2, 3, 4]
</pre> <p>Another way to access a particular array element is by using the <a href="array.html#method-i-at"><code>at</code></a> method</p> <pre class="ruby" data-language="ruby">arr.at(0) #=&gt; 1
</pre> <p>The <a href="array.html#method-i-slice"><code>slice</code></a> method works in an identical manner to <a href="array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p> <p>To raise an error for indices outside of the array bounds or else to provide a default value when that happens, you can use <a href="array.html#method-i-fetch"><code>fetch</code></a>.</p> <pre class="ruby" data-language="ruby">arr = ['a', 'b', 'c', 'd', 'e', 'f']
arr.fetch(100) #=&gt; IndexError: index 100 outside of array bounds: -6...6
arr.fetch(100, "oops") #=&gt; "oops"
</pre> <p>The special methods <a href="array.html#method-i-first"><code>first</code></a> and <a href="array.html#method-i-last"><code>last</code></a> will return the first and last elements of an array, respectively.</p> <pre class="ruby" data-language="ruby">arr.first #=&gt; 1
arr.last  #=&gt; 6
</pre> <p>To return the first <code>n</code> elements of an array, use <a href="array.html#method-i-take"><code>take</code></a></p> <pre class="ruby" data-language="ruby">arr.take(3) #=&gt; [1, 2, 3]
</pre> <p><a href="array.html#method-i-drop"><code>drop</code></a> does the opposite of <a href="array.html#method-i-take"><code>take</code></a>, by returning the elements after <code>n</code> elements have been dropped:</p> <pre class="ruby" data-language="ruby">arr.drop(3) #=&gt; [4, 5, 6]
</pre> <h2 id="class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an Array</h2> <p>Arrays keep track of their own length at all times. To query an array about the number of elements it contains, use <a href="array.html#method-i-length"><code>length</code></a>, <a href="array.html#method-i-count"><code>count</code></a> or <a href="array.html#method-i-size"><code>size</code></a>.</p> <pre class="ruby" data-language="ruby">browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
browsers.length #=&gt; 5
browsers.count #=&gt; 5
</pre> <p>To check whether an array contains any elements at all</p> <pre class="ruby" data-language="ruby">browsers.empty? #=&gt; false
</pre> <p>To check whether a particular item is included in the array</p> <pre class="ruby" data-language="ruby">browsers.include?('Konqueror') #=&gt; false
</pre> <h2 id="class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays</h2> <p>Items can be added to the end of an array by using either <a href="array.html#method-i-push"><code>push</code></a> or <a href="array.html#method-i-3C-3C"><code>&lt;&lt;</code></a></p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4]
arr.push(5) #=&gt; [1, 2, 3, 4, 5]
arr &lt;&lt; 6    #=&gt; [1, 2, 3, 4, 5, 6]
</pre> <p><a href="array.html#method-i-unshift"><code>unshift</code></a> will add a new item to the beginning of an array.</p> <pre class="ruby" data-language="ruby">arr.unshift(0) #=&gt; [0, 1, 2, 3, 4, 5, 6]
</pre> <p>With <a href="array.html#method-i-insert"><code>insert</code></a> you can add a new element to an array at any position.</p> <pre class="ruby" data-language="ruby">arr.insert(3, 'apple')  #=&gt; [0, 1, 2, 'apple', 3, 4, 5, 6]
</pre> <p>Using the <a href="array.html#method-i-insert"><code>insert</code></a> method, you can also insert multiple values at once:</p> <pre class="ruby" data-language="ruby">arr.insert(3, 'orange', 'pear', 'grapefruit')
#=&gt; [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
</pre> <h2 id="class-Array-label-Removing+Items+from+an+Array">Removing Items from an Array</h2> <p>The method <a href="array.html#method-i-pop"><code>pop</code></a> removes the last element in an array and returns it:</p> <pre class="ruby" data-language="ruby">arr =  [1, 2, 3, 4, 5, 6]
arr.pop #=&gt; 6
arr #=&gt; [1, 2, 3, 4, 5]
</pre> <p>To retrieve and at the same time remove the first item, use <a href="array.html#method-i-shift"><code>shift</code></a>:</p> <pre class="ruby" data-language="ruby">arr.shift #=&gt; 1
arr #=&gt; [2, 3, 4, 5]
</pre> <p>To delete an element at a particular index:</p> <pre class="ruby" data-language="ruby">arr.delete_at(2) #=&gt; 4
arr #=&gt; [2, 3, 5]
</pre> <p>To delete a particular element anywhere in an array, use <a href="array.html#method-i-delete"><code>delete</code></a>:</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 2, 3]
arr.delete(2) #=&gt; 2
arr #=&gt; [1,3]
</pre> <p>A useful method if you need to remove <code>nil</code> values from an array is <a href="array.html#method-i-compact"><code>compact</code></a>:</p> <pre class="ruby" data-language="ruby">arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
arr.compact  #=&gt; ['foo', 0, 'bar', 7, 'baz']
arr          #=&gt; ['foo', 0, nil, 'bar', 7, 'baz', nil]
arr.compact! #=&gt; ['foo', 0, 'bar', 7, 'baz']
arr          #=&gt; ['foo', 0, 'bar', 7, 'baz']
</pre> <p>Another common need is to remove duplicate elements from an array.</p> <p>It has the non-destructive <a href="array.html#method-i-uniq"><code>uniq</code></a>, and destructive method <a href="array.html#method-i-uniq-21"><code>uniq!</code></a></p> <pre class="ruby" data-language="ruby">arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
arr.uniq #=&gt; [2, 5, 6, 556, 8, 9, 0, 123]
</pre> <h2 id="class-Array-label-Iterating+over+Arrays">Iterating over Arrays</h2> <p>Like all classes that include the <a href="enumerable.html"><code>Enumerable</code></a> module, Array has an each method, which defines what elements should be iterated over and how. In case of Array’s <a href="array.html#method-i-each"><code>each</code></a>, all elements in the Array instance are yielded to the supplied block in sequence.</p> <p>Note that this operation leaves the array unchanged.</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5]
arr.each {|a| print a -= 10, " "}
# prints: -9 -8 -7 -6 -5
#=&gt; [1, 2, 3, 4, 5]
</pre> <p>Another sometimes useful iterator is <a href="array.html#method-i-reverse_each"><code>reverse_each</code></a> which will iterate over the elements in the array in reverse order.</p> <pre class="ruby" data-language="ruby">words = %w[first second third fourth fifth sixth]
str = ""
words.reverse_each {|word| str += "#{word} "}
p str #=&gt; "sixth fifth fourth third second first "
</pre> <p>The <a href="array.html#method-i-map"><code>map</code></a> method can be used to create a new array based on the original array, but with the values modified by the supplied block:</p> <pre class="ruby" data-language="ruby">arr.map {|a| 2*a}     #=&gt; [2, 4, 6, 8, 10]
arr                   #=&gt; [1, 2, 3, 4, 5]
arr.map! {|a| a**2}   #=&gt; [1, 4, 9, 16, 25]
arr                   #=&gt; [1, 4, 9, 16, 25]
</pre> <h2 id="class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an Array</h2> <p>Elements can be selected from an array according to criteria defined in a block. The selection can happen in a destructive or a non-destructive manner. While the destructive operations will modify the array they were called on, the non-destructive methods usually return a new array with the selected elements, but leave the original array unchanged.</p> <h3 id="class-Array-label-Non-destructive+Selection">Non-destructive Selection</h3> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5, 6]
arr.select {|a| a &gt; 3}       #=&gt; [4, 5, 6]
arr.reject {|a| a &lt; 3}       #=&gt; [3, 4, 5, 6]
arr.drop_while {|a| a &lt; 4}   #=&gt; [4, 5, 6]
arr                          #=&gt; [1, 2, 3, 4, 5, 6]
</pre> <h3 id="class-Array-label-Destructive+Selection">Destructive Selection</h3> <p><a href="array.html#method-i-select-21"><code>select!</code></a> and <a href="array.html#method-i-reject-21"><code>reject!</code></a> are the corresponding destructive methods to <a href="array.html#method-i-select"><code>select</code></a> and <a href="array.html#method-i-reject"><code>reject</code></a></p> <p>Similar to <a href="array.html#method-i-select"><code>select</code></a> vs. <a href="array.html#method-i-reject"><code>reject</code></a>, <a href="array.html#method-i-delete_if"><code>delete_if</code></a> and <a href="array.html#method-i-keep_if"><code>keep_if</code></a> have the exact opposite result when supplied with the same block:</p> <pre class="ruby" data-language="ruby">arr.delete_if {|a| a &lt; 4}   #=&gt; [4, 5, 6]
arr                         #=&gt; [4, 5, 6]

arr = [1, 2, 3, 4, 5, 6]
arr.keep_if {|a| a &lt; 4}   #=&gt; [1, 2, 3]
arr                       #=&gt; [1, 2, 3]
</pre> <h2 id="class-Array-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class Array:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p> </li>
</ul> <p>Here, class Array provides methods that are useful for:</p> <ul>
<li> <p><a href="array.html#class-Array-label-Methods+for+Creating+an+Array">Creating an Array</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Fetching">Fetching</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Assigning">Assigning</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Deleting">Deleting</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Combining">Combining</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Converting">Converting</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Other+Methods">And more.…</a></p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</h3> <ul>
<li> <p><a href="array.html#method-c-5B-5D"><code>::[]</code></a>: Returns a new array populated with given objects.</p> </li>
<li> <p><a href="array.html#method-c-new"><code>::new</code></a>: Returns a new array.</p> </li>
<li> <p><a href="array.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new array created from a given object.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Querying">Methods for Querying</h3> <ul>
<li> <p><a href="array.html#method-i-length"><code>length</code></a>, <a href="array.html#method-i-size"><code>size</code></a>: Returns the count of elements.</p> </li>
<li> <p><a href="array.html#method-i-include-3F"><code>include?</code></a>: Returns whether any element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-empty-3F"><code>empty?</code></a>: Returns whether there are no elements.</p> </li>
<li> <p><a href="array.html#method-i-all-3F"><code>all?</code></a>: Returns whether all elements meet a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-any-3F"><code>any?</code></a>: Returns whether any element meets a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-none-3F"><code>none?</code></a>: Returns whether no element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-one-3F"><code>one?</code></a>: Returns whether exactly one element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-count"><code>count</code></a>: Returns the count of elements that meet a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-find_index"><code>find_index</code></a>, <a href="array.html#method-i-index"><code>index</code></a>: Returns the index of the first element that meets a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-rindex"><code>rindex</code></a>: Returns the index of the last element that meets a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns -1, 0, or 1 * as <code>self</code> is less than, equal to, or greater than a given object.</p> </li>
<li> <p><a href="array.html#method-i-3D-3D"><code>==</code></a>: Returns whether each element in <code>self</code> is <code>==</code> to the corresponding element in a given object.</p> </li>
<li> <p><a href="array.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether each element in <code>self</code> is <code>eql?</code> to the corresponding element in a given object.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Fetching">Methods for Fetching</h3> <p>These methods do not modify <code>self</code>.</p> <ul>
<li> <p><a href="array.html#method-i-5B-5D"><code>[]</code></a>: Returns one or more elements.</p> </li>
<li> <p><a href="array.html#method-i-fetch"><code>fetch</code></a>: Returns the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-first"><code>first</code></a>: Returns one or more leading elements.</p> </li>
<li> <p><a href="array.html#method-i-last"><code>last</code></a>: Returns one or more trailing elements.</p> </li>
<li> <p><a href="array.html#method-i-max"><code>max</code></a>: Returns one or more maximum-valued elements, as determined by <code>&lt;=&gt;</code> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-min"><code>min</code></a>: Returns one or more minimum-valued elements, as determined by <code>&lt;=&gt;</code> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-minmax"><code>minmax</code></a>: Returns the minimum-valued and maximum-valued elements, as determined by <code>&lt;=&gt;</code> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-assoc"><code>assoc</code></a>: Returns the first element that is an array whose first element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-rassoc"><code>rassoc</code></a>: Returns the first element that is an array whose second element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-at"><code>at</code></a>: Returns the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-values_at"><code>values_at</code></a>: Returns the elements at given offsets.</p> </li>
<li> <p><a href="array.html#method-i-dig"><code>dig</code></a>: Returns the object in nested objects that is specified by a given index and additional arguments.</p> </li>
<li> <p><a href="array.html#method-i-drop"><code>drop</code></a>: Returns trailing elements as determined by a given index.</p> </li>
<li> <p><a href="array.html#method-i-take"><code>take</code></a>: Returns leading elements as determined by a given index.</p> </li>
<li> <p><a href="array.html#method-i-drop_while"><code>drop_while</code></a>: Returns trailing elements as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-take_while"><code>take_while</code></a>: Returns leading elements as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-slice"><code>slice</code></a>: Returns consecutive elements as determined by a given argument.</p> </li>
<li> <p><a href="array.html#method-i-sort"><code>sort</code></a>: Returns all elements in an order determined by <code>&lt;=&gt;</code> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-reverse"><code>reverse</code></a>: Returns all elements in reverse order.</p> </li>
<li> <p><a href="array.html#method-i-compact"><code>compact</code></a>: Returns an array containing all non-<code>nil</code> elements.</p> </li>
<li> <p><a href="array.html#method-i-select"><code>select</code></a>, <a href="array.html#method-i-filter"><code>filter</code></a>: Returns an array containing elements selected by a given block.</p> </li>
<li> <p><a href="array.html#method-i-uniq"><code>uniq</code></a>: Returns an array containing non-duplicate elements.</p> </li>
<li> <p><a href="array.html#method-i-rotate"><code>rotate</code></a>: Returns all elements with some rotated from one end to the other.</p> </li>
<li> <p><a href="array.html#method-i-bsearch"><code>bsearch</code></a>: Returns an element selected via a binary search as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-bsearch_index"><code>bsearch_index</code></a>: Returns the index of an element selected via a binary search as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-sample"><code>sample</code></a>: Returns one or more random elements.</p> </li>
<li> <p><a href="array.html#method-i-shuffle"><code>shuffle</code></a>: Returns elements in a random order.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Assigning">Methods for Assigning</h3> <p>These methods add, replace, or reorder elements in <code>self</code>.</p> <ul>
<li> <p><a href="array.html#method-i-5B-5D-3D"><code>[]=</code></a>: Assigns specified elements with a given object.</p> </li>
<li> <p><a href="array.html#method-i-push"><code>push</code></a>, <a href="array.html#method-i-append"><code>append</code></a>, <a href="array.html#method-i-3C-3C"><code>&lt;&lt;</code></a>: Appends trailing elements.</p> </li>
<li> <p><a href="array.html#method-i-unshift"><code>unshift</code></a>, <a href="array.html#method-i-prepend"><code>prepend</code></a>: Prepends leading elements.</p> </li>
<li> <p><a href="array.html#method-i-insert"><code>insert</code></a>: Inserts given objects at a given offset; does not replace elements.</p> </li>
<li> <p><a href="array.html#method-i-concat"><code>concat</code></a>: Appends all elements from given arrays.</p> </li>
<li> <p><a href="array.html#method-i-fill"><code>fill</code></a>: Replaces specified elements with specified objects.</p> </li>
<li> <p><a href="array.html#method-i-replace"><code>replace</code></a>: Replaces the content of <code>self</code> with the content of a given array.</p> </li>
<li> <p><a href="array.html#method-i-reverse-21"><code>reverse!</code></a>: Replaces <code>self</code> with its elements reversed.</p> </li>
<li> <p><a href="array.html#method-i-rotate-21"><code>rotate!</code></a>: Replaces <code>self</code> with its elements rotated.</p> </li>
<li> <p><a href="array.html#method-i-shuffle-21"><code>shuffle!</code></a>: Replaces <code>self</code> with its elements in random order.</p> </li>
<li> <p><a href="array.html#method-i-sort-21"><code>sort!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by <code>&lt;=&gt;</code> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-sort_by-21"><code>sort_by!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by a given block.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Deleting">Methods for Deleting</h3> <p>Each of these methods removes elements from <code>self</code>:</p> <ul>
<li> <p><a href="array.html#method-i-pop"><code>pop</code></a>: Removes and returns the last element.</p> </li>
<li> <p><a href="array.html#method-i-shift"><code>shift</code></a>: Removes and returns the first element.</p> </li>
<li> <p><a href="array.html#method-i-compact-21"><code>compact!</code></a>: Removes all <code>nil</code> elements.</p> </li>
<li> <p><a href="array.html#method-i-delete"><code>delete</code></a>: Removes elements equal to a given object.</p> </li>
<li> <p><a href="array.html#method-i-delete_at"><code>delete_at</code></a>: Removes the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-delete_if"><code>delete_if</code></a>: Removes elements specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-keep_if"><code>keep_if</code></a>: Removes elements not specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-reject-21"><code>reject!</code></a>: Removes elements specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-select-21"><code>select!</code></a>, <a href="array.html#method-i-filter-21"><code>filter!</code></a>: Removes elements not specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-slice-21"><code>slice!</code></a>: Removes and returns a sequence of elements.</p> </li>
<li> <p><a href="array.html#method-i-uniq-21"><code>uniq!</code></a>: Removes duplicates.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Combining">Methods for Combining</h3> <ul>
<li> <p><a href="array.html#method-i-26"><code>&amp;</code></a>: Returns an array containing elements found both in <code>self</code> and a given array.</p> </li>
<li> <p><a href="array.html#method-i-intersection"><code>intersection</code></a>: Returns an array containing elements found both in <code>self</code> and in each given array.</p> </li>
<li> <p><a href="array.html#method-i-2B"><code>+</code></a>: Returns an array containing all elements of <code>self</code> followed by all elements of a given array.</p> </li>
<li> <p><a href="array.html#method-i-2D"><code>-</code></a>: Returns an array containing all elements of <code>self</code> that are not found in a given array.</p> </li>
<li> <p><a href="array.html#method-i-7C"><code>|</code></a>: Returns an array containing all elements of <code>self</code> and all elements of a given array, duplicates removed.</p> </li>
<li> <p><a href="array.html#method-i-union"><code>union</code></a>: Returns an array containing all elements of <code>self</code> and all elements of given arrays, duplicates removed.</p> </li>
<li> <p><a href="array.html#method-i-difference"><code>difference</code></a>: Returns an array containing all elements of <code>self</code> that are not found in any of the given arrays..</p> </li>
<li> <p><a href="array.html#method-i-product"><code>product</code></a>: Returns or yields all combinations of elements from <code>self</code> and given arrays.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="array.html#method-i-each"><code>each</code></a>: Passes each element to a given block.</p> </li>
<li> <p><a href="array.html#method-i-reverse_each"><code>reverse_each</code></a>: Passes each element, in reverse order, to a given block.</p> </li>
<li> <p><a href="array.html#method-i-each_index"><code>each_index</code></a>: Passes each element index to a given block.</p> </li>
<li> <p><a href="array.html#method-i-cycle"><code>cycle</code></a>: Calls a given block with each element, then does so again, for a specified number of times, or forever.</p> </li>
<li> <p><a href="array.html#method-i-combination"><code>combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination does not use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-permutation"><code>permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation does not use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-repeated_combination"><code>repeated_combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination may use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-repeated_permutation"><code>repeated_permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation may use the same element more than once.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Converting">Methods for Converting</h3> <ul>
<li> <p><a href="array.html#method-i-map"><code>map</code></a>, <a href="array.html#method-i-collect"><code>collect</code></a>: Returns an array containing the block return-value for each element.</p> </li>
<li> <p><a href="array.html#method-i-map-21"><code>map!</code></a>, <a href="array.html#method-i-collect-21"><code>collect!</code></a>: Replaces each element with a block return-value.</p> </li>
<li> <p><a href="array.html#method-i-flatten"><code>flatten</code></a>: Returns an array that is a recursive flattening of <code>self</code>.</p> </li>
<li> <p><a href="array.html#method-i-flatten-21"><code>flatten!</code></a>: Replaces each nested array in <code>self</code> with the elements from that array.</p> </li>
<li> <p><a href="array.html#method-i-inspect"><code>inspect</code></a>, <a href="array.html#method-i-to_s"><code>to_s</code></a>: Returns a new <a href="string.html"><code>String</code></a> containing the elements.</p> </li>
<li> <p><a href="array.html#method-i-join"><code>join</code></a>: Returns a newsString containing the elements joined by the field separator.</p> </li>
<li> <p><a href="array.html#method-i-to_a"><code>to_a</code></a>: Returns <code>self</code> or a new array containing all elements.</p> </li>
<li> <p><a href="array.html#method-i-to_ary"><code>to_ary</code></a>: Returns <code>self</code>.</p> </li>
<li> <p><a href="array.html#method-i-to_h"><code>to_h</code></a>: Returns a new hash formed from the elements.</p> </li>
<li> <p><a href="array.html#method-i-transpose"><code>transpose</code></a>: Transposes <code>self</code>, which must be an array of arrays.</p> </li>
<li> <p><a href="array.html#method-i-zip"><code>zip</code></a>: Returns a new array of arrays containing <code>self</code> and given arrays; follow the link for details.</p> </li>
</ul> <h3 id="class-Array-label-Other+Methods">Other Methods</h3> <ul>
<li> <p><a href="array.html#method-i-2A"><code>*</code></a>: Returns one of the following:</p> <ul>
<li> <p>With integer argument <code>n</code>, a new array that is the concatenation of <code>n</code> copies of <code>self</code>.</p> </li>
<li> <p>With string argument <code>field_separator</code>, a new string that is equivalent to <code>join(field_separator)</code>.</p> </li>
</ul> </li>
<li> <p><a href="array.html#method-i-abbrev"><code>abbrev</code></a>: Returns a hash of unambiguous abbreviations for elements.</p> </li>
<li> <p><a href="array.html#method-i-pack"><code>pack</code></a>: Packs the elements into a binary sequence.</p> </li>
<li> <p><a href="array.html#method-i-sum"><code>sum</code></a>: Returns a sum of elements according to either <code>+</code> or a given block.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-5B-5D"> <span class="method-name">[]</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        ary_memcpy(ary, 0, argc, argv);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</pre> </div> <p>Returns a new array populated with the given objects.</p> <pre class="ruby" data-language="ruby">Array.[]( 1, 'a', /^A/)  # =&gt; [1, "a", /^A/]
Array[ 1, 'a', /^A/ ]    # =&gt; [1, "a", /^A/]
[ 1, 'a', /^A/ ]         # =&gt; [1, "a", /^A/]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new → new_empty_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(array) → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> new(size) → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> new(size, default_value) → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> new(size) {|index| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        rb_ary_reset(ary);
        assert(ARY_EMBED_P(ary));
        assert(ARY_EMBED_LEN(ary) == 0);
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        return ary;
    }
    rb_scan_args(argc, argv, "02", &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative array size");
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, "array size too big");
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn("block supersedes default value argument");
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre> </div> <p>Returns a new Array.</p> <p>With no block and no arguments, returns a new empty Array object.</p> <p>With no block and a single Array argument <code>array</code>, returns a new Array formed from <code>array</code>:</p> <pre class="ruby" data-language="ruby">a = Array.new([:foo, 'bar', 2])
a.class # =&gt; Array
a # =&gt; [:foo, "bar", 2]
</pre> <p>With no block and a single <a href="integer.html"><code>Integer</code></a> argument <code>size</code>, returns a new Array of the given size whose elements are all <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = Array.new(3)
a # =&gt; [nil, nil, nil]
</pre> <p>With no block and arguments <code>size</code> and <code>default_value</code>, returns an Array of the given size; each element is that same <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">a = Array.new(3, 'x')
a # =&gt; ['x', 'x', 'x']
</pre> <p>With a block and argument <code>size</code>, returns an Array of the given size; the block is called with each successive integer <code>index</code>; the element for that <code>index</code> is the return value from the block:</p> <pre class="ruby" data-language="ruby">a = Array.new(3) {|index| "Element #{index}" }
a # =&gt; ["Element 0", "Element 1", "Element 2"]
</pre> <p>Raises <a href="argumenterror.html"><code>ArgumentError</code></a> if <code>size</code> is negative.</p> <p>With a block and no argument, or a single argument <code>0</code>, ignores the block and returns a new empty Array.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(object) → object, new_array, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</pre> </div> <p>If <code>object</code> is an Array object, returns <code>object</code>.</p> <p>Otherwise if <code>object</code> responds to <code>:to_ary</code>, calls <code>object.to_ary</code> and returns the result.</p> <p>Returns <code>nil</code> if <code>object</code> does not respond to <code>:to_ary</code></p> <p>Raises an exception unless <code>object.to_ary</code> returns an Array object.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-26"> <span class="method-callseq"> array &amp; other_array → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="26-source"> <pre class="c" data-language="c">static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return ary3;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (!rb_ary_includes_by_eql(ary2, v)) continue;
            if (rb_ary_includes_by_eql(ary3, v)) continue;
            rb_ary_push(ary3, v);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = RARRAY_AREF(ary1, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_delete(hash, &amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }

    return ary3;
}</pre> </div> <p>Returns a new Array containing each element found in both <code>array</code> and Array <code>other_array</code>; duplicates are omitted; items are compared using <code>eql?</code> (items must also implement <code>hash</code> correctly):</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3] &amp; [1, 2] # =&gt; [1, 2]
[0, 1, 0, 1] &amp; [0, 1] # =&gt; [0, 1]
</pre> <p>Preserves order from <code>array</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &amp; [3, 2, 1, 0] # =&gt; [0, 1, 2]
</pre> <p>Related: <a href="array.html#method-i-intersection"><code>Array#intersection</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2A"> <span class="method-callseq"> array * n → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> array * string_separator → new_string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="c" data-language="c">static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp;
    const VALUE *ptr;
    long t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_cArray, 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative argument");
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, "argument too big");
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_cArray, len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_CONST_PTR(ary);
    t = RARRAY_LEN(ary);
    if (0 &lt; t) {
        ary_memcpy(ary2, 0, t, ptr);
        while (t &lt;= len/2) {
            ary_memcpy(ary2, t, t, RARRAY_CONST_PTR(ary2));
            t *= 2;
        }
        if (t &lt; len) {
            ary_memcpy(ary2, t, len-t, RARRAY_CONST_PTR(ary2));
        }
    }
  out:
    return ary2;
}</pre> </div> <p>When non-negative argument <a href="integer.html"><code>Integer</code></a> <code>n</code> is given, returns a new Array built by concatenating the <code>n</code> copies of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['x', 'y']
a * 3 # =&gt; ["x", "y", "x", "y", "x", "y"]
</pre> <p>When <a href="string.html"><code>String</code></a> argument <code>string_separator</code> is given, equivalent to <code>array.join(string_separator)</code>:</p> <pre class="ruby" data-language="ruby">[0, [0, 1], {foo: 0}] * ', ' # =&gt; "0, 0, 1, {:foo=&gt;0}"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> array + other_array → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len, xlen, ylen;

    y = to_ary(y);
    xlen = RARRAY_LEN(x);
    ylen = RARRAY_LEN(y);
    len = xlen + ylen;
    z = rb_ary_new2(len);

    ary_memcpy(z, 0, xlen, RARRAY_CONST_PTR(x));
    ary_memcpy(z, xlen, ylen, RARRAY_CONST_PTR(y));
    ARY_SET_LEN(z, len);
    return z;
}</pre> </div> <p>Returns a new Array containing all elements of <code>array</code> followed by all elements of <code>other_array</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1] + [2, 3]
a # =&gt; [0, 1, 2, 3]
</pre> <p>Related: <a href="array.html#method-i-concat"><code>concat</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2D"> <span class="method-callseq"> array - other_array → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    VALUE hash;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary2) == 0) { return ary_make_shared_copy(ary1); }
    ary3 = rb_ary_new();

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN || RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            VALUE elt = rb_ary_elt(ary1, i);
            if (rb_ary_includes_by_eql(ary2, elt)) continue;
            rb_ary_push(ary3, elt);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);
    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (rb_hash_stlike_lookup(hash, RARRAY_AREF(ary1, i), NULL)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }

    return ary3;
}</pre> </div> <p>Returns a new Array containing only those elements from <code>array</code> that are not found in Array <code>other_array</code>; items are compared using <code>eql?</code>; the order from <code>array</code> is preserved:</p> <pre class="ruby" data-language="ruby">[0, 1, 1, 2, 1, 1, 3, 1, 1] - [1] # =&gt; [0, 2, 3]
[0, 1, 2, 3] - [3, 0] # =&gt; [1, 2]
[0, 1, 2] - [4] # =&gt; [0, 1, 2]
</pre> <p>Related: <a href="array.html#method-i-difference"><code>Array#difference</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> array &lt;&lt; object → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    long idx = RARRAY_LEN((ary_verify(ary), ary));
    VALUE target_ary = ary_ensure_room_for_push(ary, 1);
    RARRAY_PTR_USE(ary, ptr, {
        RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
    });
    ARY_SET_LEN(ary, idx + 1);
    ary_verify(ary);
    return ary;
}</pre> </div> <p>Appends <code>object</code> to <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a &lt;&lt; :baz # =&gt; [:foo, "bar", 2, :baz]
</pre> <p>Appends <code>object</code> as one element, even if it is another Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a &lt;&lt; [3, 4]
a1 # =&gt; [:foo, "bar", 2, [3, 4]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> array &lt;=&gt; other_array → -1, 0, or 1 </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (!UNDEF_P(v)) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre> </div> <p>Returns -1, 0, or 1 as <code>self</code> is less than, equal to, or greater than <code>other_array</code>. For each index <code>i</code> in <code>self</code>, evaluates <code>result = self[i] &lt;=&gt; other_array[i]</code>.</p> <p>Returns -1 if any result is -1:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1, 3] # =&gt; -1
</pre> <p>Returns 1 if any result is 1:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1, 1] # =&gt; 1
</pre> <p>When all results are zero:</p> <ul>
<li> <p>Returns -1 if <code>array</code> is smaller than <code>other_array</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1, 2, 3] # =&gt; -1
</pre> </li>
<li> <p>Returns 1 if <code>array</code> is larger than <code>other_array</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1] # =&gt; 1
</pre> </li>
<li> <p>Returns 0 if <code>array</code> and <code>other_array</code> are the same size:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1, 2] # =&gt; 0
</pre> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> array == other_array → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) {
        if (!rb_respond_to(ary2, idTo_ary)) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</pre> </div> <p>Returns <code>true</code> if both <code>array.size == other_array.size</code> and for each index <code>i</code> in <code>array</code>, <code>array[i] == other_array[i]</code>:</p> <pre class="ruby" data-language="ruby">a0 = [:foo, 'bar', 2]
a1 = [:foo, 'bar', 2.0]
a1 == a0 # =&gt; true
[] == [] # =&gt; true
</pre> <p>Otherwise, returns <code>false</code>.</p> <p>This method is different from method <a href="array.html#method-i-eql-3F"><code>Array#eql?</code></a>, which compares elements using <code>Object#eql?</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> array[index] → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> array[start, length] → object or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> array[range] → object or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> array[aseq] → object or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    rb_check_arity(argc, 1, 2);
    if (argc == 2) {
        return rb_ary_aref2(ary, argv[0], argv[1]);
    }
    return rb_ary_aref1(ary, argv[0]);
}</pre> </div> <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p> <p>When a single <a href="integer.html"><code>Integer</code></a> argument <code>index</code> is given, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] # =&gt; :foo
a[2] # =&gt; 2
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>index</code> is negative, counts relative to the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] # =&gt; 2
a[-2] # =&gt; "bar"
</pre> <p>If <code>index</code> is out of range, returns <code>nil</code>.</p> <p>When two <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new Array of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] # =&gt; [:foo, "bar"]
a[1, 2] # =&gt; ["bar", 2]
</pre> <p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 4] # =&gt; [:foo, "bar", 2]
a[1, 3] # =&gt; ["bar", 2]
a[2, 2] # =&gt; [2]
</pre> <p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty Array.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>When a single <a href="range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] # =&gt; [:foo, "bar"]
a[1..2] # =&gt; ["bar", 2]
</pre> <p>Special case: If <code>range.start == a.size</code>, returns a new empty Array.</p> <p>If <code>range.end</code> is negative, calculates the end index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..-1] # =&gt; [:foo, "bar", 2]
a[0..-2] # =&gt; [:foo, "bar"]
a[0..-3] # =&gt; [:foo]
</pre> <p>If <code>range.start</code> is negative, calculates the start index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1..2] # =&gt; [2]
a[-2..2] # =&gt; ["bar", 2]
a[-3..2] # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[4..1] # =&gt; nil
a[4..0] # =&gt; nil
a[4..-1] # =&gt; nil
</pre> <p>When a single <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an Array of elements corresponding to the indexes produced by the sequence.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..).step(2)] # =&gt; ["data1", "data2", "data3"]
</pre> <p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="rangeerror.html"><code>RangeError</code></a>.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..11).step(2)]
# RangeError (((1..11).step(2)) out of range)
a[(7..).step(2)]
# RangeError (((7..).step(2)) out of range)
</pre> <p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="integer.html"><code>Integer</code></a>, and raises if it is impossible:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
# Raises TypeError (no implicit conversion of Symbol into Integer):
a[:foo]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-slice">slice</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> array[index] = object → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> array[start, length] = object → object </span> </div> <div class="method-heading"> <span class="method-callseq"> array[range] = object → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    rb_check_arity(argc, 2, 3);
    rb_ary_modify_check(ary);
    if (argc == 3) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[2]);
    }
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[1]);
    }

    offset = NUM2LONG(argv[0]);
    return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
}</pre> </div> <p>Assigns elements in <code>self</code>; returns the given <code>object</code>.</p> <p>When <a href="integer.html"><code>Integer</code></a> argument <code>index</code> is given, assigns <code>object</code> to an element in <code>self</code>.</p> <p>If <code>index</code> is non-negative, assigns <code>object</code> the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", "bar", 2]
</pre> <p>If <code>index</code> is greater than <code>self.length</code>, extends the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[7] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
</pre> <p>If <code>index</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] = 'two' # =&gt; "two"
a # =&gt; [:foo, "bar", "two"]
</pre> <p>When <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given and <code>object</code> is not an Array, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
</pre> <p>If <code>start</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-2, 2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>If <code>start</code> is non-negative and outside the array (<code> &gt;= self.size</code>), extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>start</code>, and ignores <code>length</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[6, 50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]
</pre> <p>If <code>length</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1, 0] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
</pre> <p>If <code>length</code> is too large for the existing array, does not extend the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1, 5] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>When <a href="range.html"><code>Range</code></a> argument <code>range</code> is given and <code>object</code> is an Array, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
</pre> <p>if <code>range.begin</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-2..2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>If the array length is less than <code>range.begin</code>, assigns <code>object</code> at offset <code>range.begin</code>, and ignores <code>length</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[6..50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]
</pre> <p>If <code>range.end</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..0] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
</pre> <p>If <code>range.end</code> is negative, assigns <code>object</code> at offset <code>start</code>, retains <code>range.end.abs -1</code> elements past that, and removes those beyond:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..-1] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
a = [:foo, 'bar', 2]
a[1..-2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", 2]
a = [:foo, 'bar', 2]
a[1..-3] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
a = [:foo, 'bar', 2]
</pre> <p>If <code>range.end</code> is too large for the existing array, replaces array elements, but does not extend the array with <code>nil</code> values:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..5] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-abbrev"> <span class="method-name">abbrev</span><span class="method-args">(pattern = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="abbrev-source"> <pre class="ruby" data-language="ruby"># File lib/abbrev.rb, line 130
def abbrev(pattern = nil)
  Abbrev::abbrev(self, pattern)
end</pre> </div> <p>Calculates the set of unambiguous abbreviations for the strings in <code>self</code>.</p> <pre class="ruby" data-language="ruby">require 'abbrev'
%w{ car cone }.abbrev
#=&gt; {"car"=&gt;"car", "ca"=&gt;"car", "cone"=&gt;"cone", "con"=&gt;"cone", "co"=&gt;"cone"}
</pre> <p>The optional <code>pattern</code> parameter is a pattern or a string. Only input strings that match the pattern or start with the string are included in the output hash.</p> <pre class="ruby" data-language="ruby">%w{ fast boat day }.abbrev(/^.a/)
#=&gt; {"fast"=&gt;"fast", "fas"=&gt;"fast", "fa"=&gt;"fast", "day"=&gt;"day", "da"=&gt;"day"}

Abbrev.abbrev(%w{car box cone}, "ca")
#=&gt; {"car"=&gt;"car", "ca"=&gt;"car"}
</pre> <p>See also <a href="abbrev.html#method-c-abbrev"><code>Abbrev.abbrev</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-all-3F"> <span class="method-callseq"> all? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> all? {|element| ... } → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> all?(obj) → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="all-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_all_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (!RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if all elements of <code>self</code> meet a given criterion.</p> <p>If <code>self</code> has no element, returns <code>true</code> and argument or block are not used.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> contains only truthy elements, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, :foo].all? # =&gt; true
[0, nil, 2].all? # =&gt; false
[].all? # =&gt; true
</pre> <p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns only truthy values, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].all? { |element| element &lt; 3 } # =&gt; true
[0, 1, 2].all? { |element| element &lt; 2 } # =&gt; false
</pre> <p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> every element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">['food', 'fool', 'foot'].all?(/foo/) # =&gt; true
['food', 'drink'].all?(/bar/) # =&gt; false
[].all?(/foo/) # =&gt; true
[0, 0, 0].all?(0) # =&gt; true
[0, 1, 2].all?(1) # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-all-3F"><code>Enumerable#all?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-any-3F"> <span class="method-callseq"> any? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> any? {|element| ... } → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> any?(obj) → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_any_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qtrue;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if any element of <code>self</code> meets a given criterion.</p> <p>If <code>self</code> has no element, returns <code>false</code> and argument or block are not used.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> has any truthy element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[nil, 0, false].any? # =&gt; true
[nil, false].any? # =&gt; false
[].any? # =&gt; false
</pre> <p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].any? {|element| element &gt; 1 } # =&gt; true
[0, 1, 2].any? {|element| element &gt; 2 } # =&gt; false
</pre> <p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj</code>.<code>===</code> any element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">['food', 'drink'].any?(/foo/) # =&gt; true
['food', 'drink'].any?(/bar/) # =&gt; false
[].any?(/foo/) # =&gt; false
[0, 1, 2].any?(1) # =&gt; true
[0, 1, 2].any?(3) # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-any-3F"><code>Enumerable#any?</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-append"> <span class="method-name">append</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-push">push</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assoc"> <span class="method-callseq"> assoc(obj) → found_array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assoc-source"> <pre class="c" data-language="c">VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 0), key))
            return v;
    }
    return Qnil;
}</pre> </div> <p>Returns the first element in <code>self</code> that is an Array whose first element <code>==</code> <code>obj</code>:</p> <pre class="ruby" data-language="ruby">a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
a.assoc(4) # =&gt; [4, 5, 6]
</pre> <p>Returns <code>nil</code> if no such element is found.</p> <p>Related: <a href="array.html#method-i-rassoc"><code>rassoc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-at"> <span class="method-callseq"> at(index) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="at-source"> <pre class="c" data-language="c">VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</pre> </div> <p>Returns the element at <a href="integer.html"><code>Integer</code></a> offset <code>index</code>; does not modify <code>self</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.at(0) # =&gt; :foo
a.at(2) # =&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bsearch"> <span class="method-callseq"> bsearch {|element| ... } → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> bsearch → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="bsearch-source"> <pre class="c" data-language="c">static VALUE
rb_ary_bsearch(VALUE ary)
{
    VALUE index_result = rb_ary_bsearch_index(ary);

    if (FIXNUM_P(index_result)) {
        return rb_ary_entry(ary, FIX2LONG(index_result));
    }
    return index_result;
}</pre> </div> <p>Returns an element from <code>self</code> selected by a binary search.</p> <p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bsearch_index"> <span class="method-callseq"> bsearch_index {|element| ... } → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> bsearch_index → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="bsearch_index-source"> <pre class="c" data-language="c">static VALUE
rb_ary_bsearch_index(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low &lt; high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (v == INT2FIX(0)) return INT2FIX(mid);
            smaller = (SIGNED_VALUE)v &lt; 0; /* Fixnum preserves its sign-bit */
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (!RTEST(v)) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &amp;zero), v, zero)) {
              case 0: return INT2FIX(mid);
              case 1: smaller = 0; break;
              case -1: smaller = 1;
            }
        }
        else {
            rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE
                     " (must be numeric, true, false or nil)",
                     rb_obj_class(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (!satisfied) return Qnil;
    return INT2FIX(low);
}</pre> </div> <p>Searches <code>self</code> as described at method <a href="array.html#method-i-bsearch"><code>bsearch</code></a>, but returns the <em>index</em> of the found element instead of the element itself.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear"> <span class="method-callseq"> clear → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify_check(ary);
    if (ARY_SHARED_P(ary)) {
        if (!ARY_EMBED_P(ary)) {
            rb_ary_unshare(ary);
            FL_SET_EMBED(ary);
            ARY_SET_EMBED_LEN(ary, 0);
        }
    }
    else {
        ARY_SET_LEN(ary, 0);
        if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
            ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
        }
    }
    ary_verify(ary);
    return ary;
}</pre> </div> <p>Removes all elements from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.clear # =&gt; []
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-collect"> <span class="method-name">collect</span> </div> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-map">map</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-collect-21"> <span class="method-name">collect!</span> </div> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-map-21">map!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-combination"> <span class="method-callseq"> combination(n) {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> combination(n) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="combination-source"> <pre class="c" data-language="c">static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long i, n, len;

    n = NUM2LONG(num);
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_combination_size);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        volatile VALUE t0;
        long *stack = ALLOCV_N(long, t0, n+1);

        RBASIC_CLEAR_CLASS(ary0);
        combinate0(len, n, stack, ary0);
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div> <p>Calls the block, if given, with combinations of elements of <code>self</code>; returns <code>self</code>. The order of combinations is indeterminate.</p> <p>When a block and an in-range positive <a href="integer.html"><code>Integer</code></a> argument <code>n</code> (<code>0 &lt; n &lt;= self.size</code>) are given, calls the block with all <code>n</code>-tuple combinations of <code>self</code>.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.combination(2) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 1]
[0, 2]
[1, 2]
</pre> <p>Another example:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.combination(3) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 1, 2]
</pre> <p>When <code>n</code> is zero, calls the block once with a new empty Array:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a1 = a.combination(0) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[]
</pre> <p>When <code>n</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.combination(-1) {|combination| fail 'Cannot happen' }
a.combination(4) {|combination| fail 'Cannot happen' }
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.combination(2) # =&gt; #&lt;Enumerator: [0, 1, 2]:combination(2)&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compact"> <span class="method-callseq"> compact → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</pre> </div> <p>Returns a new Array containing all non-<code>nil</code> elements from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [nil, 0, nil, 1, nil, 2, nil]
a.compact # =&gt; [0, 1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compact-21"> <span class="method-callseq"> compact! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compact-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = (VALUE *)RARRAY_CONST_PTR(ary); /* WB: no new reference */
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_CONST_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ary_resize_smaller(ary, n);

    return ary;
}</pre> </div> <p>Removes all <code>nil</code> elements from <code>self</code>.</p> <p>Returns <code>self</code> if any elements removed, otherwise <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-concat"> <span class="method-callseq"> concat(*other_arrays) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="concat-source"> <pre class="c" data-language="c">static VALUE
rb_ary_concat_multi(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify_check(ary);

    if (argc == 1) {
        rb_ary_concat(ary, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE args = rb_ary_hidden_new(argc);
        for (i = 0; i &lt; argc; i++) {
            rb_ary_concat(args, argv[i]);
        }
        ary_append(ary, args);
    }

    ary_verify(ary);
    return ary;
}</pre> </div> <p>Adds to <code>array</code> all elements from each Array in <code>other_arrays</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1]
a.concat([2, 3], [4, 5]) # =&gt; [0, 1, 2, 3, 4, 5]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <span class="method-callseq"> count → an_integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> count(obj) → an_integer </span> </div> <div class="method-heading"> <span class="method-callseq"> count {|element| ... } → an_integer </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long i, n = 0;

    if (rb_check_arity(argc, 0, 1) == 0) {
        VALUE v;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            v = RARRAY_AREF(ary, i);
            if (RTEST(rb_yield(v))) n++;
        }
    }
    else {
        VALUE obj = argv[0];

        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            if (rb_equal(RARRAY_AREF(ary, i), obj)) n++;
        }
    }

    return LONG2NUM(n);
}</pre> </div> <p>Returns a count of specified elements.</p> <p>With no argument and no block, returns the count of all elements:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].count # =&gt; 3
[].count # =&gt; 0
</pre> <p>With argument <code>obj</code>, returns the count of elements <code>==</code> to <code>obj</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 0.0].count(0) # =&gt; 2
[0, 1, 2].count(3) # =&gt; 0
</pre> <p>With no argument and a block given, calls the block with each element; returns the count of elements for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].count {|element| element &gt; 1} # =&gt; 2
</pre> <p>With argument <code>obj</code> and a block given, issues a warning, ignores the block, and returns the count of elements <code>==</code> to <code>obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cycle"> <span class="method-callseq"> cycle {|element| ... } → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> cycle(count) {|element| ... } → nil </span> </div> <div class="method-heading"> <span class="method-callseq"> cycle → new_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> cycle(count) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="cycle-source"> <pre class="c" data-language="c">static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_cycle_size);
    if (argc == 0 || NIL_P(argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(argv[0]);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre> </div> <p>When called with positive <a href="integer.html"><code>Integer</code></a> argument <code>count</code> and a block, calls the block with each element, then does so again, until it has done so <code>count</code> times; returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">output = []
[0, 1].cycle(2) {|element| output.push(element) } # =&gt; nil
output # =&gt; [0, 1, 0, 1]
</pre> <p>If <code>count</code> is zero or negative, does not call the block:</p> <pre class="ruby" data-language="ruby">[0, 1].cycle(0) {|element| fail 'Cannot happen' } # =&gt; nil
[0, 1].cycle(-1) {|element| fail 'Cannot happen' } # =&gt; nil
</pre> <p>When a block is given, and argument is omitted or <code>nil</code>, cycles forever:</p> <pre class="ruby" data-language="ruby"># Prints 0 and 1 forever.
[0, 1].cycle {|element| puts element }
[0, 1].cycle(nil) {|element| puts element }
</pre> <p>When no block is given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">[0, 1].cycle(2) # =&gt; #&lt;Enumerator: [0, 1]:cycle(2)&gt;
[0, 1].cycle # =&gt; # =&gt; #&lt;Enumerator: [0, 1]:cycle&gt;
[0, 1].cycle.first(5) # =&gt; [0, 1, 0, 1, 0]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(obj) → deleted_object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(obj) {|nosuch| ... } → deleted_object or block_return </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_AREF(ary, i1);

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    ary_resize_smaller(ary, i2);

    ary_verify(ary);
    return v;
}</pre> </div> <p>Removes zero or more elements from <code>self</code>.</p> <p>When no block is given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == obj</code>; returns the last deleted element:</p> <pre class="ruby" data-language="ruby">s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
a.delete('bar') # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>Returns <code>nil</code> if no elements removed.</p> <p>When a block is given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == obj</code>.</p> <p>If any such elements are found, ignores the block and returns the last deleted element:</p> <pre class="ruby" data-language="ruby">s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
a # =&gt; [:foo, 2]
</pre> <p>If no such elements are found, returns the block’s return value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete(:nosuch) {|obj| "#{obj} not found" } # =&gt; "nosuch not found"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_at"> <span class="method-callseq"> delete_at(index) → deleted_object or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_at-source"> <pre class="c" data-language="c">static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</pre> </div> <p>Deletes an element from <code>self</code>, per the given <a href="integer.html"><code>Integer</code></a> <code>index</code>.</p> <p>When <code>index</code> is non-negative, deletes the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_at(1) # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>If index is too large, returns <code>nil</code>.</p> <p>When <code>index</code> is negative, counts backward from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_at(-2) # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>If <code>index</code> is too small (far from zero), returns nil.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete_if → Enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="c" data-language="c">static VALUE
rb_ary_delete_if(VALUE ary)
{
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    ary_reject_bang(ary);
    return ary;
}</pre> </div> <p>Removes each element in <code>self</code> for which the block returns a truthy value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a.delete_if {|element| element.to_s.start_with?('b') } # =&gt; [:foo, 2]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_if # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:delete_if&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-difference"> <span class="method-callseq"> difference(*other_arrays) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="difference-source"> <pre class="c" data-language="c">static VALUE
rb_ary_difference_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE ary_diff;
    long i, length;
    volatile VALUE t0;
    bool *is_hash = ALLOCV_N(bool, t0, argc);
    ary_diff = rb_ary_new();
    length = RARRAY_LEN(ary);

    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        is_hash[i] = (length &gt; SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(argv[i]) &gt; SMALL_ARRAY_LEN);
        if (is_hash[i]) argv[i] = ary_make_hash(argv[i]);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        int j;
        VALUE elt = rb_ary_elt(ary, i);
        for (j = 0; j &lt; argc; j++) {
            if (is_hash[j]) {
                if (rb_hash_stlike_lookup(argv[j], RARRAY_AREF(ary, i), NULL))
                    break;
            }
            else {
                if (rb_ary_includes_by_eql(argv[j], elt)) break;
            }
        }
        if (j == argc) rb_ary_push(ary_diff, elt);
    }

    ALLOCV_END(t0);

    return ary_diff;
}</pre> </div> <p>Returns a new Array containing only those elements from <code>self</code> that are not found in any of the Arrays <code>other_arrays</code>; items are compared using <code>eql?</code>; order from <code>self</code> is preserved:</p> <pre class="ruby" data-language="ruby">[0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # =&gt; [0, 2, 3]
[0, 1, 2, 3].difference([3, 0], [1, 3]) # =&gt; [2]
[0, 1, 2].difference([4]) # =&gt; [0, 1, 2]
</pre> <p>Returns a copy of <code>self</code> if no arguments given.</p> <p>Related: <a href="array.html#method-i-2D"><code>Array#-</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(index, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_ary_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_ary_at(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Finds and returns the object in nested objects that is specified by <code>index</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See <a href="dig_methods_rdoc.html">Dig Methods</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [:foo, [:bar, :baz, [:bat, :bam]]]
a.dig(1) # =&gt; [:bar, :baz, [:bat, :bam]]
a.dig(1, 2) # =&gt; [:bat, :bam]
a.dig(1, 2, 0) # =&gt; :bat
a.dig(1, 2, 3) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-drop"> <span class="method-callseq"> drop(n) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="drop-source"> <pre class="c" data-language="c">static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, "attempt to drop negative size");
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (NIL_P(result)) result = rb_ary_new();
    return result;
}</pre> </div> <p>Returns a new Array containing all but the first <code>n</code> element of <code>self</code>, where <code>n</code> is a non-negative <a href="integer.html"><code>Integer</code></a>; does not modify <code>self</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.drop(0) # =&gt; [0, 1, 2, 3, 4, 5]
a.drop(1) # =&gt; [1, 2, 3, 4, 5]
a.drop(2) # =&gt; [2, 3, 4, 5]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-drop_while"> <span class="method-callseq"> drop_while {|element| ... } → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> drop_while → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="drop_while-source"> <pre class="c" data-language="c">static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</pre> </div> <p>Returns a new Array containing zero or more trailing elements of <code>self</code>; does not modify <code>self</code>.</p> <p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new Array <em>omitting</em> those elements for which the block returned a truthy value:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.drop_while {|element| element &lt; 3 } # =&gt; [3, 4, 5]
</pre> <p>With no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">[0, 1].drop_while # =&gt; # =&gt; #&lt;Enumerator: [0, 1]:drop_while&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → Enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">VALUE
rb_ary_each(VALUE ary)
{
    long i;
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_AREF(ary, i));
    }
    return ary;
}</pre> </div> <p>Iterates over array elements.</p> <p>When a block given, passes each successive array element to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each {|element|  puts "#{element.class} #{element}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Symbol foo
String bar
Integer 2
</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
</pre> <p>When no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]

e = a.each
e # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:each&gt;
a1 = e.each {|element|  puts "#{element.class} #{element}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Symbol foo
String bar
Integer 2
</pre> <p>Related: <a href="array.html#method-i-each_index"><code>each_index</code></a>, <a href="array.html#method-i-reverse_each"><code>reverse_each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_index"> <span class="method-callseq"> each_index {|index| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_index → Enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_index-source"> <pre class="c" data-language="c">static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}</pre> </div> <p>Iterates over array indexes.</p> <p>When a block given, passes each successive array index to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each_index {|index|  puts "#{index} #{a[index]}" }
</pre> <p>Output:</p> <pre>0 foo
1 bar
2 2</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each_index {|index| puts index; a.clear if index &gt; 0 }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
</pre> <p>When no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
e = a.each_index
e # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:each_index&gt;
a1 = e.each {|index|  puts "#{index} #{a[index]}"}
</pre> <p>Output:</p> <pre>0 foo
1 bar
2 2</pre> <p>Related: <a href="array.html#method-i-each"><code>each</code></a>, <a href="array.html#method-i-reverse_each"><code>reverse_each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_empty_p(VALUE ary)
{
    return RBOOL(RARRAY_LEN(ary) == 0);
}</pre> </div> <p>Returns <code>true</code> if the count of elements in <code>self</code> is zero, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql? other_array → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> and <code>other_array</code> are the same size, and if, for each index <code>i</code> in <code>self</code>, <code>self[i].eql? other_array[i]</code>:</p> <pre class="ruby" data-language="ruby">a0 = [:foo, 'bar', 2]
a1 = [:foo, 'bar', 2]
a1.eql?(a0) # =&gt; true
</pre> <p>Otherwise, returns <code>false</code>.</p> <p>This method is different from method <a href="array.html#method-i-3D-3D"><code>Array#==</code></a>, which compares using method <code>Object#==</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fetch"> <span class="method-callseq"> fetch(index) → element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch(index, default_value) → element </span> </div> <div class="method-heading"> <span class="method-callseq"> fetch(index) {|index| ... } → element </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="c" data-language="c">static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, "11", &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn("block supersedes default value argument");
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, "index %ld outside of array bounds: %ld...%ld",
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_AREF(ary, idx);
}</pre> </div> <p>Returns the element at offset <code>index</code>.</p> <p>With the single <a href="integer.html"><code>Integer</code></a> argument <code>index</code>, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1) # =&gt; "bar"
</pre> <p>If <code>index</code> is negative, counts from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(-1) # =&gt; 2
a.fetch(-2) # =&gt; "bar"
</pre> <p>With arguments <code>index</code> and <code>default_value</code>, returns the element at offset <code>index</code> if index is in range, otherwise returns <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1, nil) # =&gt; "bar"
</pre> <p>With argument <code>index</code> and a block, returns the element at offset <code>index</code> if index is in range (and the block is not called); otherwise calls the block with index and returns its return value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1) {|index| raise 'Cannot happen' } # =&gt; "bar"
a.fetch(50) {|index| "Value for #{index}" } # =&gt; "Value for 50"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fill"> <span class="method-callseq"> fill(obj) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fill(obj, start) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill(obj, start, length) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill(obj, range) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill {|index| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill(start) {|index| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill(start, length) {|index| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> fill(range) {|index| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="fill-source"> <pre class="c" data-language="c">static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item = Qundef, arg1, arg2;
    long beg = 0, end = 0, len = 0;

    if (rb_block_given_p()) {
        rb_scan_args(argc, argv, "02", &amp;arg1, &amp;arg2);
        argc += 1;              /* hackish */
    }
    else {
        rb_scan_args(argc, argv, "12", &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, "argument too big");
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        ary_mem_clear(ary, RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (UNDEF_P(item)) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            ARY_SET(ary, i, v);
        }
    }
    else {
        ary_memfill(ary, beg, len, item);
    }
    return ary;
}</pre> </div> <p>Replaces specified elements in <code>self</code> with specified objects; returns <code>self</code>.</p> <p>With argument <code>obj</code> and no block given, replaces all elements with that one object:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a # =&gt; ["a", "b", "c", "d"]
a.fill(:X) # =&gt; [:X, :X, :X, :X]
</pre> <p>With arguments <code>obj</code> and <a href="integer.html"><code>Integer</code></a> <code>start</code>, and no block given, replaces elements based on the given start.</p> <p>If <code>start</code> is in range (<code>0 &lt;= start &lt; array.size</code>), replaces all elements from offset <code>start</code> through the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, 2) # =&gt; ["a", "b", :X, :X]
</pre> <p>If <code>start</code> is too large (<code>start &gt;= array.size</code>), does nothing:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, 4) # =&gt; ["a", "b", "c", "d"]
a = ['a', 'b', 'c', 'd']
a.fill(:X, 5) # =&gt; ["a", "b", "c", "d"]
</pre> <p>If <code>start</code> is negative, counts from the end (starting index is <code>start + array.size</code>):</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, -2) # =&gt; ["a", "b", :X, :X]
</pre> <p>If <code>start</code> is too small (less than and far from zero), replaces all elements:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, -6) # =&gt; [:X, :X, :X, :X]
a = ['a', 'b', 'c', 'd']
a.fill(:X, -50) # =&gt; [:X, :X, :X, :X]
</pre> <p>With arguments <code>obj</code>, <a href="integer.html"><code>Integer</code></a> <code>start</code>, and <a href="integer.html"><code>Integer</code></a> <code>length</code>, and no block given, replaces elements based on the given <code>start</code> and <code>length</code>.</p> <p>If <code>start</code> is in range, replaces <code>length</code> elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, 1, 1) # =&gt; ["a", :X, "c", "d"]
</pre> <p>If <code>start</code> is negative, counts from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, -2, 1) # =&gt; ["a", "b", :X, "d"]
</pre> <p>If <code>start</code> is large (<code>start &gt;= array.size</code>), extends <code>self</code> with <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, 5, 0) # =&gt; ["a", "b", "c", "d", nil]
a = ['a', 'b', 'c', 'd']
a.fill(:X, 5, 2) # =&gt; ["a", "b", "c", "d", nil, :X, :X]
</pre> <p>If <code>length</code> is zero or negative, replaces no elements:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, 1, 0) # =&gt; ["a", "b", "c", "d"]
a.fill(:X, 1, -1) # =&gt; ["a", "b", "c", "d"]
</pre> <p>With arguments <code>obj</code> and <a href="range.html"><code>Range</code></a> <code>range</code>, and no block given, replaces elements based on the given range.</p> <p>If the range is positive and ascending (<code>0 &lt; range.begin &lt;= range.end</code>), replaces elements from <code>range.begin</code> to <code>range.end</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, (1..1)) # =&gt; ["a", :X, "c", "d"]
</pre> <p>If <code>range.first</code> is negative, replaces no elements:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, (-1..1)) # =&gt; ["a", "b", "c", "d"]
</pre> <p>If <code>range.last</code> is negative, counts from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, (0..-2)) # =&gt; [:X, :X, :X, "d"]
a = ['a', 'b', 'c', 'd']
a.fill(:X, (1..-2)) # =&gt; ["a", :X, :X, "d"]
</pre> <p>If <code>range.last</code> and <code>range.last</code> are both negative, both count from the end of the array:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(:X, (-1..-1)) # =&gt; ["a", "b", "c", :X]
a = ['a', 'b', 'c', 'd']
a.fill(:X, (-2..-2)) # =&gt; ["a", "b", :X, "d"]
</pre> <p>With no arguments and a block given, calls the block with each index; replaces the corresponding element with the block’s return value:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill { |index| "new_#{index}" } # =&gt; ["new_0", "new_1", "new_2", "new_3"]
</pre> <p>With argument <code>start</code> and a block given, calls the block with each index from offset <code>start</code> to the end; replaces the corresponding element with the block’s return value.</p> <p>If start is in range (<code>0 &lt;= start &lt; array.size</code>), replaces from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(1) { |index| "new_#{index}" } # =&gt; ["a", "new_1", "new_2", "new_3"]
</pre> <p>If <code>start</code> is too large(<code>start &gt;= array.size</code>), does nothing:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(4) { |index| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
a = ['a', 'b', 'c', 'd']
a.fill(4) { |index| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
</pre> <p>If <code>start</code> is negative, counts from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(-2) { |index| "new_#{index}" } # =&gt; ["a", "b", "new_2", "new_3"]
</pre> <p>If start is too small (<code>start &lt;= -array.size</code>, replaces all elements:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(-6) { |index| "new_#{index}" } # =&gt; ["new_0", "new_1", "new_2", "new_3"]
a = ['a', 'b', 'c', 'd']
a.fill(-50) { |index| "new_#{index}" } # =&gt; ["new_0", "new_1", "new_2", "new_3"]
</pre> <p>With arguments <code>start</code> and <code>length</code>, and a block given, calls the block for each index specified by start length; replaces the corresponding element with the block’s return value.</p> <p>If <code>start</code> is in range, replaces <code>length</code> elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(1, 1) { |index| "new_#{index}" } # =&gt; ["a", "new_1", "c", "d"]
</pre> <p>If start is negative, counts from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(-2, 1) { |index| "new_#{index}" } # =&gt; ["a", "b", "new_2", "d"]
</pre> <p>If <code>start</code> is large (<code>start &gt;= array.size</code>), extends <code>self</code> with <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(5, 0) { |index| "new_#{index}" } # =&gt; ["a", "b", "c", "d", nil]
a = ['a', 'b', 'c', 'd']
a.fill(5, 2) { |index| "new_#{index}" } # =&gt; ["a", "b", "c", "d", nil, "new_5", "new_6"]
</pre> <p>If <code>length</code> is zero or less, replaces no elements:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(1, 0) { |index| "new_#{index}" } # =&gt; ["a", "b", "c", "d"]
a.fill(1, -1) { |index| "new_#{index}" } # =&gt; ["a", "b", "c", "d"]
</pre> <p>With arguments <code>obj</code> and <code>range</code>, and a block given, calls the block with each index in the given range; replaces the corresponding element with the block’s return value.</p> <p>If the range is positive and ascending (<code>range 0 &lt; range.begin &lt;= range.end</code>, replaces elements from <code>range.begin</code> to <code>range.end</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(1..1) { |index| "new_#{index}" } # =&gt; ["a", "new_1", "c", "d"]
</pre> <p>If <code>range.first</code> is negative, does nothing:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(-1..1) { |index| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
</pre> <p>If <code>range.last</code> is negative, counts from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(0..-2) { |index| "new_#{index}" } # =&gt; ["new_0", "new_1", "new_2", "d"]
a = ['a', 'b', 'c', 'd']
a.fill(1..-2) { |index| "new_#{index}" } # =&gt; ["a", "new_1", "new_2", "d"]
</pre> <p>If <code>range.first</code> and <code>range.last</code> are both negative, both count from the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.fill(-1..-1) { |index| "new_#{index}" } # =&gt; ["a", "b", "c", "new_3"]
a = ['a', 'b', 'c', 'd']
a.fill(-2..-2) { |index| "new_#{index}" } # =&gt; ["a", "b", "new_2", "d"]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter"> <span class="method-name">filter</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-select">select</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter-21"> <span class="method-name">filter!</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-select-21">select!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-find_index"> <span class="method-name">find_index</span> </div> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-index">index</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-first"> <span class="method-callseq"> first → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> first(n) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="first-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 101
def first n = unspecified = true
  if Primitive.mandatory_only?
    Primitive.attr! :leaf
    Primitive.cexpr! %q{ ary_first(self) }
  else
    if unspecified
      Primitive.cexpr! %q{ ary_first(self) }
    else
      Primitive.cexpr! %q{  ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_FIRST) }
    end
  end
end</pre> </div> <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p> <p>When no argument is given, returns the first element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.first # =&gt; :foo
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>self</code> is empty, returns <code>nil</code>.</p> <p>When non-negative <a href="integer.html"><code>Integer</code></a> argument <code>n</code> is given, returns the first <code>n</code> elements in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.first(2) # =&gt; [:foo, "bar"]
</pre> <p>If <code>n &gt;= array.size</code>, returns all elements:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.first(50) # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>n == 0</code> returns an new empty Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.first(0) # []
</pre> <p>Related: <a href="array.html#method-i-last"><code>last</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-flatten"> <span class="method-callseq"> flatten → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flatten(level) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="flatten-source"> <pre class="c" data-language="c">static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int level = -1;
    VALUE result;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0])) {
        level = NUM2INT(argv[0]);
        if (level == 0) return ary_make_shared_copy(ary);
    }

    result = flatten(ary, level);
    if (result == ary) {
        result = ary_make_shared_copy(ary);
    }

    return result;
}</pre> </div> <p>Returns a new Array that is a recursive flattening of <code>self</code>:</p> <ul>
<li> <p>Each non-Array element is unchanged.</p> </li>
<li> <p>Each Array is replaced by its individual elements.</p> </li>
</ul> <p>With non-negative <a href="integer.html"><code>Integer</code></a> argument <code>level</code>, flattens recursively through <code>level</code> levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(0) # =&gt; [0, [1, [2, 3], 4], 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(1) # =&gt; [0, 1, [2, 3], 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(2) # =&gt; [0, 1, 2, 3, 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(3) # =&gt; [0, 1, 2, 3, 4, 5]
</pre> <p>With no argument, a <code>nil</code> argument, or with negative argument <code>level</code>, flattens all levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten # =&gt; [0, 1, 2, 3, 4, 5]
[0, 1, 2].flatten # =&gt; [0, 1, 2]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(-1) # =&gt; [0, 1, 2, 3, 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(-2) # =&gt; [0, 1, 2, 3, 4, 5]
[0, 1, 2].flatten(-1) # =&gt; [0, 1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-flatten-21"> <span class="method-callseq"> flatten! → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flatten!(level) → self or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="flatten-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    lv = (rb_check_arity(argc, 0, 1) ? argv[0] : Qnil);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level);
    if (result == ary) {
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_obj_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</pre> </div> <p>Replaces each nested Array in <code>self</code> with the elements from that Array; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> <p>With non-negative <a href="integer.html"><code>Integer</code></a> argument <code>level</code>, flattens recursively through <code>level</code> levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten!(1) # =&gt; [0, 1, [2, 3], 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten!(2) # =&gt; [0, 1, 2, 3, 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten!(3) # =&gt; [0, 1, 2, 3, 4, 5]
[0, 1, 2].flatten!(1) # =&gt; nil
</pre> <p>With no argument, a <code>nil</code> argument, or with negative argument <code>level</code>, flattens all levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten! # =&gt; [0, 1, 2, 3, 4, 5]
[0, 1, 2].flatten! # =&gt; nil
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten!(-1) # =&gt; [0, 1, 2, 3, 4, 5]
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten!(-2) # =&gt; [0, 1, 2, 3, 4, 5]
[0, 1, 2].flatten!(-1) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_ary_hash(VALUE ary)
{
    return rb_ary_hash_values(RARRAY_LEN(ary), RARRAY_CONST_PTR(ary));
}</pre> </div> <p>Returns the integer hash value for <code>self</code>.</p> <p>Two arrays with the same content will have the same hash code (and will compare using eql?):</p> <pre class="ruby" data-language="ruby">[0, 1, 2].hash == [0, 1, 2].hash # =&gt; true
[0, 1, 2].hash == [0, 1, 3].hash # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(obj) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;
    VALUE e;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (rb_equal(e, item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if for some index <code>i</code> in <code>self</code>, <code>obj == self[i]</code>; otherwise <code>false</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].include?(2) # =&gt; true
[0, 1, 2].include?(3) # =&gt; false
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-index"> <span class="method-callseq"> index(object) → integer or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> index {|element| ... } → integer or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> index → new_enumerator </span> </div> </div> <div class="method-description"> <p>Returns the index of a specified element.</p> <p>When argument <code>object</code> is given but no block, returns the index of the first element <code>element</code> for which <code>object == element</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.index('bar') # =&gt; 1
</pre> <p>Returns <code>nil</code> if no such element found.</p> <p>When both argument <code>object</code> and a block are given, calls the block with each successive element; returns the index of the first element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.index {|element| element == 'bar' } # =&gt; 1
</pre> <p>Returns <code>nil</code> if the block never returns a truthy value.</p> <p>When neither an argument nor a block is given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
e = a.index
e # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:index&gt;
e.each {|element| element == 'bar' } # =&gt; 1
</pre> <p>Related: <a href="array.html#method-i-rindex"><code>rindex</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-find_index">find_index</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span> </div> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-replace">replace</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-insert"> <span class="method-callseq"> insert(index, *objects) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="insert-source"> <pre class="c" data-language="c">static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    rb_ary_modify_check(ary);
    pos = NUM2LONG(argv[0]);
    if (argc == 1) return ary;
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    else if (pos &lt; 0) {
        long minpos = -RARRAY_LEN(ary) - 1;
        if (pos &lt; minpos) {
            rb_raise(rb_eIndexError, "index %ld too small for array; minimum: %ld",
                     pos, minpos);
        }
        pos++;
    }
    rb_ary_splice(ary, pos, 0, argv + 1, argc - 1);
    return ary;
}</pre> </div> <p>Inserts given <code>objects</code> before or after the element at <a href="integer.html"><code>Integer</code></a> index <code>offset</code>; returns <code>self</code>.</p> <p>When <code>index</code> is non-negative, inserts all given <code>objects</code> before the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.insert(1, :bat, :bam) # =&gt; [:foo, :bat, :bam, "bar", 2]
</pre> <p>Extends the array if <code>index</code> is beyond the array (<code>index &gt;= self.size</code>):</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.insert(5, :bat, :bam)
a # =&gt; [:foo, "bar", 2, nil, nil, :bat, :bam]
</pre> <p>Does nothing if no objects given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.insert(1)
a.insert(50)
a.insert(-50)
a # =&gt; [:foo, "bar", 2]
</pre> <p>When <code>index</code> is negative, inserts all given <code>objects</code> <em>after</em> the element at offset <code>index+self.size</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.insert(-2, :bat, :bam)
a # =&gt; [:foo, "bar", :bat, :bam, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2("[]");
    return rb_exec_recursive(inspect_ary, ary, 0);
}</pre> </div> <p>Returns the new <a href="string.html"><code>String</code></a> formed by calling method <code>#inspect</code> on each array element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.inspect # =&gt; "[:foo, \"bar\", 2]"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-intersect-3F"> <span class="method-callseq"> intersect?(other_ary) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="intersect-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_intersect_p(VALUE ary1, VALUE ary2)
{
    VALUE hash, v, result, shorter, longer;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return Qfalse;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (rb_ary_includes_by_eql(ary2, v)) return Qtrue;
        }
        return Qfalse;
    }

    shorter = ary1;
    longer = ary2;
    if (RARRAY_LEN(ary1) &gt; RARRAY_LEN(ary2)) {
        longer = ary1;
        shorter = ary2;
    }

    hash = ary_make_hash(shorter);
    result = Qfalse;

    for (i=0; i&lt;RARRAY_LEN(longer); i++) {
        v = RARRAY_AREF(longer, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_lookup(hash, vv, 0)) {
            result = Qtrue;
            break;
        }
    }

    return result;
}</pre> </div> <p>Returns <code>true</code> if the array and <code>other_ary</code> have at least one element in common, otherwise returns <code>false</code>:</p> <pre class="ruby" data-language="ruby">a = [ 1, 2, 3 ]
b = [ 3, 4, 5 ]
c = [ 5, 6, 7 ]
a.intersect?(b)   #=&gt; true
a.intersect?(c)   #=&gt; false
</pre> <p><a href="array.html"><code>Array</code></a> elements are compared using <code>eql?</code> (items must also implement <code>hash</code> correctly).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-intersection"> <span class="method-callseq"> intersection(*other_arrays) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="intersection-source"> <pre class="c" data-language="c">static VALUE
rb_ary_intersection_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = rb_ary_dup(ary);
    int i;

    for (i = 0; i &lt; argc; i++) {
        result = rb_ary_and(result, argv[i]);
    }

    return result;
}</pre> </div> <p>Returns a new Array containing each element found both in <code>self</code> and in all of the given Arrays <code>other_arrays</code>; duplicates are omitted; items are compared using <code>eql?</code> (items must also implement <code>hash</code> correctly):</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # =&gt; [0, 1]
[0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # =&gt; [0, 1]
</pre> <p>Preserves order from <code>self</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].intersection([2, 1, 0]) # =&gt; [0, 1, 2]
</pre> <p>Returns a copy of <code>self</code> if no arguments given.</p> <p>Related: <a href="array.html#method-i-26"><code>Array#&amp;</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-join"> <span class="method-callseq"> join →new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> join(separator = $,) → new_string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="join-source"> <pre class="c" data-language="c">static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(sep = argv[0])) {
        sep = rb_output_fs;
        if (!NIL_P(sep)) {
            rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, "$, is set to non-nil value");
        }
    }

    return rb_ary_join(ary, sep);
}</pre> </div> <p>Returns the new <a href="string.html"><code>String</code></a> formed by joining the array elements after conversion. For each element <code>element</code>:</p> <ul>
<li> <p>Uses <code>element.to_s</code> if <code>element</code> is not a <code>kind_of?(Array)</code>.</p> </li>
<li> <p>Uses recursive <code>element.join(separator)</code> if <code>element</code> is a <code>kind_of?(Array)</code>.</p> </li>
</ul> <p>With no argument, joins using the output field separator, <code>$,</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
$, # =&gt; nil
a.join # =&gt; "foobar2"
</pre> <p>With string argument <code>separator</code>, joins using that separator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.join("\n") # =&gt; "foo\nbar\n2"
</pre> <p>Joins recursively for nested Arrays:</p> <pre class="ruby" data-language="ruby">a = [:foo, [:bar, [:baz, :bat]]]
a.join # =&gt; "foobarbazbat"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-keep_if"> <span class="method-callseq"> keep_if {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> keep_if → new_enumeration </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="keep_if-source"> <pre class="c" data-language="c">static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_select_bang(ary);
    return ary;
}</pre> </div> <p>Retains those elements for which the block returns a truthy value; deletes all other elements; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.keep_if {|element| element.to_s.start_with?('b') } # =&gt; ["bar", :bam]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.keep_if # =&gt; #&lt;Enumerator: [:foo, "bar", 2, :bam]:keep_if&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-last"> <span class="method-callseq"> last → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> last(n) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="last-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 145
def last n = unspecified = true
  if Primitive.mandatory_only?
    Primitive.attr! :leaf
    Primitive.cexpr! %q{ ary_last(self) }
  else
    if unspecified
      Primitive.cexpr! %q{ ary_last(self) }
    else
      Primitive.cexpr! %q{ ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_LAST) }
    end
  end
end</pre> </div> <p>Returns elements from <code>self</code>; <code>self</code> is not modified.</p> <p>When no argument is given, returns the last element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last # =&gt; 2
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>self</code> is empty, returns <code>nil</code>.</p> <p>When non-negative <a href="integer.html"><code>Integer</code></a> argument <code>n</code> is given, returns the last <code>n</code> elements in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last(2) # =&gt; ["bar", 2]
</pre> <p>If <code>n &gt;= array.size</code>, returns all elements:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last(50) # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>n == 0</code>, returns an new empty Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last(0) # []
</pre> <p>Related: <a href="array.html#method-i-first"><code>first</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → an_integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</pre> </div> <p>Returns the count of elements in <code>self</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-size">size</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-map"> <span class="method-callseq"> map {|element| ... } → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> map → new_enumerator </span> </div> </div> <div class="method-description"> <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array whose elements are the return values from the block:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.map {|element| element.class }
a1 # =&gt; [Symbol, String, Integer]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.map
a1 # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:map&gt;
</pre> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-collect">collect</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-map-21"> <span class="method-callseq"> map! {|element| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> map! → new_enumerator </span> </div> </div> <div class="method-description"> <p>Calls the block, if given, with each element; replaces the element with the block’s return value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.map! { |element| element.class } # =&gt; [Symbol, String, Integer]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.map!
a1 # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:map!&gt;
</pre> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-collect-21">collect!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-max"> <span class="method-callseq"> max → element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> max {|a, b| ... } → element </span> </div> <div class="method-heading"> <span class="method-callseq"> max(n) → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> max(n) {|a, b| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="max-source"> <pre class="c" data-language="c">static VALUE
rb_ary_max(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 1, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &gt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_max_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_max_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_max_opt_float(ary, 1, result);
            }
            else {
                return ary_max_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div> <p>Returns one of the following:</p> <ul>
<li> <p>The maximum-valued element from <code>self</code>.</p> </li>
<li> <p>A new Array of maximum-valued elements selected from <code>self</code>.</p> </li>
</ul> <p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an <a href="integer.html"><code>Integer</code></a>.</p> <p>With no argument and no block, returns the element in <code>self</code> having the maximum value per method <code>&lt;=&gt;</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].max # =&gt; 2
</pre> <p>With an argument <a href="integer.html"><code>Integer</code></a> <code>n</code> and no block, returns a new Array with at most <code>n</code> elements, in descending order per method <code>&lt;=&gt;</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].max(3) # =&gt; [3, 2, 1]
[0, 1, 2, 3].max(6) # =&gt; [3, 2, 1, 0]
</pre> <p>When a block is given, the block must return an <a href="integer.html"><code>Integer</code></a>.</p> <p>With a block and no argument, calls the block <code>self.size-1</code> times to compare elements; returns the element having the maximum value per the block:</p> <pre class="ruby" data-language="ruby">['0', '00', '000'].max {|a, b| a.size &lt;=&gt; b.size } # =&gt; "000"
</pre> <p>With an argument <code>n</code> and a block, returns a new Array with at most <code>n</code> elements, in descending order per the block:</p> <pre class="ruby" data-language="ruby">['0', '00', '000'].max(2) {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["000", "00"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <span class="method-callseq"> min → element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> min { |a, b| ... } → element </span> </div> <div class="method-heading"> <span class="method-callseq"> min(n) → new_array </span> </div> <div class="method-heading"> <span class="method-callseq"> min(n) { |a, b| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
rb_ary_min(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 0, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &lt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_min_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_min_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_min_opt_float(ary, 1, result);
            }
            else {
                return ary_min_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div> <p>Returns one of the following:</p> <ul>
<li> <p>The minimum-valued element from <code>self</code>.</p> </li>
<li> <p>A new Array of minimum-valued elements selected from <code>self</code>.</p> </li>
</ul> <p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an <a href="integer.html"><code>Integer</code></a>.</p> <p>With no argument and no block, returns the element in <code>self</code> having the minimum value per method <code>&lt;=&gt;</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].min # =&gt; 0
</pre> <p>With <a href="integer.html"><code>Integer</code></a> argument <code>n</code> and no block, returns a new Array with at most <code>n</code> elements, in ascending order per method <code>&lt;=&gt;</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].min(3) # =&gt; [0, 1, 2]
[0, 1, 2, 3].min(6) # =&gt; [0, 1, 2, 3]
</pre> <p>When a block is given, the block must return an <a href="integer.html"><code>Integer</code></a>.</p> <p>With a block and no argument, calls the block <code>self.size-1</code> times to compare elements; returns the element having the minimum value per the block:</p> <pre class="ruby" data-language="ruby">['0', '00', '000'].min { |a, b| a.size &lt;=&gt; b.size } # =&gt; "0"
</pre> <p>With an argument <code>n</code> and a block, returns a new Array with at most <code>n</code> elements, in ascending order per the block:</p> <pre class="ruby" data-language="ruby">['0', '00', '000'].min(2) {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["0", "00"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-minmax"> <span class="method-callseq"> minmax → [min_val, max_val] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> minmax {|a, b| ... } → [min_val, max_val] </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="minmax-source"> <pre class="c" data-language="c">static VALUE
rb_ary_minmax(VALUE ary)
{
    if (rb_block_given_p()) {
        return rb_call_super(0, NULL);
    }
    return rb_assoc_new(rb_ary_min(0, 0, ary), rb_ary_max(0, 0, ary));
}</pre> </div> <p>Returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, either per method <code>&lt;=&gt;</code> or per a given block:.</p> <p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an <a href="integer.html"><code>Integer</code></a>; returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, per method <code>&lt;=&gt;</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].minmax # =&gt; [0, 2]
</pre> <p>When a block is given, the block must return an <a href="integer.html"><code>Integer</code></a>; the block is called <code>self.size-1</code> times to compare elements; returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, per the block:</p> <pre class="ruby" data-language="ruby">['0', '00', '000'].minmax {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["0", "000"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-none-3F"> <span class="method-callseq"> none? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> none? {|element| ... } → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> none?(obj) → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="none-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_none_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if no element of <code>self</code> meet a given criterion.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> has no truthy elements, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[nil, false].none? # =&gt; true
[nil, 0, false].none? # =&gt; false
[].none? # =&gt; true
</pre> <p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns no truthy value, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].none? {|element| element &gt; 3 } # =&gt; true
[0, 1, 2].none? {|element| element &gt; 1 } # =&gt; false
</pre> <p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> no element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">['food', 'drink'].none?(/bar/) # =&gt; true
['food', 'drink'].none?(/foo/) # =&gt; false
[].none?(/foo/) # =&gt; true
[0, 1, 2].none?(3) # =&gt; true
[0, 1, 2].none?(1) # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-none-3F"><code>Enumerable#none?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-one-3F"> <span class="method-callseq"> one? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> one? {|element| ... } → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> one?(obj) → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="one-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_one_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);
    VALUE result = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    return result;
}</pre> </div> <p>Returns <code>true</code> if exactly one element of <code>self</code> meets a given criterion.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> has exactly one truthy element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[nil, 0].one? # =&gt; true
[0, 0].one? # =&gt; false
[nil, nil].one? # =&gt; false
[].one? # =&gt; false
</pre> <p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block a truthy value for exactly one element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].one? {|element| element &gt; 0 } # =&gt; false
[0, 1, 2].one? {|element| element &gt; 1 } # =&gt; true
[0, 1, 2].one? {|element| element &gt; 2 } # =&gt; false
</pre> <p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> exactly one element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].one?(0) # =&gt; true
[0, 0, 1].one?(0) # =&gt; false
[1, 1, 2].one?(0) # =&gt; false
['food', 'drink'].one?(/bar/) # =&gt; false
['food', 'drink'].one?(/foo/) # =&gt; true
[].one?(/foo/) # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-one-3F"><code>Enumerable#one?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pack"> <span class="method-callseq"> pack(template, buffer: nil) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pack-source"> <pre class="ruby" data-language="ruby"># File pack.rb, line 7
def pack(fmt, buffer: nil)
  Primitive.pack_pack(fmt, buffer)
end</pre> </div> <p>Formats each element in <code>self</code> into a binary string; returns that string. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-permutation"> <span class="method-callseq"> permutation {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> permutation(n) {|element| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> permutation → new_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> permutation(n) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="permutation-source"> <pre class="c" data-language="c">static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_permutation_size);   /* Return enumerator if no block */
    r = n;
    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0]))
        r = NUM2LONG(argv[0]);            /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r+roomof(n, sizeof(long)));
        char *used = (char*)(p + r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, used, ary0); /* compute and yield permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div> <p>When invoked with a block, yield all permutations of elements of <code>self</code>; returns <code>self</code>. The order of permutations is indeterminate.</p> <p>When a block and an in-range positive <a href="integer.html"><code>Integer</code></a> argument <code>n</code> (<code>0 &lt; n &lt;= self.size</code>) are given, calls the block with all <code>n</code>-tuple permutations of <code>self</code>.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation(2) {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 1]
[0, 2]
[1, 0]
[1, 2]
[2, 0]
[2, 1]
</pre> <p>Another example:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation(3) {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 1, 2]
[0, 2, 1]
[1, 0, 2]
[1, 2, 0]
[2, 0, 1]
[2, 1, 0]
</pre> <p>When <code>n</code> is zero, calls the block once with a new empty Array:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation(0) {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[]
</pre> <p>When <code>n</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation(-1) {|permutation| fail 'Cannot happen' }
a.permutation(4) {|permutation| fail 'Cannot happen' }
</pre> <p>When a block given but no argument, behaves the same as <code>a.permutation(a.size)</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 1, 2]
[0, 2, 1]
[1, 0, 2]
[1, 2, 0]
[2, 0, 1]
[2, 1, 0]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.permutation # =&gt; #&lt;Enumerator: [0, 1, 2]:permutation&gt;
a.permutation(2) # =&gt; #&lt;Enumerator: [0, 1, 2]:permutation(2)&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pop"> <span class="method-callseq"> pop → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> pop(n) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="pop-source"> <pre class="c" data-language="c">static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    ary_verify(ary);
    return result;
}</pre> </div> <p>Removes and returns trailing elements.</p> <p>When no argument is given and <code>self</code> is not empty, removes and returns the last element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.pop # =&gt; 2
a # =&gt; [:foo, "bar"]
</pre> <p>Returns <code>nil</code> if the array is empty.</p> <p>When a non-negative <a href="integer.html"><code>Integer</code></a> argument <code>n</code> is given and is in range,</p> <p>removes and returns the last <code>n</code> elements in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.pop(2) # =&gt; ["bar", 2]
</pre> <p>If <code>n</code> is positive and out of range, removes and returns all elements:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.pop(50) # =&gt; [:foo, "bar", 2]
</pre> <p>Related: <a href="array.html#method-i-push"><code>push</code></a>, <a href="array.html#method-i-shift"><code>shift</code></a>, <a href="array.html#method-i-unshift"><code>unshift</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-prepend"> <span class="method-name">prepend</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-unshift">unshift</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-product"> <span class="method-callseq"> product(*other_arrays) → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> product(*other_arrays) {|combination| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="product-source"> <pre class="c" data-language="c">static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = rb_ary_hidden_new(n);
    volatile VALUE t1 = Qundef;
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we're computing the product of */
    int *counters = ALLOCV_N(int, t1, n); /* The current position in each one */
    VALUE result = Qnil;      /* The array we'll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC_CLEAR_CLASS(t0);

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]);
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            if (MUL_OVERFLOW_LONG_P(resultlen, k))
                rb_raise(rb_eRangeError, "too big to product");
            resultlen *= k;
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if (NIL_P(result)) {
            FL_SET(t0, RARRAY_SHARED_ROOT_FLAG);
            rb_yield(subarray);
            if (!FL_TEST(t0, RARRAY_SHARED_ROOT_FLAG)) {
                rb_raise(rb_eRuntimeError, "product reentered");
            }
            else {
                FL_UNSET(t0, RARRAY_SHARED_ROOT_FLAG);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overflows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }

done:
    ALLOCV_END(t1);

    return NIL_P(result) ? ary : result;
}</pre> </div> <p>Computes and returns or yields all combinations of elements from all the Arrays, including both <code>self</code> and <code>other_arrays</code>:</p> <ul>
<li> <p>The number of combinations is the product of the sizes of all the arrays, including both <code>self</code> and <code>other_arrays</code>.</p> </li>
<li> <p>The order of the returned combinations is indeterminate.</p> </li>
</ul> <p>When no block is given, returns the combinations as an Array of Arrays:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a1 = [3, 4]
a2 = [5, 6]
p = a.product(a1)
p.size # =&gt; 6 # a.size * a1.size
p # =&gt; [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]
p = a.product(a1, a2)
p.size # =&gt; 12 # a.size * a1.size * a2.size
p # =&gt; [[0, 3, 5], [0, 3, 6], [0, 4, 5], [0, 4, 6], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]
</pre> <p>If any argument is an empty Array, returns an empty Array.</p> <p>If no argument is given, returns an Array of 1-element Arrays, each containing an element of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.product # =&gt; [[0], [1], [2]]
</pre> <p>When a block is given, yields each combination as an Array; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.product(a1) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 3]
[0, 4]
[1, 3]
[1, 4]
[2, 3]
[2, 4]
</pre> <p>If any argument is an empty Array, does not call the block:</p> <pre class="ruby" data-language="ruby">a.product(a1, a2, []) {|combination| fail 'Cannot happen' }
</pre> <p>If no argument is given, yields each element of <code>self</code> as a 1-element Array:</p> <pre class="ruby" data-language="ruby">a.product {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0]
[1]
[2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-push"> <span class="method-callseq"> push(*objects) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="push-source"> <pre class="c" data-language="c">static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    return rb_ary_cat(ary, argv, argc);
}</pre> </div> <p>Appends trailing elements.</p> <p>Appends each argument in <code>objects</code> to <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.push(:baz, :bat) # =&gt; [:foo, "bar", 2, :baz, :bat]
</pre> <p>Appends each argument as one element, even if it is another Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.push([:baz, :bat], [:bam, :bad])
a1 # =&gt; [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
</pre> <p>Related: <a href="array.html#method-i-pop"><code>pop</code></a>, <a href="array.html#method-i-shift"><code>shift</code></a>, <a href="array.html#method-i-unshift"><code>unshift</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-append">append</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rassoc"> <span class="method-callseq"> rassoc(obj) → found_array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rassoc-source"> <pre class="c" data-language="c">VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (RB_TYPE_P(v, T_ARRAY) &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 1), value))
            return v;
    }
    return Qnil;
}</pre> </div> <p>Returns the first element in <code>self</code> that is an Array whose second element <code>==</code> <code>obj</code>:</p> <pre class="ruby" data-language="ruby">a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
a.rassoc(4) # =&gt; [2, 4]
</pre> <p>Returns <code>nil</code> if no such element is found.</p> <p>Related: <a href="array.html#method-i-assoc"><code>assoc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reject"> <span class="method-callseq"> reject {|element| ... } → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reject(VALUE ary)
{
    VALUE rejected_ary;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rejected_ary = rb_ary_new();
    ary_reject(ary, rejected_ary);
    return rejected_ary;
}</pre> </div> <p>Returns a new Array whose elements are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a1 = a.reject {|element| element.to_s.start_with?('b') }
a1 # =&gt; [:foo, 2]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.reject # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:reject&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reject-21"> <span class="method-callseq"> reject! {|element| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reject_bang(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    return ary_reject_bang(ary);
}</pre> </div> <p>Removes each element for which the block returns a truthy value.</p> <p>Returns <code>self</code> if any elements removed:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a.reject! {|element| element.to_s.start_with?('b') } # =&gt; [:foo, 2]
</pre> <p>Returns <code>nil</code> if no elements removed.</p> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.reject! # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:reject!&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-repeated_combination"> <span class="method-callseq"> repeated_combination(n) {|combination| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> repeated_combination(n) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="repeated_combination-source"> <pre class="c" data-language="c">static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_combination_size);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, n);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rcombinate0(len, n, p, n, ary0); /* compute and yield repeated combinations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div> <p>Calls the block with each repeated combination of length <code>n</code> of the elements of <code>self</code>; each combination is an Array; returns <code>self</code>. The order of the combinations is indeterminate.</p> <p>When a block and a positive <a href="integer.html"><code>Integer</code></a> argument <code>n</code> are given, calls the block with each <code>n</code>-tuple repeated combination of the elements of <code>self</code>. The number of combinations is <code>(n+1)(n+2)/2</code>.</p> <p><code>n</code> = 1:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.repeated_combination(1) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0]
[1]
[2]
</pre> <p><code>n</code> = 2:</p> <pre class="ruby" data-language="ruby">a.repeated_combination(2) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 0]
[0, 1]
[0, 2]
[1, 1]
[1, 2]
[2, 2]
</pre> <p>If <code>n</code> is zero, calls the block once with an empty Array.</p> <p>If <code>n</code> is negative, does not call the block:</p> <pre class="ruby" data-language="ruby">a.repeated_combination(-1) {|combination| fail 'Cannot happen' }
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.repeated_combination(2) # =&gt; #&lt;Enumerator: [0, 1, 2]:combination(2)&gt;
</pre> <p>Using Enumerators, it’s convenient to show the combinations and counts for some values of <code>n</code>:</p> <pre class="ruby" data-language="ruby">e = a.repeated_combination(0)
e.size # =&gt; 1
e.to_a # =&gt; [[]]
e = a.repeated_combination(1)
e.size # =&gt; 3
e.to_a # =&gt; [[0], [1], [2]]
e = a.repeated_combination(2)
e.size # =&gt; 6
e.to_a # =&gt; [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-repeated_permutation"> <span class="method-callseq"> repeated_permutation(n) {|permutation| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> repeated_permutation(n) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="repeated_permutation-source"> <pre class="c" data-language="c">static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_permutation_size);      /* Return Enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rpermute0(n, r, p, ary0); /* compute and yield repeated permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div> <p>Calls the block with each repeated permutation of length <code>n</code> of the elements of <code>self</code>; each permutation is an Array; returns <code>self</code>. The order of the permutations is indeterminate.</p> <p>When a block and a positive <a href="integer.html"><code>Integer</code></a> argument <code>n</code> are given, calls the block with each <code>n</code>-tuple repeated permutation of the elements of <code>self</code>. The number of permutations is <code>self.size**n</code>.</p> <p><code>n</code> = 1:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.repeated_permutation(1) {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0]
[1]
[2]
</pre> <p><code>n</code> = 2:</p> <pre class="ruby" data-language="ruby">a.repeated_permutation(2) {|permutation| p permutation }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[0, 0]
[0, 1]
[0, 2]
[1, 0]
[1, 1]
[1, 2]
[2, 0]
[2, 1]
[2, 2]
</pre> <p>If <code>n</code> is zero, calls the block once with an empty Array.</p> <p>If <code>n</code> is negative, does not call the block:</p> <pre class="ruby" data-language="ruby">a.repeated_permutation(-1) {|permutation| fail 'Cannot happen' }
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.repeated_permutation(2) # =&gt; #&lt;Enumerator: [0, 1, 2]:permutation(2)&gt;
</pre> <p>Using Enumerators, it’s convenient to show the permutations and counts for some values of <code>n</code>:</p> <pre class="ruby" data-language="ruby">e = a.repeated_permutation(0)
e.size # =&gt; 1
e.to_a # =&gt; [[]]
e = a.repeated_permutation(1)
e.size # =&gt; 3
e.to_a # =&gt; [[0], [1], [2]]
e = a.repeated_permutation(2)
e.size # =&gt; 9
e.to_a # =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-replace"> <span class="method-callseq"> replace(other_array) → self </span> </div> </div> <div class="method-description"> <p>Replaces the content of <code>self</code> with the content of <code>other_array</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.replace(['foo', :bar, 3]) # =&gt; ["foo", :bar, 3]
</pre> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-initialize_copy">initialize_copy</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse"> <span class="method-callseq"> reverse → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_m(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE dup = rb_ary_new2(len);

    if (len &gt; 0) {
        const VALUE *p1 = RARRAY_CONST_PTR(ary);
        VALUE *p2 = (VALUE *)RARRAY_CONST_PTR(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    ARY_SET_LEN(dup, RARRAY_LEN(ary));
    return dup;
}</pre> </div> <p>Returns a new Array with the elements of <code>self</code> in reverse order:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'two']
a1 = a.reverse
a1 # =&gt; ["two", "bar", "foo"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse-21"> <span class="method-callseq"> reverse! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</pre> </div> <p>Reverses <code>self</code> in place:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'two']
a.reverse! # =&gt; ["two", "bar", "foo"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_each"> <span class="method-callseq"> reverse_each {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reverse_each → Enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse_each-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }
    return ary;
}</pre> </div> <p>Iterates backwards over array elements.</p> <p>When a block given, passes, in reverse order, each element to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.reverse_each {|element|  puts "#{element.class} #{element}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Integer 2
String bar
Symbol foo
</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">2
bar
</pre> <p>When no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
e = a.reverse_each
e # =&gt; #&lt;Enumerator: [:foo, "bar", 2]:reverse_each&gt;
a1 = e.each {|element|  puts "#{element.class} #{element}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Integer 2
String bar
Symbol foo
</pre> <p>Related: <a href="array.html#method-i-each"><code>each</code></a>, <a href="array.html#method-i-each_index"><code>each_index</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rindex"> <span class="method-callseq"> rindex(object) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rindex {|element| ... } → integer or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> rindex → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="rindex-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary), len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i))))
                return LONG2NUM(i);
            if (i &gt; (len = RARRAY_LEN(ary))) {
                i = len;
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn("given block not used");
    while (i--) {
        VALUE e = RARRAY_AREF(ary, i);
        if (rb_equal(e, val)) {
            return LONG2NUM(i);
        }
        if (i &gt; RARRAY_LEN(ary)) {
            break;
        }
    }
    return Qnil;
}</pre> </div> <p>Returns the index of the last element for which <code>object == element</code>.</p> <p>When argument <code>object</code> is given but no block, returns the index of the last such element found:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.rindex('bar') # =&gt; 3
</pre> <p>Returns <code>nil</code> if no such object found.</p> <p>When a block is given but no argument, calls the block with each successive element; returns the index of the last element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.rindex {|element| element == 'bar' } # =&gt; 3
</pre> <p>Returns <code>nil</code> if the block never returns a truthy value.</p> <p>When neither an argument nor a block is given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
e = a.rindex
e # =&gt; #&lt;Enumerator: [:foo, "bar", 2, "bar"]:rindex&gt;
e.each {|element| element == 'bar' } # =&gt; 3
</pre> <p>Related: <a href="array.html#method-i-index"><code>index</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rotate"> <span class="method-callseq"> rotate → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rotate(count) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="rotate-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated;
    const VALUE *ptr;
    long len;
    long cnt = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);

    len = RARRAY_LEN(ary);
    rotated = rb_ary_new2(len);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_CONST_PTR(ary);
        len -= cnt;
        ary_memcpy(rotated, 0, len, ptr + cnt);
        ary_memcpy(rotated, len, cnt, ptr);
    }
    ARY_SET_LEN(rotated, RARRAY_LEN(ary));
    return rotated;
}</pre> </div> <p>Returns a new Array formed from <code>self</code> with elements rotated from one end to the other.</p> <p>When no argument given, returns a new Array that is like <code>self</code>, except that the first element has been rotated to the last position:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a1 = a.rotate
a1 # =&gt; ["bar", 2, "bar", :foo]
</pre> <p>When given a non-negative <a href="integer.html"><code>Integer</code></a> <code>count</code>, returns a new Array with <code>count</code> elements rotated from the beginning to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.rotate(2)
a1 # =&gt; [2, :foo, "bar"]
</pre> <p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.rotate(20)
a1 # =&gt; [2, :foo, "bar"]
</pre> <p>If <code>count</code> is zero, returns a copy of <code>self</code>, unmodified:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.rotate(0)
a1 # =&gt; [:foo, "bar", 2]
</pre> <p>When given a negative <a href="integer.html"><code>Integer</code></a> <code>count</code>, rotates in the opposite direction, from end to beginning:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.rotate(-2)
a1 # =&gt; ["bar", 2, :foo]
</pre> <p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.rotate(-5)
a1 # =&gt; ["bar", 2, :foo]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rotate-21"> <span class="method-callseq"> rotate! → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rotate!(count) → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="rotate-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);
    rb_ary_rotate(ary, n);
    return ary;
}</pre> </div> <p>Rotates <code>self</code> in place by moving elements from one end to the other; returns <code>self</code>.</p> <p>When no argument given, rotates the first element to the last position:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.rotate! # =&gt; ["bar", 2, "bar", :foo]
</pre> <p>When given a non-negative <a href="integer.html"><code>Integer</code></a> <code>count</code>, rotates <code>count</code> elements from the beginning to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.rotate!(2)
a # =&gt; [2, :foo, "bar"]
</pre> <p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.rotate!(20)
a # =&gt; [2, :foo, "bar"]
</pre> <p>If <code>count</code> is zero, returns <code>self</code> unmodified:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.rotate!(0)
a # =&gt; [:foo, "bar", 2]
</pre> <p>When given a negative <a href="integer.html"><code>Integer</code></a> <code>count</code>, rotates in the opposite direction, from end to beginning:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.rotate!(-2)
a # =&gt; ["bar", 2, :foo]
</pre> <p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.rotate!(-5)
a # =&gt; ["bar", 2, :foo]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sample"> <span class="method-callseq"> sample(random: Random) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sample(n, random: Random) → new_ary </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sample-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 60
def sample(n = (ary = false), random: Random)
  if Primitive.mandatory_only?
    # Primitive.cexpr! %{ rb_ary_sample(self, rb_cRandom, Qfalse, Qfalse) }
    Primitive.ary_sample0
  else
    # Primitive.cexpr! %{ rb_ary_sample(self, random, n, ary) }
    Primitive.ary_sample(random, n, ary)
  end
end</pre> </div> <p>Returns random elements from <code>self</code>.</p> <p>When no arguments are given, returns a random element from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a.sample # =&gt; 3
a.sample # =&gt; 8
</pre> <p>If <code>self</code> is empty, returns <code>nil</code>.</p> <p>When argument <code>n</code> is given, returns a new Array containing <code>n</code> random elements from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.sample(3) # =&gt; [8, 9, 2]
a.sample(6) # =&gt; [9, 6, 10, 3, 1, 4]
</pre> <p>Returns no more than <code>a.size</code> elements (because no new duplicates are introduced):</p> <pre class="ruby" data-language="ruby">a.sample(a.size * 2) # =&gt; [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]
</pre> <p>But <code>self</code> may contain duplicates:</p> <pre class="ruby" data-language="ruby">a = [1, 1, 1, 2, 2, 3]
a.sample(a.size * 2) # =&gt; [1, 1, 3, 2, 1, 2]
</pre> <p>The argument <code>n</code> must be a non-negative numeric value. The order of the result array is unrelated to the order of <code>self</code>. Returns a new empty Array if <code>self</code> is empty.</p> <p>The optional <code>random</code> argument will be used as the random number generator:</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a.sample(random: Random.new(1))     #=&gt; 6
a.sample(4, random: Random.new(1))  #=&gt; [6, 10, 9, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|element| ... } → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}</pre> </div> <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array containing those elements of <code>self</code> for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a1 = a.select {|element| element.to_s.start_with?('b') }
a1 # =&gt; ["bar", :bam]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select # =&gt; #&lt;Enumerator: [:foo, "bar", 2, :bam]:select&gt;
</pre>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-select-21"> <span class="method-callseq"> select! {|element| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="select-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_select_bang(VALUE ary)
{
    struct select_bang_arg args;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);

    args.ary = ary;
    args.len[0] = args.len[1] = 0;
    return rb_ensure(select_bang_i, (VALUE)&amp;args, select_bang_ensure, (VALUE)&amp;args);
}</pre> </div> <p>Calls the block, if given with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p> <p>Returns <code>self</code> if any elements were removed:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select! {|element| element.to_s.start_with?('b') } # =&gt; ["bar", :bam]
</pre> <p>Returns <code>nil</code> if no elements were removed.</p> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select! # =&gt; #&lt;Enumerator: [:foo, "bar", 2, :bam]:select!&gt;
</pre>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-filter-21">filter!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shelljoin"> <span class="method-callseq"> shelljoin → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shelljoin-source"> <pre class="ruby" data-language="ruby"># File lib/shellwords.rb, line 239
def shelljoin
  Shellwords.join(self)
end</pre> </div> <p>Builds a command line string from an argument list <code>array</code> joining all elements escaped for the Bourne shell and separated by a space.</p> <p>See <a href="shellwords.html#method-c-shelljoin"><code>Shellwords.shelljoin</code></a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shift"> <span class="method-callseq"> shift → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> shift(n) → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="c" data-language="c">static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    rb_ary_behead(ary,n);

    return result;
}</pre> </div> <p>Removes and returns leading elements.</p> <p>When no argument is given, removes and returns the first element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.shift # =&gt; :foo
a # =&gt; ['bar', 2]
</pre> <p>Returns <code>nil</code> if <code>self</code> is empty.</p> <p>When positive <a href="integer.html"><code>Integer</code></a> argument <code>n</code> is given, removes the first <code>n</code> elements; returns those elements in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.shift(2) # =&gt; [:foo, 'bar']
a # =&gt; [2]
</pre> <p>If <code>n</code> is as large as or larger than <code>self.length</code>, removes all elements; returns those elements in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.shift(3) # =&gt; [:foo, 'bar', 2]
</pre> <p>If <code>n</code> is zero, returns a new empty Array; <code>self</code> is unmodified.</p> <p>Related: <a href="array.html#method-i-push"><code>push</code></a>, <a href="array.html#method-i-pop"><code>pop</code></a>, <a href="array.html#method-i-unshift"><code>unshift</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shuffle"> <span class="method-callseq"> shuffle(random: Random) → new_ary </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shuffle-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 26
def shuffle(random: Random)
  Primitive.rb_ary_shuffle(random)
end</pre> </div> <p>Returns a new array with elements of <code>self</code> shuffled.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3] #=&gt; [1, 2, 3]
a.shuffle     #=&gt; [2, 3, 1]
a             #=&gt; [1, 2, 3]
</pre> <p>The optional <code>random</code> argument will be used as the random number generator:</p> <pre class="ruby" data-language="ruby">a.shuffle(random: Random.new(1))  #=&gt; [1, 3, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shuffle-21"> <span class="method-callseq"> shuffle!(random: Random) → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shuffle-21-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 12
def shuffle!(random: Random)
  Primitive.rb_ary_shuffle_bang(random)
end</pre> </div> <p>Shuffles the elements of <code>self</code> in place.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3] #=&gt; [1, 2, 3]
a.shuffle!    #=&gt; [2, 3, 1]
a             #=&gt; [2, 3, 1]
</pre> <p>The optional <code>random</code> argument will be used as the random number generator:</p> <pre class="ruby" data-language="ruby">a.shuffle!(random: Random.new(1))  #=&gt; [1, 3, 2]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-name">size</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-length">length</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-slice"> <span class="method-callseq"> slice(index) → object or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice(start, length) → object or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice(range) → object or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice(aseq) → object or nil </span> </div> </div> <div class="method-description"> <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p> <p>When a single <a href="integer.html"><code>Integer</code></a> argument <code>index</code> is given, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] # =&gt; :foo
a[2] # =&gt; 2
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>index</code> is negative, counts relative to the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] # =&gt; 2
a[-2] # =&gt; "bar"
</pre> <p>If <code>index</code> is out of range, returns <code>nil</code>.</p> <p>When two <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new Array of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] # =&gt; [:foo, "bar"]
a[1, 2] # =&gt; ["bar", 2]
</pre> <p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 4] # =&gt; [:foo, "bar", 2]
a[1, 3] # =&gt; ["bar", 2]
a[2, 2] # =&gt; [2]
</pre> <p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty Array.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>When a single <a href="range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] # =&gt; [:foo, "bar"]
a[1..2] # =&gt; ["bar", 2]
</pre> <p>Special case: If <code>range.start == a.size</code>, returns a new empty Array.</p> <p>If <code>range.end</code> is negative, calculates the end index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..-1] # =&gt; [:foo, "bar", 2]
a[0..-2] # =&gt; [:foo, "bar"]
a[0..-3] # =&gt; [:foo]
</pre> <p>If <code>range.start</code> is negative, calculates the start index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1..2] # =&gt; [2]
a[-2..2] # =&gt; ["bar", 2]
a[-3..2] # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[4..1] # =&gt; nil
a[4..0] # =&gt; nil
a[4..-1] # =&gt; nil
</pre> <p>When a single <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an Array of elements corresponding to the indexes produced by the sequence.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..).step(2)] # =&gt; ["data1", "data2", "data3"]
</pre> <p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="rangeerror.html"><code>RangeError</code></a>.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..11).step(2)]
# RangeError (((1..11).step(2)) out of range)
a[(7..).step(2)]
# RangeError (((7..).step(2)) out of range)
</pre> <p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="integer.html"><code>Integer</code></a>, and raises if it is impossible:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
# Raises TypeError (no implicit conversion of Symbol into Integer):
a[:foo]
</pre> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-slice-21"> <span class="method-callseq"> slice!(n) → object or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> slice!(start, length) → new_array or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice!(range) → new_array or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="slice-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1;
    long pos, len;

    rb_ary_modify_check(ary);
    rb_check_arity(argc, 1, 2);
    arg1 = argv[0];

    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
    }

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</pre> </div> <p>Removes and returns elements from <code>self</code>.</p> <p>When the only argument is an <a href="integer.html"><code>Integer</code></a> <code>n</code>, removes and returns the <em>nth</em> element in <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(1) # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>If <code>n</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(-1) # =&gt; 2
a # =&gt; [:foo, "bar"]
</pre> <p>If <code>n</code> is out of range, returns <code>nil</code>.</p> <p>When the only arguments are Integers <code>start</code> and <code>length</code>, removes <code>length</code> elements from <code>self</code> beginning at offset <code>start</code>; returns the deleted objects in a new Array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(0, 2) # =&gt; [:foo, "bar"]
a # =&gt; [2]
</pre> <p>If <code>start + length</code> exceeds the array size, removes and returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(1, 50) # =&gt; ["bar", 2]
a # =&gt; [:foo]
</pre> <p>If <code>start == a.size</code> and <code>length</code> is non-negative, returns a new empty Array.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>When the only argument is a <a href="range.html"><code>Range</code></a> object <code>range</code>, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(1..2) # =&gt; ["bar", 2]
a # =&gt; [:foo]
</pre> <p>If <code>range.start == a.size</code>, returns a new empty Array.</p> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p> <p>If <code>range.end</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(0..-2) # =&gt; [:foo, "bar"]
a # =&gt; [2]
</pre> <p>If <code>range.start</code> is negative, calculates the start index backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.slice!(-2..2) # =&gt; ["bar", 2]
a # =&gt; [:foo]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sort"> <span class="method-callseq"> sort → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sort {|a, b| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sort-source"> <pre class="c" data-language="c">VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</pre> </div> <p>Returns a new Array whose elements are those from <code>self</code>, sorted.</p> <p>With no block, compares elements using operator <code>&lt;=&gt;</code> (see <a href="comparable.html"><code>Comparable</code></a>):</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a1 = a.sort
a1 # =&gt; ["a", "b", "c", "d", "e"]
</pre> <p>With a block, calls the block with each element pair; for each element pair <code>a</code> and <code>b</code>, the block should return an integer:</p> <ul>
<li> <p>Negative when <code>b</code> is to follow <code>a</code>.</p> </li>
<li> <p>Zero when <code>a</code> and <code>b</code> are equivalent.</p> </li>
<li> <p>Positive when <code>a</code> is to follow <code>b</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a1 = a.sort {|a, b| a &lt;=&gt; b }
a1 # =&gt; ["a", "b", "c", "d", "e"]
a2 = a.sort {|a, b| b &lt;=&gt; a }
a2 # =&gt; ["e", "d", "c", "b", "a"]
</pre> <p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable:</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a1 = a.sort {|a, b| 0 }
a1 # =&gt;  ["c", "e", "b", "d", "a"]
</pre> <p>Related: <a href="enumerable.html#method-i-sort_by"><code>Enumerable#sort_by</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sort-21"> <span class="method-callseq"> sort! → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sort! {|a, b| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sort-21-source"> <pre class="c" data-language="c">VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    assert(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;
        long len = RARRAY_LEN(ary);
        RBASIC_CLEAR_CLASS(tmp);
        data.ary = tmp;
        data.receiver = ary;
        RARRAY_PTR_USE(tmp, ptr, {
            ruby_qsort(ptr, len, sizeof(VALUE),
                       rb_block_given_p()?sort_1:sort_2, &amp;data);
        }); /* WB: no new reference */
        rb_ary_modify(ary);
        if (ARY_EMBED_P(tmp)) {
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
                FL_SET_EMBED(ary);
            }
            ary_memcpy(ary, 0, ARY_EMBED_LEN(tmp), ARY_EMBED_PTR(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            if (!ARY_EMBED_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            else {
                assert(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    ary_heap_free(ary);
                }
                ARY_SET_PTR(ary, ARY_HEAP_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, len);
                ARY_SET_CAPA(ary, ARY_HEAP_LEN(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC'ed. */
        RBASIC_SET_CLASS_RAW(tmp, rb_cArray); /* rb_cArray must be marked */
    }
    ary_verify(ary);
    return ary;
}</pre> </div> <p>Returns <code>self</code> with its elements sorted in place.</p> <p>With no block, compares elements using operator <code>&lt;=&gt;</code> (see <a href="comparable.html"><code>Comparable</code></a>):</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a.sort!
a # =&gt; ["a", "b", "c", "d", "e"]
</pre> <p>With a block, calls the block with each element pair; for each element pair <code>a</code> and <code>b</code>, the block should return an integer:</p> <ul>
<li> <p>Negative when <code>b</code> is to follow <code>a</code>.</p> </li>
<li> <p>Zero when <code>a</code> and <code>b</code> are equivalent.</p> </li>
<li> <p>Positive when <code>a</code> is to follow <code>b</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a.sort! {|a, b| a &lt;=&gt; b }
a # =&gt; ["a", "b", "c", "d", "e"]
a.sort! {|a, b| b &lt;=&gt; a }
a # =&gt; ["e", "d", "c", "b", "a"]
</pre> <p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable:</p> <pre class="ruby" data-language="ruby">a = 'abcde'.split('').shuffle
a # =&gt; ["e", "b", "d", "a", "c"]
a.sort! {|a, b| 0 }
a # =&gt; ["d", "e", "c", "a", "b"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sort_by-21"> <span class="method-callseq"> sort_by! {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sort_by! → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sort_by-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern("sort_by"), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</pre> </div> <p>Sorts the elements of <code>self</code> in place, using an ordering determined by the block; returns self.</p> <p>Calls the block with each successive element; sorts elements based on the values returned from the block.</p> <p>For duplicates returned by the block, the ordering is indeterminate, and may be unstable.</p> <p>This example sorts strings based on their sizes:</p> <pre class="ruby" data-language="ruby">a = ['aaaa', 'bbb', 'cc', 'd']
a.sort_by! {|element| element.size }
a # =&gt; ["d", "cc", "bbb", "aaaa"]
</pre> <p>Returns a new <a href="enumerator.html"><code>Enumerator</code></a> if no block given:</p> <pre class="ruby" data-language="ruby">a = ['aaaa', 'bbb', 'cc', 'd']
a.sort_by! # =&gt; #&lt;Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sum"> <span class="method-callseq"> sum(init = 0) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sum(init = 0) {|element| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="c" data-language="c">static VALUE
rb_ary_sum(int argc, VALUE *argv, VALUE ary)
{
    VALUE e, v, r;
    long i, n;
    int block_given;

    v = (rb_check_arity(argc, 0, 1) ? argv[0] : LONG2FIX(0));

    block_given = rb_block_given_p();

    if (RARRAY_LEN(ary) == 0)
        return v;

    n = 0;
    r = Qundef;

    if (!FIXNUM_P(v) &amp;&amp; !RB_BIGNUM_TYPE_P(v) &amp;&amp; !RB_TYPE_P(v, T_RATIONAL)) {
        i = 0;
        goto init_is_a_value;
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
        if (FIXNUM_P(e)) {
            n += FIX2LONG(e); /* should not overflow long type */
            if (!FIXABLE(n)) {
                v = rb_big_plus(LONG2NUM(n), v);
                n = 0;
            }
        }
        else if (RB_BIGNUM_TYPE_P(e))
            v = rb_big_plus(e, v);
        else if (RB_TYPE_P(e, T_RATIONAL)) {
            if (UNDEF_P(r))
                r = e;
            else
                r = rb_rational_plus(r, e);
        }
        else
            goto not_exact;
    }
    v = finish_exact_sum(n, r, v, argc!=0);
    return v;

  not_exact:
    v = finish_exact_sum(n, r, v, i!=0);

    if (RB_FLOAT_TYPE_P(e)) {
        /*
         * Kahan-Babuska balancing compensated summation algorithm
         * See https://link.springer.com/article/10.1007/s00607-005-0139-x
         */
        double f, c;
        double x, t;

        f = NUM2DBL(v);
        c = 0.0;
        goto has_float_value;
        for (; i &lt; RARRAY_LEN(ary); i++) {
            e = RARRAY_AREF(ary, i);
            if (block_given)
                e = rb_yield(e);
            if (RB_FLOAT_TYPE_P(e))
              has_float_value:
                x = RFLOAT_VALUE(e);
            else if (FIXNUM_P(e))
                x = FIX2LONG(e);
            else if (RB_BIGNUM_TYPE_P(e))
                x = rb_big2dbl(e);
            else if (RB_TYPE_P(e, T_RATIONAL))
                x = rb_num2dbl(e);
            else
                goto not_float;

            if (isnan(f)) continue;
            if (isnan(x)) {
                f = x;
                continue;
            }
            if (isinf(x)) {
                if (isinf(f) &amp;&amp; signbit(x) != signbit(f))
                    f = NAN;
                else
                    f = x;
                continue;
            }
            if (isinf(f)) continue;

            t = f + x;
            if (fabs(f) &gt;= fabs(x))
                c += ((f - t) + x);
            else
                c += ((x - t) + f);
            f = t;
        }
        f += c;
        return DBL2NUM(f);

      not_float:
        v = DBL2NUM(f);
    }

    goto has_some_value;
    init_is_a_value:
    for (; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
      has_some_value:
        v = rb_funcall(v, idPLUS, 1, e);
    }
    return v;
}</pre> </div> <p>When no block is given, returns the object equivalent to:</p> <pre class="ruby" data-language="ruby">sum = init
array.each {|element| sum += element }
sum
</pre> <p>For example, <code>[e1, e2, e3].sum</code> returns <code>init + e1 + e2 + e3</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3]
a.sum # =&gt; 6
a.sum(100) # =&gt; 106
</pre> <p>The elements need not be numeric, but must be <code>+</code>-compatible with each other and with <code>init</code>:</p> <pre class="ruby" data-language="ruby">a = ['abc', 'def', 'ghi']
a.sum('jkl') # =&gt; "jklabcdefghi"
</pre> <p>When a block is given, it is called with each element and the block’s return value (instead of the element itself) is used as the addend:</p> <pre class="ruby" data-language="ruby">a = ['zero', 1, :two]
s = a.sum('Coerced and concatenated: ') {|element| element.to_s }
s # =&gt; "Coerced and concatenated: zero1two"
</pre> <p>Notes:</p> <ul>
<li> <p><a href="array.html#method-i-join"><code>Array#join</code></a> and <a href="array.html#method-i-flatten"><code>Array#flatten</code></a> may be faster than <a href="array.html#method-i-sum"><code>Array#sum</code></a> for an Array of Strings or an Array of Arrays.</p> </li>
<li> <p><a href="array.html#method-i-sum"><code>Array#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="integer.html#method-i-2B"><code>Integer#+</code></a>.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-take"> <span class="method-callseq"> take(n) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="take-source"> <pre class="c" data-language="c">static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to take negative size");
    }
    return rb_ary_subseq(obj, 0, len);
}</pre> </div> <p>Returns a new Array containing the first <code>n</code> element of <code>self</code>, where <code>n</code> is a non-negative <a href="integer.html"><code>Integer</code></a>; does not modify <code>self</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.take(1) # =&gt; [0]
a.take(2) # =&gt; [0, 1]
a.take(50) # =&gt; [0, 1, 2, 3, 4, 5]
a # =&gt; [0, 1, 2, 3, 4, 5]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-take_while"> <span class="method-callseq"> take_while {|element| ... } → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> take_while → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="take_while-source"> <pre class="c" data-language="c">static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</pre> </div> <p>Returns a new Array containing zero or more leading elements of <code>self</code>; does not modify <code>self</code>.</p> <p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new Array containing those elements for which the block returned a truthy value:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.take_while {|element| element &lt; 3 } # =&gt; [0, 1, 2]
a.take_while {|element| true } # =&gt; [0, 1, 2, 3, 4, 5]
a # =&gt; [0, 1, 2, 3, 4, 5]
</pre> <p>With no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">[0, 1].take_while # =&gt; #&lt;Enumerator: [0, 1]:take_while&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → self or new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}</pre> </div> <p>When <code>self</code> is an instance of Array, returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.to_a # =&gt; [:foo, "bar", 2]
</pre> <p>Otherwise, returns a new Array containing the elements of <code>self</code>:</p> <pre class="ruby" data-language="ruby">class MyArray &lt; Array; end
a = MyArray.new(['foo', 'bar', 'two'])
a.instance_of?(Array) # =&gt; false
a.kind_of?(Array) # =&gt; true
a1 = a.to_a
a1 # =&gt; ["foo", "bar", "two"]
a1.class # =&gt; Array # Not MyArray
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_ary"> <span class="method-callseq"> to_ary → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_ary-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</pre> </div> <p>Returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|item| ... } → new_hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_h(VALUE ary)
{
    long i;
    VALUE hash = rb_hash_new_with_size(RARRAY_LEN(ary));
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        const VALUE e = rb_ary_elt(ary, i);
        const VALUE elt = block_given ? rb_yield_force_blockarg(e) : e;
        const VALUE key_value_pair = rb_check_array_type(elt);
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, "wrong element type %"PRIsVALUE" at %ld (expected array)",
                     rb_obj_class(elt), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, "wrong array length at %ld (expected 2, was %ld)",
                i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }
    return hash;
}</pre> </div> <p>Returns a new <a href="hash.html"><code>Hash</code></a> formed from <code>self</code>.</p> <p>When a block is given, calls the block with each array element; the block must return a 2-element Array whose two elements form a key-value pair in the returned Hash:</p> <pre class="ruby" data-language="ruby">a = ['foo', :bar, 1, [2, 3], {baz: 4}]
h = a.to_h {|item| [item, item] }
h # =&gt; {"foo"=&gt;"foo", :bar=&gt;:bar, 1=&gt;1, [2, 3]=&gt;[2, 3], {:baz=&gt;4}=&gt;{:baz=&gt;4}}
</pre> <p>When no block is given, <code>self</code> must be an Array of 2-element sub-arrays, each sub-array is formed into a key-value pair in the new Hash:</p> <pre class="ruby" data-language="ruby">[].to_h # =&gt; {}
a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
h = a.to_h
h # =&gt; {"foo"=&gt;"zero", "bar"=&gt;"one", "baz"=&gt;"two"}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span> </div> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-transpose"> <span class="method-callseq"> transpose → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="transpose-source"> <pre class="c" data-language="c">static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {         /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, "element size differs (%ld should be %ld)",
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}</pre> </div> <p>Transposes the rows and columns in an Array of Arrays; the nested Arrays must all be the same size:</p> <pre class="ruby" data-language="ruby">a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
a.transpose # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-union"> <span class="method-callseq"> union(*other_arrays) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="union-source"> <pre class="c" data-language="c">static VALUE
rb_ary_union_multi(int argc, VALUE *argv, VALUE ary)
{
    int i;
    long sum;
    VALUE hash;

    sum = RARRAY_LEN(ary);
    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        sum += RARRAY_LEN(argv[i]);
    }

    if (sum &lt;= SMALL_ARRAY_LEN) {
        VALUE ary_union = rb_ary_new();

        rb_ary_union(ary_union, ary);
        for (i = 0; i &lt; argc; i++) rb_ary_union(ary_union, argv[i]);

        return ary_union;
    }

    hash = ary_make_hash(ary);
    for (i = 0; i &lt; argc; i++) rb_ary_union_hash(hash, argv[i]);

    return rb_hash_values(hash);
}</pre> </div> <p>Returns a new Array that is the union of <code>self</code> and all given Arrays <code>other_arrays</code>; duplicates are removed; order is preserved; items are compared using <code>eql?</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].union([4, 5], [6, 7]) # =&gt; [0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 1].union([2, 1], [3, 1]) # =&gt; [0, 1, 2, 3]
[0, 1, 2, 3].union([3, 2], [1, 0]) # =&gt; [0, 1, 2, 3]
</pre> <p>Returns a copy of <code>self</code> if no arguments given.</p> <p>Related: <a href="array.html#method-i-7C"><code>Array#|</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-uniq"> <span class="method-callseq"> uniq → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> uniq {|element| ... } → new_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="uniq-source"> <pre class="c" data-language="c">static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq;

    if (RARRAY_LEN(ary) &lt;= 1) {
        hash = 0;
        uniq = rb_ary_dup(ary);
    }
    else if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = rb_hash_values(hash);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = rb_hash_values(hash);
    }

    return uniq;
}</pre> </div> <p>Returns a new Array containing those elements from <code>self</code> that are not duplicates, the first occurrence always being retained.</p> <p>With no block given, identifies and omits duplicates using method <code>eql?</code> to compare:</p> <pre class="ruby" data-language="ruby">a = [0, 0, 1, 1, 2, 2]
a.uniq # =&gt; [0, 1, 2]
</pre> <p>With a block given, calls the block for each element; identifies (using method <code>eql?</code>) and omits duplicate values, that is, those elements for which the block returns the same value:</p> <pre class="ruby" data-language="ruby">a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
a.uniq {|element| element.size } # =&gt; ["a", "aa", "aaa"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-uniq-21"> <span class="method-callseq"> uniq! → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> uniq! {|element| ... } → self or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="uniq-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash;
    long hash_size;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p())
        hash = ary_make_hash_by(ary);
    else
        hash = ary_make_hash(ary);

    hash_size = RHASH_SIZE(hash);
    if (RARRAY_LEN(ary) == hash_size) {
        return Qnil;
    }
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary) &amp;&amp; !ARY_EMBED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
    }
    ary_resize_capa(ary, hash_size);
    rb_hash_foreach(hash, push_value, ary);

    return ary;
}</pre> </div> <p>Removes duplicate elements from <code>self</code>, the first occurrence always being retained; returns <code>self</code> if any elements removed, <code>nil</code> otherwise.</p> <p>With no block given, identifies and removes elements using method <code>eql?</code> to compare.</p> <p>Returns <code>self</code> if any elements removed:</p> <pre class="ruby" data-language="ruby">a = [0, 0, 1, 1, 2, 2]
a.uniq! # =&gt; [0, 1, 2]
</pre> <p>Returns <code>nil</code> if no elements removed.</p> <p>With a block given, calls the block for each element; identifies (using method <code>eql?</code>) and removes elements for which the block returns duplicate values.</p> <p>Returns <code>self</code> if any elements removed:</p> <pre class="ruby" data-language="ruby">a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
a.uniq! {|element| element.size } # =&gt; ['a', 'aa', 'aaa']
</pre> <p>Returns <code>nil</code> if no elements removed.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unshift"> <span class="method-callseq"> unshift(*objects) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unshift-source"> <pre class="c" data-language="c">VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE target_ary;

    if (argc == 0) {
        rb_ary_modify_check(ary);
        return ary;
    }

    target_ary = ary_ensure_room_for_unshift(ary, argc);
    ary_memcpy0(ary, 0, argc, argv, target_ary);
    ARY_SET_LEN(ary, len + argc);
    return ary;
}</pre> </div> <p>Prepends the given <code>objects</code> to <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.unshift(:bam, :bat) # =&gt; [:bam, :bat, :foo, "bar", 2]
</pre> <p>Related: <a href="array.html#method-i-push"><code>push</code></a>, <a href="array.html#method-i-pop"><code>pop</code></a>, <a href="array.html#method-i-shift"><code>shift</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-prepend">prepend</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(*indexes) → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    long i, olen = RARRAY_LEN(ary);
    VALUE result = rb_ary_new_capa(argc);
    for (i = 0; i &lt; argc; ++i) {
        append_values_at_single(result, ary, olen, argv[i]);
    }
    RB_GC_GUARD(ary);
    return result;
}</pre> </div> <p>Returns a new Array whose elements are the elements of <code>self</code> at the given <a href="integer.html"><code>Integer</code></a> or <a href="range.html"><code>Range</code></a> <code>indexes</code>.</p> <p>For each positive <code>index</code>, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(0, 2) # =&gt; [:foo, 2]
a.values_at(0..1) # =&gt; [:foo, "bar"]
</pre> <p>The given <code>indexes</code> may be in any order, and may repeat:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(2, 0, 1, 0, 2) # =&gt; [2, :foo, "bar", :foo, 2]
a.values_at(1, 0..2) # =&gt; ["bar", :foo, "bar", 2]
</pre> <p>Assigns <code>nil</code> for an <code>index</code> that is too large:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(0, 3, 1, 3) # =&gt; [:foo, nil, "bar", nil]
</pre> <p>Returns a new empty Array if no arguments given.</p> <p>For each negative <code>index</code>, counts backward from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(-1, -3) # =&gt; [2, :foo]
</pre> <p>Assigns <code>nil</code> for an <code>index</code> that is too small:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(0, -5, 1, -6, 2) # =&gt; [:foo, nil, "bar", nil, 2]
</pre> <p>The given <code>indexes</code> may have a mixture of signs:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.values_at(0, -2, 1, -1) # =&gt; [:foo, "bar", "bar", 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-zip"> <span class="method-callseq"> zip(*other_arrays) → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> zip(*other_arrays) {|other_array| ... } → nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="zip-source"> <pre class="c" data-language="c">static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len = RARRAY_LEN(ary);
    VALUE result = Qnil;

    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }

    if (rb_block_given_p()) {
        int arity = rb_block_arity();

        if (arity &gt; 1) {
            VALUE work, *tmp;

            tmp = ALLOCV_N(VALUE, work, argc+1);

            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                tmp[0] = RARRAY_AREF(ary, i);
                for (j=0; j&lt;argc; j++) {
                    tmp[j+1] = rb_ary_elt(argv[j], i);
                }
                rb_yield_values2(argc+1, tmp);
            }

            if (work) ALLOCV_END(work);
        }
        else {
            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                VALUE tmp = rb_ary_new2(argc+1);

                rb_ary_push(tmp, RARRAY_AREF(ary, i));
                for (j=0; j&lt;argc; j++) {
                    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
                }
                rb_yield(tmp);
            }
        }
    }
    else {
        result = rb_ary_new_capa(len);

        for (i=0; i&lt;len; i++) {
            VALUE tmp = rb_ary_new_capa(argc+1);

            rb_ary_push(tmp, RARRAY_AREF(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_ary_push(result, tmp);
        }
    }

    return result;
}</pre> </div> <p>When no block given, returns a new Array <code>new_array</code> of size <code>self.size</code> whose elements are Arrays.</p> <p>Each nested array <code>new_array[n]</code> is of size <code>other_arrays.size+1</code>, and contains:</p> <ul>
<li> <p>The <em>nth</em> element of <code>self</code>.</p> </li>
<li> <p>The <em>nth</em> element of each of the <code>other_arrays</code>.</p> </li>
</ul> <p>If all <code>other_arrays</code> and <code>self</code> are the same size:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
</pre> <p>If any array in <code>other_arrays</code> is smaller than <code>self</code>, fills to <code>self.size</code> with <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2]
c = [:c0, :c1]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
</pre> <p>If any array in <code>other_arrays</code> is larger than <code>self</code>, its trailing elements are ignored:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3, :b4]
c = [:c0, :c1, :c2, :c3, :c4, :c5]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
</pre> <p>When a block is given, calls the block with each of the sub-arrays (formed as above); returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
a.zip(b, c) {|sub_array| p sub_array} # =&gt; nil
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[:a0, :b0, :c0]
[:a1, :b1, :c1]
[:a2, :b2, :c2]
[:a3, :b3, :c3]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-7C"> <span class="method-callseq"> array | other_array → new_array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="7C-source"> <pre class="c" data-language="c">static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) + RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        VALUE ary3 = rb_ary_new();
        rb_ary_union(ary3, ary1);
        rb_ary_union(ary3, ary2);
        return ary3;
    }

    hash = ary_make_hash(ary1);
    rb_ary_union_hash(hash, ary2);

    return rb_hash_values(hash);
}</pre> </div> <p>Returns the union of <code>array</code> and Array <code>other_array</code>; duplicates are removed; order is preserved; items are compared using <code>eql?</code>:</p> <pre class="ruby" data-language="ruby">[0, 1] | [2, 3] # =&gt; [0, 1, 2, 3]
[0, 1, 1] | [2, 2, 3] # =&gt; [0, 1, 2, 3]
[0, 1, 2] | [3, 2, 1, 0] # =&gt; [0, 1, 2, 3]
</pre> <p>Related: <a href="array.html#method-i-union"><code>Array#union</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
