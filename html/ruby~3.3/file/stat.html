<h1 id="class-File::Stat" class="class"> class File::Stat </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../comparable.html">Comparable</a></dd>
</dl> <section class="description"> <p>Objects of class <a href="stat.html"><code>File::Stat</code></a> encapsulate common status information for <a href="../file.html"><code>File</code></a> objects. The information is recorded at the moment the <a href="stat.html"><code>File::Stat</code></a> object is created; changes made to the file after that point will not be reflected. <a href="stat.html"><code>File::Stat</code></a> objects are returned by <a href="../io.html#method-i-stat"><code>IO#stat</code></a>, <a href="../file.html#method-c-stat"><code>File::stat</code></a>, <a href="../file.html#method-i-lstat"><code>File#lstat</code></a>, and <a href="../file.html#method-c-lstat"><code>File::lstat</code></a>. Many of these methods return platform-specific values, and not all values are meaningful on all systems. See also <a href="../kernel.html#method-i-test"><code>Kernel#test</code></a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_stat_init(VALUE obj, VALUE fname)
{
    struct stat st;

    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (STAT(StringValueCStr(fname), &amp;st) == -1) {
        rb_sys_fail_path(fname);
    }

    struct rb_stat *rb_st;
    TypedData_Get_Struct(obj, struct rb_stat, &amp;stat_data_type, rb_st);

    rb_st-&gt;stat = st;
    rb_st-&gt;initialized = true;

    return Qnil;
}</pre> </div> <pre>File::Stat.new(file_name)  -&gt; stat</pre> <p>Create a <a href="stat.html"><code>File::Stat</code></a> object for the given file name (raising an exception if the file doesn’t exist).</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> stat &lt;=&gt; other_stat → -1, 0, 1, nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
rb_stat_cmp(VALUE self, VALUE other)
{
    if (rb_obj_is_kind_of(other, rb_obj_class(self))) {
        struct timespec ts1 = stat_mtimespec(get_stat(self));
        struct timespec ts2 = stat_mtimespec(get_stat(other));
        if (ts1.tv_sec == ts2.tv_sec) {
            if (ts1.tv_nsec == ts2.tv_nsec) return INT2FIX(0);
            if (ts1.tv_nsec &lt; ts2.tv_nsec) return INT2FIX(-1);
            return INT2FIX(1);
        }
        if (ts1.tv_sec &lt; ts2.tv_sec) return INT2FIX(-1);
        return INT2FIX(1);
    }
    return Qnil;
}</pre> </div> <p>Compares <a href="stat.html"><code>File::Stat</code></a> objects by comparing their respective modification times.</p> <p><code>nil</code> is returned if <code>other_stat</code> is not a <a href="stat.html"><code>File::Stat</code></a> object</p> <pre class="ruby" data-language="ruby">f1 = File.new("f1", "w")
sleep 1
f2 = File.new("f2", "w")
f1.stat &lt;=&gt; f2.stat   #=&gt; -1
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-atime"> <span class="method-callseq"> atime → time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="atime-source"> <pre class="c" data-language="c">static VALUE
rb_stat_atime(VALUE self)
{
    return stat_atime(get_stat(self));
}</pre> </div> <p>Returns the last access time for this file as an object of class <a href="../time.html"><code>Time</code></a>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").atime   #=&gt; Wed Dec 31 18:00:00 CST 1969
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-birthtime"> <span class="method-callseq"> birthtime → time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="birthtime-source"> <pre class="c" data-language="c">static VALUE
rb_stat_birthtime(VALUE self)
{
    return stat_birthtime(get_stat(self));
}</pre> </div> <p>Returns the birth time for <em>stat</em>.</p> <p>If the platform doesn’t have birthtime, raises <a href="../notimplementederror.html"><code>NotImplementedError</code></a>.</p> <pre class="ruby" data-language="ruby">File.write("testfile", "foo")
sleep 10
File.write("testfile", "bar")
sleep 10
File.chmod(0644, "testfile")
sleep 10
File.read("testfile")
File.stat("testfile").birthtime   #=&gt; 2014-02-24 11:19:17 +0900
File.stat("testfile").mtime       #=&gt; 2014-02-24 11:19:27 +0900
File.stat("testfile").ctime       #=&gt; 2014-02-24 11:19:37 +0900
File.stat("testfile").atime       #=&gt; 2014-02-24 11:19:47 +0900
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-blksize"> <span class="method-callseq"> blksize → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="blksize-source"> <pre class="c" data-language="c">static VALUE
rb_stat_blksize(VALUE self)
{
#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
    return ULONG2NUM(get_stat(self)-&gt;st_blksize);
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the native file system’s block size. Will return <code>nil</code> on platforms that don’t support this information.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").blksize   #=&gt; 4096
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-blockdev-3F"> <span class="method-callseq"> blockdev? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="blockdev-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_b(VALUE obj)
{
#ifdef S_ISBLK
    if (S_ISBLK(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if the file is a block device, <code>false</code> if it isn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").blockdev?    #=&gt; false
File.stat("/dev/hda1").blockdev?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-blocks"> <span class="method-callseq"> blocks → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="blocks-source"> <pre class="c" data-language="c">static VALUE
rb_stat_blocks(VALUE self)
{
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
# if SIZEOF_STRUCT_STAT_ST_BLOCKS &gt; SIZEOF_LONG
    return ULL2NUM(get_stat(self)-&gt;st_blocks);
# else
    return ULONG2NUM(get_stat(self)-&gt;st_blocks);
# endif
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the number of native file system blocks allocated for this file, or <code>nil</code> if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").blocks   #=&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chardev-3F"> <span class="method-callseq"> chardev? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chardev-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_c(VALUE obj)
{
    if (S_ISCHR(get_stat(obj)-&gt;st_mode)) return Qtrue;

    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if the file is a character device, <code>false</code> if it isn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/tty").chardev?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ctime"> <span class="method-callseq"> ctime → time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ctime-source"> <pre class="c" data-language="c">static VALUE
rb_stat_ctime(VALUE self)
{
    return stat_ctime(get_stat(self));
}</pre> </div> <p>Returns the change time for <em>stat</em> (that is, the time directory information about the file was changed, not the file itself).</p> <p>Note that on Windows (NTFS), returns creation time (birth time).</p> <pre class="ruby" data-language="ruby">File.stat("testfile").ctime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dev"> <span class="method-callseq"> dev → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dev-source"> <pre class="c" data-language="c">static VALUE
rb_stat_dev(VALUE self)
{
#if SIZEOF_STRUCT_STAT_ST_DEV &lt;= SIZEOF_DEV_T
    return DEVT2NUM(get_stat(self)-&gt;st_dev);
#elif SIZEOF_STRUCT_STAT_ST_DEV &lt;= SIZEOF_LONG
    return ULONG2NUM(get_stat(self)-&gt;st_dev);
#else
    return ULL2NUM(get_stat(self)-&gt;st_dev);
#endif
}</pre> </div> <p>Returns an integer representing the device on which <em>stat</em> resides.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").dev   #=&gt; 774
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dev_major"> <span class="method-callseq"> dev_major → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dev_major-source"> <pre class="c" data-language="c">static VALUE
rb_stat_dev_major(VALUE self)
{
#if defined(major)
    return UINT2NUM(major(get_stat(self)-&gt;st_dev));
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the major part of <code>File_Stat#dev</code> or <code>nil</code>.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/fd1").dev_major   #=&gt; 2
File.stat("/dev/tty").dev_major   #=&gt; 5
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dev_minor"> <span class="method-callseq"> dev_minor → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dev_minor-source"> <pre class="c" data-language="c">static VALUE
rb_stat_dev_minor(VALUE self)
{
#if defined(minor)
    return UINT2NUM(minor(get_stat(self)-&gt;st_dev));
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the minor part of <code>File_Stat#dev</code> or <code>nil</code>.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/fd1").dev_minor   #=&gt; 1
File.stat("/dev/tty").dev_minor   #=&gt; 0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-directory-3F"> <span class="method-callseq"> directory? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="directory-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_d(VALUE obj)
{
    if (S_ISDIR(get_stat(obj)-&gt;st_mode)) return Qtrue;
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is a directory, <code>false</code> otherwise.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").directory?   #=&gt; false
File.stat(".").directory?          #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-executable-3F"> <span class="method-callseq"> executable? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="executable-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_x(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) {
        return RBOOL(st-&gt;st_mode &amp; S_IXUGO);
    }
#endif
#ifdef S_IXUSR
    if (rb_stat_owned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IXUSR);
#endif
#ifdef S_IXGRP
    if (rb_stat_grpowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IXGRP);
#endif
#ifdef S_IXOTH
    if (!(st-&gt;st_mode &amp; S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is executable or if the operating system doesn’t distinguish executable files from nonexecutable files. The tests are made using the effective owner of the process.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").executable?   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-executable_real-3F"> <span class="method-callseq"> executable_real? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="executable_real-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_X(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) {
        return RBOOL(st-&gt;st_mode &amp; S_IXUGO);
    }
#endif
#ifdef S_IXUSR
    if (rb_stat_rowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IXUSR);
#endif
#ifdef S_IXGRP
    if (rb_group_member(get_stat(obj)-&gt;st_gid))
        return RBOOL(st-&gt;st_mode &amp; S_IXGRP);
#endif
#ifdef S_IXOTH
    if (!(st-&gt;st_mode &amp; S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Same as <code>executable?</code>, but tests using the real owner of the process.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-file-3F"> <span class="method-callseq"> file? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="file-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_f(VALUE obj)
{
    if (S_ISREG(get_stat(obj)-&gt;st_mode)) return Qtrue;
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is a regular file (not a device file, pipe, socket, etc.).</p> <pre class="ruby" data-language="ruby">File.stat("testfile").file?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ftype"> <span class="method-callseq"> ftype → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ftype-source"> <pre class="c" data-language="c">static VALUE
rb_stat_ftype(VALUE obj)
{
    return rb_file_ftype(get_stat(obj));
}</pre> </div> <p>Identifies the type of <em>stat</em>. The return string is one of: “<code>file</code>”, “<code>directory</code>”, “<code>characterSpecial</code>”, “<code>blockSpecial</code>”, “<code>fifo</code>”, “<code>link</code>”, “<code>socket</code>”, or “<code>unknown</code>”.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/tty").ftype   #=&gt; "characterSpecial"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-gid"> <span class="method-callseq"> gid → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="gid-source"> <pre class="c" data-language="c">static VALUE
rb_stat_gid(VALUE self)
{
    return GIDT2NUM(get_stat(self)-&gt;st_gid);
}</pre> </div> <p>Returns the numeric group id of the owner of <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").gid   #=&gt; 500
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-grpowned-3F"> <span class="method-callseq"> grpowned? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="grpowned-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_grpowned(VALUE obj)
{
#ifndef _WIN32
    if (rb_group_member(get_stat(obj)-&gt;st_gid)) return Qtrue;
#endif
    return Qfalse;
}</pre> </div> <p>Returns true if the effective group id of the process is the same as the group id of <em>stat</em>. On Windows, returns <code>false</code>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").grpowned?      #=&gt; true
File.stat("/etc/passwd").grpowned?   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ino"> <span class="method-callseq"> ino → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ino-source"> <pre class="c" data-language="c">static VALUE
rb_stat_ino(VALUE self)
{
#ifdef HAVE_STRUCT_STAT_ST_INOHIGH
    /* assume INTEGER_PACK_LSWORD_FIRST and st_inohigh is just next of st_ino */
    return rb_integer_unpack(&amp;get_stat(self)-&gt;st_ino, 2,
            SIZEOF_STRUCT_STAT_ST_INO, 0,
            INTEGER_PACK_LSWORD_FIRST|INTEGER_PACK_NATIVE_BYTE_ORDER|
            INTEGER_PACK_2COMP);
#elif SIZEOF_STRUCT_STAT_ST_INO &gt; SIZEOF_LONG
    return ULL2NUM(get_stat(self)-&gt;st_ino);
#else
    return ULONG2NUM(get_stat(self)-&gt;st_ino);
#endif
}</pre> </div> <p>Returns the inode number for <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").ino   #=&gt; 1083669
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_stat_inspect(VALUE self)
{
    VALUE str;
    size_t i;
    static const struct {
        const char *name;
        VALUE (*func)(VALUE);
    } member[] = {
        {"dev",     rb_stat_dev},
        {"ino",     rb_stat_ino},
        {"mode",    rb_stat_mode},
        {"nlink",   rb_stat_nlink},
        {"uid",     rb_stat_uid},
        {"gid",     rb_stat_gid},
        {"rdev",    rb_stat_rdev},
        {"size",    rb_stat_size},
        {"blksize", rb_stat_blksize},
        {"blocks",  rb_stat_blocks},
        {"atime",   rb_stat_atime},
        {"mtime",   rb_stat_mtime},
        {"ctime",   rb_stat_ctime},
#if defined(HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC)
        {"birthtime",   rb_stat_birthtime},
#endif
    };

    struct rb_stat* rb_st;
    TypedData_Get_Struct(self, struct rb_stat, &amp;stat_data_type, rb_st);
    if (!rb_st-&gt;initialized) {
        return rb_sprintf("#&lt;%s: uninitialized&gt;", rb_obj_classname(self));
    }

    str = rb_str_buf_new2("#&lt;");
    rb_str_buf_cat2(str, rb_obj_classname(self));
    rb_str_buf_cat2(str, " ");

    for (i = 0; i &lt; sizeof(member)/sizeof(member[0]); i++) {
        VALUE v;

        if (i &gt; 0) {
            rb_str_buf_cat2(str, ", ");
        }
        rb_str_buf_cat2(str, member[i].name);
        rb_str_buf_cat2(str, "=");
        v = (*member[i].func)(self);
        if (i == 2) {           /* mode */
            rb_str_catf(str, "0%lo", (unsigned long)NUM2ULONG(v));
        }
        else if (i == 0 || i == 6) { /* dev/rdev */
            rb_str_catf(str, "0x%"PRI_DEVT_PREFIX"x", NUM2DEVT(v));
        }
        else {
            rb_str_append(str, rb_inspect(v));
        }
    }
    rb_str_buf_cat2(str, "&gt;");

    return str;
}</pre> </div> <p>Produce a nicely formatted description of <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("/etc/passwd").inspect
   #=&gt; "#&lt;File::Stat dev=0xe000005, ino=1078078, mode=0100644,
   #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,
   #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,
   #    mtime=Fri Sep 12 15:41:41 CDT 2003,
   #    ctime=Mon Oct 27 11:20:27 CST 2003,
   #    birthtime=Mon Aug 04 08:13:49 CDT 2003&gt;"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mode"> <span class="method-callseq"> mode → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mode-source"> <pre class="c" data-language="c">static VALUE
rb_stat_mode(VALUE self)
{
    return UINT2NUM(ST2UINT(get_stat(self)-&gt;st_mode));
}</pre> </div> <p>Returns an integer representing the permission bits of <em>stat</em>. The meaning of the bits is platform dependent; on Unix systems, see <code>stat(2)</code>.</p> <pre class="ruby" data-language="ruby">File.chmod(0644, "testfile")   #=&gt; 1
s = File.stat("testfile")
sprintf("%o", s.mode)          #=&gt; "100644"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-mtime"> <span class="method-callseq"> mtime → time </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="mtime-source"> <pre class="c" data-language="c">static VALUE
rb_stat_mtime(VALUE self)
{
    return stat_mtime(get_stat(self));
}</pre> </div> <p>Returns the modification time of <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").mtime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-nlink"> <span class="method-callseq"> nlink → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="nlink-source"> <pre class="c" data-language="c">static VALUE
rb_stat_nlink(VALUE self)
{
    /* struct stat::st_nlink is nlink_t in POSIX.  Not the case for Windows. */
    const struct stat *ptr = get_stat(self);

    if (sizeof(ptr-&gt;st_nlink) &lt;= sizeof(int)) {
        return UINT2NUM((unsigned)ptr-&gt;st_nlink);
    }
    else if (sizeof(ptr-&gt;st_nlink) == sizeof(long)) {
        return ULONG2NUM((unsigned long)ptr-&gt;st_nlink);
    }
    else if (sizeof(ptr-&gt;st_nlink) == sizeof(LONG_LONG)) {
        return ULL2NUM((unsigned LONG_LONG)ptr-&gt;st_nlink);
    }
    else {
        rb_bug(":FIXME: don't know what to do");
    }
}</pre> </div> <p>Returns the number of hard links to <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").nlink             #=&gt; 1
File.link("testfile", "testfile.bak")   #=&gt; 0
File.stat("testfile").nlink             #=&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-owned-3F"> <span class="method-callseq"> owned? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="owned-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_owned(VALUE obj)
{
    if (get_stat(obj)-&gt;st_uid == geteuid()) return Qtrue;
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if the effective user id of the process is the same as the owner of <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").owned?      #=&gt; true
File.stat("/etc/passwd").owned?   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pipe-3F"> <span class="method-callseq"> pipe? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pipe-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_p(VALUE obj)
{
#ifdef S_IFIFO
    if (S_ISFIFO(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if the operating system supports pipes and <em>stat</em> is a pipe; <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rdev"> <span class="method-callseq"> rdev → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rdev-source"> <pre class="c" data-language="c">static VALUE
rb_stat_rdev(VALUE self)
{
#ifdef HAVE_STRUCT_STAT_ST_RDEV
# if SIZEOF_STRUCT_STAT_ST_RDEV &lt;= SIZEOF_DEV_T
    return DEVT2NUM(get_stat(self)-&gt;st_rdev);
# elif SIZEOF_STRUCT_STAT_ST_RDEV &lt;= SIZEOF_LONG
    return ULONG2NUM(get_stat(self)-&gt;st_rdev);
# else
    return ULL2NUM(get_stat(self)-&gt;st_rdev);
# endif
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns an integer representing the device type on which <em>stat</em> resides. Returns <code>nil</code> if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/fd1").rdev   #=&gt; 513
File.stat("/dev/tty").rdev   #=&gt; 1280
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rdev_major"> <span class="method-callseq"> rdev_major → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rdev_major-source"> <pre class="c" data-language="c">static VALUE
rb_stat_rdev_major(VALUE self)
{
#if defined(HAVE_STRUCT_STAT_ST_RDEV) &amp;&amp; defined(major)
    return UINT2NUM(major(get_stat(self)-&gt;st_rdev));
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the major part of <code>File_Stat#rdev</code> or <code>nil</code>.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/fd1").rdev_major   #=&gt; 2
File.stat("/dev/tty").rdev_major   #=&gt; 5
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rdev_minor"> <span class="method-callseq"> rdev_minor → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rdev_minor-source"> <pre class="c" data-language="c">static VALUE
rb_stat_rdev_minor(VALUE self)
{
#if defined(HAVE_STRUCT_STAT_ST_RDEV) &amp;&amp; defined(minor)
    return UINT2NUM(minor(get_stat(self)-&gt;st_rdev));
#else
    return Qnil;
#endif
}</pre> </div> <p>Returns the minor part of <code>File_Stat#rdev</code> or <code>nil</code>.</p> <pre class="ruby" data-language="ruby">File.stat("/dev/fd1").rdev_minor   #=&gt; 1
File.stat("/dev/tty").rdev_minor   #=&gt; 0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-readable-3F"> <span class="method-callseq"> readable? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="readable-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_r(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) return Qtrue;
#endif
#ifdef S_IRUSR
    if (rb_stat_owned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IRUSR);
#endif
#ifdef S_IRGRP
    if (rb_stat_grpowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IRGRP);
#endif
#ifdef S_IROTH
    if (!(st-&gt;st_mode &amp; S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is readable by the effective user id of this process.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").readable?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-readable_real-3F"> <span class="method-callseq"> readable_real? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="readable_real-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_R(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) return Qtrue;
#endif
#ifdef S_IRUSR
    if (rb_stat_rowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IRUSR);
#endif
#ifdef S_IRGRP
    if (rb_group_member(get_stat(obj)-&gt;st_gid))
        return RBOOL(st-&gt;st_mode &amp; S_IRGRP);
#endif
#ifdef S_IROTH
    if (!(st-&gt;st_mode &amp; S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is readable by the real user id of this process.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").readable_real?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-setgid-3F"> <span class="method-callseq"> setgid? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="setgid-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_sgid(VALUE obj)
{
#ifdef S_ISGID
    if (get_stat(obj)-&gt;st_mode &amp; S_ISGID) return Qtrue;
#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> has the set-group-id permission bit set, <code>false</code> if it doesn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("/usr/sbin/lpc").setgid?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-setuid-3F"> <span class="method-callseq"> setuid? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="setuid-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_suid(VALUE obj)
{
#ifdef S_ISUID
    if (get_stat(obj)-&gt;st_mode &amp; S_ISUID) return Qtrue;
#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> has the set-user-id permission bit set, <code>false</code> if it doesn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("/bin/su").setuid?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
rb_stat_size(VALUE self)
{
    return OFFT2NUM(get_stat(self)-&gt;st_size);
}</pre> </div> <p>Returns the size of <em>stat</em> in bytes.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").size   #=&gt; 66
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size-3F"> <span class="method-callseq"> size? → Integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_s(VALUE obj)
{
    rb_off_t size = get_stat(obj)-&gt;st_size;

    if (size == 0) return Qnil;
    return OFFT2NUM(size);
}</pre> </div> <p>Returns <code>nil</code> if <em>stat</em> is a zero-length file, the size of the file otherwise.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").size?   #=&gt; 66
File.stat(File::NULL).size?   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-socket-3F"> <span class="method-callseq"> socket? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="socket-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_S(VALUE obj)
{
#ifdef S_ISSOCK
    if (S_ISSOCK(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is a socket, <code>false</code> if it isn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").socket?   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sticky-3F"> <span class="method-callseq"> sticky? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sticky-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_sticky(VALUE obj)
{
#ifdef S_ISVTX
    if (get_stat(obj)-&gt;st_mode &amp; S_ISVTX) return Qtrue;
#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> has its sticky bit set, <code>false</code> if it doesn’t or if the operating system doesn’t support this feature.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").sticky?   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-symlink-3F"> <span class="method-callseq"> symlink? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="symlink-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_l(VALUE obj)
{
#ifdef S_ISLNK
    if (S_ISLNK(get_stat(obj)-&gt;st_mode)) return Qtrue;
#endif
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is a symbolic link, <code>false</code> if it isn’t or if the operating system doesn’t support this feature. As <a href="../file.html#method-c-stat"><code>File::stat</code></a> automatically follows symbolic links, <a href="stat.html#method-i-symlink-3F"><code>symlink?</code></a> will always be <code>false</code> for an object returned by <a href="../file.html#method-c-stat"><code>File::stat</code></a>.</p> <pre class="ruby" data-language="ruby">File.symlink("testfile", "alink")   #=&gt; 0
File.stat("alink").symlink?         #=&gt; false
File.lstat("alink").symlink?        #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-uid"> <span class="method-callseq"> uid → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="uid-source"> <pre class="c" data-language="c">static VALUE
rb_stat_uid(VALUE self)
{
    return UIDT2NUM(get_stat(self)-&gt;st_uid);
}</pre> </div> <p>Returns the numeric user id of the owner of <em>stat</em>.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").uid   #=&gt; 501
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-world_readable-3F"> <span class="method-callseq"> world_readable? → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="world_readable-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_wr(VALUE obj)
{
#ifdef S_IROTH
    struct stat *st = get_stat(obj);
    if ((st-&gt;st_mode &amp; (S_IROTH)) == S_IROTH) {
        return UINT2NUM(st-&gt;st_mode &amp; (S_IRUGO|S_IWUGO|S_IXUGO));
    }
#endif
    return Qnil;
}</pre> </div> <p>If <em>stat</em> is readable by others, returns an integer representing the file permission bits of <em>stat</em>. Returns <code>nil</code> otherwise. The meaning of the bits is platform dependent; on Unix systems, see <code>stat(2)</code>.</p> <pre class="ruby" data-language="ruby">m = File.stat("/etc/passwd").world_readable?  #=&gt; 420
sprintf("%o", m)                              #=&gt; "644"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-world_writable-3F"> <span class="method-callseq"> world_writable? → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="world_writable-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_ww(VALUE obj)
{
#ifdef S_IWOTH
    struct stat *st = get_stat(obj);
    if ((st-&gt;st_mode &amp; (S_IWOTH)) == S_IWOTH) {
        return UINT2NUM(st-&gt;st_mode &amp; (S_IRUGO|S_IWUGO|S_IXUGO));
    }
#endif
    return Qnil;
}</pre> </div> <p>If <em>stat</em> is writable by others, returns an integer representing the file permission bits of <em>stat</em>. Returns <code>nil</code> otherwise. The meaning of the bits is platform dependent; on Unix systems, see <code>stat(2)</code>.</p> <pre class="ruby" data-language="ruby">m = File.stat("/tmp").world_writable?         #=&gt; 511
sprintf("%o", m)                              #=&gt; "777"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-writable-3F"> <span class="method-callseq"> writable? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="writable-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_w(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) return Qtrue;
#endif
#ifdef S_IWUSR
    if (rb_stat_owned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IWUSR);
#endif
#ifdef S_IWGRP
    if (rb_stat_grpowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IWGRP);
#endif
#ifdef S_IWOTH
    if (!(st-&gt;st_mode &amp; S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is writable by the effective user id of this process.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").writable?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-writable_real-3F"> <span class="method-callseq"> writable_real? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="writable_real-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_W(VALUE obj)
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) return Qtrue;
#endif
#ifdef S_IWUSR
    if (rb_stat_rowned(obj))
        return RBOOL(st-&gt;st_mode &amp; S_IWUSR);
#endif
#ifdef S_IWGRP
    if (rb_group_member(get_stat(obj)-&gt;st_gid))
        return RBOOL(st-&gt;st_mode &amp; S_IWGRP);
#endif
#ifdef S_IWOTH
    if (!(st-&gt;st_mode &amp; S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is writable by the real user id of this process.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").writable_real?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-zero-3F"> <span class="method-callseq"> zero? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="zero-3F-source"> <pre class="c" data-language="c">static VALUE
rb_stat_z(VALUE obj)
{
    if (get_stat(obj)-&gt;st_size == 0) return Qtrue;
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>stat</em> is a zero-length file; <code>false</code> otherwise.</p> <pre class="ruby" data-language="ruby">File.stat("testfile").zero?   #=&gt; false
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
