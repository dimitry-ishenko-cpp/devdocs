<h1 id="class-Struct" class="class"> class Struct </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <p>Class Struct provides a convenient way to create a simple class that can store and fetch values.</p> <p>This example creates a subclass of <code>Struct</code>, <code>Struct::Customer</code>; the first argument, a string, is the name of the subclass; the other arguments, symbols, determine the <em>members</em> of the new subclass.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new('Customer', :name, :address, :zip)
Customer.name       # =&gt; "Struct::Customer"
Customer.class      # =&gt; Class
Customer.superclass # =&gt; Struct
</pre> <p>Corresponding to each member are two methods, a writer and a reader, that store and fetch values:</p> <pre class="ruby" data-language="ruby">methods = Customer.instance_methods false
methods # =&gt; [:zip, :address=, :zip=, :address, :name, :name=]
</pre> <p>An instance of the subclass may be created, and its members assigned values, via method <code>::new</code>:</p> <pre class="ruby" data-language="ruby">joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe # =&gt; #&lt;struct Struct::Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=12345&gt;
</pre> <p>The member values may be managed thus:</p> <pre class="ruby" data-language="ruby">joe.name    # =&gt; "Joe Smith"
joe.name = 'Joseph Smith'
joe.name    # =&gt; "Joseph Smith"
</pre> <p>And thus; note that member name may be expressed as either a string or a symbol:</p> <pre class="ruby" data-language="ruby">joe[:name]  # =&gt; "Joseph Smith"
joe[:name] = 'Joseph Smith, Jr.'
joe['name'] # =&gt; "Joseph Smith, Jr."
</pre> <p>See <a href="struct.html#method-c-new"><code>Struct::new</code></a>.</p> <h2 id="class-Struct-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class Struct:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p> </li>
</ul> <p>See also <span><code>Data</code></span>, which is a somewhat similar, but stricter concept for defining immutable value objects.</p> <p>Here, class Struct provides methods that are useful for:</p> <ul>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Creating+a+Struct+Subclass">Creating a Struct Subclass</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Fetching">Fetching</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Assigning">Assigning</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="struct.html#class-Struct-label-Methods+for+Converting">Converting</a></p> </li>
</ul> <h3 id="class-Struct-label-Methods+for+Creating+a+Struct+Subclass">Methods for Creating a <a href="struct.html"><code>Struct</code></a> Subclass</h3> <ul><li> <p><a href="struct.html#method-c-new"><code>::new</code></a>: Returns a new subclass of Struct.</p> </li></ul> <h3 id="class-Struct-label-Methods+for+Querying">Methods for Querying</h3> <ul>
<li> <p><a href="struct.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
<li> <p><a href="struct.html#method-i-length"><code>length</code></a>, <a href="struct.html#method-i-size"><code>size</code></a>: Returns the number of members.</p> </li>
</ul> <h3 id="class-Struct-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="struct.html#method-i-3D-3D"><code>==</code></a>: Returns whether a given object is equal to <code>self</code>, using <code>==</code> to compare member values.</p> </li>
<li> <p><a href="struct.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether a given object is equal to <code>self</code>, using <code>eql?</code> to compare member values.</p> </li>
</ul> <h3 id="class-Struct-label-Methods+for+Fetching">Methods for Fetching</h3> <ul>
<li> <p><a href="struct.html#method-i-5B-5D"><code>[]</code></a>: Returns the value associated with a given member name.</p> </li>
<li> <p><a href="struct.html#method-i-to_a"><code>to_a</code></a>, <a href="struct.html#method-i-values"><code>values</code></a>, <a href="struct.html#method-i-deconstruct"><code>deconstruct</code></a>: Returns the member values in <code>self</code> as an array.</p> </li>
<li> <p><a href="struct.html#method-i-deconstruct_keys"><code>deconstruct_keys</code></a>: Returns a hash of the name/value pairs for given member names.</p> </li>
<li> <p><a href="struct.html#method-i-dig"><code>dig</code></a>: Returns the object in nested objects that is specified by a given member name and additional arguments.</p> </li>
<li> <p><a href="struct.html#method-i-members"><code>members</code></a>: Returns an array of the member names.</p> </li>
<li> <p><a href="struct.html#method-i-select"><code>select</code></a>, <a href="struct.html#method-i-filter"><code>filter</code></a>: Returns an array of member values from <code>self</code>, as selected by the given block.</p> </li>
<li> <p><a href="struct.html#method-i-values_at"><code>values_at</code></a>: Returns an array containing values for given member names.</p> </li>
</ul> <h3 id="class-Struct-label-Methods+for+Assigning">Methods for Assigning</h3> <ul><li> <p><a href="struct.html#method-i-5B-5D-3D"><code>[]=</code></a>: Assigns a given value to a given member name.</p> </li></ul> <h3 id="class-Struct-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="struct.html#method-i-each"><code>each</code></a>: Calls a given block with each member name.</p> </li>
<li> <p><a href="struct.html#method-i-each_pair"><code>each_pair</code></a>: Calls a given block with each member name/value pair.</p> </li>
</ul> <h3 id="class-Struct-label-Methods+for+Converting">Methods for Converting</h3> <ul>
<li> <p><a href="struct.html#method-i-inspect"><code>inspect</code></a>, <a href="struct.html#method-i-to_s"><code>to_s</code></a>: Returns a string representation of <code>self</code>.</p> </li>
<li> <p><a href="struct.html#method-i-to_h"><code>to_h</code></a>: Returns a hash of the member name/value pairs in <code>self</code>.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 9
def self.json_create(object)
  new(*object['v'])
end</pre> </div> <p>See <a href="struct.html#method-i-as_json"><code>as_json</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-keyword_init-3F"> <span class="method-callseq"> StructClass::keyword_init? → true or falsy value </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="keyword_init-3F-source"> <pre class="c" data-language="c">static VALUE
rb_struct_s_keyword_init_p(VALUE obj)
{
}</pre> </div> <p>Returns <code>true</code> if the class was initialized with <code>keyword_init: true</code>. Otherwise returns <code>nil</code> or <code>false</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new(:a)
Foo.keyword_init? # =&gt; nil
Bar = Struct.new(:a, keyword_init: true)
Bar.keyword_init? # =&gt; true
Baz = Struct.new(:a, keyword_init: false)
Baz.keyword_init? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-members"> <span class="method-callseq"> StructClass::members → array_of_symbols </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="members-source"> <pre class="c" data-language="c">static VALUE
rb_struct_s_members_m(VALUE klass)
{
    VALUE members = rb_struct_s_members(klass);

    return rb_ary_dup(members);
}</pre> </div> <p>Returns the member names of the <a href="struct.html"><code>Struct</code></a> descendant as an array:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
Customer.members # =&gt; [:name, :address, :zip]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(*member_names, keyword_init: nil){|Struct_subclass| ... } → Struct_subclass </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(class_name, *member_names, keyword_init: nil){|Struct_subclass| ... } → Struct_subclass </span> </div> <div class="method-heading"> <span class="method-callseq"> new(*member_names) → Struct_subclass_instance </span> </div> <div class="method-heading"> <span class="method-callseq"> new(**member_names) → Struct_subclass_instance </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_struct_s_def(int argc, VALUE *argv, VALUE klass)
{
    VALUE name = Qnil, rest, keyword_init = Qnil;
    long i;
    VALUE st;
    VALUE opt;

    argc = rb_scan_args(argc, argv, "0*:", NULL, &amp;opt);
    if (argc &gt;= 1 &amp;&amp; !SYMBOL_P(argv[0])) {
        name = argv[0];
        --argc;
        ++argv;
    }

    if (!NIL_P(opt)) {
        static ID keyword_ids[1];

        if (!keyword_ids[0]) {
            keyword_ids[0] = rb_intern("keyword_init");
        }
        rb_get_kwargs(opt, keyword_ids, 0, 1, &amp;keyword_init);
        if (UNDEF_P(keyword_init)) {
            keyword_init = Qnil;
        }
        else if (RTEST(keyword_init)) {
            keyword_init = Qtrue;
        }
    }

    rest = rb_ident_hash_new();
    RBASIC_CLEAR_CLASS(rest);
    for (i=0; i&lt;argc; i++) {
        VALUE mem = rb_to_symbol(argv[i]);
        if (rb_is_attrset_sym(mem)) {
            rb_raise(rb_eArgError, "invalid struct member: %"PRIsVALUE, mem);
        }
        if (RTEST(rb_hash_has_key(rest, mem))) {
            rb_raise(rb_eArgError, "duplicate member: %"PRIsVALUE, mem);
        }
        rb_hash_aset(rest, mem, Qtrue);
    }
    rest = rb_hash_keys(rest);
    RBASIC_CLEAR_CLASS(rest);
    OBJ_FREEZE_RAW(rest);
    if (NIL_P(name)) {
        st = anonymous_struct(klass);
    }
    else {
        st = new_struct(name, klass);
    }
    setup_struct(st, rest);
    rb_ivar_set(st, id_keyword_init, keyword_init);
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, st);
    }

    return st;
}</pre> </div> <p><code>Struct.new</code> returns a new subclass of <code>Struct</code>. The new subclass:</p> <ul>
<li> <p>May be anonymous, or may have the name given by <code>class_name</code>.</p> </li>
<li> <p>May have members as given by <code>member_names</code>.</p> </li>
<li> <p>May have initialization via ordinary arguments, or via keyword arguments</p> </li>
</ul> <p>The new subclass has its own method <code>::new</code>; thus:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new('Foo', :foo, :bar) # =&gt; Struct::Foo
f = Foo.new(0, 1)                   # =&gt; #&lt;struct Struct::Foo foo=0, bar=1&gt;
</pre> <p><strong>Class Name</strong></p> <p>With string argument <code>class_name</code>, returns a new subclass of <code>Struct</code> named <code>Struct::<em>class_name</em></code>:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new('Foo', :foo, :bar) # =&gt; Struct::Foo
Foo.name                            # =&gt; "Struct::Foo"
Foo.superclass                      # =&gt; Struct
</pre> <p>Without string argument <code>class_name</code>, returns a new anonymous subclass of <code>Struct</code>:</p> <pre class="ruby" data-language="ruby">Struct.new(:foo, :bar).name # =&gt; nil
</pre> <p><strong>Block</strong></p> <p>With a block given, the created subclass is yielded to the block:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new('Customer', :name, :address) do |new_class|
  p "The new subclass is #{new_class}"
  def greeting
    "Hello #{name} at #{address}"
  end
end           # =&gt; Struct::Customer
dave = Customer.new('Dave', '123 Main')
dave # =&gt;     #&lt;struct Struct::Customer name="Dave", address="123 Main"&gt;
dave.greeting # =&gt; "Hello Dave at 123 Main"
</pre> <p>Output, from <code>Struct.new</code>:</p> <pre class="ruby" data-language="ruby">"The new subclass is Struct::Customer"
</pre> <p><strong>Member Names</strong></p> <p><a href="symbol.html"><code>Symbol</code></a> arguments <code>member_names</code> determines the members of the new subclass:</p> <pre class="ruby" data-language="ruby">Struct.new(:foo, :bar).members        # =&gt; [:foo, :bar]
Struct.new('Foo', :foo, :bar).members # =&gt; [:foo, :bar]
</pre> <p>The new subclass has instance methods corresponding to <code>member_names</code>:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new('Foo', :foo, :bar)
Foo.instance_methods(false) # =&gt; [:foo, :bar, :foo=, :bar=]
f = Foo.new                 # =&gt; #&lt;struct Struct::Foo foo=nil, bar=nil&gt;
f.foo                       # =&gt; nil
f.foo = 0                   # =&gt; 0
f.bar                       # =&gt; nil
f.bar = 1                   # =&gt; 1
f                           # =&gt; #&lt;struct Struct::Foo foo=0, bar=1&gt;
</pre> <p><strong>Singleton Methods</strong></p> <p>A subclass returned by <a href="struct.html#method-c-new"><code>Struct.new</code></a> has these singleton methods:</p> <ul>
<li> <p>Method <code>::new </code> creates an instance of the subclass:</p> <pre class="ruby" data-language="ruby">Foo.new          # =&gt; #&lt;struct Struct::Foo foo=nil, bar=nil&gt;
Foo.new(0)       # =&gt; #&lt;struct Struct::Foo foo=0, bar=nil&gt;
Foo.new(0, 1)    # =&gt; #&lt;struct Struct::Foo foo=0, bar=1&gt;
Foo.new(0, 1, 2) # Raises ArgumentError: struct size differs

# Initialization with keyword arguments:
Foo.new(foo: 0)         # =&gt; #&lt;struct Struct::Foo foo=0, bar=nil&gt;
Foo.new(foo: 0, bar: 1) # =&gt; #&lt;struct Struct::Foo foo=0, bar=1&gt;
Foo.new(foo: 0, bar: 1, baz: 2)
# Raises ArgumentError: unknown keywords: baz
</pre> </li>
<li> <p>Method <code>:inspect</code> returns a string representation of the subclass:</p> <pre class="ruby" data-language="ruby">Foo.inspect
# =&gt; "Struct::Foo"
</pre> </li>
<li> <p>Method <code>::members</code> returns an array of the member names:</p> <pre class="ruby" data-language="ruby">Foo.members # =&gt; [:foo, :bar]
</pre> </li>
</ul> <p><strong>Keyword Argument</strong></p> <p>By default, the arguments for initializing an instance of the new subclass can be both positional and keyword arguments.</p> <p>Optional keyword argument <code>keyword_init:</code> allows to force only one type of arguments to be accepted:</p> <pre class="ruby" data-language="ruby">KeywordsOnly = Struct.new(:foo, :bar, keyword_init: true)
KeywordsOnly.new(bar: 1, foo: 0)
# =&gt; #&lt;struct KeywordsOnly foo=0, bar=1&gt;
KeywordsOnly.new(0, 1)
# Raises ArgumentError: wrong number of arguments

PositionalOnly = Struct.new(:foo, :bar, keyword_init: false)
PositionalOnly.new(0, 1)
# =&gt; #&lt;struct PositionalOnly foo=0, bar=1&gt;
PositionalOnly.new(bar: 1, foo: 0)
# =&gt; #&lt;struct PositionalOnly foo={:foo=&gt;1, :bar=&gt;2}, bar=nil&gt;
# Note that no error is raised, but arguments treated as one hash value

# Same as not providing keyword_init:
Any = Struct.new(:foo, :bar, keyword_init: nil)
Any.new(foo: 1, bar: 2)
# =&gt; #&lt;struct Any foo=1, bar=2&gt;
Any.new(1, 2)
# =&gt; #&lt;struct Any foo=1, bar=2&gt;
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> self == other → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_struct_equal(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_equal, s, s2, s2);
}</pre> </div> <p>Returns <code>true</code> if and only if the following are true; otherwise returns <code>false</code>:</p> <ul>
<li> <p><code>other.class == self.class</code>.</p> </li>
<li> <p>For each member name <code>name</code>, <code>other.name == self.name</code>.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe_jr == joe # =&gt; true
joe_jr[:name] = 'Joe Smith, Jr.'
# =&gt; "Joe Smith, Jr."
joe_jr == joe # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> struct[name] → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[n] → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aref(VALUE s, VALUE idx)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    return RSTRUCT_GET(s, i);
}</pre> </div> <p>Returns a value from <code>self</code>.</p> <p>With symbol or string argument <code>name</code> given, returns the value for the named member:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe[:zip] # =&gt; 12345
</pre> <p>Raises <a href="nameerror.html"><code>NameError</code></a> if <code>name</code> is not the name of a member.</p> <p>With integer argument <code>n</code> given, returns <code>self.values[n]</code> if <code>n</code> is in range; see <a href="array.html#class-Array-label-Array+Indexes">Array Indexes at <code>Array</code></a>:</p> <pre class="ruby" data-language="ruby">joe[2]  # =&gt; 12345
joe[-2] # =&gt; "123 Maple, Anytown NC"
</pre> <p>Raises <a href="indexerror.html"><code>IndexError</code></a> if <code>n</code> is out of range.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> struct[name] = value → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[n] = value → value </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aset(VALUE s, VALUE idx, VALUE val)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    rb_struct_modify(s);
    RSTRUCT_SET(s, i, val);
    return val;
}</pre> </div> <p>Assigns a value to a member.</p> <p>With symbol or string argument <code>name</code> given, assigns the given <code>value</code> to the named member; returns <code>value</code>:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe[:zip] = 54321 # =&gt; 54321
joe # =&gt; #&lt;struct Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=54321&gt;
</pre> <p>Raises <a href="nameerror.html"><code>NameError</code></a> if <code>name</code> is not the name of a member.</p> <p>With integer argument <code>n</code> given, assigns the given <code>value</code> to the <code>n</code>-th member if <code>n</code> is in range; see <a href="array.html#class-Array-label-Array+Indexes">Array Indexes at <code>Array</code></a>:</p> <pre class="ruby" data-language="ruby">joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe[2] = 54321           # =&gt; 54321
joe[-3] = 'Joseph Smith' # =&gt; "Joseph Smith"
joe # =&gt; #&lt;struct Customer name="Joseph Smith", address="123 Maple, Anytown NC", zip=54321&gt;
</pre> <p>Raises <a href="indexerror.html"><code>IndexError</code></a> if <code>n</code> is out of range.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 30
def as_json(*)
  klass = self.class.name
  klass.to_s.empty? and raise JSON::JSONError, "Only named structs are supported!"
  {
    JSON.create_id =&gt; klass,
    'v'            =&gt; values,
  }
end</pre> </div> <p>Methods <code>Struct#as_json</code> and <code>Struct.json_create</code> may be used to serialize and deserialize a Struct object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <code>Struct#as_json</code> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/struct'
Customer = Struct.new('Customer', :name, :address, :zip)
x = Struct::Customer.new.as_json
# =&gt; {"json_class"=&gt;"Struct::Customer", "v"=&gt;[nil, nil, nil]}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Struct object:</p> <pre class="ruby" data-language="ruby">Struct::Customer.json_create(x)
# =&gt; #&lt;struct Struct::Customer name=nil, address=nil, zip=nil&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct"> <span class="method-name">deconstruct</span> </div> </div> <div class="aliases"> Alias for: <a href="struct.html#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-callseq"> deconstruct_keys(array_of_names) → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
rb_struct_deconstruct_keys(VALUE s, VALUE keys)
{
    VALUE h;
    long i;

    if (NIL_P(keys)) {
        return rb_struct_to_h(s);
    }
    if (UNLIKELY(!RB_TYPE_P(keys, T_ARRAY))) {
        rb_raise(rb_eTypeError,
                 "wrong argument type %"PRIsVALUE" (expected Array or nil)",
                 rb_obj_class(keys));

    }
    if (RSTRUCT_LEN(s) &lt; RARRAY_LEN(keys)) {
        return rb_hash_new_with_size(0);
    }
    h = rb_hash_new_with_size(RARRAY_LEN(keys));
    for (i=0; i&lt;RARRAY_LEN(keys); i++) {
        VALUE key = RARRAY_AREF(keys, i);
        int i = rb_struct_pos(s, &amp;key);
        if (i &lt; 0) {
            return h;
        }
        rb_hash_aset(h, key, RSTRUCT_GET(s, i));
    }
    return h;
}</pre> </div> <p>Returns a hash of the name/value pairs for the given member names.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
h = joe.deconstruct_keys([:zip, :address])
h # =&gt; {:zip=&gt;12345, :address=&gt;"123 Maple, Anytown NC"}
</pre> <p>Returns all names and values if <code>array_of_names</code> is <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = joe.deconstruct_keys(nil)
h # =&gt; {:name=&gt;"Joseph Smith, Jr.", :address=&gt;"123 Maple, Anytown NC", :zip=&gt;12345}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(name, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> dig(n, *identifiers) → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_struct_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_struct_lookup(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Finds and returns an object among nested objects. The nested objects may be instances of various classes. See <a href="dig_methods_rdoc.html">Dig Methods</a>.</p> <p>Given symbol or string argument <code>name</code>, returns the object that is specified by <code>name</code> and <code>identifiers</code>:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new(:a)
f = Foo.new(Foo.new({b: [1, 2, 3]}))
f.dig(:a) # =&gt; #&lt;struct Foo a={:b=&gt;[1, 2, 3]}&gt;
f.dig(:a, :a) # =&gt; {:b=&gt;[1, 2, 3]}
f.dig(:a, :a, :b) # =&gt; [1, 2, 3]
f.dig(:a, :a, :b, 0) # =&gt; 1
f.dig(:b, 0) # =&gt; nil
</pre> <p>Given integer argument <code>n</code>, returns the object that is specified by <code>n</code> and <code>identifiers</code>:</p> <pre class="ruby" data-language="ruby">f.dig(0) # =&gt; #&lt;struct Foo a={:b=&gt;[1, 2, 3]}&gt;
f.dig(0, 0) # =&gt; {:b=&gt;[1, 2, 3]}
f.dig(0, 0, :b) # =&gt; [1, 2, 3]
f.dig(0, 0, :b, 0) # =&gt; 1
f.dig(:b, 0) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each(VALUE s)
{
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        rb_yield(RSTRUCT_GET(s, i));
    }
    return s;
}</pre> </div> <p>Calls the given block with the value of each member; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each {|value| p value }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"Joe Smith"
"123 Maple, Anytown NC"
12345
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> <p>Related: <a href="struct.html#method-i-each_pair"><code>each_pair</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_pair"> <span class="method-callseq"> each_pair {|(name, value)| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each_pair(VALUE s)
{
    VALUE members;
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    members = rb_struct_members(s);
    if (rb_block_pair_yield_optimizable()) {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield_values(2, key, value);
        }
    }
    else {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield(rb_assoc_new(key, value));
        }
    }
    return s;
}</pre> </div> <p>Calls the given block with each member name/value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip) # =&gt; Customer
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each_pair {|(name, value)| p "#{name} =&gt; #{value}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"name =&gt; Joe Smith"
"address =&gt; 123 Maple, Anytown NC"
"zip =&gt; 12345"
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> <p>Related: <a href="struct.html#method-i-each"><code>each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_struct_eql(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_eql, s, s2, s2);
}</pre> </div> <p>Returns <code>true</code> if and only if the following are true; otherwise returns <code>false</code>:</p> <ul>
<li> <p><code>other.class == self.class</code>.</p> </li>
<li> <p>For each member name <code>name</code>, <code>other.name.eql?(self.name)</code>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe_jr.eql?(joe) # =&gt; true
joe_jr[:name] = 'Joe Smith, Jr.'
joe_jr.eql?(joe) # =&gt; false
</pre> </li>
</ul> <p>Related: <a href="basicobject.html#method-i-3D-3D"><code>Object#==</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter"> <span class="method-name">filter</span> </div> </div> <div class="aliases"> Alias for: <a href="struct.html#method-i-select">select</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_struct_hash(VALUE s)
{
    long i, len;
    st_index_t h;
    VALUE n;

    h = rb_hash_start(rb_hash(rb_obj_class(s)));
    len = RSTRUCT_LEN(s);
    for (i = 0; i &lt; len; i++) {
        n = rb_hash(RSTRUCT_GET(s, i));
        h = rb_hash_uint(h, NUM2LONG(n));
    }
    h = rb_hash_end(h);
    return ST2FIX(h);
}</pre> </div> <p>Returns the integer hash value for <code>self</code>.</p> <p>Two structs of the same class and with the same content will have the same hash code (and will compare using <a href="struct.html#method-i-eql-3F"><code>Struct#eql?</code></a>):</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.hash == joe_jr.hash # =&gt; true
joe_jr[:name] = 'Joe Smith, Jr.'
joe.hash == joe_jr.hash # =&gt; false
</pre> <p>Related: <a href="object.html#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_struct_inspect(VALUE s)
{
    return rb_exec_recursive(inspect_struct, s, rb_str_new2("#&lt;struct "));
}</pre> </div> <p>Returns a string representation of <code>self</code>:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip) # =&gt; Customer
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.inspect # =&gt; "#&lt;struct Customer name=\"Joe Smith\", address=\"123 Maple, Anytown NC\", zip=12345&gt;"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="struct.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-length"> <span class="method-name">length</span> </div> </div> <div class="aliases"> Alias for: <a href="struct.html#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-members"> <span class="method-callseq"> members → array_of_symbols </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="members-source"> <pre class="c" data-language="c">static VALUE
rb_struct_members_m(VALUE obj)
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}</pre> </div> <p>Returns the member names from <code>self</code> as an array:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
Customer.new.members # =&gt; [:name, :address, :zip]
</pre> <p>Related: <a href="struct.html#method-i-to_a"><code>to_a</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|value| ... } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_struct_select(int argc, VALUE *argv, VALUE s)
{
    VALUE result;
    long i;

    rb_check_arity(argc, 0, 0);
    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT_LEN(s); i++) {
        if (RTEST(rb_yield(RSTRUCT_GET(s, i)))) {
            rb_ary_push(result, RSTRUCT_GET(s, i));
        }
    }

    return result;
}</pre> </div> <p>With a block given, returns an array of values from <code>self</code> for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
a = joe.select {|value| value.is_a?(String) }
a # =&gt; ["Joe Smith", "123 Maple, Anytown NC"]
a = joe.select {|value| value.is_a?(Integer) }
a # =&gt; [12345]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="struct.html#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</pre> </div> <p>Returns the number of members.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.size #=&gt; 3
</pre>  </div> <div class="aliases"> Also aliased as: <a href="struct.html#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_CONST_PTR(s));
}</pre> </div> <p>Returns the values in <code>self</code> as an array:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a # =&gt; ["Joe Smith", "123 Maple, Anytown NC", 12345]
</pre> <p>Related: <a href="struct.html#method-i-members"><code>members</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="struct.html#method-i-values">values</a>, <a href="struct.html#method-i-deconstruct">deconstruct</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|name, value| ... } → hash </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_h(VALUE s)
{
    VALUE h = rb_hash_new_with_size(RSTRUCT_LEN(s));
    VALUE members = rb_struct_members(s);
    long i;
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        VALUE k = rb_ary_entry(members, i), v = RSTRUCT_GET(s, i);
        if (block_given)
            rb_hash_set_pair(h, rb_yield_values(2, k, v));
        else
            rb_hash_aset(h, k, v);
    }
    return h;
}</pre> </div> <p>Returns a hash containing the name and value for each member:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
h = joe.to_h
h # =&gt; {:name=&gt;"Joe Smith", :address=&gt;"123 Maple, Anytown NC", :zip=&gt;12345}
</pre> <p>If a block is given, it is called with each name/value pair; the block should return a 2-element array whose elements will become a key/value pair in the returned hash:</p> <pre class="ruby" data-language="ruby">h = joe.to_h{|name, value| [name.upcase, value.to_s.upcase]}
h # =&gt; {:NAME=&gt;"JOE SMITH", :ADDRESS=&gt;"123 MAPLE, ANYTOWN NC", :ZIP=&gt;"12345"}
</pre> <p>Raises <a href="argumenterror.html"><code>ArgumentError</code></a> if the block returns an inappropriate value.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 49
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/struct'
Customer = Struct.new('Customer', :name, :address, :zip)
puts Struct::Customer.new.to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Struct","t":{'name':'Rowdy',"age":null}}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span> </div> </div> <div class="aliases"> Alias for: <a href="struct.html#method-i-inspect">inspect</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span> </div> </div> <div class="aliases"> Alias for: <a href="struct.html#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(*integers) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> values_at(integer_range) → array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_struct_values_at(int argc, VALUE *argv, VALUE s)
{
    return rb_get_values_at(s, RSTRUCT_LEN(s), argc, argv, struct_entry);
}</pre> </div> <p>Returns an array of values from <code>self</code>.</p> <p>With integer arguments <code>integers</code> given, returns an array containing each value given by one of <code>integers</code>:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.values_at(0, 2)    # =&gt; ["Joe Smith", 12345]
joe.values_at(2, 0)    # =&gt; [12345, "Joe Smith"]
joe.values_at(2, 1, 0) # =&gt; [12345, "123 Maple, Anytown NC", "Joe Smith"]
joe.values_at(0, -3)   # =&gt; ["Joe Smith", "Joe Smith"]
</pre> <p>Raises <a href="indexerror.html"><code>IndexError</code></a> if any of <code>integers</code> is out of range; see <a href="array.html#class-Array-label-Array+Indexes">Array Indexes at <code>Array</code></a>.</p> <p>With integer range argument <code>integer_range</code> given, returns an array containing each value given by the elements of the range; fills with <code>nil</code> values for range elements larger than the structure:</p> <pre class="ruby" data-language="ruby">joe.values_at(0..2)
# =&gt; ["Joe Smith", "123 Maple, Anytown NC", 12345]
joe.values_at(-3..-1)
# =&gt; ["Joe Smith", "123 Maple, Anytown NC", 12345]
joe.values_at(1..4) # =&gt; ["123 Maple, Anytown NC", 12345, nil, nil]
</pre> <p>Raises <a href="rangeerror.html"><code>RangeError</code></a> if any element of the range is negative and out of range; see <a href="array.html#class-Array-label-Array+Indexes">Array Indexes at <code>Array</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
