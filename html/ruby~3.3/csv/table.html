<h1 id="class-CSV::Table" class="class"> class CSV::Table </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <h1 id="class-CSV::Table-label-CSV-3A-3ATable">CSV::Table</h1> <p>A CSV::Table instance represents CSV data. (see <a href="../csv.html">class CSV</a>).</p> <p>The instance may have:</p> <ul>
<li> <p>Rows: each is a Table::Row object.</p> </li>
<li> <p>Headers: names for the columns.</p> </li>
</ul> <h3 id="class-CSV::Table-label-Instance+Methods">Instance Methods</h3> <p>CSV::Table has three groups of instance methods:</p> <ul>
<li> <p>Its own internally defined instance methods.</p> </li>
<li> <p>Methods included by module <a href="../enumerable.html"><code>Enumerable</code></a>.</p> </li>
<li> <p>Methods delegated to class <a href="../array.html"><code>Array</code></a>.:</p> <ul>
<li> <p><a href="../array.html#method-i-empty-3F"><code>Array#empty?</code></a></p> </li>
<li> <p><a href="../array.html#method-i-length"><code>Array#length</code></a></p> </li>
<li> <p><a href="../array.html#method-i-size"><code>Array#size</code></a></p> </li>
</ul> </li>
</ul> <h2 id="class-CSV::Table-label-Creating+a+CSV-3A-3ATable+Instance">Creating a CSV::Table Instance</h2> <p>Commonly, a new CSV::Table instance is created by parsing CSV source using headers:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.class # =&gt; CSV::Table
</pre> <p>You can also create an instance directly. See <a href="table.html#method-c-new"><code>::new</code></a>.</p> <h2 id="class-CSV::Table-label-Headers">Headers</h2> <p>If a table has headers, the headers serve as labels for the columns of data. Each header serves as the label for its column.</p> <p>The headers for a CSV::Table object are stored as an Array of Strings.</p> <p>Commonly, headers are defined in the first row of CSV source:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.headers # =&gt; ["Name", "Value"]
</pre> <p>If no headers are defined, the Array is empty:</p> <pre class="ruby" data-language="ruby">table = CSV::Table.new([])
table.headers # =&gt; []
</pre> <h2 id="class-CSV::Table-label-Access+Modes">Access Modes</h2> <p>CSV::Table provides three modes for accessing table data:</p> <ul>
<li> <p>Row mode.</p> </li>
<li> <p>Column mode.</p> </li>
<li> <p>Mixed mode (the default for a new table).</p> </li>
</ul> <p>The access mode for aCSV::Table instance affects the behavior of some of its instance methods:</p> <ul>
<li> <p><a href="table.html#method-i-5B-5D"><code>[]</code></a></p> </li>
<li> <p><a href="table.html#method-i-5B-5D-3D"><code>[]=</code></a></p> </li>
<li> <p><a href="table.html#method-i-delete"><code>delete</code></a></p> </li>
<li> <p><a href="table.html#method-i-delete_if"><code>delete_if</code></a></p> </li>
<li> <p><a href="table.html#method-i-each"><code>each</code></a></p> </li>
<li> <p><a href="table.html#method-i-values_at"><code>values_at</code></a></p> </li>
</ul> <h3 id="class-CSV::Table-label-Row+Mode">Row Mode</h3> <p><a href="../set.html"><code>Set</code></a> a table to row mode with method <a href="table.html#method-i-by_row-21"><code>by_row!</code></a>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
</pre> <p>Specify a single row by an Integer index:</p> <pre class="ruby" data-language="ruby"># Get a row.
table[1] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
# Set a row, then get it.
table[1] = CSV::Row.new(['Name', 'Value'], ['bam', 3])
table[1] # =&gt; #&lt;CSV::Row "Name":"bam" "Value":3&gt;
</pre> <p>Specify a sequence of rows by a Range:</p> <pre class="ruby" data-language="ruby"># Get rows.
table[1..2] # =&gt; [#&lt;CSV::Row "Name":"bam" "Value":3&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
# Set rows, then get them.
table[1..2] = [
  CSV::Row.new(['Name', 'Value'], ['bat', 4]),
  CSV::Row.new(['Name', 'Value'], ['bad', 5]),
]
table[1..2] # =&gt; [["Name", #&lt;CSV::Row "Name":"bat" "Value":4&gt;], ["Value", #&lt;CSV::Row "Name":"bad" "Value":5&gt;]]
</pre> <h3 id="class-CSV::Table-label-Column+Mode">Column Mode</h3> <p><a href="../set.html"><code>Set</code></a> a table to column mode with method <a href="table.html#method-i-by_col-21"><code>by_col!</code></a>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
</pre> <p>Specify a column by an Integer index:</p> <pre class="ruby" data-language="ruby"># Get a column.
table[0]
# Set a column, then get it.
table[0] = ['FOO', 'BAR', 'BAZ']
table[0] # =&gt; ["FOO", "BAR", "BAZ"]
</pre> <p>Specify a column by its String header:</p> <pre class="ruby" data-language="ruby"># Get a column.
table['Name'] # =&gt; ["FOO", "BAR", "BAZ"]
# Set a column, then get it.
table['Name'] = ['Foo', 'Bar', 'Baz']
table['Name'] # =&gt; ["Foo", "Bar", "Baz"]
</pre> <h3 id="class-CSV::Table-label-Mixed+Mode">Mixed Mode</h3> <p>In mixed mode, you can refer to either rows or columns:</p> <ul>
<li> <p>An Integer index refers to a row.</p> </li>
<li> <p>A Range index refers to multiple rows.</p> </li>
<li> <p>A String index refers to a column.</p> </li>
</ul> <p><a href="../set.html"><code>Set</code></a> a table to mixed mode with method <a href="table.html#method-i-by_col_or_row-21"><code>by_col_or_row!</code></a>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre> <p>Specify a single row by an Integer index:</p> <pre class="ruby" data-language="ruby"># Get a row.
table[1] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
# Set a row, then get it.
table[1] = CSV::Row.new(['Name', 'Value'], ['bam', 3])
table[1] # =&gt; #&lt;CSV::Row "Name":"bam" "Value":3&gt;
</pre> <p>Specify a sequence of rows by a Range:</p> <pre class="ruby" data-language="ruby"># Get rows.
table[1..2] # =&gt; [#&lt;CSV::Row "Name":"bam" "Value":3&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
# Set rows, then get them.
table[1] = CSV::Row.new(['Name', 'Value'], ['bat', 4])
table[2] = CSV::Row.new(['Name', 'Value'], ['bad', 5])
table[1..2] # =&gt; [["Name", #&lt;CSV::Row "Name":"bat" "Value":4&gt;], ["Value", #&lt;CSV::Row "Name":"bad" "Value":5&gt;]]
</pre> <p>Specify a column by its String header:</p> <pre class="ruby" data-language="ruby"># Get a column.
table['Name'] # =&gt; ["foo", "bat", "bad"]
# Set a column, then get it.
table['Name'] = ['Foo', 'Bar', 'Baz']
table['Name'] # =&gt; ["Foo", "Bar", "Baz"]
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-mode"> <span class="method-name">mode</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The current access mode for indexing and iteration.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-table"> <span class="method-name">table</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Internal data format used to compare equality.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> CSV::Table.new(array_of_rows, headers = nil) → csv_table </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 199
def initialize(array_of_rows, headers: nil)
  @table = array_of_rows
  @headers = headers
  unless @headers
    if @table.empty?
      @headers = []
    else
      @headers = @table.first.headers
    end
  end

  @mode  = :col_or_row
end</pre> </div> <p>Returns a new CSV::Table object.</p> <ul>
<li> <p>Argument <code>array_of_rows</code> must be an Array of <a href="row.html"><code>CSV::Row</code></a> objects.</p> </li>
<li> <p>Argument <code>headers</code>, if given, may be an Array of Strings.</p> </li>
</ul>  <p>Create an empty CSV::Table object:</p> <pre class="ruby" data-language="ruby">table = CSV::Table.new([])
table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:1&gt;
</pre> <p>Create a non-empty CSV::Table object:</p> <pre class="ruby" data-language="ruby">rows = [
  CSV::Row.new([], []),
  CSV::Row.new([], []),
  CSV::Row.new([], []),
]
table  = CSV::Table.new(rows)
table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre>  <p>If argument <code>headers</code> is an Array of Strings, those Strings become the table’s headers:</p> <pre class="ruby" data-language="ruby">table = CSV::Table.new([], headers: ['Name', 'Age'])
table.headers # =&gt; ["Name", "Age"]
</pre> <p>If argument <code>headers</code> is not given and the table has rows, the headers are taken from the first row:</p> <pre class="ruby" data-language="ruby">rows = [
  CSV::Row.new(['Foo', 'Bar'], []),
  CSV::Row.new(['foo', 'bar'], []),
  CSV::Row.new(['FOO', 'BAR'], []),
]
table  = CSV::Table.new(rows)
table.headers # =&gt; ["Foo", "Bar"]
</pre> <p>If argument <code>headers</code> is not given and the table is empty (has no rows), the headers are also empty:</p> <pre class="ruby" data-language="ruby">table  = CSV::Table.new([])
table.headers # =&gt; []
</pre>  <p>Raises an exception if argument <code>array_of_rows</code> is not an Array object:</p> <pre class="ruby" data-language="ruby"># Raises NoMethodError (undefined method `first' for :foo:Symbol):
CSV::Table.new(:foo)
</pre> <p>Raises an exception if an element of <code>array_of_rows</code> is not a CSV::Table object:</p> <pre class="ruby" data-language="ruby"># Raises NoMethodError (undefined method `headers' for :foo:Symbol):
CSV::Table.new([:foo])
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> table &lt;&lt; row_or_array → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 762
def &lt;&lt;(row_or_array)
  if row_or_array.is_a? Array  # append Array
    @table &lt;&lt; Row.new(headers, row_or_array)
  else                         # append Row
    @table &lt;&lt; row_or_array
  end

  self # for chaining
end</pre> </div> <p>If <code>row_or_array</code> is a CSV::Row object, it is appended to the table:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table &lt;&lt; CSV::Row.new(table.headers, ['bat', 3])
table[3] # =&gt; #&lt;CSV::Row "Name":"bat" "Value":3&gt;
</pre> <p>If <code>row_or_array</code> is an Array, it is used to create a new CSV::Row object which is then appended to the table:</p> <pre class="ruby" data-language="ruby">table &lt;&lt; ['bam', 4]
table[4] # =&gt; #&lt;CSV::Row "Name":"bam" "Value":4&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> table == other_table → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 965
def ==(other)
  return @table == other.table if other.is_a? CSV::Table
  @table == other
end</pre> </div> <p>Returns <code>true</code> if all each row of <code>self</code> <code>==</code> the corresponding row of <code>other_table</code>, otherwise, <code>false</code>.</p> <p>The access mode does no affect the result.</p> <p>Equal tables:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
other_table = CSV.parse(source, headers: true)
table == other_table # =&gt; true
</pre> <p>Different row count:</p> <pre class="ruby" data-language="ruby">other_table.delete(2)
table == other_table # =&gt; false
</pre> <p>Different last row:</p> <pre class="ruby" data-language="ruby">other_table &lt;&lt; ['bat', 3]
table == other_table # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> table[n] → row or column_data </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> table[range] → array_of_rows or array_of_column_data </span> </div> <div class="method-heading"> <span class="method-callseq"> table[header] → array_of_column_data </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 514
def [](index_or_header)
  if @mode == :row or  # by index
     (@mode == :col_or_row and (index_or_header.is_a?(Integer) or index_or_header.is_a?(Range)))
    @table[index_or_header]
  else                 # by header
    @table.map { |row| row[index_or_header] }
  end
end</pre> </div> <p>Returns data from the table; does not modify the table.</p>  <dl class="rdoc-list note-list">
<dt>Fetch a Row by Its Integer Index </dt>

</dl> <ul>
<li> <p>Form: <code>table[n]</code>, <code>n</code> an integer.</p> </li>
<li> <p>Access mode: <code>:row</code> or <code>:col_or_row</code>.</p> </li>
<li> <p>Return value: <em>nth</em> row of the table, if that row exists; otherwise <code>nil</code>.</p> </li>
</ul> <p>Returns the <em>nth</em> row of the table if that row exists:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
table[1] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
table[1] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
</pre> <p>Counts backward from the last row if <code>n</code> is negative:</p> <pre class="ruby" data-language="ruby">table[-1] # =&gt; #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;
</pre> <p>Returns <code>nil</code> if <code>n</code> is too large or too small:</p> <pre class="ruby" data-language="ruby">table[4] # =&gt; nil
table[-4] # =&gt; nil
</pre> <p>Raises an exception if the access mode is <code>:row</code> and <code>n</code> is not an Integer:</p> <pre class="ruby" data-language="ruby">table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
# Raises TypeError (no implicit conversion of String into Integer):
table['Name']
</pre>  <dl class="rdoc-list note-list">
<dt>Fetch a Column by Its Integer Index </dt>

</dl> <ul>
<li> <p>Form: <code>table[n]</code>, <code>n</code> an Integer.</p> </li>
<li> <p>Access mode: <code>:col</code>.</p> </li>
<li> <p>Return value: <em>nth</em> column of the table, if that column exists; otherwise an Array of <code>nil</code> fields of length <code>self.size</code>.</p> </li>
</ul> <p>Returns the <em>nth</em> column of the table if that column exists:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
table[1] # =&gt; ["0", "1", "2"]
</pre> <p>Counts backward from the last column if <code>n</code> is negative:</p> <pre class="ruby" data-language="ruby">table[-2] # =&gt; ["foo", "bar", "baz"]
</pre> <p>Returns an Array of <code>nil</code> fields if <code>n</code> is too large or too small:</p> <pre class="ruby" data-language="ruby">table[4] # =&gt; [nil, nil, nil]
table[-4] # =&gt; [nil, nil, nil]
</pre>  <dl class="rdoc-list note-list">
<dt>Fetch Rows by Range </dt>

</dl> <ul>
<li> <p>Form: <code>table[range]</code>, <code>range</code> a Range object.</p> </li>
<li> <p>Access mode: <code>:row</code> or <code>:col_or_row</code>.</p> </li>
<li> <p>Return value: rows from the table, beginning at row <code>range.start</code>, if those rows exists.</p> </li>
</ul> <p>Returns rows from the table, beginning at row <code>range.first</code>, if those rows exist:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
rows = table[1..2] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
rows # =&gt; [#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
rows = table[1..2] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
rows # =&gt; [#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
</pre> <p>If there are too few rows, returns all from <code>range.start</code> to the end:</p> <pre class="ruby" data-language="ruby">rows = table[1..50] # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
rows # =&gt; [#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
</pre> <p>Special case: if <code>range.start == table.size</code>, returns an empty Array:</p> <pre class="ruby" data-language="ruby">table[table.size..50] # =&gt; []
</pre> <p>If <code>range.end</code> is negative, calculates the ending index from the end:</p> <pre class="ruby" data-language="ruby">rows = table[0..-1]
rows # =&gt; [#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;, #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
</pre> <p>If <code>range.start</code> is negative, calculates the starting index from the end:</p> <pre class="ruby" data-language="ruby">rows = table[-1..2]
rows # =&gt; [#&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
</pre> <p>If <code>range.start</code> is larger than <code>table.size</code>, returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">table[4..4] # =&gt; nil
</pre>  <dl class="rdoc-list note-list">
<dt>Fetch Columns by Range </dt>

</dl> <ul>
<li> <p>Form: <code>table[range]</code>, <code>range</code> a Range object.</p> </li>
<li> <p>Access mode: <code>:col</code>.</p> </li>
<li> <p>Return value: column data from the table, beginning at column <code>range.start</code>, if those columns exist.</p> </li>
</ul> <p>Returns column values from the table, if the column exists; the values are arranged by row:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col!
table[0..1] # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Special case: if <code>range.start == headers.size</code>, returns an Array (size: <code>table.size</code>) of empty Arrays:</p> <pre class="ruby" data-language="ruby">table[table.headers.size..50] # =&gt; [[], [], []]
</pre> <p>If <code>range.end</code> is negative, calculates the ending index from the end:</p> <pre class="ruby" data-language="ruby">table[0..-1] # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>If <code>range.start</code> is negative, calculates the starting index from the end:</p> <pre class="ruby" data-language="ruby">table[-2..2] # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>If <code>range.start</code> is larger than <code>table.size</code>, returns an Array of <code>nil</code> values:</p> <pre class="ruby" data-language="ruby">table[4..4] # =&gt; [nil, nil, nil]
</pre>  <dl class="rdoc-list note-list">
<dt>Fetch a Column by Its String Header </dt>

</dl> <ul>
<li> <p>Form: <code>table[header]</code>, <code>header</code> a String header.</p> </li>
<li> <p>Access mode: <code>:col</code> or <code>:col_or_row</code></p> </li>
<li> <p>Return value: column data from the table, if that <code>header</code> exists.</p> </li>
</ul> <p>Returns column values from the table, if the column exists:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
table['Name'] # =&gt; ["foo", "bar", "baz"]
table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
col = table['Name']
col # =&gt; ["foo", "bar", "baz"]
</pre> <p>Modifying the returned column values does not modify the table:</p> <pre class="ruby" data-language="ruby">col[0] = 'bat'
col # =&gt; ["bat", "bar", "baz"]
table['Name'] # =&gt; ["foo", "bar", "baz"]
</pre> <p>Returns an Array of <code>nil</code> values if there is no such column:</p> <pre class="ruby" data-language="ruby">table['Nosuch'] # =&gt; [nil, nil, nil]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> table[n] = row → row </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> table[n] = field_or_array_of_fields → field_or_array_of_fields </span> </div> <div class="method-heading"> <span class="method-callseq"> table[header] = field_or_array_of_fields → field_or_array_of_fields </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 649
def []=(index_or_header, value)
  if @mode == :row or  # by index
     (@mode == :col_or_row and index_or_header.is_a? Integer)
    if value.is_a? Array
      @table[index_or_header] = Row.new(headers, value)
    else
      @table[index_or_header] = value
    end
  else                 # set column
    unless index_or_header.is_a? Integer
      index = @headers.index(index_or_header) || @headers.size
      @headers[index] = index_or_header
    end
    if value.is_a? Array  # multiple values
      @table.each_with_index do |row, i|
        if row.header_row?
          row[index_or_header] = index_or_header
        else
          row[index_or_header] = value[i]
        end
      end
    else                  # repeated value
      @table.each do |row|
        if row.header_row?
          row[index_or_header] = index_or_header
        else
          row[index_or_header] = value
        end
      end
    end
  end
end</pre> </div> <p>Puts data onto the table.</p>  <dl class="rdoc-list note-list">
<dt>
<a href="../set.html"><code>Set</code></a> a Row by Its Integer Index </dt>

</dl> <ul>
<li> <p>Form: <code>table[n] = row</code>, <code>n</code> an Integer, <code>row</code> a CSV::Row instance or an Array of fields.</p> </li>
<li> <p>Access mode: <code>:row</code> or <code>:col_or_row</code>.</p> </li>
<li> <p>Return value: <code>row</code>.</p> </li>
</ul> <p>If the row exists, it is replaced:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
new_row = CSV::Row.new(['Name', 'Value'], ['bat', 3])
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
return_value = table[0] = new_row
return_value.equal?(new_row) # =&gt; true # Returned the row
table[0].to_h # =&gt; {"Name"=&gt;"bat", "Value"=&gt;3}
</pre> <p>With access mode <code>:col_or_row</code>:</p> <pre class="ruby" data-language="ruby">table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
table[0] = CSV::Row.new(['Name', 'Value'], ['bam', 4])
table[0].to_h # =&gt; {"Name"=&gt;"bam", "Value"=&gt;4}
</pre> <p>With an Array instead of a CSV::Row, inherits headers from the table:</p> <pre class="ruby" data-language="ruby">array = ['bad', 5]
return_value = table[0] = array
return_value.equal?(array) # =&gt; true # Returned the array
table[0].to_h # =&gt; {"Name"=&gt;"bad", "Value"=&gt;5}
</pre> <p>If the row does not exist, extends the table by adding rows: assigns rows with <code>nil</code> as needed:</p> <pre class="ruby" data-language="ruby">table.size # =&gt; 3
table[5] = ['bag', 6]
table.size # =&gt; 6
table[3] # =&gt; nil
table[4]# =&gt; nil
table[5].to_h # =&gt; {"Name"=&gt;"bag", "Value"=&gt;6}
</pre> <p>Note that the <code>nil</code> rows are actually <code>nil</code>, not a row of <code>nil</code> fields.</p>  <dl class="rdoc-list note-list">
<dt>
<a href="../set.html"><code>Set</code></a> a Column by Its Integer Index </dt>

</dl> <ul>
<li> <p>Form: <code>table[n] = array_of_fields</code>, <code>n</code> an Integer, <code>array_of_fields</code> an Array of String fields.</p> </li>
<li> <p>Access mode: <code>:col</code>.</p> </li>
<li> <p>Return value: <code>array_of_fields</code>.</p> </li>
</ul> <p>If the column exists, it is replaced:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
new_col = [3, 4, 5]
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
return_value = table[1] = new_col
return_value.equal?(new_col) # =&gt; true # Returned the column
table[1] # =&gt; [3, 4, 5]
# The rows, as revised:
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
table[0].to_h # =&gt; {"Name"=&gt;"foo", "Value"=&gt;3}
table[1].to_h # =&gt; {"Name"=&gt;"bar", "Value"=&gt;4}
table[2].to_h # =&gt; {"Name"=&gt;"baz", "Value"=&gt;5}
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
</pre> <p>If there are too few values, fills with <code>nil</code> values:</p> <pre class="ruby" data-language="ruby">table[1] = [0]
table[1] # =&gt; [0, nil, nil]
</pre> <p>If there are too many values, ignores the extra values:</p> <pre class="ruby" data-language="ruby">table[1] = [0, 1, 2, 3, 4]
table[1] # =&gt; [0, 1, 2]
</pre> <p>If a single value is given, replaces all fields in the column with that value:</p> <pre class="ruby" data-language="ruby">table[1] = 'bat'
table[1] # =&gt; ["bat", "bat", "bat"]
</pre>  <dl class="rdoc-list note-list">
<dt>
<a href="../set.html"><code>Set</code></a> a Column by Its String Header </dt>

</dl> <ul>
<li> <p>Form: <code>table[header] = field_or_array_of_fields</code>, <code>header</code> a String header, <code>field_or_array_of_fields</code> a field value or an Array of String fields.</p> </li>
<li> <p>Access mode: <code>:col</code> or <code>:col_or_row</code>.</p> </li>
<li> <p>Return value: <code>field_or_array_of_fields</code>.</p> </li>
</ul> <p>If the column exists, it is replaced:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
new_col = [3, 4, 5]
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
return_value = table['Value'] = new_col
return_value.equal?(new_col) # =&gt; true # Returned the column
table['Value'] # =&gt; [3, 4, 5]
# The rows, as revised:
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
table[0].to_h # =&gt; {"Name"=&gt;"foo", "Value"=&gt;3}
table[1].to_h # =&gt; {"Name"=&gt;"bar", "Value"=&gt;4}
table[2].to_h # =&gt; {"Name"=&gt;"baz", "Value"=&gt;5}
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
</pre> <p>If there are too few values, fills with <code>nil</code> values:</p> <pre class="ruby" data-language="ruby">table['Value'] = [0]
table['Value'] # =&gt; [0, nil, nil]
</pre> <p>If there are too many values, ignores the extra values:</p> <pre class="ruby" data-language="ruby">table['Value'] = [0, 1, 2, 3, 4]
table['Value'] # =&gt; [0, 1, 2]
</pre> <p>If the column does not exist, extends the table by adding columns:</p> <pre class="ruby" data-language="ruby">table['Note'] = ['x', 'y', 'z']
table['Note'] # =&gt; ["x", "y", "z"]
# The rows, as revised:
table.by_row!
table[0].to_h # =&gt; {"Name"=&gt;"foo", "Value"=&gt;0, "Note"=&gt;"x"}
table[1].to_h # =&gt; {"Name"=&gt;"bar", "Value"=&gt;1, "Note"=&gt;"y"}
table[2].to_h # =&gt; {"Name"=&gt;"baz", "Value"=&gt;2, "Note"=&gt;"z"}
table.by_col!
</pre> <p>If a single value is given, replaces all fields in the column with that value:</p> <pre class="ruby" data-language="ruby">table['Value'] = 'bat'
table['Value'] # =&gt; ["bat", "bat", "bat"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_col"> <span class="method-callseq"> by_col → table_dup </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_col-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 242
def by_col
  self.class.new(@table.dup).by_col!
end</pre> </div> <p>Returns a duplicate of <code>self</code>, in column mode (see <a href="#class-CSV::Table-label-Column+Mode">Column Mode</a>):</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.mode # =&gt; :col_or_row
dup_table = table.by_col
dup_table.mode # =&gt; :col
dup_table.equal?(table) # =&gt; false # It's a dup
</pre> <p>This may be used to chain method calls without changing the mode (but also will affect performance and memory usage):</p> <pre class="ruby" data-language="ruby">dup_table.by_col['Name']
</pre> <p>Also note that changes to the duplicate table will not affect the original.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_col-21"> <span class="method-callseq"> by_col! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_col-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 257
def by_col!
  @mode = :col

  self
end</pre> </div> <p>Sets the mode for <code>self</code> to column mode (see <a href="#class-CSV::Table-label-Column+Mode">Column Mode</a>); returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.mode # =&gt; :col_or_row
table1 = table.by_col!
table.mode # =&gt; :col
table1.equal?(table) # =&gt; true # Returned self
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_col_or_row"> <span class="method-callseq"> by_col_or_row → table_dup </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_col_or_row-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 280
def by_col_or_row
  self.class.new(@table.dup).by_col_or_row!
end</pre> </div> <p>Returns a duplicate of <code>self</code>, in mixed mode (see <a href="#class-CSV::Table-label-Mixed+Mode">Mixed Mode</a>):</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true).by_col!
table.mode # =&gt; :col
dup_table = table.by_col_or_row
dup_table.mode # =&gt; :col_or_row
dup_table.equal?(table) # =&gt; false # It's a dup
</pre> <p>This may be used to chain method calls without changing the mode (but also will affect performance and memory usage):</p> <pre class="ruby" data-language="ruby">dup_table.by_col_or_row['Name']
</pre> <p>Also note that changes to the duplicate table will not affect the original.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_col_or_row-21"> <span class="method-callseq"> by_col_or_row! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_col_or_row-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 295
def by_col_or_row!
  @mode = :col_or_row

  self
end</pre> </div> <p>Sets the mode for <code>self</code> to mixed mode (see <a href="#class-CSV::Table-label-Mixed+Mode">Mixed Mode</a>); returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true).by_col!
table.mode # =&gt; :col
table1 = table.by_col_or_row!
table.mode # =&gt; :col_or_row
table1.equal?(table) # =&gt; true # Returned self
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_row"> <span class="method-callseq"> by_row → table_dup </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_row-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 318
def by_row
  self.class.new(@table.dup).by_row!
end</pre> </div> <p>Returns a duplicate of <code>self</code>, in row mode (see <a href="#class-CSV::Table-label-Row+Mode">Row Mode</a>):</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.mode # =&gt; :col_or_row
dup_table = table.by_row
dup_table.mode # =&gt; :row
dup_table.equal?(table) # =&gt; false # It's a dup
</pre> <p>This may be used to chain method calls without changing the mode (but also will affect performance and memory usage):</p> <pre class="ruby" data-language="ruby">dup_table.by_row[1]
</pre> <p>Also note that changes to the duplicate table will not affect the original.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-by_row-21"> <span class="method-callseq"> by_row! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="by_row-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 333
def by_row!
  @mode = :row

  self
end</pre> </div> <p>Sets the mode for <code>self</code> to row mode (see <a href="#class-CSV::Table-label-Row+Mode">Row Mode</a>); returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.mode # =&gt; :col_or_row
table1 = table.by_row!
table.mode # =&gt; :row
table1.equal?(table) # =&gt; true # Returned self
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(*indexes) → deleted_values </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(*headers) → deleted_values </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 834
def delete(*indexes_or_headers)
  if indexes_or_headers.empty?
    raise ArgumentError, "wrong number of arguments (given 0, expected 1+)"
  end
  deleted_values = indexes_or_headers.map do |index_or_header|
    if @mode == :row or  # by index
        (@mode == :col_or_row and index_or_header.is_a? Integer)
      @table.delete_at(index_or_header)
    else                 # by header
      if index_or_header.is_a? Integer
        @headers.delete_at(index_or_header)
      else
        @headers.delete(index_or_header)
      end
      @table.map { |row| row.delete(index_or_header).last }
    end
  end
  if indexes_or_headers.size == 1
    deleted_values[0]
  else
    deleted_values
  end
end</pre> </div> <p>If the access mode is <code>:row</code> or <code>:col_or_row</code>, and each argument is either an Integer or a Range, returns deleted rows. Otherwise, returns deleted columns data.</p> <p>In either case, the returned values are in the order specified by the arguments. Arguments may be repeated.</p>  <p>Returns rows as an Array of CSV::Row objects.</p> <p>One index:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
deleted_values = table.delete(0)
deleted_values # =&gt; [#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;]
</pre> <p>Two indexes:</p> <pre class="ruby" data-language="ruby">table = CSV.parse(source, headers: true)
deleted_values = table.delete(2, 0)
deleted_values # =&gt; [#&lt;CSV::Row "Name":"baz" "Value":"2"&gt;, #&lt;CSV::Row "Name":"foo" "Value":"0"&gt;]
</pre>  <p>Returns columns data as column Arrays.</p> <p>One header:</p> <pre class="ruby" data-language="ruby">table = CSV.parse(source, headers: true)
deleted_values = table.delete('Name')
deleted_values # =&gt; ["foo", "bar", "baz"]
</pre> <p>Two headers:</p> <pre class="ruby" data-language="ruby">table = CSV.parse(source, headers: true)
deleted_values = table.delete('Value', 'Name')
deleted_values # =&gt; [["0", "1", "2"], ["foo", "bar", "baz"]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {|row_or_column| ... } → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 887
def delete_if(&amp;block)
  return enum_for(__method__) { @mode == :row or @mode == :col_or_row ? size : headers.size } unless block_given?

  if @mode == :row or @mode == :col_or_row  # by index
    @table.delete_if(&amp;block)
  else                                      # by header
    headers.each do |header|
      delete(header) if yield([header, self[header]])
    end
  end

  self # for chaining
end</pre> </div> <p>Removes rows or columns for which the block returns a truthy value; returns <code>self</code>.</p> <p>Removes rows when the access mode is <code>:row</code> or <code>:col_or_row</code>; calls the block with each CSV::Row object:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
table.size # =&gt; 3
table.delete_if {|row| row['Name'].start_with?('b') }
table.size # =&gt; 1
</pre> <p>Removes columns when the access mode is <code>:col</code>; calls the block with each column as a 2-element array containing the header and an Array of column fields:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
table.headers.size # =&gt; 2
table.delete_if {|column_data| column_data[1].include?('2') }
table.headers.size # =&gt; 1
</pre> <p>Returns a new Enumerator if no block is given:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.delete_if # =&gt; #&lt;Enumerator: #&lt;CSV::Table mode:col_or_row row_count:4&gt;:delete_if&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <span class="method-name">dig</span><span class="method-args">(index_or_header, *index_or_headers)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 1021
def dig(index_or_header, *index_or_headers)
  value = self[index_or_header]
  if value.nil?
    nil
  elsif index_or_headers.empty?
    value
  else
    unless value.respond_to?(:dig)
      raise TypeError, "#{value.class} does not have \#dig method"
    end
    value.dig(*index_or_headers)
  end
end</pre> </div> <p>Extracts the nested value specified by the sequence of <code>index</code> or <code>header</code> objects by calling dig at each step, returning nil if any intermediate step is nil.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|row_or_column| ... ) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 930
def each(&amp;block)
  return enum_for(__method__) { @mode == :col ? headers.size : size } unless block_given?

  if @mode == :col
    headers.each.with_index do |header, i|
      yield([header, @table.map {|row| row[header, i]}])
    end
  else
    @table.each(&amp;block)
  end

  self # for chaining
end</pre> </div> <p>Calls the block with each row or column; returns <code>self</code>.</p> <p>When the access mode is <code>:row</code> or <code>:col_or_row</code>, calls the block with each CSV::Row object:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;
table.each {|row| p row }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
#&lt;CSV::Row "Name":"baz" "Value":"2"&gt;
</pre> <p>When the access mode is <code>:col</code>, calls the block with each column as a 2-element array containing the header and an Array of column fields:</p> <pre class="ruby" data-language="ruby">table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;
table.each {|column_data| p column_data }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["Name", ["foo", "bar", "baz"]]
["Value", ["0", "1", "2"]]
</pre> <p>Returns a new Enumerator if no block is given:</p> <pre class="ruby" data-language="ruby">table.each # =&gt; #&lt;Enumerator: #&lt;CSV::Table mode:col row_count:4&gt;:each&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-headers"> <span class="method-callseq"> headers → array_of_headers </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 360
def headers
  if @table.empty?
    @headers.dup
  else
    @table.first.headers
  end
end</pre> </div> <p>Returns a new Array containing the String headers for the table.</p> <p>If the table is not empty, returns the headers from the first row:</p> <pre class="ruby" data-language="ruby">rows = [
  CSV::Row.new(['Foo', 'Bar'], []),
  CSV::Row.new(['FOO', 'BAR'], []),
  CSV::Row.new(['foo', 'bar'], []),
]
table  = CSV::Table.new(rows)
table.headers # =&gt; ["Foo", "Bar"]
table.delete(0)
table.headers # =&gt; ["FOO", "BAR"]
table.delete(0)
table.headers # =&gt; ["foo", "bar"]
</pre> <p>If the table is empty, returns a copy of the headers in the table itself:</p> <pre class="ruby" data-language="ruby">table.delete(0)
table.headers # =&gt; ["Foo", "Bar"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 1048
def inspect
  inspected = +"#&lt;#{self.class} mode:#{@mode} row_count:#{to_a.size}&gt;"
  summary = to_csv(limit: 5)
  inspected &lt;&lt; "\n" &lt;&lt; summary if summary.encoding.ascii_compatible?
  inspected
end</pre> </div> <p>Returns a <code>US-ASCII</code>-encoded String showing table:</p> <ul>
<li> <p>Class: <code>CSV::Table</code>.</p> </li>
<li> <p>Access mode: <code>:row</code>, <code>:col</code>, or <code>:col_or_row</code>.</p> </li>
<li> <p>Size: <a href="row.html"><code>Row</code></a> count, including the header row.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.inspect # =&gt; "#&lt;CSV::Table mode:col_or_row row_count:4&gt;\nName,Value\nfoo,0\nbar,1\nbaz,2\n"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-push"> <span class="method-callseq"> push(*rows_or_arrays) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="push-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 788
def push(*rows)
  rows.each { |row| self &lt;&lt; row }

  self # for chaining
end</pre> </div> <p>A shortcut for appending multiple rows. Equivalent to:</p> <pre class="ruby" data-language="ruby">rows.each {|row| self &lt;&lt; row }
</pre> <p>Each argument may be either a CSV::Row object or an Array:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
rows = [
  CSV::Row.new(table.headers, ['bat', 3]),
  ['bam', 4]
]
table.push(*rows)
table[3..4] # =&gt; [#&lt;CSV::Row "Name":"bat" "Value":3&gt;, #&lt;CSV::Row "Name":"bam" "Value":4&gt;]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array_of_arrays </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 978
def to_a
  array = [headers]
  @table.each do |row|
    array.push(row.fields) unless row.header_row?
  end

  array
end</pre> </div> <p>Returns the table as an Array of Arrays; the headers are in the first row:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.to_a # =&gt; [["Name", "Value"], ["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_csv"> <span class="method-callseq"> to_csv(**options) → csv_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_csv-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 1004
def to_csv(write_headers: true, limit: nil, **options)
  array = write_headers ? [headers.to_csv(**options)] : []
  limit ||= @table.size
  limit = @table.size + 1 + limit if limit &lt; 0
  limit = 0 if limit &lt; 0
  @table.first(limit).each do |row|
    array.push(row.fields.to_csv(**options)) unless row.header_row?
  end

  array.join("")
end</pre> </div> <p>Returns the table as CSV string. See <a href="../csv.html#class-CSV-label-Options+for+Generating">Options for Generating</a>.</p> <p>Defaults option <code>write_headers</code> to <code>true</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.to_csv # =&gt; "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
</pre> <p>Omits the headers if option <code>write_headers</code> is given as <code>false</code> (see {Option <code>write_headers</code><a href="../csv.html#class-CSV-label-Option+write_headers">}</a>):</p> <pre class="ruby" data-language="ruby">table.to_csv(write_headers: false) # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Limit rows if option <code>limit</code> is given like <code>2</code>:</p> <pre class="ruby" data-language="ruby">table.to_csv(limit: 2) # =&gt; "Name,Value\nfoo,0\nbar,1\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="table.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span> </div> </div> <div class="aliases"> Alias for: <a href="table.html#method-i-to_csv">to_csv</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(*indexes) → array_of_rows </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> values_at(*headers) → array_of_columns_data </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="ruby" data-language="ruby"># File lib/csv/table.rb, line 734
def values_at(*indices_or_headers)
  if @mode == :row or  # by indices
     ( @mode == :col_or_row and indices_or_headers.all? do |index|
                                  index.is_a?(Integer)         or
                                  ( index.is_a?(Range)         and
                                    index.first.is_a?(Integer) and
                                    index.last.is_a?(Integer) )
                                end )
    @table.values_at(*indices_or_headers)
  else                 # by headers
    @table.map { |row| row.values_at(*indices_or_headers) }
  end
end</pre> </div> <p>If the access mode is <code>:row</code> or <code>:col_or_row</code>, and each argument is either an Integer or a Range, returns rows. Otherwise, returns columns data.</p> <p>In either case, the returned values are in the order specified by the arguments. Arguments may be repeated.</p>  <p>Returns rows as an Array of CSV::Row objects.</p> <p>No argument:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.values_at # =&gt; []
</pre> <p>One index:</p> <pre class="ruby" data-language="ruby">values = table.values_at(0)
values # =&gt; [#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;]
</pre> <p>Two indexes:</p> <pre class="ruby" data-language="ruby">values = table.values_at(2, 0)
values # =&gt; [#&lt;CSV::Row "Name":"baz" "Value":"2"&gt;, #&lt;CSV::Row "Name":"foo" "Value":"0"&gt;]
</pre> <p>One Range:</p> <pre class="ruby" data-language="ruby">values = table.values_at(1..2)
values # =&gt; [#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;, #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]
</pre> <p>Ranges and indexes:</p> <pre class="ruby" data-language="ruby">values = table.values_at(0..1, 1..2, 0, 2)
pp values
</pre> <p>Output:</p> <pre>[#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;,
 #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;,
 #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;,
 #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;,
 #&lt;CSV::Row "Name":"foo" "Value":"0"&gt;,
 #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;]</pre>  <p>Returns columns data as row Arrays, each consisting of the specified columns data for that row:</p> <pre class="ruby" data-language="ruby">values = table.values_at('Name')
values # =&gt; [["foo"], ["bar"], ["baz"]]
values = table.values_at('Value', 'Name')
values # =&gt; [["0", "foo"], ["1", "bar"], ["2", "baz"]]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
