<h1 id="class-CSV::Row" class="class"> class CSV::Row </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <h1 id="class-CSV::Row-label-CSV-3A-3ARow">CSV::Row</h1> <p>A CSV::Row instance represents a CSV table row. (see <a href="../csv.html">class CSV</a>).</p> <p>The instance may have:</p> <ul>
<li> <p>Fields: each is an object, not necessarily a String.</p> </li>
<li> <p>Headers: each serves a key, and also need not be a String.</p> </li>
</ul> <h3 id="class-CSV::Row-label-Instance+Methods">Instance Methods</h3> <p>CSV::Row has three groups of instance methods:</p> <ul>
<li> <p>Its own internally defined instance methods.</p> </li>
<li> <p>Methods included by module <a href="../enumerable.html"><code>Enumerable</code></a>.</p> </li>
<li> <p>Methods delegated to class <a href="../array.html"><code>Array</code></a>.:</p> <ul>
<li> <p><a href="../array.html#method-i-empty-3F"><code>Array#empty?</code></a></p> </li>
<li> <p><a href="../array.html#method-i-length"><code>Array#length</code></a></p> </li>
<li> <p><a href="../array.html#method-i-size"><code>Array#size</code></a></p> </li>
</ul> </li>
</ul> <h2 id="class-CSV::Row-label-Creating+a+CSV-3A-3ARow+Instance">Creating a CSV::Row Instance</h2> <p>Commonly, a new CSV::Row instance is created by parsing CSV source that has headers:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
table.each {|row| p row }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
#&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
#&lt;CSV::Row "Name":"baz" "Value":"2"&gt;
</pre> <p>You can also create a row directly. See <a href="row.html#method-c-new"><code>::new</code></a>.</p> <h2 id="class-CSV::Row-label-Headers">Headers</h2> <p>Like a CSV::Table, a CSV::Row has headers.</p> <p>A CSV::Row that was created by parsing CSV source inherits its headers from the table:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table.first
row.headers # =&gt; ["Name", "Value"]
</pre> <p>You can also create a new row with headers; like the keys in a Hash, the headers need not be Strings:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new([:name, :value], ['foo', 0])
row.headers # =&gt; [:name, :value]
</pre> <p>The new row retains its headers even if added to a table that has headers:</p> <pre class="ruby" data-language="ruby">table &lt;&lt; row # =&gt; #&lt;CSV::Table mode:col_or_row row_count:5&gt;
row.headers # =&gt; [:name, :value]
row[:name] # =&gt; "foo"
row['Name'] # =&gt; nil
</pre> <h2 id="class-CSV::Row-label-Accessing+Fields">Accessing Fields</h2> <p>You may access a field in a CSV::Row with either its Integer index (Array-style) or its header (Hash-style).</p> <p>Fetch a field using method <a href="row.html#method-i-5B-5D"><code>[]</code></a>:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
row[1] # =&gt; 0
row['Value'] # =&gt; 0
</pre> <p><a href="../set.html"><code>Set</code></a> a field using method <a href="row.html#method-i-5B-5D-3D"><code>[]=</code></a>:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
row # =&gt; #&lt;CSV::Row "Name":"foo" "Value":0&gt;
row[0] = 'bar'
row['Value'] = 1
row # =&gt; #&lt;CSV::Row "Name":"bar" "Value":1&gt;
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-row"> <span class="method-name">row</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Internal data format used to compare equality.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> CSV::Row.new(headers, fields, header_row = false) → csv_row </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 105
def initialize(headers, fields, header_row = false)
  @header_row = header_row
  headers.each { |h| h.freeze if h.is_a? String }

  # handle extra headers or fields
  @row = if headers.size &gt;= fields.size
    headers.zip(fields)
  else
    fields.zip(headers).each(&amp;:reverse!)
  end
end</pre> </div> <p>Returns the new CSV::Row instance constructed from arguments <code>headers</code> and <code>fields</code>; both should be Arrays; note that the fields need not be Strings:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
row # =&gt; #&lt;CSV::Row "Name":"foo" "Value":0&gt;
</pre> <p>If the Array lengths are different, the shorter is <code>nil</code>-filled:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new(['Name', 'Value', 'Date', 'Size'], ['foo', 0])
row # =&gt; #&lt;CSV::Row "Name":"foo" "Value":0 "Date":nil "Size":nil&gt;
</pre> <p>Each CSV::Row object is either a <em>field row</em> or a <em>header row</em>; by default, a new row is a field row; for the row created above:</p> <pre class="ruby" data-language="ruby">row.field_row? # =&gt; true
row.header_row? # =&gt; false
</pre> <p>If the optional argument <code>header_row</code> is given as <code>true</code>, the created row is a header row:</p> <pre class="ruby" data-language="ruby">row = CSV::Row.new(['Name', 'Value'], ['foo', 0], header_row = true)
row # =&gt; #&lt;CSV::Row "Name":"foo" "Value":0&gt;
row.field_row? # =&gt; false
row.header_row? # =&gt; true
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> row &lt;&lt; [header, value] → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> row &lt;&lt; hash → self </span> </div> <div class="method-heading"> <span class="method-callseq"> row &lt;&lt; value → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 389
def &lt;&lt;(arg)
  if arg.is_a?(Array) and arg.size == 2  # appending a header and name
    @row &lt;&lt; arg
  elsif arg.is_a?(Hash)                  # append header and name pairs
    arg.each { |pair| @row &lt;&lt; pair }
  else                                   # append field value
    @row &lt;&lt; [nil, arg]
  end

  self  # for chaining
end</pre> </div> <p>Adds a field to <code>self</code>; returns <code>self</code>:</p> <p>If the argument is a 2-element Array <code>[header, value]</code>, a field is added with the given <code>header</code> and <code>value</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row &lt;&lt; ['NAME', 'Bat']
row # =&gt; #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" "NAME":"Bat"&gt;
</pre> <p>If the argument is a Hash, each <code>key-value</code> pair is added as a field with header <code>key</code> and value <code>value</code>.</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row &lt;&lt; {NAME: 'Bat', name: 'Bam'}
row # =&gt; #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" NAME:"Bat" name:"Bam"&gt;
</pre> <p>Otherwise, the given <code>value</code> is added as a field with no header.</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row &lt;&lt; 'Bag'
row # =&gt; #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bag"&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> row == other → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 633
def ==(other)
  return @row == other.row if other.is_a? CSV::Row
  @row == other
end</pre> </div> <p>Returns <code>true</code> if <code>other</code> is a /CSV::Row that has the same fields (headers and values) in the same order as <code>self</code>; otherwise returns <code>false</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
other_row = table[0]
row == other_row # =&gt; true
other_row = table[1]
row == other_row # =&gt; false
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-field">field</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> row[index] = value → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> row[header, offset] = value → value </span> </div> <div class="method-heading"> <span class="method-callseq"> row[header] = value → value </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 339
def []=(*args)
  value = args.pop

  if args.first.is_a? Integer
    if @row[args.first].nil?  # extending past the end with index
      @row[args.first] = [nil, value]
      @row.map! { |pair| pair.nil? ? [nil, nil] : pair }
    else                      # normal index assignment
      @row[args.first][1] = value
    end
  else
    index = index(*args)
    if index.nil?             # appending a field
      self &lt;&lt; [args.first, value]
    else                      # normal header assignment
      @row[index][1] = value
    end
  end
end</pre> </div> <p>Assigns the field value for the given <code>index</code> or <code>header</code>; returns <code>value</code>.</p>  <p>Assign field value by Integer index:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row[0] = 'Bat'
row[1] = 3
row # =&gt; #&lt;CSV::Row "Name":"Bat" "Value":3&gt;
</pre> <p>Counts backward from the last column if <code>index</code> is negative:</p> <pre class="ruby" data-language="ruby">row[-1] = 4
row[-2] = 'Bam'
row # =&gt; #&lt;CSV::Row "Name":"Bam" "Value":4&gt;
</pre> <p>Extends the row with <code>nil:nil</code> if positive <code>index</code> is not in the row:</p> <pre class="ruby" data-language="ruby">row[4] = 5
row # =&gt; #&lt;CSV::Row "Name":"bad" "Value":4 nil:nil nil:nil nil:5&gt;
</pre> <p>Raises <a href="../indexerror.html"><code>IndexError</code></a> if negative <code>index</code> is too small (too far from zero).</p>  <p>Assign field value by header (first found):</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row['Name'] = 'Bat'
row # =&gt; #&lt;CSV::Row "Name":"Bat" "Name":"Bar" "Name":"Baz"&gt;
</pre> <p>Assign field value by header, ignoring <code>offset</code> leading fields:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row['Name', 2] = 4
row # =&gt; #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":4&gt;
</pre> <p>Append new field by (new) header:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row['New'] = 6
row# =&gt; #&lt;CSV::Row "Name":"foo" "Value":"0" "New":6&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct"> <span class="method-callseq"> deconstruct → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 682
def deconstruct
  fields
end</pre> </div> <p>Returns the new Array suitable for pattern matching containing the values of the row.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-callseq"> deconstruct_keys(keys) → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 667
def deconstruct_keys(keys)
  if keys.nil?
    to_h
  else
    keys.to_h { |key| [key, self[key]] }
  end
end</pre> </div> <p>Returns the new Hash suitable for pattern matching containing only the keys specified as an argument.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(index) → [header, value] or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(header) → [header, value] or empty_array </span> </div> <div class="method-heading"> <span class="method-callseq"> delete(header, offset) → [header, value] or empty_array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 451
def delete(header_or_index, minimum_index = 0)
  if header_or_index.is_a? Integer                 # by index
    @row.delete_at(header_or_index)
  elsif i = index(header_or_index, minimum_index)  # by header
    @row.delete_at(i)
  else
    [ ]
  end
end</pre> </div> <p>Removes a specified field from <code>self</code>; returns the 2-element Array <code>[header, value]</code> if the field exists.</p> <p>If an Integer argument <code>index</code> is given, removes and returns the field at offset <code>index</code>, or returns <code>nil</code> if the field does not exist:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.delete(1) # =&gt; ["Name", "Bar"]
row.delete(50) # =&gt; nil
</pre> <p>Otherwise, if the single argument <code>header</code> is given, removes and returns the first-found field with the given header, of returns a new empty Array if the field does not exist:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.delete('Name') # =&gt; ["Name", "Foo"]
row.delete('NAME') # =&gt; []
</pre> <p>If argument <code>header</code> and Integer argument <code>offset</code> are given, removes and returns the first-found field with the given header whose <code>index</code> is at least as large as <code>offset</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.delete('Name', 1) # =&gt; ["Name", "Bar"]
row.delete('NAME', 1) # =&gt; []
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {|header, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 476
def delete_if(&amp;block)
  return enum_for(__method__) { size } unless block_given?

  @row.delete_if(&amp;block)

  self  # for chaining
end</pre> </div> <p>Removes fields from <code>self</code> as selected by the block; returns <code>self</code>.</p> <p>Removes each field for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.delete_if {|header, value| value.start_with?('B') } # =&gt; true
row # =&gt; #&lt;CSV::Row "Name":"Foo"&gt;
row.delete_if {|header, value| header.start_with?('B') } # =&gt; false
</pre> <p>If no block is given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">row.delete_if # =&gt; #&lt;Enumerator: #&lt;CSV::Row "Name":"Foo"&gt;:delete_if&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(index_or_header, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 715
def dig(index_or_header, *indexes)
  value = field(index_or_header)
  if value.nil?
    nil
  elsif indexes.empty?
    value
  else
    unless value.respond_to?(:dig)
      raise TypeError, "#{value.class} does not have \#dig method"
    end
    value.dig(*indexes)
  end
end</pre> </div> <p>Finds and returns the object in nested object that is specified by <code>index_or_header</code> and <code>specifiers</code>.</p> <p>The nested objects may be instances of various classes. See <a href="../dig_methods_rdoc.html">Dig Methods</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.dig(1) # =&gt; "0"
row.dig('Value') # =&gt; "0"
row.dig(5) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|header, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 610
def each(&amp;block)
  return enum_for(__method__) { size } unless block_given?

  @row.each(&amp;block)

  self  # for chaining
end</pre> </div> <p>Calls the block with each header-value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.each {|header, value| p [header, value] }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["Name", "Foo"]
["Name", "Bar"]
["Name", "Baz"]
</pre> <p>If no block is given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">row.each # =&gt; #&lt;Enumerator: #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz"&gt;:each&gt;
</pre>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-each_pair">each_pair</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-each_pair"> <span class="method-name">each_pair</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fetch"> <span class="method-callseq"> fetch(header) → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch(header, default) → value </span> </div> <div class="method-heading"> <span class="method-callseq"> fetch(header) {|row| ... } → value </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 258
def fetch(header, *varargs)
  raise ArgumentError, "Too many arguments" if varargs.length &gt; 1
  pair = @row.assoc(header)
  if pair
    pair.last
  else
    if block_given?
      yield header
    elsif varargs.empty?
      raise KeyError, "key not found: #{header}"
    else
      varargs.first
    end
  end
end</pre> </div> <p>Returns the field value as specified by <code>header</code>.</p>  <p>With the single argument <code>header</code>, returns the field value for that header (first found):</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.fetch('Name') # =&gt; "Foo"
</pre> <p>Raises exception <code>KeyError</code> if the header does not exist.</p>  <p>With arguments <code>header</code> and <code>default</code> given, returns the field value for the header (first found) if the header exists, otherwise returns <code>default</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.fetch('Name', '') # =&gt; "Foo"
row.fetch(:nosuch, '') # =&gt; ""
</pre>  <p>With argument <code>header</code> and a block given, returns the field value for the header (first found) if the header exists; otherwise calls the block and returns its return value:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.fetch('Name') {|header| fail 'Cannot happen' } # =&gt; "Foo"
row.fetch(:nosuch) {|header| "Header '#{header} not found'" } # =&gt; "Header 'nosuch not found'"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-field"> <span class="method-callseq"> field(index) → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> field(header) → value </span> </div> <div class="method-heading"> <span class="method-callseq"> field(header, offset) → value </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="field-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 203
def field(header_or_index, minimum_index = 0)
  # locate the pair
  finder = (header_or_index.is_a?(Integer) || header_or_index.is_a?(Range)) ? :[] : :assoc
  pair   = @row[minimum_index..-1].public_send(finder, header_or_index)

  # return the field if we have a pair
  if pair.nil?
    nil
  else
    header_or_index.is_a?(Range) ? pair.map(&amp;:last) : pair.last
  end
end</pre> </div> <p>Returns the field value for the given <code>index</code> or <code>header</code>.</p>  <p>Fetch field value by Integer index:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.field(0) # =&gt; "foo"
row.field(1) # =&gt; "bar"
</pre> <p>Counts backward from the last column if <code>index</code> is negative:</p> <pre class="ruby" data-language="ruby">row.field(-1) # =&gt; "0"
row.field(-2) # =&gt; "foo"
</pre> <p>Returns <code>nil</code> if <code>index</code> is out of range:</p> <pre class="ruby" data-language="ruby">row.field(2) # =&gt; nil
row.field(-3) # =&gt; nil
</pre>  <p>Fetch field value by header (first found):</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.field('Name') # =&gt; "Foo"
</pre> <p>Fetch field value by header, ignoring <code>offset</code> leading fields:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.field('Name', 2) # =&gt; "Baz"
</pre> <p>Returns <code>nil</code> if the header does not exist.</p>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-field-3F"> <span class="method-callseq"> field?(value) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="field-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 589
def field?(data)
  fields.include? data
end</pre> </div> <p>Returns <code>true</code> if <code>value</code> is a field in this row, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.field?('Bar') # =&gt; true
row.field?('BAR') # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-field_row-3F"> <span class="method-callseq"> field_row? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="field_row-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 148
def field_row?
  not header_row?
end</pre> </div> <p>Returns <code>true</code> if this is a field row, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fields"> <span class="method-callseq"> fields(*specifiers) → array_of_fields </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="fields-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 530
def fields(*headers_and_or_indices)
  if headers_and_or_indices.empty?  # return all fields--no arguments
    @row.map(&amp;:last)
  else                              # or work like values_at()
    all = []
    headers_and_or_indices.each do |h_or_i|
      if h_or_i.is_a? Range
        index_begin = h_or_i.begin.is_a?(Integer) ? h_or_i.begin :
                                                    index(h_or_i.begin)
        index_end   = h_or_i.end.is_a?(Integer)   ? h_or_i.end :
                                                    index(h_or_i.end)
        new_range   = h_or_i.exclude_end? ? (index_begin...index_end) :
                                            (index_begin..index_end)
        all.concat(fields.values_at(new_range))
      else
        all &lt;&lt; field(*Array(h_or_i))
      end
    end
    return all
  end
end</pre> </div> <p>Returns field values per the given <code>specifiers</code>, which may be any mixture of:</p> <ul>
<li> <p>Integer index.</p> </li>
<li> <p>Range of Integer indexes.</p> </li>
<li> <p>2-element Array containing a header and offset.</p> </li>
<li> <p>Header.</p> </li>
<li> <p>Range of headers.</p> </li>
</ul> <p>For <code>specifier</code> in one of the first four cases above, returns the result of <code>self.field(specifier)</code>; see <a href="row.html#method-i-field"><code>field</code></a>.</p> <p>Although there may be any number of <code>specifiers</code>, the examples here will illustrate one at a time.</p> <p>When the specifier is an Integer <code>index</code>, returns <code>self.field(index)</code>L</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.fields(1) # =&gt; ["Bar"]
</pre> <p>When the specifier is a Range of Integers <code>range</code>, returns <code>self.field(range)</code>:</p> <pre class="ruby" data-language="ruby">row.fields(1..2) # =&gt; ["Bar", "Baz"]
</pre> <p>When the specifier is a 2-element Array <code>array</code>, returns <code>self.field(array)</code>L</p> <pre class="ruby" data-language="ruby">row.fields('Name', 1) # =&gt; ["Foo", "Bar"]
</pre> <p>When the specifier is a header <code>header</code>, returns <code>self.field(header)</code>L</p> <pre class="ruby" data-language="ruby">row.fields('Name') # =&gt; ["Foo"]
</pre> <p>When the specifier is a Range of headers <code>range</code>, forms a new Range <code>new_range</code> from the indexes of <code>range.start</code> and <code>range.end</code>, and returns <code>self.field(new_range)</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,NAME,name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.fields('Name'..'NAME') # =&gt; ["Foo", "Bar"]
</pre> <p>Returns all fields if no argument given:</p> <pre class="ruby" data-language="ruby">row.fields # =&gt; ["Foo", "Bar", "Baz"]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-values_at">values_at</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-has_key-3F"> <span class="method-callseq"> has_key?(header) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="has_key-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 279
def has_key?(header)
  !!@row.assoc(header)
end</pre> </div> <p>Returns <code>true</code> if there is a field with the given <code>header</code>, <code>false</code> otherwise.</p>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-include-3F">include?</a>, <a href="row.html#method-i-key-3F">key?</a>, <a href="row.html#method-i-member-3F">member?</a>, <a href="row.html#method-i-header-3F">header?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-header-3F"> <span class="method-name">header?</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-has_key-3F">has_key?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-header_row-3F"> <span class="method-callseq"> header_row? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="header_row-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 140
def header_row?
  @header_row
end</pre> </div> <p>Returns <code>true</code> if this is a header row, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-headers"> <span class="method-callseq"> headers → array_of_headers </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 160
def headers
  @row.map(&amp;:first)
end</pre> </div> <p>Returns the headers for this row:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table.first
row.headers # =&gt; ["Name", "Value"]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <span class="method-name">include?</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-has_key-3F">has_key?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-index"> <span class="method-callseq"> index(header) → index </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> index(header, offset) → index </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="index-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 573
def index(header, minimum_index = 0)
  # find the pair
  index = headers[minimum_index..-1].index(header)
  # return the index at the right offset, if we found one
  index.nil? ? nil : index + minimum_index
end</pre> </div> <p>Returns the index for the given header, if it exists; otherwise returns <code>nil</code>.</p> <p>With the single argument <code>header</code>, returns the index of the first-found field with the given <code>header</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.index('Name') # =&gt; 0
row.index('NAME') # =&gt; nil
</pre> <p>With arguments <code>header</code> and <code>offset</code>, returns the index of the first-found field with given <code>header</code>, but ignoring the first <code>offset</code> fields:</p> <pre class="ruby" data-language="ruby">row.index('Name', 1) # =&gt; 1
row.index('Name', 3) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-callseq"> initialize_copy(other_row) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 130
def initialize_copy(other)
  super_return_value = super
  @row = @row.collect(&amp;:dup)
  super_return_value
end</pre> </div> <p>Calls superclass method.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 740
def inspect
  str = ["#&lt;", self.class.to_s]
  each do |header, field|
    str &lt;&lt; " " &lt;&lt; (header.is_a?(Symbol) ? header.to_s : header.inspect) &lt;&lt;
           ":" &lt;&lt; field.inspect
  end
  str &lt;&lt; "&gt;"
  begin
    str.join('')
  rescue  # any encoding error
    str.map do |s|
      e = Encoding::Converter.asciicompat_encoding(s.encoding)
      e ? s.encode(e) : s.force_encoding("ASCII-8BIT")
    end.join('')
  end
end</pre> </div> <p>Returns an ASCII-compatible String showing:</p> <ul>
<li> <p><a href="../class.html"><code>Class</code></a> CSV::Row.</p> </li>
<li> <p>Header-value pairs.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.inspect # =&gt; "#&lt;CSV::Row \"Name\":\"foo\" \"Value\":\"0\"&gt;"
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-key-3F"> <span class="method-name">key?</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-has_key-3F">has_key?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-member-3F"> <span class="method-name">member?</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-has_key-3F">has_key?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-push"> <span class="method-callseq"> push(*values) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="push-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 410
def push(*args)
  args.each { |arg| self &lt;&lt; arg }

  self  # for chaining
end</pre> </div> <p>Appends each of the given <code>values</code> to <code>self</code> as a field; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.push('Bat', 'Bam')
row # =&gt; #&lt;CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bat" nil:"Bam"&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_csv"> <span class="method-callseq"> to_csv → csv_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_csv-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 694
def to_csv(**options)
  fields.to_csv(**options)
end</pre> </div> <p>Returns the row as a CSV <a href="../string.html"><code>String</code></a>. Headers are not included:</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.to_csv # =&gt; "foo,0\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="ruby" data-language="ruby"># File lib/csv/row.rb, line 653
def to_h
  hash = {}
  each do |key, _value|
    hash[key] = self[key] unless hash.key?(key)
  end
  hash
end</pre> </div> <p>Returns the new Hash formed by adding each header-value pair in <code>self</code> as a key-value pair in the Hash.</p> <pre class="ruby" data-language="ruby">source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.to_h # =&gt; {"Name"=&gt;"foo", "Value"=&gt;"0"}
</pre> <p>Header order is preserved, but repeated headers are ignored:</p> <pre class="ruby" data-language="ruby">source = "Name,Name,Name\nFoo,Bar,Baz\n"
table = CSV.parse(source, headers: true)
row = table[0]
row.to_h # =&gt; {"Name"=&gt;"Foo"}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="row.html#method-i-to_hash">to_hash</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_hash"> <span class="method-name">to_hash</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-to_h">to_h</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-to_csv">to_csv</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <span class="method-name">values_at</span> </div> </div> <div class="aliases"> Alias for: <a href="row.html#method-i-fields">fields</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
