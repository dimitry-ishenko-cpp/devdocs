<h1 id="extending-twig">Extending Twig</h1> <p>Twig can be extended in many ways; you can add extra tags, filters, tests, operators, global variables, and functions. You can even extend the parser itself with node visitors.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The first section of this chapter describes how to extend Twig. If you want to reuse your changes in different projects or if you want to share them with others, you should then create an extension as described in the following section.</p> </div> <div class="admonition caution"> <p class="first admonition-title">Caution</p> <p class="last">When extending Twig without creating an extension, Twig won’t be able to recompile your templates when the PHP code is updated. To see your changes in real-time, either disable template caching or package your code into an extension (see the next section of this chapter).</p> </div> <p>Before extending Twig, you must understand the differences between all the different possible extension points and when to use them.</p> <p>First, remember that Twig has two main language constructs:</p> <ul class="simple"> <li>
<code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">}}</span></code>: used to print the result of an expression evaluation;</li> <li>
<code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">%}</span></code>: used to execute statements.</li> </ul> <p>To understand why Twig exposes so many extension points, let’s see how to implement a <em>Lorem ipsum</em> generator (it needs to know the number of words to generate).</p> <p>You can use a <code class="docutils literal notranslate"><span class="pre">lipsum</span></code> <em>tag</em>:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{%</span> <span class="k">lipsum</span> <span class="m">40</span> <span class="cp">%}</span>
</pre></div> <p>That works, but using a tag for <code class="docutils literal notranslate"><span class="pre">lipsum</span></code> is not a good idea for at least three main reasons:</p> <ul> <li>
<p class="first"><code class="docutils literal notranslate"><span class="pre">lipsum</span></code> is not a language construct;</p> </li> <li>
<p class="first">The tag outputs something;</p> </li> <li>
<p class="first">The tag is not flexible as you cannot use it in an expression:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="s1">'some text'</span> <span class="o">~</span> <span class="o">{%</span> <span class="nv">lipsum</span> <span class="m">40</span> <span class="o">%}</span> <span class="o">~</span> <span class="s1">'some more text'</span> <span class="cp">}}</span>
</pre></div> </li> </ul> <p>In fact, you rarely need to create tags; and that’s good news because tags are the most complex extension point.</p> <p>Now, let’s use a <code class="docutils literal notranslate"><span class="pre">lipsum</span></code> <em>filter</em>:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="m">40</span><span class="o">|</span><span class="nf">lipsum</span> <span class="cp">}}</span>
</pre></div> <p>Again, it works. But a filter should transform the passed value to something else. Here, we use the value to indicate the number of words to generate (so, <code class="docutils literal notranslate"><span class="pre">40</span></code> is an argument of the filter, not the value we want to transform).</p> <p>Next, let’s use a <code class="docutils literal notranslate"><span class="pre">lipsum</span></code> <em>function</em>:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="nv">lipsum</span><span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div> <p>Here we go. For this specific example, the creation of a function is the extension point to use. And you can use it anywhere an expression is accepted:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="s1">'some text'</span> <span class="o">~</span> <span class="nv">lipsum</span><span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="o">~</span> <span class="s1">'some more text'</span> <span class="cp">}}</span>

<span class="cp">{%</span> <span class="k">set</span> <span class="nv">lipsum</span> <span class="o">=</span> <span class="nv">lipsum</span><span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="cp">%}</span>
</pre></div> <p>Lastly, you can also use a <em>global</em> object with a method able to generate lorem ipsum text:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="nv">text.lipsum</span><span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div> <p>As a rule of thumb, use functions for frequently used features and global objects for everything else.</p> <p>Keep in mind the following when you want to extend Twig:</p> <table border="1" class="docutils"> <colgroup> <col width="14%"> <col width="37%"> <col width="14%"> <col width="35%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">What?</th> <th class="head">Implementation difficulty?</th> <th class="head">How often?</th> <th class="head">When?</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><em>macro</em></td> <td>simple</td> <td>frequent</td> <td>Content generation</td> </tr> <tr class="row-odd">
<td><em>global</em></td> <td>simple</td> <td>frequent</td> <td>Helper object</td> </tr> <tr class="row-even">
<td><em>function</em></td> <td>simple</td> <td>frequent</td> <td>Content generation</td> </tr> <tr class="row-odd">
<td><em>filter</em></td> <td>simple</td> <td>frequent</td> <td>Value transformation</td> </tr> <tr class="row-even">
<td><em>tag</em></td> <td>complex</td> <td>rare</td> <td>DSL language construct</td> </tr> <tr class="row-odd">
<td><em>test</em></td> <td>simple</td> <td>rare</td> <td>Boolean decision</td> </tr> <tr class="row-even">
<td><em>operator</em></td> <td>simple</td> <td>rare</td> <td>Values transformation</td> </tr> </tbody> </table>  <h2 id="globals">Globals</h2> <p>A global variable is like any other template variable, except that it’s available in all templates and macros:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addGlobal</span><span class="p">(</span><span class="s1">'text'</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Text</span><span class="p">());</span>
</pre></div> </div> <p>You can then use the <code class="docutils literal notranslate"><span class="pre">text</span></code> variable anywhere in a template:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="nv">text.lipsum</span><span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div>   <h2 id="filters">Filters</h2> <p>Creating a filter consists of associating a name with a PHP callable:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="c1">// an anonymous function</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">str_rot13</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// or a simple PHP function</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="s1">'str_rot13'</span><span class="p">);</span>

<span class="c1">// or a class static method</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'SomeClass'</span><span class="p">,</span> <span class="s1">'rot13Filter'</span><span class="p">]);</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="s1">'SomeClass::rot13Filter'</span><span class="p">);</span>

<span class="c1">// or a class method</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">'rot13Filter'</span><span class="p">]);</span>
<span class="c1">// the one below needs a runtime implementation (see below for more information)</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'SomeClass'</span><span class="p">,</span> <span class="s1">'rot13Filter'</span><span class="p">]);</span>
</pre></div> </div> <p>The first argument passed to the <code class="docutils literal notranslate"><span class="pre">\Twig\TwigFilter</span></code> constructor is the name of the filter you will use in templates and the second one is the PHP callable to associate with it.</p> <p>Then, add the filter to the Twig environment:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addFilter</span><span class="p">(</span><span class="nv">$filter</span><span class="p">);</span>
</pre></div> </div> <p>And here is how to use it in a template:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="s1">'Twig'</span><span class="o">|</span><span class="nf">rot13</span> <span class="cp">}}</span>

<span class="c">{# will output Gjvt #}</span>
</pre></div> <p>When called by Twig, the PHP callable receives the left side of the filter (before the pipe <code class="docutils literal notranslate"><span class="pre">|</span></code>) as the first argument and the extra arguments passed to the filter (within parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code>) as extra arguments.</p> <p>For instance, the following code:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="s1">'TWIG'</span><span class="o">|</span><span class="nf">lower</span> <span class="cp">}}</span>
<span class="cp">{{</span> <span class="nv">now</span><span class="o">|</span><span class="nf">date</span><span class="o">(</span><span class="s1">'d/m/Y'</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div> <p>is compiled to something like the following:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">echo</span> <span class="nb">strtolower</span><span class="p">(</span><span class="s1">'TWIG'</span><span class="p">)</span> <span class="cp">?&gt;</span>
<span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nx">twig_date_format_filter</span><span class="p">(</span><span class="nv">$now</span><span class="p">,</span> <span class="s1">'d/m/Y'</span><span class="p">)</span> <span class="cp">?&gt;</span>
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">\Twig\TwigFilter</span></code> class takes an array of options as its last argument:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="s1">'str_rot13'</span><span class="p">,</span> <span class="nv">$options</span><span class="p">);</span>
</pre></div> </div>  <h3 id="environment-aware-filters">Environment-aware Filters</h3> <p>If you want to access the current environment instance in your filter, set the <code class="docutils literal notranslate"><span class="pre">needs_environment</span></code> option to <code class="docutils literal notranslate"><span class="pre">true</span></code>; Twig will pass the current environment as the first argument to the filter call:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">\Twig\Environment</span> <span class="nv">$env</span><span class="p">,</span> <span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// get the current charset for instance</span>
    <span class="nv">$charset</span> <span class="o">=</span> <span class="nv">$env</span><span class="o">-&gt;</span><span class="na">getCharset</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">str_rot13</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[</span><span class="s1">'needs_environment'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">]);</span>
</pre></div> </div>   <h3 id="context-aware-filters">Context-aware Filters</h3> <p>If you want to access the current context in your filter, set the <code class="docutils literal notranslate"><span class="pre">needs_context</span></code> option to <code class="docutils literal notranslate"><span class="pre">true</span></code>; Twig will pass the current context as the first argument to the filter call (or the second one if <code class="docutils literal notranslate"><span class="pre">needs_environment</span></code> is also set to <code class="docutils literal notranslate"><span class="pre">true</span></code>):</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$context</span><span class="p">,</span> <span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="s1">'needs_context'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">]);</span>

<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">\Twig\Environment</span> <span class="nv">$env</span><span class="p">,</span> <span class="nv">$context</span><span class="p">,</span> <span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="s1">'needs_context'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span> <span class="s1">'needs_environment'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">]);</span>
</pre></div> </div>   <h3 id="automatic-escaping">Automatic Escaping</h3> <p>If automatic escaping is enabled, the output of the filter may be escaped before printing. If your filter acts as an escaper (or explicitly outputs HTML or JavaScript code), you will want the raw output to be printed. In such a case, set the <code class="docutils literal notranslate"><span class="pre">is_safe</span></code> option:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'nl2br'</span><span class="p">,</span> <span class="s1">'nl2br'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'is_safe'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'html'</span><span class="p">]]);</span>
</pre></div> </div> <p>Some filters may need to work on input that is already escaped or safe, for example when adding (safe) HTML tags to originally unsafe output. In such a case, set the <code class="docutils literal notranslate"><span class="pre">pre_escape</span></code> option to escape the input data before it is run through your filter:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'somefilter'</span><span class="p">,</span> <span class="s1">'somefilter'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'pre_escape'</span> <span class="o">=&gt;</span> <span class="s1">'html'</span><span class="p">,</span> <span class="s1">'is_safe'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'html'</span><span class="p">]]);</span>
</pre></div> </div>   <h3 id="variadic-filters">Variadic Filters</h3> <p>When a filter should accept an arbitrary number of arguments, set the <code class="docutils literal notranslate"><span class="pre">is_variadic</span></code> option to <code class="docutils literal notranslate"><span class="pre">true</span></code>; Twig will pass the extra arguments as the last argument to the filter call as an array:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'thumbnail'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$file</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$options</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="s1">'is_variadic'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">]);</span>
</pre></div> </div> <p>Be warned that <a class="reference internal" href="templates.html#named-arguments"><span class="std std-ref">named arguments</span></a> passed to a variadic filter cannot be checked for validity as they will automatically end up in the option array.</p>   <h3 id="dynamic-filters">Dynamic Filters</h3> <p>A filter name containing the special <code class="docutils literal notranslate"><span class="pre">*</span></code> character is a dynamic filter and the <code class="docutils literal notranslate"><span class="pre">*</span></code> part will match any string:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'*_path'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$arguments</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div> </div> <p>The following filters are matched by the above defined dynamic filter:</p> <ul class="simple"> <li><code class="docutils literal notranslate"><span class="pre">product_path</span></code></li> <li><code class="docutils literal notranslate"><span class="pre">category_path</span></code></li> </ul> <p>A dynamic filter can define more than one dynamic parts:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'*_path_*'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$suffix</span><span class="p">,</span> <span class="nv">$arguments</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div> </div> <p>The filter receives all dynamic part values before the normal filter arguments, but after the environment and the context. For instance, a call to <code class="docutils literal notranslate"><span class="pre">'foo'|a_path_b()</span></code> will result in the following arguments to be passed to the filter: <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'foo')</span></code>.</p>   <h3 id="deprecated-filters">Deprecated Filters</h3> <p>You can mark a filter as being deprecated by setting the <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> option to <code class="docutils literal notranslate"><span class="pre">true</span></code>. You can also give an alternative filter that replaces the deprecated one when that makes sense:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'obsolete'</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="s1">'deprecated'</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span> <span class="s1">'alternative'</span> <span class="o">=&gt;</span> <span class="s1">'new_one'</span><span class="p">]);</span>
</pre></div> </div> <p>When a filter is deprecated, Twig emits a deprecation notice when compiling a template using it. See <a class="reference internal" href="recipes.html#deprecation-notices"><span class="std std-ref">Displaying Deprecation Notices</span></a> for more information.</p>    <h2 id="functions">Functions</h2> <p>Functions are defined in the exact same way as filters, but you need to create an instance of <code class="docutils literal notranslate"><span class="pre">\Twig\TwigFunction</span></code>:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$function</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigFunction</span><span class="p">(</span><span class="s1">'function_name'</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addFunction</span><span class="p">(</span><span class="nv">$function</span><span class="p">);</span>
</pre></div> </div> <p>Functions support the same features as filters, except for the <code class="docutils literal notranslate"><span class="pre">pre_escape</span></code> and <code class="docutils literal notranslate"><span class="pre">preserves_safety</span></code> options.</p>   <h2 id="tests">Tests</h2> <p>Tests are defined in the exact same way as filters and functions, but you need to create an instance of <code class="docutils literal notranslate"><span class="pre">\Twig\TwigTest</span></code>:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigTest</span><span class="p">(</span><span class="s1">'test_name'</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addTest</span><span class="p">(</span><span class="nv">$test</span><span class="p">);</span>
</pre></div> </div> <p>Tests allow you to create custom application specific logic for evaluating boolean conditions. As a simple example, let’s create a Twig test that checks if objects are ‘red’:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\TwigTest</span><span class="p">(</span><span class="s1">'red'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$value</span><span class="o">-&gt;</span><span class="na">color</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$value</span><span class="o">-&gt;</span><span class="na">color</span> <span class="o">==</span> <span class="s1">'red'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$value</span><span class="o">-&gt;</span><span class="na">paint</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$value</span><span class="o">-&gt;</span><span class="na">paint</span> <span class="o">==</span> <span class="s1">'red'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">});</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addTest</span><span class="p">(</span><span class="nv">$test</span><span class="p">);</span>
</pre></div> </div> <p>Test functions must always return <code class="docutils literal notranslate"><span class="pre">true</span></code>/<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p> <p>When creating tests you can use the <code class="docutils literal notranslate"><span class="pre">node_class</span></code> option to provide custom test compilation. This is useful if your test can be compiled into PHP primitives. This is used by many of the tests built into Twig:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Twig\Environment</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Twig\Node\Expression\TestExpression</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Twig\TwigTest</span><span class="p">;</span>

<span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TwigTest</span><span class="p">(</span>
    <span class="s1">'odd'</span><span class="p">,</span>
    <span class="k">null</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">'node_class'</span> <span class="o">=&gt;</span> <span class="nx">OddTestExpression</span><span class="o">::</span><span class="na">class</span><span class="p">]);</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addTest</span><span class="p">(</span><span class="nv">$test</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">OddTestExpression</span> <span class="k">extends</span> <span class="nx">TestExpression</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">compile</span><span class="p">(</span><span class="nx">\Twig\Compiler</span> <span class="nv">$compiler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$compiler</span>
            <span class="o">-&gt;</span><span class="na">raw</span><span class="p">(</span><span class="s1">'('</span><span class="p">)</span>
            <span class="o">-&gt;</span><span class="na">subcompile</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getNode</span><span class="p">(</span><span class="s1">'node'</span><span class="p">))</span>
            <span class="o">-&gt;</span><span class="na">raw</span><span class="p">(</span><span class="s1">' % 2 != 0'</span><span class="p">)</span>
            <span class="o">-&gt;</span><span class="na">raw</span><span class="p">(</span><span class="s1">')'</span><span class="p">)</span>
        <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> <p>The above example shows how you can create tests that use a node class. The node class has access to one sub-node called <code class="docutils literal notranslate"><span class="pre">node</span></code>. This sub-node contains the value that is being tested. When the <code class="docutils literal notranslate"><span class="pre">odd</span></code> filter is used in code such as:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{%</span> <span class="k">if</span> <span class="nv">my_value</span> <span class="k">is</span> <span class="nf">odd</span> <span class="cp">%}</span>
</pre></div> <p>The <code class="docutils literal notranslate"><span class="pre">node</span></code> sub-node will contain an expression of <code class="docutils literal notranslate"><span class="pre">my_value</span></code>. Node-based tests also have access to the <code class="docutils literal notranslate"><span class="pre">arguments</span></code> node. This node will contain the various other arguments that have been provided to your test.</p> <p>If you want to pass a variable number of positional or named arguments to the test, set the <code class="docutils literal notranslate"><span class="pre">is_variadic</span></code> option to <code class="docutils literal notranslate"><span class="pre">true</span></code>. Tests support dynamic names (see dynamic filters for the syntax).</p>   <h2 id="tags">Tags</h2> <p>One of the most exciting features of a template engine like Twig is the possibility to define new <strong>language constructs</strong>. This is also the most complex feature as you need to understand how Twig’s internals work.</p> <p>Most of the time though, a tag is not needed:</p> <ul> <li>
<p class="first">If your tag generates some output, use a <strong>function</strong> instead.</p> </li> <li>
<p class="first">If your tag modifies some content and returns it, use a <strong>filter</strong> instead.</p> <p>For instance, if you want to create a tag that converts a Markdown formatted text to HTML, create a <code class="docutils literal notranslate"><span class="pre">markdown</span></code> filter instead:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{{</span> <span class="s1">'**markdown** text'</span><span class="o">|</span><span class="nf">markdown</span> <span class="cp">}}</span>
</pre></div> <p>If you want use this filter on large amounts of text, wrap it with the <a class="reference internal" href="tags/apply.html"><span class="doc">apply</span></a> tag:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{%</span> <span class="k">apply</span> <span class="nv">markdown</span> <span class="cp">%}</span>
<span class="x">Title</span>
<span class="x">=====</span>

<span class="x">Much better than creating a tag as you can **compose** filters.</span>
<span class="cp">{%</span> <span class="k">endapply</span> <span class="cp">%}</span>
</pre></div> </li> <li>
<p class="first">If your tag does not output anything, but only exists because of a side effect, create a <strong>function</strong> that returns nothing and call it via the <a class="reference internal" href="tags/do.html"><span class="doc">filter</span></a> tag.</p> <p>For instance, if you want to create a tag that logs text, create a <code class="docutils literal notranslate"><span class="pre">log</span></code> function instead and call it via the <a class="reference internal" href="tags/do.html"><span class="doc">do</span></a> tag:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{%</span> <span class="k">do</span> <span class="nv">log</span><span class="o">(</span><span class="s1">'Log some things'</span><span class="o">)</span> <span class="cp">%}</span>
</pre></div> </li> </ul> <p>If you still want to create a tag for a new language construct, great!</p> <p>Let’s create a <code class="docutils literal notranslate"><span class="pre">set</span></code> tag that allows the definition of simple variables from within a template. The tag can be used like follows:</p> <div class="highlight-twig notranslate"><pre data-language="php" class="highlight"><span class="cp">{%</span> <span class="k">set</span> <span class="nv">name</span> <span class="o">=</span> <span class="s2">"value"</span> <span class="cp">%}</span>

<span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>

<span class="c">{# should output value #}</span>
</pre></div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code class="docutils literal notranslate"><span class="pre">set</span></code> tag is part of the Core extension and as such is always available. The built-in version is slightly more powerful and supports multiple assignments by default.</p> </div> <p>Three steps are needed to define a new tag:</p> <ul class="simple"> <li>Defining a Token Parser class (responsible for parsing the template code);</li> <li>Defining a Node class (responsible for converting the parsed code to PHP);</li> <li>Registering the tag.</li> </ul>  <h3 id="registering-a-new-tag">Registering a new tag</h3> <p>Add a tag by calling the <code class="docutils literal notranslate"><span class="pre">addTokenParser</span></code> method on the <code class="docutils literal notranslate"><span class="pre">\Twig\Environment</span></code> instance:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addTokenParser</span><span class="p">(</span><span class="k">new</span> <span class="nx">Project_Set_TokenParser</span><span class="p">());</span>
</pre></div> </div>   <h3 id="defining-a-token-parser">Defining a Token Parser</h3> <p>Now, let’s see the actual code of this class:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Set_TokenParser</span> <span class="k">extends</span> <span class="nx">\Twig\TokenParser\AbstractTokenParser</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">parse</span><span class="p">(</span><span class="nx">\Twig\Token</span> <span class="nv">$token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$parser</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parser</span><span class="p">;</span>
        <span class="nv">$stream</span> <span class="o">=</span> <span class="nv">$parser</span><span class="o">-&gt;</span><span class="na">getStream</span><span class="p">();</span>

        <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$stream</span><span class="o">-&gt;</span><span class="na">expect</span><span class="p">(</span><span class="nx">\Twig\Token</span><span class="o">::</span><span class="na">NAME_TYPE</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">getValue</span><span class="p">();</span>
        <span class="nv">$stream</span><span class="o">-&gt;</span><span class="na">expect</span><span class="p">(</span><span class="nx">\Twig\Token</span><span class="o">::</span><span class="na">OPERATOR_TYPE</span><span class="p">,</span> <span class="s1">'='</span><span class="p">);</span>
        <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$parser</span><span class="o">-&gt;</span><span class="na">getExpressionParser</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">parseExpression</span><span class="p">();</span>
        <span class="nv">$stream</span><span class="o">-&gt;</span><span class="na">expect</span><span class="p">(</span><span class="nx">\Twig\Token</span><span class="o">::</span><span class="na">BLOCK_END_TYPE</span><span class="p">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nx">Project_Set_Node</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$value</span><span class="p">,</span> <span class="nv">$token</span><span class="o">-&gt;</span><span class="na">getLine</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getTag</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTag</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s1">'set'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">getTag()</span></code> method must return the tag we want to parse, here <code class="docutils literal notranslate"><span class="pre">set</span></code>.</p> <p>The <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method is invoked whenever the parser encounters a <code class="docutils literal notranslate"><span class="pre">set</span></code> tag. It should return a <code class="docutils literal notranslate"><span class="pre">\Twig\Node\Node</span></code> instance that represents the node (the <code class="docutils literal notranslate"><span class="pre">Project_Set_Node</span></code> calls creating is explained in the next section).</p> <p>The parsing process is simplified thanks to a bunch of methods you can call from the token stream (<code class="docutils literal notranslate"><span class="pre">$this-&gt;parser-&gt;getStream()</span></code>):</p> <ul class="simple"> <li>
<code class="docutils literal notranslate"><span class="pre">getCurrent()</span></code>: Gets the current token in the stream.</li> <li>
<code class="docutils literal notranslate"><span class="pre">next()</span></code>: Moves to the next token in the stream, <em>but returns the old one</em>.</li> <li>
<code class="docutils literal notranslate"><span class="pre">test($type)</span></code>, <code class="docutils literal notranslate"><span class="pre">test($value)</span></code> or <code class="docutils literal notranslate"><span class="pre">test($type,</span> <span class="pre">$value)</span></code>: Determines whether the current token is of a particular type or value (or both). The value may be an array of several possible values.</li> <li>
<code class="docutils literal notranslate"><span class="pre">expect($type[,</span> <span class="pre">$value[,</span> <span class="pre">$message]])</span></code>: If the current token isn’t of the given type/value a syntax error is thrown. Otherwise, if the type and value are correct, the token is returned and the stream moves to the next token.</li> <li>
<code class="docutils literal notranslate"><span class="pre">look()</span></code>: Looks at the next token without consuming it.</li> </ul> <p>Parsing expressions is done by calling the <code class="docutils literal notranslate"><span class="pre">parseExpression()</span></code> like we did for the <code class="docutils literal notranslate"><span class="pre">set</span></code> tag.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">Reading the existing <code class="docutils literal notranslate"><span class="pre">TokenParser</span></code> classes is the best way to learn all the nitty-gritty details of the parsing process.</p> </div>   <h3 id="defining-a-node">Defining a Node</h3> <p>The <code class="docutils literal notranslate"><span class="pre">Project_Set_Node</span></code> class itself is quite short:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Set_Node</span> <span class="k">extends</span> <span class="nx">\Twig\Node\Node</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nx">\Twig\Node\Expression\AbstractExpression</span> <span class="nv">$value</span><span class="p">,</span> <span class="nv">$line</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">parent</span><span class="o">::</span><span class="na">__construct</span><span class="p">([</span><span class="s1">'value'</span> <span class="o">=&gt;</span> <span class="nv">$value</span><span class="p">],</span> <span class="p">[</span><span class="s1">'name'</span> <span class="o">=&gt;</span> <span class="nv">$name</span><span class="p">],</span> <span class="nv">$line</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">compile</span><span class="p">(</span><span class="nx">\Twig\Compiler</span> <span class="nv">$compiler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$compiler</span>
            <span class="o">-&gt;</span><span class="na">addDebugInfo</span><span class="p">(</span><span class="nv">$this</span><span class="p">)</span>
            <span class="o">-&gt;</span><span class="na">write</span><span class="p">(</span><span class="s1">'$context[\''</span><span class="o">.</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getAttribute</span><span class="p">(</span><span class="s1">'name'</span><span class="p">)</span><span class="o">.</span><span class="s1">'\'] = '</span><span class="p">)</span>
            <span class="o">-&gt;</span><span class="na">subcompile</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getNode</span><span class="p">(</span><span class="s1">'value'</span><span class="p">))</span>
            <span class="o">-&gt;</span><span class="na">raw</span><span class="p">(</span><span class="s2">";</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
        <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> <p>The compiler implements a fluid interface and provides methods that helps the developer generate beautiful and readable PHP code:</p> <ul class="simple"> <li>
<code class="docutils literal notranslate"><span class="pre">subcompile()</span></code>: Compiles a node.</li> <li>
<code class="docutils literal notranslate"><span class="pre">raw()</span></code>: Writes the given string as is.</li> <li>
<code class="docutils literal notranslate"><span class="pre">write()</span></code>: Writes the given string by adding indentation at the beginning of each line.</li> <li>
<code class="docutils literal notranslate"><span class="pre">string()</span></code>: Writes a quoted string.</li> <li>
<code class="docutils literal notranslate"><span class="pre">repr()</span></code>: Writes a PHP representation of a given value (see <code class="docutils literal notranslate"><span class="pre">\Twig\Node\ForNode</span></code> for a usage example).</li> <li>
<code class="docutils literal notranslate"><span class="pre">addDebugInfo()</span></code>: Adds the line of the original template file related to the current node as a comment.</li> <li>
<code class="docutils literal notranslate"><span class="pre">indent()</span></code>: Indents the generated code (see <code class="docutils literal notranslate"><span class="pre">\Twig\Node\BlockNode</span></code> for a usage example).</li> <li>
<code class="docutils literal notranslate"><span class="pre">outdent()</span></code>: Outdents the generated code (see <code class="docutils literal notranslate"><span class="pre">\Twig\Node\BlockNode</span></code> for a usage example).</li> </ul>    <h2>Creating an Extension</h2> <p>The main motivation for writing an extension is to move often used code into a reusable class like adding support for internationalization. An extension can define tags, filters, tests, operators, functions, and node visitors.</p> <p>Most of the time, it is useful to create a single extension for your project, to host all the specific tags and filters you want to add to Twig.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">When packaging your code into an extension, Twig is smart enough to recompile your templates whenever you make a change to it (when <code class="docutils literal notranslate"><span class="pre">auto_reload</span></code> is enabled).</p> </div> <p>An extension is a class that implements the following interface:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">interface</span> <span class="nx">\Twig\Extension\ExtensionInterface</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * Returns the token parser instances to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Twig\TokenParser\TokenParserInterface[]</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTokenParsers</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * Returns the node visitor instances to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Twig\NodeVisitor\NodeVisitorInterface[]</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getNodeVisitors</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * Returns a list of filters to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Twig\TwigFilter[]</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFilters</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * Returns a list of tests to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Twig\TwigTest[]</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTests</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * Returns a list of functions to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Twig\TwigFunction[]</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFunctions</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * Returns a list of operators to add to the existing list.</span>
<span class="sd">     *</span>
<span class="sd">     * @return array&lt;array&gt; First array of unary operators, second array of binary operators</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getOperators</span><span class="p">();</span>
<span class="p">}</span>
</pre></div> </div> <p>To keep your extension class clean and lean, inherit from the built-in <code class="docutils literal notranslate"><span class="pre">\Twig\Extension\AbstractExtension</span></code> class instead of implementing the interface as it provides empty implementations for all methods:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div> </div> <p>This extension does nothing for now. We will customize it in the next sections.</p> <p>You can save your extension anywhere on the filesystem, as all extensions must be registered explicitly to be available in your templates.</p> <p>You can register an extension by using the <code class="docutils literal notranslate"><span class="pre">addExtension()</span></code> method on your main <code class="docutils literal notranslate"><span class="pre">Environment</span></code> object:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nv">$twig</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Twig\Environment</span><span class="p">(</span><span class="nv">$loader</span><span class="p">);</span>
<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addExtension</span><span class="p">(</span><span class="k">new</span> <span class="nx">Project_Twig_Extension</span><span class="p">());</span>
</pre></div> </div> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">The Twig core extensions are great examples of how extensions work.</p> </div>  <h3 id="id1">Globals</h3> <p>Global variables can be registered in an extension via the <code class="docutils literal notranslate"><span class="pre">getGlobals()</span></code> method:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span> <span class="k">implements</span> <span class="nx">\Twig\Extension\GlobalsInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getGlobals</span><span class="p">()</span><span class="o">:</span> <span class="k">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s1">'text'</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Text</span><span class="p">(),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div>   <h3 id="id2">Functions</h3> <p>Functions can be registered in an extension via the <code class="docutils literal notranslate"><span class="pre">getFunctions()</span></code> method:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFunctions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigFunction</span><span class="p">(</span><span class="s1">'lipsum'</span><span class="p">,</span> <span class="s1">'generate_lipsum'</span><span class="p">),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div>   <h3 id="id3">Filters</h3> <p>To add a filter to an extension, you need to override the <code class="docutils literal notranslate"><span class="pre">getFilters()</span></code> method. This method must return an array of filters to add to the Twig environment:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFilters</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigFilter</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="s1">'str_rot13'</span><span class="p">),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div>   <h3 id="id4">Tags</h3> <p>Adding a tag in an extension can be done by overriding the <code class="docutils literal notranslate"><span class="pre">getTokenParsers()</span></code> method. This method must return an array of tags to add to the Twig environment:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTokenParsers</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">new</span> <span class="nx">Project_Set_TokenParser</span><span class="p">()];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div> <p>In the above code, we have added a single new tag, defined by the <code class="docutils literal notranslate"><span class="pre">Project_Set_TokenParser</span></code> class. The <code class="docutils literal notranslate"><span class="pre">Project_Set_TokenParser</span></code> class is responsible for parsing the tag and compiling it to PHP.</p>   <h3 id="operators">Operators</h3> <p>The <code class="docutils literal notranslate"><span class="pre">getOperators()</span></code> methods lets you add new operators. Here is how to add the <code class="docutils literal notranslate"><span class="pre">!</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, and <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> operators:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getOperators</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="s1">'!'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'precedence'</span> <span class="o">=&gt;</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="nx">\Twig\Node\Expression\Unary\NotUnary</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
            <span class="p">],</span>
            <span class="p">[</span>
                <span class="s1">'||'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'precedence'</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="nx">\Twig\Node\Expression\Binary\OrBinary</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="s1">'associativity'</span> <span class="o">=&gt;</span> <span class="nx">\Twig\ExpressionParser</span><span class="o">::</span><span class="na">OPERATOR_LEFT</span><span class="p">],</span>
                <span class="s1">'&amp;&amp;'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'precedence'</span> <span class="o">=&gt;</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="nx">\Twig\Node\Expression\Binary\AndBinary</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="s1">'associativity'</span> <span class="o">=&gt;</span> <span class="nx">\Twig\ExpressionParser</span><span class="o">::</span><span class="na">OPERATOR_LEFT</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div>   <h3 id="id5">Tests</h3> <p>The <code class="docutils literal notranslate"><span class="pre">getTests()</span></code> method lets you add new test functions:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTests</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigTest</span><span class="p">(</span><span class="s1">'even'</span><span class="p">,</span> <span class="s1">'twig_test_even'</span><span class="p">),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div> </div>   <h3 id="definition-vs-runtime">Definition vs Runtime</h3> <p>Twig filters, functions, and tests runtime implementations can be defined as any valid PHP callable:</p> <ul class="simple"> <li>
<strong>functions/static methods</strong>: Simple to implement and fast (used by all Twig core extensions); but it is hard for the runtime to depend on external objects;</li> <li>
<strong>closures</strong>: Simple to implement;</li> <li>
<strong>object methods</strong>: More flexible and required if your runtime code depends on external objects.</li> </ul> <p>The simplest way to use methods is to define them on the extension itself:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$rot13Provider</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nv">$rot13Provider</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rot13Provider</span> <span class="o">=</span> <span class="nv">$rot13Provider</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFunctions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigFunction</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">'rot13'</span><span class="p">]),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">rot13</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rot13Provider</span><span class="o">-&gt;</span><span class="na">rot13</span><span class="p">(</span><span class="nv">$value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> <p>This is very convenient but not recommended as it makes template compilation depend on runtime dependencies even if they are not needed (think for instance as a dependency that connects to a database engine).</p> <p>You can decouple the extension definitions from their runtime implementations by registering a <code class="docutils literal notranslate"><span class="pre">\Twig\RuntimeLoader\RuntimeLoaderInterface</span></code> instance on the environment that knows how to instantiate such runtime classes (runtime classes must be autoload-able):</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">RuntimeLoader</span> <span class="k">implements</span> <span class="nx">\Twig\RuntimeLoader\RuntimeLoaderInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="nv">$class</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// implement the logic to create an instance of $class</span>
        <span class="c1">// and inject its dependencies</span>
        <span class="c1">// most of the time, it means using your dependency injection container</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">'Project_Twig_RuntimeExtension'</span> <span class="o">===</span> <span class="nv">$class</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nv">$class</span><span class="p">(</span><span class="k">new</span> <span class="nx">Rot13Provider</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nv">$twig</span><span class="o">-&gt;</span><span class="na">addRuntimeLoader</span><span class="p">(</span><span class="k">new</span> <span class="nx">RuntimeLoader</span><span class="p">());</span>
</pre></div> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Twig comes with a PSR-11 compatible runtime loader (<code class="docutils literal notranslate"><span class="pre">\Twig\RuntimeLoader\ContainerRuntimeLoader</span></code>).</p> </div> <p>It is now possible to move the runtime logic to a new <code class="docutils literal notranslate"><span class="pre">Project_Twig_RuntimeExtension</span></code> class and use it directly in the extension:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">class</span> <span class="nc">Project_Twig_RuntimeExtension</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$rot13Provider</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nv">$rot13Provider</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rot13Provider</span> <span class="o">=</span> <span class="nv">$rot13Provider</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">rot13</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rot13Provider</span><span class="o">-&gt;</span><span class="na">rot13</span><span class="p">(</span><span class="nv">$value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Project_Twig_Extension</span> <span class="k">extends</span> <span class="nx">\Twig\Extension\AbstractExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFunctions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigFunction</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'Project_Twig_RuntimeExtension'</span><span class="p">,</span> <span class="s1">'rot13'</span><span class="p">]),</span>
            <span class="c1">// or</span>
            <span class="k">new</span> <span class="nx">\Twig\TwigFunction</span><span class="p">(</span><span class="s1">'rot13'</span><span class="p">,</span> <span class="s1">'Project_Twig_RuntimeExtension::rot13'</span><span class="p">),</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div>    <h2 id="testing-an-extension">Testing an Extension</h2>  <h3 id="functional-tests">Functional Tests</h3> <p>You can create functional tests for extensions by creating the following file structure in your test directory:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="nx">Fixtures</span><span class="o">/</span>
    <span class="nx">filters</span><span class="o">/</span>
        <span class="nx">foo</span><span class="o">.</span><span class="nx">test</span>
        <span class="nx">bar</span><span class="o">.</span><span class="nx">test</span>
    <span class="nx">functions</span><span class="o">/</span>
        <span class="nx">foo</span><span class="o">.</span><span class="nx">test</span>
        <span class="nx">bar</span><span class="o">.</span><span class="nx">test</span>
    <span class="nx">tags</span><span class="o">/</span>
        <span class="nx">foo</span><span class="o">.</span><span class="nx">test</span>
        <span class="nx">bar</span><span class="o">.</span><span class="nx">test</span>
<span class="nx">IntegrationTest</span><span class="o">.</span><span class="nx">php</span>
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">IntegrationTest.php</span></code> file should look like this:</p> <div class="highlight-php notranslate">
<div class="highlight"><pre data-language="php" class="highlight"><span class="k">use</span> <span class="nx">Twig\Test\IntegrationTestCase</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Project_Tests_IntegrationTest</span> <span class="k">extends</span> <span class="nx">IntegrationTestCase</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getExtensions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">Project_Twig_Extension1</span><span class="p">(),</span>
            <span class="k">new</span> <span class="nx">Project_Twig_Extension2</span><span class="p">(),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFixturesDir</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="no">__DIR__</span><span class="o">.</span><span class="s1">'/Fixtures/'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> <p>Fixtures examples can be found within the Twig repository <a class="reference external" href="https://github.com/twigphp/Twig/tree/3.x/tests/Fixtures">tests/Twig/Fixtures</a> directory.</p>   <h3 id="node-tests">Node Tests</h3> <p>Testing the node visitors can be complex, so extend your test cases from <code class="docutils literal notranslate"><span class="pre">\Twig\Test\NodeTestCase</span></code>. Examples can be found in the Twig repository <a class="reference external" href="https://github.com/twigphp/Twig/tree/3.x/tests/Node">tests/Twig/Node</a> directory.</p>     <div class="navigation" style="text-align: center"> <a accesskey="P" title="Twig for Developers" href="api.html"> « Twig for Developers </a> <span class="separator">|</span> <a accesskey="N" title="Twig Internals" href="internals.html"> Twig Internals » </a> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2018 by the Twig Team<br>Licensed under the three clause BSD license.<br>The Twig logo is &copy; 2010&ndash;2020 Symfony<br>
    <a href="https://twig.symfony.com/doc/3.x/advanced.html" class="_attribution-link">https://twig.symfony.com/doc/3.x/advanced.html</a>
  </p>
</div>
