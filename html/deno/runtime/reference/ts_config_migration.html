<h1>Configuring TypeScript</h1>
<div>
<p>Deno’s flexibility shines in its equal treatment of TypeScript and JavaScript. Whether you’re transitioning from JavaScript to TypeScript or vice versa, Deno has features to ease the journey.</p> <h2 id="type-checking-javascript" tabindex="-1">Type Checking JavaScript </h2> <p>You may wish to make your JavaScript more type-sound without adding type annotations everywhere. Deno supports using the TypeScript type checker to type check JavaScript. You can mark individual files by adding the check JavaScript pragma to the file:</p> <div class="relative">
<pre class="language-js" tabindex="0"><code data-language="js"><span class="token comment">// @ts-check</span>
</code></pre>   </div>
<p>This will cause the type checker to infer type information about the JavaScript code and raise any issues as diagnostic issues.</p> <p>These can be turned on for all JavaScript files in a program by providing a configuration file with the check JS option set to <code data-language="ts">true</code>, as below. Then use the <code data-language="ts">--config</code> option when running on the command line.</p> <div class="relative">
<pre class="language-json" tabindex="0"><code data-language="json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"checkJs"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
<h2 id="using-jsdoc-in-javascript" tabindex="-1">Using JSDoc in JavaScript </h2> <p>When type-checking JavaScript or importing JavaScript into TypeScript, JSDoc annotations can provide additional type information beyond what can just be inferred from the code itself. Deno supports this seamlessly if you annotate your code inline with the supported <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html">TypeScript JSDoc</a>.</p> <p>For example to set the type of an array use the following JSDoc comment:</p> <div class="relative">
<pre class="language-js" tabindex="0"><code data-language="js"><span class="token comment">/** @type {string[]} */</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>   </div>
<h2 id="skipping-type-checking" tabindex="-1">Skipping type checking </h2> <p>You might have TypeScript code that you are experimenting with, where the syntax is valid but not fully type safe. You can bypass type checking for a whole program by passing the <code data-language="ts">--no-check</code> flag.</p> <p>You can also skip whole files being type checked, including JavaScript if you have check JS enabled, by using the <code data-language="ts">nocheck</code> pragma:</p> <div class="relative">
<pre class="language-js" tabindex="0"><code data-language="js"><span class="token comment">// @ts-nocheck</span>
</code></pre>   </div>
<h2 id="renaming-js-files-to-ts-files" tabindex="-1">Renaming JS files to TS files </h2> <p>TypeScript files benefit from the TypeScript compiler being able to do more thorough safety checks of your code. This is often referred to as <em>strict mode</em>. When you rename a <code data-language="ts">.js</code> file to <code data-language="ts">.ts</code> you'll might see new type errors that you TypeScript wasn't able to detect before.</p> <h2 id="configuring-typescript-in-deno" tabindex="-1">Configuring TypeScript in Deno </h2> <p>TypeScript offers many configuration options, which can be daunting if you're just starting out with TS. Deno aims to simplify using TypeScript, instead of drowning you in countless settings. Deno configures TypeScript to <strong>just work</strong> out of the box. No extra configuration headaches required!</p> <p>However, if you do want to change the TypeScript compiler options, Deno allows you to do so in your <code data-language="ts">deno.json</code> file. Provide a path on the command line, or use the default. For example:</p> <div class="relative">
<pre class="language-console" tabindex="0"><code data-language="console">deno run --config ./deno.json main.ts
</code></pre>   </div>

<div class="admonition note"> <div class="title">Note</div>  <p>If you are creating libraries that require a configuration file, remember that all of the consumers of your TS modules will require that configuration file too. In addition, there could be settings in the configuration file that make other TypeScript modules incompatible.</p> 
</div>  <h2 id="ts-compiler-options" tabindex="-1">TS Compiler Options </h2> <p>Here is a table of compiler options that can be changed, their default in Deno and any other notes about that option:</p> <table> <thead> <tr> <th>Option</th> <th>Default</th> <th>Notes</th> </tr> </thead> <tbody> <tr> <td><code data-language="ts">allowJs</code></td> <td><code data-language="ts">true</code></td> <td>This almost never needs to be changed</td> </tr> <tr> <td><code data-language="ts">allowUnreachableCode</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">allowUnusedLabels</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">checkJs</code></td> <td><code data-language="ts">false</code></td> <td>If <code data-language="ts">true</code> causes TypeScript to type check JavaScript</td> </tr> <tr> <td><code data-language="ts">jsx</code></td> <td><code data-language="ts">"react"</code></td> <td></td> </tr> <tr> <td><code data-language="ts">jsxFactory</code></td> <td><code data-language="ts">"React.createElement"</code></td> <td></td> </tr> <tr> <td><code data-language="ts">jsxFragmentFactory</code></td> <td><code data-language="ts">"React.Fragment"</code></td> <td></td> </tr> <tr> <td><code data-language="ts">keyofStringsOnly</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">lib</code></td> <td><code data-language="ts">[ "deno.window" ]</code></td> <td>The default for this varies based on other settings in Deno. If it is supplied, it overrides the default. See below for more information.</td> </tr> <tr> <td><code data-language="ts">noErrorTruncation</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noFallthroughCasesInSwitch</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noImplicitAny</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noImplicitOverride</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noImplicitReturns</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noImplicitThis</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noImplicitUseStrict</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noStrictGenericChecks</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noUnusedLocals</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noUnusedParameters</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">noUncheckedIndexedAccess</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">reactNamespace</code></td> <td><code data-language="ts">React</code></td> <td></td> </tr> <tr> <td><code data-language="ts">strict</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">strictBindCallApply</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">strictFunctionTypes</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">strictPropertyInitialization</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">strictNullChecks</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> <tr> <td><code data-language="ts">suppressExcessPropertyErrors</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">suppressImplicitAnyIndexErrors</code></td> <td><code data-language="ts">false</code></td> <td></td> </tr> <tr> <td><code data-language="ts">useUnknownInCatchVariables</code></td> <td><code data-language="ts">true</code></td> <td></td> </tr> </tbody> </table> <p>For a full list of compiler options and how they affect TypeScript, please refer to the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">TypeScript Handbook</a>.</p> <h2 id="using-the-%22lib%22-property" tabindex="-1">Using the "lib" property </h2> <p>If you're working on a project that ships code to multiple runtimes, like browsers for example, you can tweak the default types via the "lib" property within the <code data-language="ts">compilerOptions</code>.</p> <p>The built-in libraries that are of interest to users:</p> <ul> <li>
<code data-language="ts">"deno.ns"</code> - This includes all the custom <code data-language="ts">Deno</code> global namespace APIs plus the Deno additions to <code data-language="ts">import.meta</code>. This should generally not conflict with other libraries or global types.</li> <li>
<code data-language="ts">"deno.unstable"</code> - This includes the addition unstable <code data-language="ts">Deno</code> global namespace APIs.</li> <li>
<code data-language="ts">"deno.window"</code> - This is the "default" library used when checking Deno main runtime scripts. It includes the <code data-language="ts">"deno.ns"</code> as well as other type libraries for the extensions that are built into Deno. This library will conflict with libraries like <code data-language="ts">"dom"</code> and <code data-language="ts">"dom.iterable"</code> that are standard TypeScript libraries.</li> <li>
<code data-language="ts">"deno.worker"</code> - This is the library used when checking a Deno web worker script. For more information about web workers, check out <a href="ts_config_migration.html#type-checking-web-workers">Type Checking Web Workers</a>.</li> <li>
<code data-language="ts">"dom.asynciterable"</code> - TypeScript currently does not include the DOM async iterables that Deno implements (plus several browsers), so we have implemented it ourselves until it becomes available in TypeScript.</li> </ul> <p>These are common libraries that are not enabled by default, but are useful when writing code that is intended to also work in another runtime:</p> <ul> <li>
<code data-language="ts">"dom"</code> - The main browser global library that ships with TypeScript. The type definitions conflict in many ways with <code data-language="ts">"deno.window"</code> and so if <code data-language="ts">"dom"</code> is used, then consider using just <code data-language="ts">"deno.ns"</code> to expose the Deno specific APIs.</li> <li>
<code data-language="ts">"dom.iterable"</code> - The iterable extensions to the browser global library.</li> <li>
<code data-language="ts">"scripthost"</code> - The library for the Microsoft Windows Script Host.</li> <li>
<code data-language="ts">"webworker"</code> - The main library for web workers in the browser. Like <code data-language="ts">"dom"</code> this will conflict with <code data-language="ts">"deno.window"</code> or <code data-language="ts">"deno.worker"</code>, so consider using just <code data-language="ts">"deno.ns"</code> to expose the Deno specific APIs.</li> <li>
<code data-language="ts">"webworker.importscripts"</code> - The library that exposes the <code data-language="ts">importScripts()</code> API in the web worker.</li> <li>
<code data-language="ts">"webworker.iterable"</code> - The library that adds iterables to objects within a web worker. Modern browsers support this.</li> </ul> <h2 id="targeting-deno-and-the-browser" tabindex="-1">Targeting Deno and the Browser </h2> <p>You may want to write code that seamlessly runs in both Deno and the browser. In this case you'll need to conditionally check the execution environment before using any APIs exclusive to one or the other. In such cases, a typical <code data-language="ts">compilerOptions</code> configuration might look like this:</p> <div>
<div class="markdownBlockTitle">deno.json</div>
<div class="relative">
<pre class="language-json" tabindex="0"><code data-language="json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"dom"</span><span class="token punctuation">,</span> <span class="token string">"dom.iterable"</span><span class="token punctuation">,</span> <span class="token string">"dom.asynciterable"</span><span class="token punctuation">,</span> <span class="token string">"deno.ns"</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
</div>
<p>This should allow most code to be type checked properly by Deno.</p> <p>If you expect to run the code in Deno with the <code data-language="ts">--unstable</code> flag, then you should add that library to the mix as well:</p> <div>
<div class="markdownBlockTitle">deno.json</div>
<div class="relative">
<pre class="language-json" tabindex="0"><code data-language="json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">"dom"</span><span class="token punctuation">,</span>
      <span class="token string">"dom.iterable"</span><span class="token punctuation">,</span>
      <span class="token string">"dom.asynciterable"</span><span class="token punctuation">,</span>
      <span class="token string">"deno.ns"</span><span class="token punctuation">,</span>
      <span class="token string">"deno.unstable"</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
</div>
<p>Typically, when you use the <code data-language="ts">"lib"</code> option in TypeScript, you need to include an "es" library as well. In the case of <code data-language="ts">"deno.ns"</code> and <code data-language="ts">"deno.unstable"</code>, they automatically include <code data-language="ts">"esnext"</code> when you bring them in.</p> 
<div class="admonition note"> <div class="title">Note</div>  <p>If you get type errors like <strong>cannot find <code data-language="ts">document</code> or <code data-language="ts">HTMLElement</code></strong>, it is likely that the library you are using has dependencies on the DOM. This is common for packages that are designed to run in a browser as well as server-side. By default, Deno only includes the libraries that are directly supported. Assuming the package properly identifies what environment it is running in at runtime it is "safe" to use the DOM libraries to type check the code.</p> 
</div>  <h2 id="types-and-type-declarations" tabindex="-1">Types and Type Declarations </h2> <p>Deno applies a design principle of <em>no non-standard module resolution</em>. When TypeScript checks a file, it focuses solely on its types. In contrast, the <code data-language="ts">tsc</code> compiler employs intricate logic to resolve those types. By default, <code data-language="ts">tsc</code> expects ambiguous module specifiers with extensions (e.g., <code data-language="ts">.ts</code>, <code data-language="ts">.d.ts</code> or <code data-language="ts">.js</code>). Deno, however, deals with explicit specifiers.</p> <p>Here’s where it gets interesting: Imagine you want to consume a TypeScript file that’s already transpiled to JavaScript, along with its type definition file (<code data-language="ts">mod.js</code> and <code data-language="ts">mod.d.ts</code>). If you import <code data-language="ts">mod.js</code> into Deno, it strictly follows your request and imports the JavaScript file. But here’s the catch: Your code won’t be as thoroughly type-checked as if TypeScript considered the <code data-language="ts">mod.d.ts</code> file alongside the <code data-language="ts">mod.js</code> file.</p> <p>To address this, Deno offers two solutions, each catering to specific scenarios:</p> <p><strong>As the Importer:</strong> If you know what types should apply to a JavaScript module, you can enhance type checking by explicitly specifying the types.</p> <p><strong>As the Supplier:</strong> If you’re the provider or host of the module, everyone consuming it benefits without worrying about type resolution.</p> <h2 id="providing-types-when-importing" tabindex="-1">Providing types when importing </h2> <p>If you are consuming a JavaScript module and you have either created types (a <code data-language="ts">.d.ts</code> file) or have otherwise obtained the types you want to use, you can instruct Deno to use that file when type checking, instead of the JavaScript file, using the <code data-language="ts">@ts-types</code> compiler hint.</p> <p>For example if you have a JavaScript module, <code data-language="ts">coolLib.js</code>, and a separate <code data-language="ts">coolLib.d.ts</code> file, you would import it like this:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token comment">// @ts-types="./coolLib.d.ts"</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> coolLib <span class="token keyword">from</span> <span class="token string">"./coolLib.js"</span><span class="token punctuation">;</span>
</code></pre>   </div>
<p>When you’re performing type checking on <code data-language="ts">coolLib</code> and using it in your file, the TypeScript type definitions from <code data-language="ts">coolLib.d.ts</code> will take precedence over examining the JavaScript file.</p> <p>The compiler hint pattern-matching is quite flexible, it accepts both quoted and non-quoted values for the specifier, as well as any whitespace around the equals sign.</p> <h2 id="providing-types-when-hosting" tabindex="-1">Providing types when hosting </h2> <p>If you have control over the module’s source code or how the file is hosted on a web server, there are two ways to let Deno know about the types for a specific module (which won’t require any special action from the importer).</p> <h3 id="%40ts-self-types" tabindex="-1">@ts-self-types </h3> <p>If you are providing a JavaScript file, and want to provide a declaration file that contains the types for this file, you can specify a <code data-language="ts">@ts-self-types</code> directive in the JS file, pointing to the declaration file.</p> <p>For example, if you make a <code data-language="ts">coolLib.js</code> library, and write its type definitions in <code data-language="ts">coolLib.d.ts</code> the <code data-language="ts">ts-self-types</code> directive would look like this:</p> <div>
<div class="markdownBlockTitle">coolLib.js</div>
<div class="relative">
<pre class="language-js" tabindex="0"><code data-language="js"><span class="token comment">// @ts-self-types="./coolLib.d.ts"</span>

<span class="token comment">// ... the rest of the JavaScript ...</span>
</code></pre>   </div>
</div>
<h3 id="x-typescript-types" tabindex="-1">X-TypeScript-Types </h3> <p>Deno supports a header for remote modules that instructs Deno where to locate the types for a given module. For example, a response for <code data-language="ts">https://example.com/coolLib.js</code> might look something like this:</p> <div class="relative">
<pre class="language-console" tabindex="0"><code data-language="console">HTTP/1.1 200 OK
Content-Type: application/javascript; charset=UTF-8
Content-Length: 648
X-TypeScript-Types: ./coolLib.d.ts
</code></pre>   </div>
<p>When seeing this header, Deno would attempt to retrieve <code data-language="ts">https://example.com/coolLib.d.ts</code> and use that when type checking the original module.</p> <h2 id="using-ambient-or-global-types" tabindex="-1">Using ambient or global types </h2> <p>Overall it is better to use module/UMD type definitions with Deno, where a module expressly imports the types it depends upon. Modular type definitions can express <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html">augmentation of the global scope</a> via the <code data-language="ts">declare global</code> in the type definition. For example:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token keyword">declare</span> global <span class="token punctuation">{</span>
  <span class="token keyword">var</span> AGlobalString<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
<p>This would make <code data-language="ts">AGlobalString</code> available in the global namespace when importing the type definition.</p> <p>In some cases though, when leveraging other existing type libraries, it may not be possible to leverage modular type definitions. Therefore there are ways to include arbitrary type definitions when type checking programmes.</p> <h3 id="triple-slash-directive" tabindex="-1">Triple-slash directive </h3> <p>This option couples the type definitions to the code itself. By adding a triple-slash <code data-language="ts">types</code> directive in a TS file (not a JS file!), near the type of a module, type checking the file will include the type definition. For example:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token comment">/// &lt;reference types="./types.d.ts" /&gt;</span>
</code></pre>   </div>
<p>The specifier provided is resolved just like any other specifier in Deno, which means it requires an extension, and is relative to the module referencing it. It can be a fully qualified URL as well:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token comment">/// &lt;reference types="https://deno.land/x/pkg@1.0.0/types.d.ts" /&gt;</span>
</code></pre>   </div>
<h3 id="suppling-%22types%22-in-deno.json" tabindex="-1">Suppling "types" in deno.json </h3> <p>Another option is to provide a <code data-language="ts">"types"</code> value to the <code data-language="ts">"compilerOptions"</code> in your <code data-language="ts">deno.json</code>. For example:</p> <div>
<div class="markdownBlockTitle">deno.json</div>
<div class="relative">
<pre class="language-json" tabindex="0"><code data-language="json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">"./types.d.ts"</span><span class="token punctuation">,</span>
      <span class="token string">"https://deno.land/x/pkg@1.0.0/types.d.ts"</span><span class="token punctuation">,</span>
      <span class="token string">"/Users/me/pkg/types.d.ts"</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
</div>
<p>Like the triple-slash reference above, the specifier supplied in the <code data-language="ts">"types"</code> array will be resolved like other specifiers in Deno. In the case of relative specifiers, it will be resolved relative to the path to the config file. Make sure to tell Deno to use this file by specifying <code data-language="ts">--config=path/to/file</code> flag.</p> <h2 id="type-checking-web-workers" tabindex="-1">Type Checking Web Workers </h2> <p>When Deno loads a TypeScript module in a web worker, it will automatically type check the module and its dependencies against the Deno web worker library. This can present a challenge in other contexts like <code data-language="ts">deno check</code> or in editors. There are a couple of ways to instruct Deno to use the worker libraries instead of the standard Deno libraries.</p> <h3 id="triple-slash-directives" tabindex="-1">Triple-slash directives </h3> <p>This option couples the library settings with the code itself. By adding the following triple-slash directives near the top of the entry point file for the worker script, Deno will now type check it as a Deno worker script, irrespective of how the module is analyzed:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token comment">/// &lt;reference no-default-lib="true" /&gt;</span>
<span class="token comment">/// &lt;reference lib="deno.worker" /&gt;</span>
</code></pre>   </div>
<p>The first directive ensures that no other default libraries are used. If this is omitted, you will get some conflicting type definitions, because Deno will try to apply the standard Deno library as well. The second instructs Deno to apply the built-in Deno worker type definitions plus dependent libraries (like <code data-language="ts">"esnext"</code>).</p> <p>The one disadvantage of this, is that it makes the code less portable to other non-Deno platforms like <code data-language="ts">tsc</code>, as it is only Deno which has the <code data-language="ts">"deno.worker"</code> library built into it.</p> <h3 id="providing-%22lib%22-setting-in-deno.json" tabindex="-1">Providing "lib" setting in deno.json </h3> <p>You can provide a "lib" option in your <code data-language="ts">deno.json</code> file to instruct Deno to use library files. For example:</p> <div>
<div class="markdownBlockTitle">deno.json</div>
<div class="relative">
<pre class="language-json" tabindex="0"><code data-language="json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"deno.worker"</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>   </div>
</div>
<p>Then when running deno subcommand, you would need to pass the <code data-language="ts">--config path/to/file</code> argument, or if you are using an IDE which leverages the Deno language server, set the <code data-language="ts">deno.config</code> setting.</p> <p>If you also have non-worker scripts, you will either need to omit the <code data-language="ts">--config</code> argument, or have one that is configured to meet the needs of your non-worker scripts.</p> <h2 id="important-points" tabindex="-1">Important points </h2> <h3 id="type-declaration-semantics" tabindex="-1">Type declaration semantics </h3> <p>Type declaration files (<code data-language="ts">.d.ts</code> files) follow the same semantics as other files in Deno. This means that declaration files are assumed to be module declarations (<em>UMD declarations</em>) and not ambient/global declarations. It is unpredictable how Deno will handle ambient/global declarations.</p> <p>In addition, if a type declaration imports something else, like another <code data-language="ts">.d.ts</code> file, its resolution follow the normal import rules of Deno. For a lot of the <code data-language="ts">.d.ts</code> files that are generated and available on the web, they may not be compatible with Deno.</p> <p><a href="https://esm.sh">esm.sh</a> is a CDN which provides type declarations by default (via the <code data-language="ts">X-TypeScript-Types</code> header). It can be disabled by appending <code data-language="ts">?no-dts</code> to the import URL:</p> <div class="relative">
<pre class="language-ts" tabindex="0"><code data-language="ts"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">"https://esm.sh/react?no-dts"</span><span class="token punctuation">;</span>
</code></pre>   </div>
<h2 id="behavior-of-javascript-when-type-checking" tabindex="-1">Behavior of JavaScript when type checking </h2> <p>When you import JavaScript code into TypeScript within Deno, even if you’ve set <code data-language="ts">checkJs</code> to <code data-language="ts">false</code> (which is the default behavior for Deno), the TypeScript compiler will still analyze the JavaScript module. It tries to infer the shape of the exports from that module to validate the import in your TypeScript file.</p> <p>Usually, this isn’t an issue when importing a standard ES module. However, there are cases where TypeScript’s analysis might fail, for example, with modules that have special packaging or are global UMD (Universal Module Definition) modules. When faced with such situations, the best approach is to provide some form of type information using one of the methods mentioned earlier.</p> <h3 id="internals" tabindex="-1">Internals </h3> <p>While it isn't required to understand how Deno works internally to be able to leverage TypeScript with Deno well, it can help to understand how it works.</p> <p>Before any code is executed or compiled, Deno generates a module graph by parsing the root module, and then detecting all of its dependencies, and then retrieving and parsing those modules, recursively, until all the dependencies are retrieved.</p> <p>For each dependency, there are two potential "slots" that are used. There is the code slot and the type slot. As the module graph is filled out, if the module is something that is or can be emitted to JavaScript, it fills the code slot, and type only dependencies, like <code data-language="ts">.d.ts</code> files fill the type slot.</p> <p>When the module graph is built, and there is a need to type check the graph, Deno starts up the TypeScript compiler and feeds it the names of the modules that need to be potentially emitted as JavaScript. During that process, the TypeScript compiler will request additional modules, and Deno will look at the slots for the dependency, offering it the type slot if it is filled before offering it the code slot.</p> <p>This means when you import a <code data-language="ts">.d.ts</code> module, or you use one of the solutions above to provide alternative type modules for JavaScript code, that is what is provided to TypeScript instead when resolving the module.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018–2024 the Deno authors<br>Licensed under the MIT License.<br>
    <a href="https://docs.deno.com/runtime/reference/ts_config_migration" class="_attribution-link">https://docs.deno.com/runtime/reference/ts_config_migration</a>
  </p>
</div>
