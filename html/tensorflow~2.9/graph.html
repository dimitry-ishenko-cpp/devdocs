<h1 class="devsite-page-title">tf.Graph</h1> <devsite-bookmark></devsite-bookmark>      <table class="tfo-notebook-buttons tfo-api nocontent" align="left">  <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L3012-L5431">  View source on GitHub </a> </td> </table> <p>A TensorFlow computation, represented as a dataflow graph.</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/Graph"><code translate="no" dir="ltr">tf.compat.v1.Graph</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.Graph()
</pre>  <p>Graphs are used by <a href="function.html"><code translate="no" dir="ltr">tf.function</code></a>s to represent the function's computations. Each graph contains a set of <a href="operation.html"><code translate="no" dir="ltr">tf.Operation</code></a> objects, which represent units of computation; and <a href="tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> objects, which represent the units of data that flow between operations.</p> <h3 id="using_graphs_directly_deprecated" data-text="Using graphs directly (deprecated)">Using graphs directly (deprecated)</h3> <p>A <a href="graph.html"><code translate="no" dir="ltr">tf.Graph</code></a> can be constructed and used directly without a <a href="function.html"><code translate="no" dir="ltr">tf.function</code></a>, as was required in TensorFlow 1, but this is deprecated and it is recommended to use a <a href="function.html"><code translate="no" dir="ltr">tf.function</code></a> instead. If a graph is directly used, other deprecated TensorFlow 1 classes are also required to execute the graph, such as a <a href="compat/v1/session.html"><code translate="no" dir="ltr">tf.compat.v1.Session</code></a>.</p> <p>A default graph can be registered with the <a href="graph.html#as_default"><code translate="no" dir="ltr">tf.Graph.as_default</code></a> context manager. Then, operations will be added to the graph instead of being executed eagerly. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">g = tf.Graph()
with g.as_default():
  # Define operations and tensors in `g`.
  c = tf.constant(30.0)
  assert c.graph is g
</pre> <p><a href="compat/v1/get_default_graph.html"><code translate="no" dir="ltr">tf.compat.v1.get_default_graph()</code></a> can be used to obtain the default graph.</p> <p>Important note: This class <em>is not</em> thread-safe for graph construction. All operations should be created from a single thread, or external synchronization must be provided. Unless otherwise specified, all methods are not thread-safe.</p> <p>A <code translate="no" dir="ltr">Graph</code> instance supports an arbitrary number of "collections" that are identified by name. For convenience when building a large graph, collections can store groups of related objects: for example, the <a href="variable.html"><code translate="no" dir="ltr">tf.Variable</code></a> uses a collection (named <code translate="no" dir="ltr">tf.GraphKeys.GLOBAL_VARIABLES</code>) for all variables that are created during the construction of a graph. The caller may define additional collections by specifying a new name.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">building_function</code> </td> <td> Returns True iff this graph represents a function. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">collections</code> </td> <td> Returns the names of the collections known to this graph. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">finalized</code> </td> <td> True if this graph has been finalized. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">graph_def_versions</code> </td> <td> The GraphDef version information of this graph. <p>For details on the meaning of each version, see <a href="https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto"><code translate="no" dir="ltr">GraphDef</code></a>. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> The graph-level random seed of this graph. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">version</code> </td> <td> Returns a version number that increases as ops are added to the graph. <p>Note that this is unrelated to the <a href="graph.html#graph_def_versions"><code translate="no" dir="ltr">tf.Graph.graph_def_versions</code></a>. </p>
</td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="add_to_collection" data-text="add_to_collection"><code translate="no" dir="ltr">add_to_collection</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4215-L4231">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
add_to_collection(
    name, value
)
</pre> <p>Stores <code translate="no" dir="ltr">value</code> in the collection with the given <code translate="no" dir="ltr">name</code>.</p> <p>Note that collections are not sets, so it is possible to add a value to a collection several times.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The key for the collection. The <code translate="no" dir="ltr">GraphKeys</code> class contains many standard names for collections. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">value</code> </td> <td> The value to add to the collection. </td> </tr> </table> <h3 id="add_to_collections" data-text="add_to_collections"><code translate="no" dir="ltr">add_to_collections</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4233-L4252">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
add_to_collections(
    names, value
)
</pre> <p>Stores <code translate="no" dir="ltr">value</code> in the collections given by <code translate="no" dir="ltr">names</code>.</p> <p>Note that collections are not sets, so it is possible to add a value to a collection several times. This function makes sure that duplicates in <code translate="no" dir="ltr">names</code> are ignored, but it will not check for pre-existing membership of <code translate="no" dir="ltr">value</code> in any of the collections in <code translate="no" dir="ltr">names</code>.</p> <p><code translate="no" dir="ltr">names</code> can be any iterable, but if <code translate="no" dir="ltr">names</code> is a string, it is treated as a single collection name.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">names</code> </td> <td> The keys for the collections to add to. The <code translate="no" dir="ltr">GraphKeys</code> class contains many standard names for collections. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">value</code> </td> <td> The value to add to the collections. </td> </tr> </table> <h3 id="as_default" data-text="as_default"><code translate="no" dir="ltr">as_default</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4168-L4208">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
as_default()
</pre> <p>Returns a context manager that makes this <code translate="no" dir="ltr">Graph</code> the default graph.</p> <p>This method should be used if you want to create multiple graphs in the same process. For convenience, a global default graph is provided, and all ops will be added to this graph if you do not create a new graph explicitly.</p> <p>Use this method with the <code translate="no" dir="ltr">with</code> keyword to specify that ops created within the scope of a block should be added to this graph. In this case, once the scope of the <code translate="no" dir="ltr">with</code> is exited, the previous default graph is set again as default. There is a stack, so it's ok to have multiple nested levels of <code translate="no" dir="ltr">as_default</code> calls.</p> <p>The default graph is a property of the current thread. If you create a new thread, and wish to use the default graph in that thread, you must explicitly add a <code translate="no" dir="ltr">with g.as_default():</code> in that thread's function.</p> <p>The following code examples are equivalent:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># 1. Using Graph.as_default():
g = tf.Graph()
with g.as_default():
  c = tf.constant(5.0)
  assert c.graph is g

# 2. Constructing and making default:
with tf.Graph().as_default() as g:
  c = tf.constant(5.0)
  assert c.graph is g
</pre> <p>If eager execution is enabled ops created under this context manager will be added to the graph instead of executed eagerly.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager for using this graph as the default graph. </td> </tr> 
</table> <h3 id="as_graph_def" data-text="as_graph_def"><code translate="no" dir="ltr">as_graph_def</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L3542-L3569">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
as_graph_def(
    from_version=None, add_shapes=False
)
</pre> <p>Returns a serialized <code translate="no" dir="ltr">GraphDef</code> representation of this graph.</p> <p>The serialized <code translate="no" dir="ltr">GraphDef</code> can be imported into another <code translate="no" dir="ltr">Graph</code> (using <a href="graph_util/import_graph_def.html"><code translate="no" dir="ltr">tf.import_graph_def</code></a>) or used with the <a href="https://www.tensorflow.org/versions/r2.9/api_docs/api_docs/cc/index">C++ Session API</a>.</p> <p>This method is thread-safe.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">from_version</code> </td> <td> Optional. If this is set, returns a <code translate="no" dir="ltr">GraphDef</code> containing only the nodes that were added to this graph since its <code translate="no" dir="ltr">version</code> property had the given value. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">add_shapes</code> </td> <td> If true, adds an "_output_shapes" list attr to each node with the inferred shapes of each of its outputs. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto"><code translate="no" dir="ltr">GraphDef</code></a> protocol buffer. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the <code translate="no" dir="ltr">graph_def</code> would be too large. </td> </tr> </table> <h3 id="as_graph_element" data-text="as_graph_element"><code translate="no" dir="ltr">as_graph_element</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L3918-L3952">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
as_graph_element(
    obj, allow_tensor=True, allow_operation=True
)
</pre> <p>Returns the object referred to by <code translate="no" dir="ltr">obj</code>, as an <code translate="no" dir="ltr">Operation</code> or <code translate="no" dir="ltr">Tensor</code>.</p> <p>This function validates that <code translate="no" dir="ltr">obj</code> represents an element of this graph, and gives an informative error message if it is not.</p> <p>This function is the canonical way to get/validate an object of one of the allowed types from an external argument reference in the Session API.</p> <p>This method may be called concurrently from multiple threads.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">obj</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>, an <code translate="no" dir="ltr">Operation</code>, or the name of a tensor or operation. Can also be any object with an <code translate="no" dir="ltr">_as_graph_element()</code> method that returns a value of one of these types. Note: <code translate="no" dir="ltr">_as_graph_element</code> will be called inside the graph's lock and so may not modify the graph. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">allow_tensor</code> </td> <td> If true, <code translate="no" dir="ltr">obj</code> may refer to a <code translate="no" dir="ltr">Tensor</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">allow_operation</code> </td> <td> If true, <code translate="no" dir="ltr">obj</code> may refer to an <code translate="no" dir="ltr">Operation</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The <code translate="no" dir="ltr">Tensor</code> or <code translate="no" dir="ltr">Operation</code> in the Graph corresponding to <code translate="no" dir="ltr">obj</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">obj</code> is not a type we support attempting to convert to types. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">obj</code> is of an appropriate type but invalid. For example, an invalid string. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">KeyError</code> </td> <td> If <code translate="no" dir="ltr">obj</code> is not an object in the graph. </td> </tr> </table> <h3 id="clear_collection" data-text="clear_collection"><code translate="no" dir="ltr">clear_collection</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4324-L4334">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
clear_collection(
    name
)
</pre> <p>Clears all values in a collection.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The key for the collection. The <code translate="no" dir="ltr">GraphKeys</code> class contains many standard names for collections. </td> </tr> </table> <h3 id="colocate_with" data-text="colocate_with"><code translate="no" dir="ltr">colocate_with</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4581-L4658">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@tf_contextlib.contextmanager
colocate_with(
    op, ignore_existing=False
)
</pre> <p>Returns a context manager that specifies an op to colocate with.</p> <blockquote class="note">
<strong>Note:</strong><span> this function is not for public use, only for internal libraries.</span>
</blockquote> <h4 id="for_example" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = tf.Variable([1.0])
with g.colocate_with(a):
  b = tf.constant(1.0)
  c = tf.add(a, b)
</pre> <p><code translate="no" dir="ltr">b</code> and <code translate="no" dir="ltr">c</code> will always be colocated with <code translate="no" dir="ltr">a</code>, no matter where <code translate="no" dir="ltr">a</code> is eventually placed.</p> <blockquote class="note">
<strong>Note:</strong><span> Using a colocation scope resets any existing device constraints.</span>
</blockquote> <p>If <code translate="no" dir="ltr">op</code> is <code translate="no" dir="ltr">None</code> then <code translate="no" dir="ltr">ignore_existing</code> must be <code translate="no" dir="ltr">True</code> and the new scope resets all colocation and device constraints.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">op</code> </td> <td> The op to colocate all created ops with, or <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ignore_existing</code> </td> <td> If true, only applies colocation of this op within the context, rather than applying all colocation properties on the stack. If <code translate="no" dir="ltr">op</code> is <code translate="no" dir="ltr">None</code>, this value must be <code translate="no" dir="ltr">True</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if op is None but ignore_existing is False. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Yields</th></tr> <tr class="alt"> <td colspan="2"> A context manager that specifies the op with which to colocate newly created ops. </td> </tr> 
</table> <h3 id="container" data-text="container"><code translate="no" dir="ltr">container</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4764-L4814">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@tf_contextlib.contextmanager
container(
    container_name
)
</pre> <p>Returns a context manager that specifies the resource container to use.</p> <p>Stateful operations, such as variables and queues, can maintain their states on devices so that they can be shared by multiple processes. A resource container is a string name under which these stateful operations are tracked. These resources can be released or cleared with <code translate="no" dir="ltr">tf.Session.reset()</code>.</p> <h4 id="for_example_2" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with g.container('experiment0'):
  # All stateful Operations constructed in this context will be placed
  # in resource container "experiment0".
  v1 = tf.Variable([1.0])
  v2 = tf.Variable([2.0])
  with g.container("experiment1"):
    # All stateful Operations constructed in this context will be
    # placed in resource container "experiment1".
    v3 = tf.Variable([3.0])
    q1 = tf.queue.FIFOQueue(10, tf.float32)
  # All stateful Operations constructed in this context will be
  # be created in the "experiment0".
  v4 = tf.Variable([4.0])
  q1 = tf.queue.FIFOQueue(20, tf.float32)
  with g.container(""):
    # All stateful Operations constructed in this context will be
    # be placed in the default resource container.
    v5 = tf.Variable([5.0])
    q3 = tf.queue.FIFOQueue(30, tf.float32)

# Resets container "experiment0", after which the state of v1, v2, v4, q1
# will become undefined (such as uninitialized).
tf.Session.reset(target, ["experiment0"])
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">container_name</code> </td> <td> container name string. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager for defining resource containers for stateful ops, yields the container name. </td> </tr> 
</table> <h3 id="control_dependencies" data-text="control_dependencies"><code translate="no" dir="ltr">control_dependencies</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4945-L5056">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
control_dependencies(
    control_inputs
)
</pre> <p>Returns a context manager that specifies control dependencies.</p> <p>Use with the <code translate="no" dir="ltr">with</code> keyword to specify that all operations constructed within the context should have control dependencies on <code translate="no" dir="ltr">control_inputs</code>. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with g.control_dependencies([a, b, c]):
  # `d` and `e` will only run after `a`, `b`, and `c` have executed.
  d = ...
  e = ...
</pre> <p>Multiple calls to <code translate="no" dir="ltr">control_dependencies()</code> can be nested, and in that case a new <code translate="no" dir="ltr">Operation</code> will have control dependencies on the union of <code translate="no" dir="ltr">control_inputs</code> from all active contexts.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with g.control_dependencies([a, b]):
  # Ops constructed here run after `a` and `b`.
  with g.control_dependencies([c, d]):
    # Ops constructed here run after `a`, `b`, `c`, and `d`.
</pre> <p>You can pass None to clear the control dependencies:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with g.control_dependencies([a, b]):
  # Ops constructed here run after `a` and `b`.
  with g.control_dependencies(None):
    # Ops constructed here run normally, not waiting for either `a` or `b`.
    with g.control_dependencies([c, d]):
      # Ops constructed here run after `c` and `d`, also not waiting
      # for either `a` or `b`.
</pre>
<blockquote class="note">
<strong>Note:</strong><span> The control dependencies context applies <em>only</em> to ops that are constructed within the context. Merely using an op or tensor in the context does not add a control dependency. The following example illustrates this point:</span>
</blockquote>
<pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># WRONG
def my_func(pred, tensor):
  t = tf.matmul(tensor, tensor)
  with tf.control_dependencies([pred]):
    # The matmul op is created outside the context, so no control
    # dependency will be added.
    return t

# RIGHT
def my_func(pred, tensor):
  with tf.control_dependencies([pred]):
    # The matmul op is created in the context, so a control dependency
    # will be added.
    return tf.matmul(tensor, tensor)
</pre> <p>Also note that though execution of ops created under this scope will trigger execution of the dependencies, the ops created under this scope might still be pruned from a normal tensorflow graph. For example, in the following snippet of code the dependencies are never executed:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">loss = model.loss()
with tf.control_dependencies(dependencies):
  loss = loss + tf.constant(1)  # note: dependencies ignored in the
                                # backward pass
return tf.gradients(loss, model.variables)
</pre> <p>This is because evaluating the gradient graph does not require evaluating the constant(1) op created in the forward pass.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">control_inputs</code> </td> <td> A list of <code translate="no" dir="ltr">Operation</code> or <code translate="no" dir="ltr">Tensor</code> objects which must be executed or computed before running the operations defined in the context. Can also be <code translate="no" dir="ltr">None</code> to clear the control dependencies. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager that specifies control dependencies for all operations constructed within the context. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">control_inputs</code> is not a list of <code translate="no" dir="ltr">Operation</code> or <code translate="no" dir="ltr">Tensor</code> objects. </td> </tr> </table> <h3 id="create_op" data-text="create_op"><code translate="no" dir="ltr">create_op</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L3636-L3693">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
create_op(
    op_type,
    inputs,
    dtypes=None,
    input_types=None,
    name=None,
    attrs=None,
    op_def=None,
    compute_shapes=True,
    compute_device=True
)
</pre> <p>Creates an <code translate="no" dir="ltr">Operation</code> in this graph. (deprecated arguments)</p> <aside class="deprecated"><strong>Deprecated:</strong><span> SOME ARGUMENTS ARE DEPRECATED: <code translate="no" dir="ltr">(compute_shapes)</code>. They will be removed in a future version. Instructions for updating: Shapes are always computed; don't use the compute_shapes as it has no effect.</span></aside> <p>This is a low-level interface for creating an <code translate="no" dir="ltr">Operation</code>. Most programs will not call this method directly, and instead use the Python op constructors, such as <a href="constant.html"><code translate="no" dir="ltr">tf.constant()</code></a>, which add ops to the default graph.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">op_type</code> </td> <td> The <code translate="no" dir="ltr">Operation</code> type to create. This corresponds to the <code translate="no" dir="ltr">OpDef.name</code> field for the proto that defines the operation. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> A list of <code translate="no" dir="ltr">Tensor</code> objects that will be inputs to the <code translate="no" dir="ltr">Operation</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtypes</code> </td> <td> (Optional) A list of <code translate="no" dir="ltr">DType</code> objects that will be the types of the tensors that the operation produces. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">input_types</code> </td> <td> (Optional.) A list of <code translate="no" dir="ltr">DType</code>s that will be the types of the tensors that the operation consumes. By default, uses the base <code translate="no" dir="ltr">DType</code> of each input in <code translate="no" dir="ltr">inputs</code>. Operations that expect reference-typed inputs must specify <code translate="no" dir="ltr">input_types</code> explicitly. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A string name for the operation. If not specified, a name is generated based on <code translate="no" dir="ltr">op_type</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">attrs</code> </td> <td> (Optional.) A dictionary where the key is the attribute name (a string) and the value is the respective <code translate="no" dir="ltr">attr</code> attribute of the <code translate="no" dir="ltr">NodeDef</code> proto that will represent the operation (an <code translate="no" dir="ltr">AttrValue</code> proto). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">op_def</code> </td> <td> (Optional.) The <code translate="no" dir="ltr">OpDef</code> proto that describes the <code translate="no" dir="ltr">op_type</code> that the operation will have. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compute_shapes</code> </td> <td> (Optional.) Deprecated. Has no effect (shapes are always computed). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compute_device</code> </td> <td> (Optional.) If True, device functions will be executed to compute the device property of the Operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> if any of the inputs is not a <code translate="no" dir="ltr">Tensor</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if colocation conflicts with existing device assignment. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Operation</code> object. </td> </tr> 
</table> <h3 id="device" data-text="device"><code translate="no" dir="ltr">device</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4667-L4736">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@tf_contextlib.contextmanager
device(
    device_name_or_function
)
</pre> <p>Returns a context manager that specifies the default device to use.</p> <p>The <code translate="no" dir="ltr">device_name_or_function</code> argument may either be a device name string, a device function, or None:</p> <ul> <li>If it is a device name string, all operations constructed in this context will be assigned to the device with that name, unless overridden by a nested <code translate="no" dir="ltr">device()</code> context.</li> <li>If it is a function, it will be treated as a function from Operation objects to device name strings, and invoked each time a new Operation is created. The Operation will be assigned to the device with the returned name.</li> <li>If it is None, all <code translate="no" dir="ltr">device()</code> invocations from the enclosing context will be ignored.</li> </ul> <p>For information about the valid syntax of device name strings, see the documentation in <a href="https://www.tensorflow.org/code/tensorflow/core/util/device_name_utils.h"><code translate="no" dir="ltr">DeviceNameUtils</code></a>.</p> <h4 id="for_example_3" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with g.device('/device:GPU:0'):
  # All operations constructed in this context will be placed
  # on GPU 0.
  with g.device(None):
    # All operations constructed in this context will have no
    # assigned device.

# Defines a function from `Operation` to device string.
def matmul_on_gpu(n):
  if n.type == "MatMul":
    return "/device:GPU:0"
  else:
    return "/cpu:0"

with g.device(matmul_on_gpu):
  # All operations of type "MatMul" constructed in this context
  # will be placed on GPU 0; all other operations will be placed
  # on CPU 0.
</pre>
<blockquote class="note">
<strong>Note:</strong><span> The device scope may be overridden by op wrappers or other library code. For example, a variable assignment op <code translate="no" dir="ltr">v.assign()</code> must be colocated with the <a href="variable.html"><code translate="no" dir="ltr">tf.Variable</code></a> <code translate="no" dir="ltr">v</code>, and incompatible device scopes will be ignored.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">device_name_or_function</code> </td> <td> The device name or function to use in the context. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Yields</th></tr> <tr class="alt"> <td colspan="2"> A context manager that specifies the default device to use for newly created ops. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If device scopes are not properly nested. </td> </tr> </table> <h3 id="finalize" data-text="finalize"><code translate="no" dir="ltr">finalize</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L3397-L3405">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
finalize()
</pre> <p>Finalizes this graph, making it read-only.</p> <p>After calling <code translate="no" dir="ltr">g.finalize()</code>, no new operations can be added to <code translate="no" dir="ltr">g</code>. This method is used to ensure that no operations are added to a graph when it is shared between multiple threads, for example when using a <a href="compat/v1/train/queuerunner.html"><code translate="no" dir="ltr">tf.compat.v1.train.QueueRunner</code></a>.</p> <h3 id="get_all_collection_keys" data-text="get_all_collection_keys"><code translate="no" dir="ltr">get_all_collection_keys</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4319-L4322">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_all_collection_keys()
</pre> <p>Returns a list of collections used in this graph.</p> <h3 id="get_collection" data-text="get_collection"><code translate="no" dir="ltr">get_collection</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4279-L4317">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_collection(
    name, scope=None
)
</pre> <p>Returns a list of values in the collection with the given <code translate="no" dir="ltr">name</code>.</p> <p>This is different from <code translate="no" dir="ltr">get_collection_ref()</code> which always returns the actual collection list if it exists in that it returns a new list each time it is called.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The key for the collection. For example, the <code translate="no" dir="ltr">GraphKeys</code> class contains many standard names for collections. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">scope</code> </td> <td> (Optional.) A string. If supplied, the resulting list is filtered to include only items whose <code translate="no" dir="ltr">name</code> attribute matches <code translate="no" dir="ltr">scope</code> using <code translate="no" dir="ltr">re.match</code>. Items without a <code translate="no" dir="ltr">name</code> attribute are never returned if a scope is supplied. The choice of <code translate="no" dir="ltr">re.match</code> means that a <code translate="no" dir="ltr">scope</code> without special tokens filters by prefix. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The list of values in the collection with the given <code translate="no" dir="ltr">name</code>, or an empty list if no value has been added to that collection. The list contains the values in the order under which they were collected. </td> </tr> 
</table> <h3 id="get_collection_ref" data-text="get_collection_ref"><code translate="no" dir="ltr">get_collection_ref</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4254-L4277">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_collection_ref(
    name
)
</pre> <p>Returns a list of values in the collection with the given <code translate="no" dir="ltr">name</code>.</p> <p>If the collection exists, this returns the list itself, which can be modified in place to change the collection. If the collection does not exist, it is created as an empty list and the list is returned.</p> <p>This is different from <code translate="no" dir="ltr">get_collection()</code> which always returns a copy of the collection list if it exists and never creates an empty collection.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The key for the collection. For example, the <code translate="no" dir="ltr">GraphKeys</code> class contains many standard names for collections. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The list of values in the collection with the given <code translate="no" dir="ltr">name</code>, or an empty list if no value has been added to that collection. </td> </tr> 
</table> <h3 id="get_name_scope" data-text="get_name_scope"><code translate="no" dir="ltr">get_name_scope</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4547-L4562">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_name_scope()
</pre> <p>Returns the current name scope.</p> <h4 id="for_example_4" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with tf.name_scope('scope1'):
  with tf.name_scope('scope2'):
    print(tf.compat.v1.get_default_graph().get_name_scope())
</pre> <p>would print the string <code translate="no" dir="ltr">scope1/scope2</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A string representing the current name scope. </td> </tr> 
</table> <h3 id="get_operation_by_name" data-text="get_operation_by_name"><code translate="no" dir="ltr">get_operation_by_name</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4061-L4080">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_operation_by_name(
    name
)
</pre> <p>Returns the <code translate="no" dir="ltr">Operation</code> with the given <code translate="no" dir="ltr">name</code>.</p> <p>This method may be called concurrently from multiple threads.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The name of the <code translate="no" dir="ltr">Operation</code> to return. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The <code translate="no" dir="ltr">Operation</code> with the given <code translate="no" dir="ltr">name</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">name</code> is not a string. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">KeyError</code> </td> <td> If <code translate="no" dir="ltr">name</code> does not correspond to an operation in this graph. </td> </tr> </table> <h3 id="get_operations" data-text="get_operations"><code translate="no" dir="ltr">get_operations</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4043-L4059">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_operations()
</pre> <p>Return the list of operations in the graph.</p> <p>You can modify the operations in place, but modifications to the list such as inserts/delete have no effect on the list of operations known to the graph.</p> <p>This method may be called concurrently from multiple threads.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A list of Operations. </td> </tr> 
</table> <h3 id="get_tensor_by_name" data-text="get_tensor_by_name"><code translate="no" dir="ltr">get_tensor_by_name</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4109-L4128">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_tensor_by_name(
    name
)
</pre> <p>Returns the <code translate="no" dir="ltr">Tensor</code> with the given <code translate="no" dir="ltr">name</code>.</p> <p>This method may be called concurrently from multiple threads.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The name of the <code translate="no" dir="ltr">Tensor</code> to return. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The <code translate="no" dir="ltr">Tensor</code> with the given <code translate="no" dir="ltr">name</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">name</code> is not a string. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">KeyError</code> </td> <td> If <code translate="no" dir="ltr">name</code> does not correspond to a tensor in this graph. </td> </tr> </table> <h3 id="gradient_override_map" data-text="gradient_override_map"><code translate="no" dir="ltr">gradient_override_map</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5201-L5260">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@tf_contextlib.contextmanager
gradient_override_map(
    op_type_map
)
</pre> <p>EXPERIMENTAL: A context manager for overriding gradient functions.</p> <p>This context manager can be used to override the gradient function that will be used for ops within the scope of the context.</p> <h4 id="for_example_5" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">@tf.RegisterGradient("CustomSquare")
def _custom_square_grad(op, grad):
  # ...

with tf.Graph().as_default() as g:
  c = tf.constant(5.0)
  s_1 = tf.square(c)  # Uses the default gradient for tf.square.
  with g.gradient_override_map({"Square": "CustomSquare"}):
    s_2 = tf.square(s_2)  # Uses _custom_square_grad to compute the
                          # gradient of s_2.
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">op_type_map</code> </td> <td> A dictionary mapping op type strings to alternative op type strings. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager that sets the alternative op type to be used for one or more ops created in that context. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">op_type_map</code> is not a dictionary mapping strings to strings. </td> </tr> </table> <h3 id="is_feedable" data-text="is_feedable"><code translate="no" dir="ltr">is_feedable</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5268-L5270">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
is_feedable(
    tensor
)
</pre> <p>Returns <code translate="no" dir="ltr">True</code> if and only if <code translate="no" dir="ltr">tensor</code> is feedable.</p> <h3 id="is_fetchable" data-text="is_fetchable"><code translate="no" dir="ltr">is_fetchable</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5276-L5281">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
is_fetchable(
    tensor_or_op
)
</pre> <p>Returns <code translate="no" dir="ltr">True</code> if and only if <code translate="no" dir="ltr">tensor_or_op</code> is fetchable.</p> <h3 id="name_scope" data-text="name_scope"><code translate="no" dir="ltr">name_scope</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4373-L4491">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@tf_contextlib.contextmanager
name_scope(
    name
)
</pre> <p>Returns a context manager that creates hierarchical names for operations.</p> <p>A graph maintains a stack of name scopes. A <code translate="no" dir="ltr">with name_scope(...):</code> statement pushes a new name onto the stack for the lifetime of the context.</p> <p>The <code translate="no" dir="ltr">name</code> argument will be interpreted as follows:</p> <ul> <li>A string (not ending with '/') will create a new name scope, in which <code translate="no" dir="ltr">name</code> is appended to the prefix of all operations created in the context. If <code translate="no" dir="ltr">name</code> has been used before, it will be made unique by calling <code translate="no" dir="ltr">self.unique_name(name)</code>.</li> <li>A scope previously captured from a <code translate="no" dir="ltr">with g.name_scope(...) as scope:</code> statement will be treated as an "absolute" name scope, which makes it possible to re-enter existing scopes.</li> <li>A value of <code translate="no" dir="ltr">None</code> or the empty string will reset the current name scope to the top-level (empty) name scope.</li> </ul> <h4 id="for_example_6" data-text="For example:">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">with tf.Graph().as_default() as g:
  c = tf.constant(5.0, name="c")
  assert c.op.name == "c"
  c_1 = tf.constant(6.0, name="c")
  assert c_1.op.name == "c_1"

  # Creates a scope called "nested"
  with g.name_scope("nested") as scope:
    nested_c = tf.constant(10.0, name="c")
    assert nested_c.op.name == "nested/c"

    # Creates a nested scope called "inner".
    with g.name_scope("inner"):
      nested_inner_c = tf.constant(20.0, name="c")
      assert nested_inner_c.op.name == "nested/inner/c"

    # Create a nested scope called "inner_1".
    with g.name_scope("inner"):
      nested_inner_1_c = tf.constant(30.0, name="c")
      assert nested_inner_1_c.op.name == "nested/inner_1/c"

      # Treats `scope` as an absolute name scope, and
      # switches to the "nested/" scope.
      with g.name_scope(scope):
        nested_d = tf.constant(40.0, name="d")
        assert nested_d.op.name == "nested/d"

        with g.name_scope(""):
          e = tf.constant(50.0, name="e")
          assert e.op.name == "e"
</pre> <p>The name of the scope itself can be captured by <code translate="no" dir="ltr">with g.name_scope(...) as scope:</code>, which stores the name of the scope in the variable <code translate="no" dir="ltr">scope</code>. This value can be used to name an operation that represents the overall result of executing the ops in a scope. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">inputs = tf.constant(...)
with g.name_scope('my_layer') as scope:
  weights = tf.Variable(..., name="weights")
  biases = tf.Variable(..., name="biases")
  affine = tf.matmul(inputs, weights) + biases
  output = tf.nn.relu(affine, name=scope)
</pre>
<blockquote class="note">
<strong>Note:</strong><span> This constructor validates the given <code translate="no" dir="ltr">name</code>. Valid scope names match one of the following regular expressions:</span>
</blockquote>
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[A-Za-z0-9.][A-Za-z0-9_.\-/]* (for scopes at the root)
[A-Za-z0-9_.\-/]* (for other scopes)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the scope. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager that installs <code translate="no" dir="ltr">name</code> as a new name scope. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">name</code> is not a valid scope name, according to the rules above. </td> </tr> </table> <h3 id="prevent_feeding" data-text="prevent_feeding"><code translate="no" dir="ltr">prevent_feeding</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5264-L5266">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
prevent_feeding(
    tensor
)
</pre> <p>Marks the given <code translate="no" dir="ltr">tensor</code> as unfeedable in this graph.</p> <h3 id="prevent_fetching" data-text="prevent_fetching"><code translate="no" dir="ltr">prevent_fetching</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5272-L5274">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
prevent_fetching(
    op
)
</pre> <p>Marks the given <code translate="no" dir="ltr">op</code> as unfetchable in this graph.</p> <h3 id="switch_to_thread_local" data-text="switch_to_thread_local"><code translate="no" dir="ltr">switch_to_thread_local</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L5283-L5298">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
switch_to_thread_local()
</pre> <p>Make device, colocation and dependencies stacks thread-local.</p> <p>Device, colocation and dependencies stacks are not thread-local be default. If multiple threads access them, then the state is shared. This means that one thread may affect the behavior of another thread.</p> <p>After this method is called, the stacks become thread-local. If multiple threads access them, then the state is not shared. Each thread uses its own value; a thread doesn't affect other threads by mutating such a stack.</p> <p>The initial value for every thread's stack is set to the current value of the stack when <code translate="no" dir="ltr">switch_to_thread_local()</code> was first called.</p> <h3 id="unique_name" data-text="unique_name"><code translate="no" dir="ltr">unique_name</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/framework/ops.py#L4495-L4545">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
unique_name(
    name, mark_as_used=True
)
</pre> <p>Return a unique operation name for <code translate="no" dir="ltr">name</code>.</p> <blockquote class="note">
<strong>Note:</strong><span> You rarely need to call <code translate="no" dir="ltr">unique_name()</code> directly. Most of the time you just need to create <code translate="no" dir="ltr">with g.name_scope()</code> blocks to generate structured names.</span>
</blockquote> <p><code translate="no" dir="ltr">unique_name</code> is used to generate structured names, separated by <code translate="no" dir="ltr">"/"</code>, to help identify operations when debugging a graph. Operation names are displayed in error messages reported by the TensorFlow runtime, and in various visualization tools such as TensorBoard.</p> <p>If <code translate="no" dir="ltr">mark_as_used</code> is set to <code translate="no" dir="ltr">True</code>, which is the default, a new unique name is created and marked as in use. If it's set to <code translate="no" dir="ltr">False</code>, the unique name is returned without actually being marked as used. This is useful when the caller simply wants to know what the name to be created will be.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The name for an operation. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">mark_as_used</code> </td> <td> Whether to mark this name as being used. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A string to be passed to <code translate="no" dir="ltr">create_op()</code> that will be used to name the operation being created. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/Graph" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/Graph</a>
  </p>
</div>
