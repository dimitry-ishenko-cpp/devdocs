<h1 class="devsite-page-title">tf.compat.v1.train.batch_join</h1> <devsite-bookmark></devsite-bookmark>       <p>Runs a list of tensors to fill a queue to create batches of examples. (deprecated)</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.compat.v1.train.batch_join(
    tensors_list,
    batch_size,
    capacity=32,
    enqueue_many=False,
    shapes=None,
    dynamic_pad=False,
    allow_smaller_final_batch=False,
    shared_name=None,
    name=None
)
</pre>  <aside class="deprecated"><strong>Deprecated:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Queue-based input pipelines have been replaced by <a href="../../../data.html"><code translate="no" dir="ltr">tf.data</code></a>. Use <code translate="no" dir="ltr">tf.data.Dataset.interleave(...).batch(batch_size)</code> (or <code translate="no" dir="ltr">padded_batch(...)</code> if <code translate="no" dir="ltr">dynamic_pad=True</code>).</span></aside> <p>The <code translate="no" dir="ltr">tensors_list</code> argument is a list of tuples of tensors, or a list of dictionaries of tensors. Each element in the list is treated similarly to the <code translate="no" dir="ltr">tensors</code> argument of <a href="batch.html"><code translate="no" dir="ltr">tf.compat.v1.train.batch()</code></a>.</p> <aside class="warning"><strong>Warning:</strong><span> This function is nondeterministic, since it starts a separate thread for each tensor.</span></aside> <p>Enqueues a different list of tensors in different threads. Implemented using a queue -- a <code translate="no" dir="ltr">QueueRunner</code> for the queue is added to the current <code translate="no" dir="ltr">Graph</code>'s <code translate="no" dir="ltr">QUEUE_RUNNER</code> collection.</p> <p><code translate="no" dir="ltr">len(tensors_list)</code> threads will be started, with thread <code translate="no" dir="ltr">i</code> enqueuing the tensors from <code translate="no" dir="ltr">tensors_list[i]</code>. <code translate="no" dir="ltr">tensors_list[i1][j]</code> must match <code translate="no" dir="ltr">tensors_list[i2][j]</code> in type and shape, except in the first dimension if <code translate="no" dir="ltr">enqueue_many</code> is true.</p> <p>If <code translate="no" dir="ltr">enqueue_many</code> is <code translate="no" dir="ltr">False</code>, each <code translate="no" dir="ltr">tensors_list[i]</code> is assumed to represent a single example. An input tensor <code translate="no" dir="ltr">x</code> will be output as a tensor with shape <code translate="no" dir="ltr">[batch_size] + x.shape</code>.</p> <p>If <code translate="no" dir="ltr">enqueue_many</code> is <code translate="no" dir="ltr">True</code>, <code translate="no" dir="ltr">tensors_list[i]</code> is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of <code translate="no" dir="ltr">tensors_list[i]</code> should have the same size in the first dimension. The slices of any input tensor <code translate="no" dir="ltr">x</code> are treated as examples, and the output tensors will have shape <code translate="no" dir="ltr">[batch_size] + x.shape[1:]</code>.</p> <p>The <code translate="no" dir="ltr">capacity</code> argument controls the how long the prefetching is allowed to grow the queues.</p> <p>The returned operation is a dequeue operation and will throw <a href="../../../errors/outofrangeerror.html"><code translate="no" dir="ltr">tf.errors.OutOfRangeError</code></a> if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</p> <blockquote class="note">
<strong>Note:</strong><span> If <code translate="no" dir="ltr">dynamic_pad</code> is <code translate="no" dir="ltr">False</code>, you must ensure that either (i) the <code translate="no" dir="ltr">shapes</code> argument is passed, or (ii) all of the tensors in <code translate="no" dir="ltr">tensors_list</code> must have fully-defined shapes. <code translate="no" dir="ltr">ValueError</code> will be raised if neither of these conditions holds.</span>
</blockquote> <p>If <code translate="no" dir="ltr">dynamic_pad</code> is <code translate="no" dir="ltr">True</code>, it is sufficient that the <em>rank</em> of the tensors is known, but individual dimensions may have value <code translate="no" dir="ltr">None</code>. In this case, for each enqueue the dimensions with value <code translate="no" dir="ltr">None</code> may have a variable length; upon dequeue, the output tensors will be padded on the right to the maximum shape of the tensors in the current minibatch. For numbers, this padding takes value 0. For strings, this padding is the empty string. See <code translate="no" dir="ltr">PaddingFIFOQueue</code> for more info.</p> <p>If <code translate="no" dir="ltr">allow_smaller_final_batch</code> is <code translate="no" dir="ltr">True</code>, a smaller batch value than <code translate="no" dir="ltr">batch_size</code> is returned when the queue is closed and there are not enough elements to fill the batch, otherwise the pending elements are discarded. In addition, all output tensors' static shapes, as accessed via the <code translate="no" dir="ltr">shape</code> property will have a first <code translate="no" dir="ltr">Dimension</code> value of <code translate="no" dir="ltr">None</code>, and operations that depend on fixed batch_size would fail.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors_list</code> </td> <td> A list of tuples or dictionaries of tensors to enqueue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> An integer. The new batch size pulled from the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">capacity</code> </td> <td> An integer. The maximum number of elements in the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">enqueue_many</code> </td> <td> Whether each tensor in <code translate="no" dir="ltr">tensor_list_list</code> is a single example. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shapes</code> </td> <td> (Optional) The shapes for each example. Defaults to the inferred shapes for <code translate="no" dir="ltr">tensor_list_list[i]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dynamic_pad</code> </td> <td> Boolean. Allow variable dimensions in input shapes. The given dimensions are padded upon dequeue so that tensors within a batch have the same shapes. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">allow_smaller_final_batch</code> </td> <td> (Optional) Boolean. If <code translate="no" dir="ltr">True</code>, allow the final batch to be smaller if there are insufficient items left in the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shared_name</code> </td> <td> (Optional) If set, this queue will be shared under the given name across multiple sessions. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional) A name for the operations. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A list or dictionary of tensors with the same number and types as <code translate="no" dir="ltr">tensors_list[i]</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the <code translate="no" dir="ltr">shapes</code> are not specified, and cannot be inferred from the elements of <code translate="no" dir="ltr">tensor_list_list</code>. </td> </tr> </table> <p><section><devsite-expandable expanded> <h2 class="showalways" id="eager-compatibility" data-text="eager compatibility">eager compatibility</h2></devsite-expandable></section></p> <p>Input pipelines based on Queues are not supported when eager execution is enabled. Please use the <a href="../../../data.html"><code translate="no" dir="ltr">tf.data</code></a> API to ingest data under eager execution.</p>   <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/compat/v1/train/batch_join" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/compat/v1/train/batch_join</a>
  </p>
</div>
