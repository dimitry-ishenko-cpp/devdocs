<h1 class="devsite-page-title">tf.keras.optimizers.legacy.Optimizer</h1> <devsite-bookmark></devsite-bookmark>       <p>Base class for Keras optimizers.</p> <p>Inherits From: <a href="../optimizer.html"><code translate="no" dir="ltr">Optimizer</code></a></p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers/legacy/Optimizer"><code translate="no" dir="ltr">tf.compat.v1.keras.optimizers.legacy.Optimizer</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.keras.optimizers.legacy.Optimizer(
    name, gradient_aggregator=None, gradient_transformers=None, **kwargs
)
</pre>  <p>You should not use this class directly, but instead instantiate one of its subclasses such as <a href="../sgd.html"><code translate="no" dir="ltr">tf.keras.optimizers.SGD</code></a>, <a href="../adam.html"><code translate="no" dir="ltr">tf.keras.optimizers.Adam</code></a>, etc.</p> <h3 id="usage" data-text="Usage">Usage</h3> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an optimizer with the desired parameters.
opt = tf.keras.optimizers.SGD(learning_rate=0.1)
# `loss` is a callable that takes no argument and returns the value
# to minimize.
loss = lambda: 3 * var1 * var1 + 2 * var2 * var2
# In graph mode, returns op that minimizes the loss by updating the listed
# variables.
opt_op = opt.minimize(loss, var_list=[var1, var2])
opt_op.run()
# In eager mode, simply call minimize to update the list of variables.
opt.minimize(loss, var_list=[var1, var2])
</pre> <h3 id="usage_in_custom_training_loops" data-text="Usage in custom training loops">Usage in custom training loops</h3> <p>In Keras models, sometimes variables are created when the model is first called, instead of construction time. Examples include 1) sequential models without input shape pre-defined, or 2) subclassed models. Pass var_list as callable in these cases.</p> <h4 id="example" data-text="Example:">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">opt = tf.keras.optimizers.SGD(learning_rate=0.1)
model = tf.keras.Sequential()
model.add(tf.keras.layers.Dense(num_hidden, activation='relu'))
model.add(tf.keras.layers.Dense(num_classes, activation='sigmoid'))
loss_fn = lambda: tf.keras.losses.mse(model(input), output)
var_list_fn = lambda: model.trainable_weights
for input, output in data:
  opt.minimize(loss_fn, var_list_fn)
</pre> <h3 id="processing_gradients_before_applying_them" data-text="Processing gradients before applying them">Processing gradients before applying them</h3> <p>Calling <code translate="no" dir="ltr">minimize()</code> takes care of both computing the gradients and applying them to the variables. If you want to process the gradients before applying them you can instead use the optimizer in three steps:</p> <ol> <li>Compute the gradients with <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a>.</li> <li>Process the gradients as you wish.</li> <li>Apply the processed gradients with <code translate="no" dir="ltr">apply_gradients()</code>.</li> </ol> <h4 id="example_2" data-text="Example:">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an optimizer.
opt = tf.keras.optimizers.SGD(learning_rate=0.1)

# Compute the gradients for a list of variables.
with tf.GradientTape() as tape:
  loss = &lt;call_loss_function&gt;
vars = &lt;list_of_variables&gt;
grads = tape.gradient(loss, vars)

# Process the gradients, for example cap them, etc.
# capped_grads = [MyCapper(g) for g in grads]
processed_grads = [process_gradient(g) for g in grads]

# Ask the optimizer to apply the processed gradients.
opt.apply_gradients(zip(processed_grads, var_list))
</pre> <h3 id="use_with_tfdistributestrategy" data-text="Use with tf.distribute.Strategy">Use with <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a>
</h3> <p>This optimizer class is <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a> aware, which means it automatically sums gradients across all replicas. To average gradients, you divide your loss by the global batch size, which is done automatically if you use <a href="../../../keras.html"><code translate="no" dir="ltr">tf.keras</code></a> built-in training or evaluation loops. See the <code translate="no" dir="ltr">reduction</code> argument of your loss which should be set to <a href="../../losses/reduction.html#SUM_OVER_BATCH_SIZE"><code translate="no" dir="ltr">tf.keras.losses.Reduction.SUM_OVER_BATCH_SIZE</code></a> for averaging or <a href="../../losses/reduction.html#SUM"><code translate="no" dir="ltr">tf.keras.losses.Reduction.SUM</code></a> for not.</p> <p>To aggregate gradients yourself, call <code translate="no" dir="ltr">apply_gradients</code> with <code translate="no" dir="ltr">experimental_aggregate_gradients</code> set to False. This is useful if you need to process aggregated gradients.</p> <p>If you are not using these and you want to average gradients, you should use <a href="../../../math/reduce_sum.html"><code translate="no" dir="ltr">tf.math.reduce_sum</code></a> to add up your per-example losses and then divide by the global batch size. Note that when using <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a>, the first component of a tensor's shape is the <em>replica-local</em> batch size, which is off by a factor equal to the number of replicas being used to compute a single step. As a result, using <a href="../../../math/reduce_mean.html"><code translate="no" dir="ltr">tf.math.reduce_mean</code></a> will give the wrong answer, resulting in gradients that can be many times too big.</p> <h3 id="variable_constraints" data-text="Variable Constraints">Variable Constraints</h3> <p>All Keras optimizers respect variable constraints. If constraint function is passed to any variable, the constraint will be applied to the variable after the gradient has been applied to the variable. Important: If gradient is sparse tensor, variable constraint is not supported.</p> <h3 id="thread_compatibility" data-text="Thread Compatibility">Thread Compatibility</h3> <p>The entire optimizer is currently thread compatible, not thread-safe. The user needs to perform synchronization if necessary.</p> <h3 id="slots" data-text="Slots">Slots</h3> <p>Many optimizer subclasses, such as <code translate="no" dir="ltr">Adam</code> and <code translate="no" dir="ltr">Adagrad</code> allocate and manage additional variables associated with the variables to train. These are called <i>Slots</i>. Slots have names and you can ask the optimizer for the names of the slots that it uses. Once you have a slot name you can ask the optimizer for the variable it created to hold the slot value.</p> <p>This can be useful if you want to log debug a training algorithm, report stats about the slots, etc.</p> <h3 id="hyperparameters" data-text="Hyperparameters">Hyperparameters</h3> <p>These are arguments passed to the optimizer subclass constructor (the <code translate="no" dir="ltr">__init__</code> method), and then passed to <code translate="no" dir="ltr">self._set_hyper()</code>. They can be either regular Python values (like 1.0), tensors, or callables. If they are callable, the callable will be called during <code translate="no" dir="ltr">apply_gradients()</code> to get the value for the hyper parameter.</p> <p>Hyperparameters can be overwritten through user code:</p> <h4 id="example_3" data-text="Example:">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an optimizer with the desired parameters.
opt = tf.keras.optimizers.SGD(learning_rate=0.1)
# `loss` is a callable that takes no argument and returns the value
# to minimize.
loss = lambda: 3 * var1 + 2 * var2
# In eager mode, simply call minimize to update the list of variables.
opt.minimize(loss, var_list=[var1, var2])
# update learning rate
opt.learning_rate = 0.05
opt.minimize(loss, var_list=[var1, var2])
</pre> <h3 id="callable_learning_rate" data-text="Callable learning rate">Callable learning rate</h3> <p>Optimizer accepts a callable learning rate in two ways. The first way is through built-in or customized <a href="../schedules/learningrateschedule.html"><code translate="no" dir="ltr">tf.keras.optimizers.schedules.LearningRateSchedule</code></a>. The schedule will be called on each iteration with <code translate="no" dir="ltr">schedule(iteration)</code>, a <a href="../../../variable.html"><code translate="no" dir="ltr">tf.Variable</code></a> owned by the optimizer.</p> <h4 id="example_4" data-text="Example:">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
var = tf.Variable(np.random.random(size=(1,)))
learning_rate = tf.keras.optimizers.schedules.ExponentialDecay(
initial_learning_rate=.01, decay_steps=20, decay_rate=.1)
opt = tf.keras.optimizers.SGD(learning_rate=learning_rate)
loss = lambda: 3 * var
opt.minimize(loss, var_list=[var])
&lt;tf.Variable...
</pre> <p>The second way is through a callable function that does not accept any arguments.</p> <h4 id="example_5" data-text="Example:">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
var = tf.Variable(np.random.random(size=(1,)))
def lr_callable():
  return .1
opt = tf.keras.optimizers.SGD(learning_rate=lr_callable)
loss = lambda: 3 * var
opt.minimize(loss, var_list=[var])
&lt;tf.Variable...
</pre> <h3 id="creating_a_custom_optimizer" data-text="Creating a custom optimizer">Creating a custom optimizer</h3> <p>If you intend to create your own optimization algorithm, simply inherit from this class and override the following methods:</p> <ul> <li>
<code translate="no" dir="ltr">_resource_apply_dense</code> (update variable given gradient tensor is a dense <a href="../../../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>)</li> <li>
<code translate="no" dir="ltr">_resource_apply_sparse</code> (update variable given gradient tensor is a sparse <a href="../../../indexedslices.html"><code translate="no" dir="ltr">tf.IndexedSlices</code></a>. The most common way for this to happen is if you are taking the gradient through a <a href="../../../gather.html"><code translate="no" dir="ltr">tf.gather</code></a>.)</li> <li>
<code translate="no" dir="ltr">_create_slots</code> (if your optimizer algorithm requires additional variables)</li> <li>
<code translate="no" dir="ltr">get_config</code> (serialization of the optimizer, include all hyper parameters)</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> String. The name to use for momentum accumulator weights created by the optimizer. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">gradient_aggregator</code> </td> <td> The function to use to aggregate gradients across devices (when using <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a>). If <code translate="no" dir="ltr">None</code>, defaults to summing the gradients across devices. The function should accept and return a list of <code translate="no" dir="ltr">(gradient, variable)</code> tuples. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">gradient_transformers</code> </td> <td> Optional. List of functions to use to transform gradients before applying updates to Variables. The functions are applied after <code translate="no" dir="ltr">gradient_aggregator</code>. The functions should accept and return a list of <code translate="no" dir="ltr">(gradient, variable)</code> tuples. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> keyword arguments. Allowed arguments are <code translate="no" dir="ltr">clipvalue</code>, <code translate="no" dir="ltr">clipnorm</code>, <code translate="no" dir="ltr">global_clipnorm</code>. If <code translate="no" dir="ltr">clipvalue</code> (float) is set, the gradient of each weight is clipped to be no higher than this value. If <code translate="no" dir="ltr">clipnorm</code> (float) is set, the gradient of each weight is individually clipped so that its norm is no higher than this value. If <code translate="no" dir="ltr">global_clipnorm</code> (float) is set the gradient of all weights is clipped so that their global norm is no higher than this value. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> in case of any invalid argument. </td> </tr> </table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/optimizers/legacy/Optimizer" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/optimizers/legacy/Optimizer</a>
  </p>
</div>
