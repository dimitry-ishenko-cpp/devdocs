<h1 class="devsite-page-title">tf.keras.optimizers.experimental.Optimizer</h1> <devsite-bookmark></devsite-bookmark>       <p>Abstract optimizer base class.</p> <p>Inherits From: <a href="../../../module.html"><code translate="no" dir="ltr">Module</code></a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.keras.optimizers.experimental.Optimizer(
    name,
    clipnorm=None,
    clipvalue=None,
    global_clipnorm=None,
    use_ema=False,
    ema_momentum=0.99,
    ema_overwrite_frequency=None,
    jit_compile=True,
    **kwargs
)
</pre>  <p>This class supports distributed training. If you want to implement your own optimizer, please subclass this class instead of _BaseOptimizer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> String. The name to use for momentum accumulator weights created by the optimizer. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">clipnorm</code> </td> <td> Float. If set, the gradient of each weight is individually clipped so that its norm is no higher than this value. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">clipvalue</code> </td> <td> Float. If set, the gradient of each weight is clipped to be no higher than this value. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">global_clipnorm</code> </td> <td> Float. If set, the gradient of all weights is clipped so that their global norm is no higher than this value. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">use_ema</code> </td> <td> Boolean, defaults to False. If True, exponential moving average (EMA) is applied. EMA consists of computing an exponential moving average of the weights of the model (as the weight values change after each training batch), and periodically overwriting the weights with their moving average. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ema_momentum</code> </td> <td> Float, defaults to 0.99. Only used if <code translate="no" dir="ltr">use_ema=True</code>. This is the momentum to use when computing the EMA of the model's weights: <code translate="no" dir="ltr">new_average = ema_momentum * old_average + (1 - ema_momentum) * current_variable_value</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ema_overwrite_frequency</code> </td> <td> Int or None, defaults to None. Only used if <code translate="no" dir="ltr">use_ema=True</code>. Every <code translate="no" dir="ltr">ema_overwrite_frequency</code> steps of iterations, we overwrite the model variable by its moving average. If None, the optimizer does not overwrite model variables in the middle of training, and you need to explicitly overwrite the variables at the end of training by calling <code translate="no" dir="ltr">optimizer.finalize_variable_values()</code> (which updates the model variables in-place). When using the built-in <code translate="no" dir="ltr">fit()</code> training loop, this happens automatically after the last epoch, and you don't need to do anything. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">jit_compile</code> </td> <td> Boolean, defaults to True. If True, the optimizer will use XLA compilation. <code translate="no" dir="ltr">jit_compile</code> cannot be True when training with <a href="../../../distribute/experimental/parameterserverstrategy.html"><code translate="no" dir="ltr">tf.distribute.experimental.ParameterServerStrategy</code></a>. Additionally, if no GPU device is found, this flag will be ignored. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> keyword arguments only used for backward compatibility. </td> </tr> </table> <h3 id="usage" data-text="Usage">Usage</h3> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an optimizer with the desired parameters.
opt = tf.keras.optimizers.experimental.SGD(learning_rate=0.1)
var1, var2 = tf.Variable(1.0), tf.Variable(2.0)
# `loss` is a callable that takes no argument and returns the value
# to minimize.
loss = lambda: 3 * var1 * var1 + 2 * var2 * var2
# Call minimize to update the list of variables.
opt.minimize(loss, var_list=[var1, var2])
</pre> <h3 id="processing_gradients_before_applying_them" data-text="Processing gradients before applying them">Processing gradients before applying them</h3> <p>Calling <code translate="no" dir="ltr">minimize()</code> takes care of both computing the gradients and applying them to the variables. If you want to process the gradients before applying them you can instead use the optimizer in three steps:</p> <ol> <li>Compute the gradients with <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a>.</li> <li>Process the gradients as you wish.</li> <li>Apply the processed gradients with <code translate="no" dir="ltr">apply_gradients()</code>.</li> </ol> <h4 id="example" data-text="Example:">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an optimizer.
opt = tf.keras.optimizers.experimental.SGD(learning_rate=0.1)
var1, var2 = tf.Variable(1.0), tf.Variable(2.0)

# Compute the gradients for a list of variables.
with tf.GradientTape() as tape:
  loss = 3 * var1 * var1 + 2 * var2 * var2
grads = tape.gradient(loss, [var1, var2])

# Process the gradients.
grads[0] = grads[0] + 1

# Ask the optimizer to apply the gradients on variables.
opt.apply_gradients(zip(grads, [var1, var2]))
</pre> <h3 id="dynamic_learning_rate" data-text="Dynamic learning rate">Dynamic learning rate</h3> <p>Dynamic learning rate can be achieved by setting learning rate as a built-in or customized <a href="../schedules/learningrateschedule.html"><code translate="no" dir="ltr">tf.keras.optimizers.schedules.LearningRateSchedule</code></a>.</p> <h4 id="example_2" data-text="Example:">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
var = tf.Variable(np.random.random(size=(1,)))
learning_rate = tf.keras.optimizers.schedules.ExponentialDecay(
  initial_learning_rate=.01, decay_steps=20, decay_rate=.1)
opt = tf.keras.optimizers.experimental.SGD(learning_rate=learning_rate)
loss = lambda: 3 * var
opt.minimize(loss, var_list=[var])
</pre> <h3 id="gradients_clipping" data-text="Gradients clipping">Gradients clipping</h3> <p>Users can clip the gradients before applying to variables by setting <code translate="no" dir="ltr">clipnorm</code>, <code translate="no" dir="ltr">clipvalue</code> and <code translate="no" dir="ltr">global_clipnorm</code>. Notice that <code translate="no" dir="ltr">clipnorm</code> and <code translate="no" dir="ltr">global_clipnorm</code> can only have one being set.</p> <h4 id="example_3" data-text="Example:">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
opt = tf.keras.optimizers.experimental.SGD(learning_rate=1, clipvalue=1)
var1, var2 = tf.Variable(2.0), tf.Variable(2.0)
with tf.GradientTape() as tape:
  loss = 2 * var1 + 2 * var2
grads = tape.gradient(loss, [var1, var2])
print([grads[0].numpy(), grads[1].numpy()])
[2.0, 2.0]
opt.apply_gradients(zip(grads, [var1, var2]))
# Without clipping, we should get [0, 0], but as gradients are clipped to
# have max value 1, we get [1.0, 1.0].
print([var1.numpy(), var2.numpy()])
[1.0, 1.0]
</pre> <h3 id="using_exponential_moving_average" data-text="Using exponential moving average.">Using exponential moving average.</h3> <p>Empirically it has been found that using the exponential moving average (EMA) of the trained parameters of a deep network achieves a better performance than using its trained parameters directly. Keras optimizers allows users to compute this moving average and overwrite the model variables at desired time.</p> <h4 id="example_4" data-text="Example:">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Create an SGD optimizer with EMA on. `ema_momentum` controls the decay rate
# of the moving average. `ema_momentum=1` means no decay and the stored moving
# average is always model variable's initial value before training. Reversely,
# `ema_momentum=0` is equivalent to not using EMA. `ema_overwrite_frequency=3`
# means every 3 iterations, we overwrite the trainable variables with their
# moving average values.
opt = tf.keras.optimizers.experimental.SGD(
    learning_rate=1,
    use_ema=True,
    ema_momentum=0.5,
    ema_overwrite_frequency=3)
var1, var2 = tf.Variable(2.0), tf.Variable(2.0)
with tf.GradientTape() as tape:
  loss = var1 + var2
grads = tape.gradient(loss, [var1, var2])
# First iteration: [var1, var2] = [1.0, 1.0]
opt.apply_gradients(zip(grads, [var1, var2]))
print([var1, var2])

# Second iteration: [var1, var2] = [0.0, 0.0]
opt.apply_gradients(zip(grads, [var1, var2]))
print([var1, var2])

# Third iteration, without EMA, we should see [var1, var2] = [-1.0, -1.0],
# but overwriting results in [var1, var2] = [-0.125, -0.125]. The full
# calculation for the moving average of var1 is:
# var1=2*0.5**3+1*(1-0.5)*0.5**2+0*(1-0.5)*0.5**1+(-1)*(1-0.5)=-0.125.
opt.apply_gradients(zip(grads, [var1, var2]))
print([var1, var2])

</pre> <p>When optimizer is constructed with <code translate="no" dir="ltr">use_ema=True</code>, in custom training loop, users can explicitly call <code translate="no" dir="ltr">finalize_variable_values()</code> to overwrite trainable variables with their EMA values. <code translate="no" dir="ltr">finalize_variable_values()</code> is by default called at the end of <code translate="no" dir="ltr">model.fit()</code>.</p> <h3 id="use_with_tfdistributestrategy" data-text="Use with tf.distribute.Strategy">Use with <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a>
</h3> <p>This optimizer class is <a href="../../../distribute/strategy.html"><code translate="no" dir="ltr">tf.distribute.Strategy</code></a> aware, which means it automatically sums gradients across all replicas. To aggregate gradients yourself, call <code translate="no" dir="ltr">apply_gradients</code> with <code translate="no" dir="ltr">skip_aggregate_gradients</code> set to True. This is useful if you need to process aggregated gradients.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># This example is not runnable, it consists of dummy code for simple tutorial.
strategy = tf.distribute.experimental.TPUStrategy()

with strategy.scope():
  opt = tf.keras.optimizers.experimental.SGD()
  model = magic_function_that_returns_model()
  gradients = magic_function_that_returns_gradients()
  # Custom logic to aggregate gradients.
  gradients = strategy.reduce("SUM", gradients, axis=None)
  opt.apply_gradients(zip(gradients, model.trainable_variables),
      skip_aggregate_gradients=True)
</pre> <h3 id="creating_a_custom_optimizer" data-text="Creating a custom optimizer">Creating a custom optimizer</h3> <p>If you intend to create your own optimization algorithm, please inherit from this class and override the following methods:</p> <ul> <li>
<code translate="no" dir="ltr">build</code>: Create your optimizer-related variables, such as <code translate="no" dir="ltr">momentums</code> in SGD optimizer.</li> <li>
<code translate="no" dir="ltr">update_step</code>: Implement your optimizer's updating logic.</li> <li>
<code translate="no" dir="ltr">get_config</code>: serialization of the optimizer, include all hyper parameters.</li> </ul> <p>Your optimizer would automatically be compatible with tensorflow distributed training if you subclass <code translate="no" dir="ltr">optimizer_experimental.Optimizer</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">iterations</code> </td> <td> The number of training steps this <code translate="no" dir="ltr">optimizer</code> has run. <p>By default, iterations would be incremented by one every time <code translate="no" dir="ltr">apply_gradients()</code> is called. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">learning_rate</code> </td> <td> 
</td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="add_variable" data-text="add_variable"><code translate="no" dir="ltr">add_variable</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L319-L341">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
add_variable(
    shape, dtype=None, initializer='zeros', name=None
)
</pre> <p>Create an optimizer variable.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> A list of integers, a tuple of integers, or a 1-D Tensor of type int32. Defaults to scalar if unspecified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> The DType of the optimizer variable to be created. Defaults to <a href="../../backend/floatx.html"><code translate="no" dir="ltr">tf.keras.backend.floatx</code></a> if unspecified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">initializer</code> </td> <td> string or callable. Initializer instance. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> The name of the optimizer variable to be created. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An optimizer variable, in the format of tf.Variable. </td> </tr> 
</table> <h3 id="add_variable_from_reference" data-text="add_variable_from_reference"><code translate="no" dir="ltr">add_variable_from_reference</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L760-L768">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
add_variable_from_reference(
    model_variable, variable_name, shape=None, initial_value=None
)
</pre> <p>Create an optimizer variable from model variable.</p> <p>Create an optimizer variable based on the information of model variable. For example, in SGD optimizer momemtum, for each model variable, a corresponding momemtum variable is created of the same shape and dtype.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">model_variable</code> </td> <td> tf.Variable. The corresponding model variable to the optimizer variable to be created. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">variable_name</code> </td> <td> String. The name prefix of the optimizer variable to be created. The create variables name will follow the pattern <code translate="no" dir="ltr">{variable_name}/{model_variable.name}</code>, e.g., <code translate="no" dir="ltr">momemtum/dense_1</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> List or Tuple, defaults to None. The shape of the optimizer variable to be created. If None, the created variable will have the same shape as <code translate="no" dir="ltr">model_variable</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">initial_value</code> </td> <td> A Tensor, or Python object convertible to a Tensor, defaults to None. The initial value of the optimizer variable, if None, the initial value will be default to 0. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An optimizer variable. </td> </tr> 
</table> <h3 id="aggregate_gradients" data-text="aggregate_gradients"><code translate="no" dir="ltr">aggregate_gradients</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L779-L791">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
aggregate_gradients(
    grads_and_vars
)
</pre> <p>Aggregate gradients on all devices.</p> <p>By default we will perform reduce_sum of gradients across devices. Users can implement their own aggregation logic by overriding this method.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">grads_and_vars</code> </td> <td> List of (gradient, variable) pairs. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of (gradient, variable) pairs. </td> </tr> 
</table> <h3 id="apply_gradients" data-text="apply_gradients"><code translate="no" dir="ltr">apply_gradients</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L793-L811">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
apply_gradients(
    grads_and_vars, skip_gradients_aggregation=False
)
</pre> <p>Apply gradients to variables.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">grads_and_vars</code> </td> <td> List of (gradient, variable) pairs. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">skip_gradients_aggregation</code> </td> <td> If true, gradients aggregation will not be performed inside optimizer. Usually this arg is set to True when you write custom code aggregating gradients outside the optimizer. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> None </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">grads_and_vars</code> is malformed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If called in a cross-replica context. </td> </tr> </table> <h3 id="build" data-text="build"><code translate="no" dir="ltr">build</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L279-L300">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@abc.abstractmethod
build(
    var_list
)
</pre> <p>Initialize the optimizer's variables, such as momemtum variables.</p> <p>This function has to be implemented by subclass optimizers, and subclass optimizers need to call <code translate="no" dir="ltr">super().build(var_list)</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">var_list</code> </td> <td> List of model variables to build optimizers on. For example, SGD optimizer with momentum will store one momentum variable corresponding to each model variable. </td> </tr> </table> <h3 id="compute_gradients" data-text="compute_gradients"><code translate="no" dir="ltr">compute_gradients</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L152-L177">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
compute_gradients(
    loss, var_list, tape=None
)
</pre> <p>Compute gradients of loss on trainable variables.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">loss</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> or callable. If a callable, <code translate="no" dir="ltr">loss</code> should take no arguments and return the value to minimize. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">var_list</code> </td> <td> list or tuple of <code translate="no" dir="ltr">Variable</code> objects to update to minimize <code translate="no" dir="ltr">loss</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">tape</code> </td> <td> (Optional) <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a>. If <code translate="no" dir="ltr">loss</code> is provided as a <code translate="no" dir="ltr">Tensor</code>, the tape that computed the <code translate="no" dir="ltr">loss</code> must be provided. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A list of (gradient, variable) pairs. Variable is always present, but gradient can be <code translate="no" dir="ltr">None</code>. </td> </tr> 
</table> <h3 id="finalize_variable_values" data-text="finalize_variable_values"><code translate="no" dir="ltr">finalize_variable_values</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L469-L481">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
finalize_variable_values(
    var_list
)
</pre> <p>Set the final value of model's trainable variables.</p> <p>Sometimes there are some extra steps before ending the variable updates, such as overriding the model variables with its average value.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">var_list</code> </td> <td> list of model variables. </td> </tr> </table> <h3 id="from_config" data-text="from_config"><code translate="no" dir="ltr">from_config</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L518-L535">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_config(
    config
)
</pre> <p>Creates an optimizer from its config.</p> <p>This method is the reverse of <code translate="no" dir="ltr">get_config</code>, capable of instantiating the same optimizer from the config dictionary.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">config</code> </td> <td> A Python dictionary, typically the output of get_config. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An optimizer instance. </td> </tr> 
</table> <h3 id="get_config" data-text="get_config"><code translate="no" dir="ltr">get_config</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L493-L516">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_config()
</pre> <p>Returns the config of the optimizer.</p> <p>An optimizer config is a Python dictionary (serializable) containing the configuration of an optimizer. The same optimizer can be reinstantiated later (without any saved state) from this configuration.</p> <p>Subclass optimizer should override this method to include other hyperparameters.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Python dictionary. </td> </tr> 
</table> <h3 id="minimize" data-text="minimize"><code translate="no" dir="ltr">minimize</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L382-L401">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
minimize(
    loss, var_list, tape=None
)
</pre> <p>Minimize <code translate="no" dir="ltr">loss</code> by updating <code translate="no" dir="ltr">var_list</code>.</p> <p>This method simply computes gradient using <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a> and calls <code translate="no" dir="ltr">apply_gradients()</code>. If you want to process the gradient before applying then call <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a> and <code translate="no" dir="ltr">apply_gradients()</code> explicitly instead of using this function.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">loss</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> or callable. If a callable, <code translate="no" dir="ltr">loss</code> should take no arguments and return the value to minimize. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">var_list</code> </td> <td> list or tuple of <code translate="no" dir="ltr">Variable</code> objects to update to minimize <code translate="no" dir="ltr">loss</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">tape</code> </td> <td> (Optional) <a href="../../../gradienttape.html"><code translate="no" dir="ltr">tf.GradientTape</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> None </td> </tr> 
</table> <h3 id="update_step" data-text="update_step"><code translate="no" dir="ltr">update_step</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/optimizers/optimizer_experimental/optimizer.py#L104-L118">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@abc.abstractmethod
update_step(
    gradient, variable
)
</pre> <p>Function to update variable value based on given gradients.</p> <p>This method must be implemented in customized optimizers.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">gradient</code> </td> <td> backpropagated gradient of the given variable. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">variable</code> </td> <td> variable whose value needs to be updated. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Operation</code> that applies the specified gradients. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/optimizers/experimental/Optimizer" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/optimizers/experimental/Optimizer</a>
  </p>
</div>
